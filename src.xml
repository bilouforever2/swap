<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;
using pdb.db.piece.type;
using pdb.db.obj;


namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log;
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;
        public const DispatcherPriority DISPATCHER_PRIORITY = DispatcherPriority.Background; 


        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }
        private static DetailClassementViewModel detailClassementViewModel;
        internal static DetailClassementViewModel DetailClassementViewModel { set { detailClassementViewModel = value; } }

        public App()
            : base()
        {
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private void CheckException(string from, object sender, object ex)
        {
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {

                pdb.player.ViewModel.Colors.MementoColor.recover();

                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
                log = Logger.getLogger("Program");
                misc.init(log);

                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");


                var xmlConf = CConf.loadConf();
                export = CConf.Export;
                import = CConf.Import;

                gen = new Consolid();
                var mementoAlbum = Memento.Instance.confAlbum;
                if (mementoAlbum != null && mementoAlbum.Composants.Count > 0)
                    gen.SortAlbumMode = mementoAlbum;
                else
                    gen.SortAlbumMode = CConf.ConfGen.AlbumSort;
                Memento.Instance.confAlbum = gen.SortAlbumMode;
                Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;

                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);

                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni();
                Db.loadData();

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                Memento.Instance.save();
                thLoop = new Thread(loop);
                thLoop.Start();

                MemUtil.Start(CConf.GcCollect);
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        private static bool _updateStats;
        public static void go()
        {
            go(false);
        }
        public static void go(bool updateStats)
        {
            lock (_lock)
            {
                _updateStats |= updateStats;
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        private static void goInit()
        {
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;
            gen.MakeConsolid(Db.List.getList(),true);

            if (CConf.ResetOneCl)
            {
                Classement min = Classement.create("00003.0"); decimal mind = min.ClassementValueDecimal;
                Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;

                foreach (Piece p in gen.sortByClass())
                {
                    decimal clValue = p.ClassementValueDecimal;
                    if (clValue > zer0d)
                    {
                        if (clValue >= zer0d)
                        {
                            var dPiece = Db.getPiece(p.PieceId);
                            var strNewCl = "0000" + dPiece.getClassement().ToString();
                            var newCl = Classement.create(strNewCl);
                            p.Enabled = true;

                            p.setClassement(newCl.ClassList, newCl.Rating);
                            dPiece.Classement.eraseClassement2(newCl);
                        }
                        else
                            p.Enabled = false;
                    }
                }
                /*
                var _albums = gen.Albums;
                foreach (var album in _albums.List)
                {
                    if (album.Name == "Mémos vocaux" || album.Name == "Pictures at an Exhibition")
                    {
                    }
                    var l = album.Tracks;
                    decimal pluspetitNonNull = int.MaxValue;
                    foreach (Piece t in l)
                    {
                        decimal clValue = t.ClassementValueDecimal;
                        if (clValue > zer0d)
                        {
                            if (clValue < pluspetitNonNull)
                                pluspetitNonNull = clValue;
                        }

                    }
                    foreach (Piece t in l)
                    {
                        if (t.Parent == null)
                        {
                            decimal clValue = t.ClassementValueDecimal;
                            if (t.isClassListNumeric && clValue > zer0d)
                            {
                                if (clValue > pluspetitNonNull)
                                {
                                    var dPiece = Db.getPiece(t.PieceId);
                                    t.Enabled = true;
                                    t.setClassement("0", 0);
                                    dPiece.Classement.eraseClassement2();
                                }
                            }
                        }
                    }
                }*/
                gen.MakeConsolid(Db.List.getList(),true);
            }


            gen.buildMusique();
           // gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


          //  gen.timeRanking();
           // gen.eraseGrouping();
            // gen.writeComment();
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
            gen.createRot(CConf.ListBase, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            //gen.CommentGo = true;
            //gen.GroupinGO = true;
            //  PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual;
            PlayerViewModel.ConfAlbumSort = gen.SortAlbumMode;
            Memento.Instance.confAlbum = gen.SortAlbumMode;
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;

            foreach (CPiece p in Db.List)
            {
                if (p.DurationInSec == 0 && p.Exists)
                {
                    try
                    {
                        PlayerViewModel.Player.getDuration(p);
                        log.log("{0} duration {1} s", p, p.DurationInSec);
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }

                }
            }


           // detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
            new Thread(() =>
            gen.builStats(null)).Start(); 
        }

        private static void _go()
        {
            try
            {
                Memento.Instance.save();
                var confSort = PlayerViewModel.ConfAlbumSort;
                if (confSort != null)
                    Piece.SeuilProvisoire = confSort.lastModif;
                detailClassementViewModel.IhmInDispo = ihmInDispo.rot;
                //gen.CommentGo = false;
                //gen.GroupinGO = false;
                bib.Aborted = true;
                Db.saveAsync();
                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;
                // if (__end || __go) return;

                if (PlayerViewModel.Instance.CreateRot)
                {
                    //  gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
                    //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 
                    gen.MakeConsolid(Db.List.getList(),_updateStats); //   bib.Musique.Tracks);
                    //  if (__end || __go) return;
                    AlbumCtl.Instance.init();
                    //   if (__end || __go) return;
                    //gen.timeRanking();
                    //  if (__end || __go) return;
                    ChronoData.DateAuto = true;

                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);

                    //      if (__end || __go) return;
                    bib.Aborted = false;
                    ListWriterMgr.Async = false;
                    //listWriter = new ListWriter(root);
                    try
                    {
                        CConf.loadConf();
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                    // gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                    gen.createRot(CConf.ListBase, App.bib);
                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);


                    //log.log("visibles"); 
                    //foreach (TrackListViewModel visible in Player.VisibleItems)
                    //{
                    //    if (__end || __go) return;
                    //    visible.PieceGen.writeCommentGrouping();
                    //    visible.refresh(); 
                    //}
                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;
                    //gen.writeComment();
                    //if (__end || __go) return;
                    //gen.writeGrouping();
                    if (refresh != null)
                        refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;

                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;



                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);
                    // _refresh = true;
                    lock (_lock)
                    {
                        if (_updateStats)
                        {                           
                            detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
                            new Thread(() =>
                            gen.builStats(() => detailClassementViewModel.IhmInDispo = ihmInDispo.none)).Start();

                        }
                        else
                            detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                    }
                    //bib = new BibViewModel(Db.Root); 
                    //gen.createRot(CConf.ListBase, bib);
                    //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;


                }


            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                if (refresh != null && PlayerViewModel.Instance.CreateRot)
                    refresh(PHASE2, EventArgs.Empty);

                // detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                lock (_lock)
                {
                    ExportCmd.CalculExport();
                    if (_updateStats)
                    {
                        _updateStats = false;                         
                    }
                }
            }


        }

        public static event EventHandler refresh;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            App.bib.Aborted = true;
            Db.WriteDB1();
            Db.WriteDB2();
            App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.Track);
            if (l == null)
                return null;
            foreach (ITrackMetaData p in l)
            {

                TrackListViewModel trackList = PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                    return null;
                case MessageBoxResult.No:
                    return false;
                case MessageBoxResult.None:
                    return null;
                case MessageBoxResult.OK:
                    return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export;
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog();
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir;
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\PieceViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.gen;
using pdb.db.obj;
using pdb.util;
using Math = System.Math; 

namespace pdb.player.ViewModel
{
    class PieceViewModel : ViewModelBase
    {
        private CPiece piece;
        private Piece gen;
        private PieceViewModel(CPiece piece, Piece gen)
        {
            this.piece = piece; //.Piece.Track as CPiece; 
            this.gen = gen;
        }
        private static BgDict<int, PieceViewModel> dict = new BgDict<int, PieceViewModel>();

        public static PieceViewModel getPiece(TrackList track)
        {
            Piece gen = track.Piece;
            CPiece piece = gen.Track as CPiece;
            int id = piece.PieceId;
            PieceViewModel pv = null;
            if (!dict.ContainsKey(id))
            {
                pv = new PieceViewModel(piece, gen);
                dict.Add(id, pv);
                return pv;
            }
            return dict[id];
        }
        public CPiece Piece { get { return piece; } }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                if (value != piece.Enabled)
                {
                    gen.albumMustRefresh(); 
                    piece.Enabled = value;
                    OnPropertyChanged("Enabled");
                }
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {

                if (value != piece.Rating)
                {
                    piece.Rating = value;
                    OnPropertyChanged("Rating");
                }
            }
        }

        public String Classement
        {
            get
            {
                return piece.StrClassement;
            }
            set
            {
                if (value != piece.StrClassement)
                {
                    piece.StrClassement = value;
                    gen.invalidateCache(); 
                    OnPropertyChanged("Classement");


                }
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                if (value != piece.Year)
                {
                    piece.Year = value;
                    OnPropertyChanged("Year");
                }
            }
        }

        public DateTime Added
        {
            get
            {
                return piece.Added;
            }
        }

        public DateTime FirstAcces
        {
            get
            {
                return gen.FirstAcces; 
            }
        }

       

        public DateTime AlbumAdded
        {
            get
            {
                return gen.AlbumAdded;
            }
        }

        //public void eraseCommentGrouping() { _commentGroupingOk = false; }
        //private bool _commentGroupingOk;

        //public string Comment
        //{
        //    get
        //    {
        //        if (!_commentGroupingOk)
        //        {
        //            _commentGroupingOk = true;
        //            gen.writeCommentGrouping();

        //        }
        //        return gen.Comment;
        //    }
        //    set
        //    {
        //        if (value != piece.Comment)
        //        {
        //            piece.Comment = value;
        //            OnPropertyChanged("Comment");

        //        }
        //    }
        //}

        //public string Grouping
        //{
        //    get
        //    {
        //        if (!_commentGroupingOk)
        //        {
        //            _commentGroupingOk = true;
        //            gen.writeCommentGrouping();
        //        }
        //        return gen.Grouping;
        //    }
        //    set
        //    {
        //        if (value != piece.Grouping)
        //        {
        //            piece.setGrouping(value, true);
        //            OnPropertyChanged("Grouping");
        //        }
        //    }
        //}




        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }

        public bool Exists { get { return piece.Exists; } }
        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set
            {
                if (!Exists)
                    return;
                if (value != Duration)
                {
                    var deltaMs = Math.Abs(value.TotalMilliseconds - Duration.TotalMilliseconds);
                    if (deltaMs >= 1)
                    {
                        piece.Duration = value;
                        if (deltaMs >= 1000)
                            OnPropertyChanged("Duration");
                    }
                }
            }
        }

        public string Location
        {
            get { return piece.Location; }
        }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                if (value != piece.Artist)
                {
                    App.gen.Albums.changeArtist(gen, value);
                    piece.Artist = value;
                    OnPropertyChanged("Artist");
                }
            }
        }

        public string Album
        {
            get
            {
                return piece.Album;
            }
            set
            {
                if (value != piece.Album)
                {     
                    App.gen.Albums.changeAlbum(gen, value);
                    piece.Album = value;
                    OnPropertyChanged("Album");
                }
            }
        }

        public string Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                if (value != piece.Name)
                {
                    piece.Name = value;
                    OnPropertyChanged("Name");
                }
            }
        }

        public int TrackNumber
        {
            get
            {
                return piece.TrackNumber;
            }
            set
            {
                if (value != piece.TrackNumber)
                {
                    var alb = gen.PieceAlbum;
                    if (alb != null)
                        alb.mustRefresh(); 
                    piece.TrackNumber = value;
                    OnPropertyChanged("TrackNumber");
                }
            }
        }

        public string getLocation()
        {
            return piece.getLocation();
        }


    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\TrackListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Windows;
using pdb.obj;
using pdb.util;
using pdb.gen;
using pdb.db.obj;
using pdb.gen.albums;

namespace pdb.player.ViewModel
{

    public class TrackListViewModel : BibViewModelBase, ITrackNativeDates
    {




        #region répercut
        //  private static BgDict<int, List<TrackListViewModel>> dictT = new BgDict<int, List<TrackListViewModel>>();
        #endregion
        private TrackList track;
        private PieceViewModel piece;
        private static TrackListViewModel currentPlaying;
        private static TrackListViewModel currentSelected;
        public TrackList Track { get { return track; } }
        public CPiece Piece { get { return piece.Piece; } }
        public Piece PieceGen { get { return track.Piece; } }
        public Piece Master { get { return PieceGen.Master; } }

        public void remove()
        {
            //var list = dictT[PieceId];
            //if (list == null)
            //    return;
            //list.Remove(this);
        }

        public void refresh()
        {
           // piece.eraseCommentGrouping();
            OnPropertyChanged("ExportStatus");
            OnPropertyChanged("TV");
            //OnPropertyChanged("Comment");
            //OnPropertyChanged("Grouping");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("ClassementVirtuel");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("");
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                if (value != base.IsSelected)
                {
                    base.IsSelected = value;
                    if (value)
                        CurrentSelected = this;
                    OnPropertyChanged("TV");
                }
            }
        }

        private int index;
        public int Index
        {
            get { return index; }
            set
            {
                if (value != index)
                {
                    index = value;
                    OnPropertyChanged("Index");
                }
            }
        }

        public int StackValue { get { return PieceGen.StackValue; } }
        public int StackIndex { get { return PieceGen.StackIndex; } }

        public bool Empeached { get { return PieceGen.isEmpeached(); } }

        public static event EventHandler CurrentSelectedChanged;
        public static TrackListViewModel CurrentSelected
        {
            get
            {
                return currentSelected;
            }
            set
            {
                if (value != currentSelected)
                {
                    currentSelected = value;
                    if (CurrentSelectedChanged != null)
                        CurrentSelectedChanged("Track", EventArgs.Empty);
                }
            }
        }

        public static event EventHandler CurrentHumanSelectedChanged;
        private static TrackListViewModel humanSelected;
        private static int humanSelectedId;
        public static TrackListViewModel HumanSelected
        {
            get { return humanSelected; }
            //set
            //{
            //    if (value != humanSelected)
            //    {
            //        humanSelected = value;
            //        if (CurrentHumanSelectedChanged != null)
            //            CurrentHumanSelectedChanged("Human", EventArgs.Empty);
            //    }
            //}
        }

        private static bool setHumanSelectedUsed;
        private static volatile object _lock = new object(); 
        public static void setHumanSelected(PlayListViewModel pl, TrackListViewModel track)
        {
            lock (_lock)
            {
                if (setHumanSelectedUsed)
                    return; 
            }

            try
            {
                lock (_lock)
                    setHumanSelectedUsed = true; 
                //if (humanSelected != null)
                //{
                //    humanSelected.refresh();
                //   // var b = humanSelected.Grouping; 
                //}
                if (track != humanSelected)
                {
                    humanSelected = track;


                    //  humanSelected.refresh();
                    // var b = humanSelected.Grouping; 
                    int id = 0;
                    if (track != null) id = track.PieceId;
                    if (id != humanSelectedId)
                    {
                        humanSelectedId = id;
                        if (CurrentHumanSelectedChanged != null)
                            CurrentHumanSelectedChanged(pl, EventArgs.Empty);
                    }
                }
            }
            finally
            {
                lock (_lock)
                    setHumanSelectedUsed = false; 
            }
        }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
                //if (value != track.Enabled)
                //{
                //    track.Piece.Enabled = value;
                //    OnPropertyChanged("Enabled");
                //}
            }
        }
        //  private exportState exportState;
        //public int ExportState
        //{
        //    get
        //    {
        //        return (int)exportState;
        //    }
        //}

        public static EventHandler ExportStatusChange;
        private static void OnExportStatusChange(TrackListViewModel tv)
        {
            if (ExportStatusChange != null)
                ExportStatusChange(tv, EventArgs.Empty);
        }

        public static event EventHandler ClassementChange;
        private static void OnClassementChange(TrackListViewModel tv)
        {
            if (ClassementChange != null)
                ClassementChange(tv, EventArgs.Empty);
        }

        public TrackListViewModel TV { get { return this; } }

        public exportState ExportStatus
        {
            get
            {
                return Piece.ExportStatus; // exportState;
            }
            set
            {
                if (Piece.ExportStatus != value)
                {
                    Piece.ExportStatus = value;
                    OnPropertyChanged("ExportStatus");
                    OnPropertyChanged("TV");
                    OnPropertyChanged("Background");
                    OnExportStatusChange(this);
                    //refresh();


                }
            }
        }

        public int IndexExport
        {
            get { return PieceGen.IndexExport; }
        }

        public selectedCoeff SelectedMotif
        {
            get
            {
                if (PieceGen == null)
                    return selectedCoeff.none;
                return PieceGen.SelectedMotif;
            }
        }








        public TrackListViewModel(TrackList track, PlayListViewModel playlist)
            : base(track, playlist)
        {
            this.track = track;
            this.piece = PieceViewModel.getPiece(track); // new PieceViewModel(track); // track.Piece.Track as CPiece; 
            piece.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(piece_PropertyChanged);
            int id = track.PieceId;
            //if (!dictT.ContainsKey(id))
            //{
            //    var list = new List<TrackListViewModel>();
            //    dictT.Add(id, list);
            //}

            //dictT[id].Add(this);

        }

        void piece_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            OnPropertyChanged(e.PropertyName);
        }

        public String StrPlaying
        {
            get
            {
                if (playing) return "<))";
                return "";
            }
        }
        public string MedianneStatus
        {
            get
            {
                var p = PieceGen;
                if (p.Medianne)
                    return ">>";
                if (p.MedianneLight)
                    return ">";
                if (p.Border)
                    return "-";
                if (p.BorderMin)
                    return "-";
                if (p.BorderEffect)
                    return "--";

                return "";
            }
        }

        private bool playing;
        public bool Playing
        {
            get { return playing; }
            set
            {
                if (value != playing)
                {
                    playing = value;
                    if (playing)
                    {
                        CurrentPlaying = this;
                    }
                    OnPropertyChanged("Playing");
                    OnPropertyChanged("StrPlaying");
                }
            }
        }

        public static TrackListViewModel CurrentPlaying
        {
            get
            {
                return currentPlaying;
            }
            set
            {
                if (value != currentPlaying)
                {
                    if (currentPlaying != null)
                        currentPlaying.Playing = false;
                    currentPlaying = value;
                }
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
                //if (value != track.Rating)
                //{
                //    track.Rating = value;
                //    onPropertyChanged("Rating");
                //}
            }
        }

        //  private pdb.db.obj.CPiece CPiece { get { return track.Piece.Track as pdb.db.obj.CPiece; } }


        //public static readonly DependencyProperty ClassementProperty =
        //DependencyProperty.Register("Classement", typeof(String),
        // typeof(PieceViewModel), new UIPropertyMetadata(null));
        public String Classement
        {
            get
            {
                return piece.Piece.StrClassement;
            }
            set
            {

                // piece.StrClassement = value;
                //if (value != piece.Piece.StrClassement)
                //{
                piece.Classement = value;
                PieceGen.invalidateCache();
                App.gen.Albums.signalClassChange(track);
                try
                {

                    PlayerViewModel.makeauto(this);
                    App.bib.setClassement(this, value);



                    // piece.Piece.StrClassement = value;

                }
                catch
                {
                }

                OnClassementChange(this);
                App.go(true);
                // onPropertyChanged("Classement");


                // }

            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
                //if (value != piece.Year)
                //{
                //    track.Year = value;
                //    onPropertyChanged("Year");
                //}
            }
        }

        public DateTime Added { get { return piece.Added; } }

        public DateTime FirstAcces
        {
            get
            {
                return piece.FirstAcces;
            }
        }



        public DateTime AlbumAdded
        {
            get
            {
                return piece.AlbumAdded;
            }
        }

        public int RankAlbum { get { return PieceGen.RankAlbum; } }
        public int RankAlbumReverse { get { return PieceGen.RankAlbumReverse; } }
        public int RankAllAlbum { get { return PieceGen.RankAllAlbum; } }


        public int Rank { get { return PieceGen.Rank.Twice; } }
        //public static readonly DependencyProperty CommentProperty =
        //DependencyProperty.Register("Comment", typeof(string),
        //typeof(PieceViewModel), new UIPropertyMetadata(null)); 
        //public string Comment
        //{
        //    get
        //    {
        //        if (PieceGen.Virtual)
        //            return "";
        //        return piece.Comment;
        //    }
        //    set
        //    {
        //        if (PieceGen.Virtual)
        //            return;
        //        //piece.Comment = value; 
        //        if (value != piece.Comment)
        //        {
        //            //  track.Comment = value;
        //            piece.Comment = value;
        //            OnPropertyChanged("Comment");

        //        }
        //    }
        //}

        //public string Grouping
        //{
        //    get { return track.Piece.Grouping; }
        //    set
        //    {
        //        //  piece.Grouping = value;
        //        if (value != track.Piece.Grouping)
        //        {
        //            track.Piece.setGrouping(value, true);
        //            // track.setGrouping(value, true);
        //            OnPropertyChanged("Grouping");
        //        }
        //    }
        //}




        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }


        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set
            {
                piece.Duration = value;
                //if (!Exists)
                //    return; 
                //if (value != Duration)
                //{
                //    var deltaMs = Math.Abs(value.TotalMilliseconds - Duration.TotalMilliseconds);
                //    if (deltaMs >= 1)
                //    {
                //        track.Duration = value;
                //        if (deltaMs >= 1000)
                //            onPropertyChanged("Duration");
                //    }
                //}
            }
        }

        public string Location
        {
            get { return piece.Location; }
        }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
                //if (value != track.Artist)
                //{
                //    track.Artist = value;
                //    onPropertyChanged("Artist");
                //}
            }
        }

        public string Album
        {
            get
            {
                if (track.Virtual)
                {
                    if (track.Piece.VirtualByArtist)
                        return string.Format("[{0}]", track.Album);
                    return track.Album;
                }
                return piece.Album;
            }
            set
            {
                if (!track.Virtual)
                    piece.Album = value;
                //if (value != track.Album)
                //{
                //    track.Album = value;
                //    onPropertyChanged("Album");
                //}
            }
        }

        public string MasterAlbum
        {
            get
            {
                //    if (track.Virtual)
                //        return " " + PieceGen.Master.Album;
                return PieceGen.Master.Album;
            }
            set
            {
                if (value == null)
                    return;
                value = value.Trim();
                if (value != PieceGen.Master.Album)
                {
                    PieceGen.Master.Album = value;
                    OnPropertyChanged("MasterAlbum");
                }
            }
        }

        public Album album { get { return PieceGen.PieceAlbum; } }

        public string Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
                //if (value != track.Name)
                //{
                //    track.Piece.Name = value;
                //    onPropertyChanged("Name");
                //}
            }
        }

        public int TrackNumber
        {
            get
            {
                return track.Piece.TrackNumber;
            }
            set
            {
                if (!track.Virtual)
                    piece.TrackNumber = value;
                //if (value != track.TrackNumber)
                //{
                //    track.TrackNumber = value;
                //    onPropertyChanged("TrackNumber");
                //}
            }
        }


        public void setClassement(string className, int rating)
        {
            piece.Piece.setClassement(className, rating);
            PieceGen.invalidateCache();

        }

        public string ClassName
        {
            get
            {
                return piece.Piece.ClassName;
            }
            set
            {
                piece.Piece.ClassName = value;
            }
        }


        public DateTime PlayedDate
        {
            get { return piece.Piece.PlayedDate; }
        }

        public string ArtWork
        {
            get
            {
                return piece.Piece.ArtWork;
            }
            set
            {
                piece.Piece.ArtWork = value;
            }
        }

        //public void setGrouping(string value, bool prior)
        //{
        //    track.Piece.setGrouping(value, prior);
        //    piece.Grouping = value; // TODO je fait quoi de ça ???
        //    // onPropertyChanged("Grouping");
        //}

        public string ClassementVirtuel { get { return PieceGen.ClassementVirtuel; } }

        public decimal CoeffVirtuel { get { return PieceGen.CoeffVirtuel; } }

        public string ClassementVirtuel2 { get { return PieceGen.ClassementVirtuel2; } }

        public decimal CoeffVirtuel2 { get { return PieceGen.CoeffVirtuel2; } }

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.Piece.ClassPlayLists; }
        }

        public List<DateTime> Dates
        {
            get { return new List<DateTime>(piece.Piece.Dates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.Piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return track.Piece.ClassEvol; }
        }

        public long Size { get { return Piece.Size; } }

        public bool Exists { get { return Piece.Exists; } }

        //public void onPropertyChanged(string propertyName)
        //{
        //    var list = dictT[PieceId];
        //    if (list == null)
        //    {
        //        OnPropertyChanged(propertyName);
        //    }
        //    else
        //    {
        //        foreach (TrackListViewModel t in dictT[PieceId])
        //            t.OnPropertyChanged(propertyName);
        //    }
        //}




        public int PieceId
        {
            get { return track.PieceId; }
        }
        public int MasterId { get { return PieceGen.MasterId; } }


        public int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }

        public void setParent(TrackListViewModel parent)
        {
            track.Piece.albumMustRefresh();
            parent.track.Piece.albumMustRefresh();

            piece.Piece.Parent = parent.Piece.Master;
            track.Piece.Parent = parent.track.Piece;

            track.Piece.albumMustRefresh();
            parent.track.Piece.albumMustRefresh();
        }

        public void fusion(TrackListViewModel toDelete)
        {
            App.Db.List.fusion(piece.Piece, toDelete.Piece);

        }





        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public DateTime? UpdateClassement { get { return PieceGen.UpdateClassement; } }
        public DateTime? AlbumUpdateClassement { get { return PieceGen.AlbumUpdateClassement; } }

        public DateTime? LastRead { get { return PieceGen.LastRead; } }
        public DateTime? AlbumLastRead { get { return PieceGen.AlbumLastRead; } }

        public int NbClass { get { return PieceGen.NbClass; } }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }


        public string getLocation()
        {
            return piece.getLocation();
        }

        public string EquivLight
        {
            get
            {
                if (album == null)
                    return "";
                return album.EquivLight;
            }
        }

        public int AlbumCount
        {
            get
            {
                if (album == null)
                    return 0;
                return album.Count; 
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\AlbumCtl.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.AlbumCtl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*" />
            <RowDefinition Height="3" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />

        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0"  Grid.Column="0" DockPanel.Dock="Bottom" ConfCouleur="album"
                       x:Name="dg" x:Uid="album"
                       AutoGenerateColumns="False" 
                        IsSynchronizedWithCurrentItem="false" 
                                        
                       SelectedItem="{Binding SelectedTrackInAlbumView}">



            <!--<DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="DataGridRow.IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="DataGridRow.Background" Value="White" />
                    <Style.Triggers>
                        <Trigger Property="DataGridRow.IsSelected" Value="True">
                            <Setter Property="DataGridRow.Background" Value="Brown" />
                        </Trigger>
                    </Style.Triggers>

                </Style>
            </DataGrid.RowStyle>-->

            <DataGrid.Columns>
                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
                <DataGridCheckBoxColumn Header="" Binding="{Binding Exists,Mode=OneWay}" />
                <!--<DataGridCheckBoxColumn Header=""  Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->
                <DataGridTextColumn Header="" Binding="{Binding Index,Mode=OneWay}" />
                <DataGridTextColumn Header="p" Binding="{Binding TrackNumber,Converter={StaticResource Int}}"/>
                <DataGridTextColumn Header="Nom" Binding="{Binding Name,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="" Binding="{Binding MedianneStatus,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement,Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Virtuel" Binding="{Binding ClassementVirtuel,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff" Binding="{Binding CoeffVirtuel, Mode=OneWay, Converter={StaticResource decimal},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Virtuel2" Binding="{Binding ClassementVirtuel2,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff2" Binding="{Binding CoeffVirtuel2,Mode=OneWay, Converter={StaticResource decimal},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Rank" Binding="{Binding Rank,Mode=OneWay,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" />
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" />

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" />
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" />
                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>
                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum}"/>
                <DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>


                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}}" />

                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}" />
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="IndexExport" Binding="{Binding IndexExport, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
            </DataGrid.Columns>


            <DataGrid.ItemContainerStyle>

                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="FontWeight" Value="Normal" />
                    <Setter Property="BorderThickness" Value="0" />
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="FontWeight" Value="Bold" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exis
                    ts}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>

            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},ConverterParameter=album,   UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=album,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />
                   
                    
                    
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />




                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected"  Value="True">-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Foreground"  Value="White" />-->
                    <!--<Setter Property="BorderThickness" Value="1" />-->
                    <!--</Trigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <!--<Setter Property="Height"  Value="20" />-->
                  
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=album,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Padding" Value="10,10,10,10" />
                </Style>
            </DataGrid.RowStyle>

            <DataGrid.ContextMenu>
                <ContextMenu>

                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />
                    <MenuItem Header="Naviguer vers"  Command="{Binding Explorer}" />



                </ContextMenu>
            </DataGrid.ContextMenu>
        </l:EnhancedDataGrid>
        <GridSplitter Grid.Row="1" HorizontalAlignment="Stretch"   ResizeBehavior="PreviousAndNext"  IsTabStop="True"  />
        <Grid Grid.Row="2"  Visibility="{Binding HasArtWork, Converter={StaticResource boolVis}}">
            <Image Source="{Binding ArtWork}" ></Image>
            <!--<ListView ItemsSource="{Binding Images}">
                <ListView.ItemTemplate>
                    <DataTemplate>
                        <StackPanel>
                            <Image Source="{Binding}"  />
                        </StackPanel>
                    </DataTemplate>
                </ListView.ItemTemplate>
                <ListView.ItemsPanel>
                    <ItemsPanelTemplate>
                        <StackPanel Orientation="Horizontal" HorizontalAlignment="Stretch" VerticalAlignment="Stretch"></StackPanel>
                    </ItemsPanelTemplate>
                </ListView.ItemsPanel>

            </ListView>-->

            <Image Source="{Binding ArtWork}" ></Image>
           
        </Grid>
        <Grid Grid.Row="3">

            <l:EnhancedDataGrid Grid.Row="0"  Grid.Column="0" DockPanel.Dock="Bottom" ConfCouleur="albums"
                       x:Name="dgalbums" x:Uid="albums"
                       AutoGenerateColumns="False" 
                        IsSynchronizedWithCurrentItem="False" 
                                
                                HeadersVisibility="All" 
                                
                                 >
                <DataGrid.Columns>
                    <DataGridTextColumn Header="Album" Binding="{Binding Album,Mode=OneWay}" />
                    <DataGridTextColumn Header="Rang" Binding="{Binding RankAlbumReverse,Mode=OneWay}" />
                    <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                    <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>
                    <DataGridTextColumn Header="EquivLight"  Binding="{Binding EquivLight, Mode=OneWay}" />
                    <DataGridTextColumn Header="AlbumCount"  Binding="{Binding AlbumCount, Mode=OneWay, Converter={StaticResource Int}}" />

                </DataGrid.Columns>
                <DataGrid.ItemContainerStyle>
                    <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                        <!--<Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />-->
                        <Setter Property="FontWeight" Value="Normal" />                        
                    </Style>
                </DataGrid.ItemContainerStyle>
                
                <DataGrid.CellStyle>
                    <Style TargetType="DataGridCell">
                        <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=albums,  UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=albums, UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="BorderThickness" Value="0" />
                        <Setter Property="BorderBrush" Value="Transparent" />
                    </Style>
                </DataGrid.CellStyle>
                <DataGrid.RowStyle>
                    <Style TargetType="DataGridRow">                        
                        <Setter Property="BorderThickness" Value="0" />
                        <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=albums,  UpdateSourceTrigger=PropertyChanged}" />
                    </Style>
                </DataGrid.RowStyle>


            </l:EnhancedDataGrid>
            <ComboBox Name="cbx_mode" HorizontalAlignment="Right"  Width="20" Height="25" VerticalAlignment="Top" SelectionChanged="cbx_mode_SelectionChanged" >
                <ComboBoxItem  ToolTip="album du morceau sélectionné" >identique</ComboBoxItem>
                <ComboBoxItem ToolTip="album du morceau maitre" >origine</ComboBoxItem>
                <ComboBoxItem ToolTip="album du morceau maitre si virtuel" >origine si virtuel</ComboBoxItem>
                <ComboBoxItem ToolTip="album le plus long entre le maitre et le virtuel" >le plus long</ComboBoxItem>
                <ComboBoxItem ToolTip="album le plus court entre le maitre et le virtuel" >le plus court</ComboBoxItem>
            </ComboBox>



        </Grid>

       
    </Grid>
</UserControl>  
]]></content>
  </file>
  <file path="\pdb.player\Vue\DataGridPlayList.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.DataGridPlayList"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             mc:Ignorable="d" 
             d:DesignHeight="300" d:DesignWidth="300" >
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0" x:Name="dg" x:Uid="main" ConfCouleur="main"
                            AutoGenerateColumns="False" IsSynchronizedWithCurrentItem="False"                   
                            SelectedItem="{Binding SelectedTrack, Mode=TwoWay}"               
                  >
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="{Binding Export.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding Export}" />
                    <MenuItem Header="{Binding ExportCompress.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding ExportCompress}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />
                    <MenuItem Header="Naviguer vers"  Command="{Binding Explorer}" />



                </ContextMenu>
            </DataGrid.ContextMenu>


            <DataGrid.Columns>


                <DataGridTextColumn Binding="{Binding Index,Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>

                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>

                    </DataGridTemplateColumn.CellTemplate>


                </DataGridTemplateColumn>

                <!--<DataGridCheckBoxColumn Header="" Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->

                <DataGridCheckBoxColumn Header="" Binding="{Binding Exists,Mode=OneWay}" />
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Piste"  Binding="{Binding TrackNumber,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Rank" Binding="{Binding Rank,Mode=OneWay,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="RankAlbum" Binding="{Binding RankAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankAlbumReverse" Binding="{Binding RankAlbumReverse, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankAllAlbum" Binding="{Binding RankAllAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <!--<DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>-->
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}">

                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Header="IndexExport" Binding="{Binding IndexExport, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                <DataGridTextColumn Header="StackValue" Binding="{Binding StackValue, Mode=OneWay}"  >
                    <DataGridTextColumn.CellStyle>
                        <Style TargetType="DataGridCell" >
                            <Setter Property="ToolTip" Value="{Binding NbAlbumMoved, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.CellStyle>

                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Lecture"  Binding="{Binding LastRead, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Lecture Album"  Binding="{Binding AlbumLastRead, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>

                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Converter={StaticResource Int}}" />

                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="Ajouté"  Binding="{Binding Added, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="Ajouté (Album)"  Binding="{Binding AlbumAdded, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="1er accès"  Binding="{Binding FirstAcces, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="EquivLight"  Binding="{Binding EquivLight, Mode=OneWay}" />
                <DataGridCheckBoxColumn Header="Empêché" Binding="{Binding Empeached,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="AlbumCount"  Binding="{Binding AlbumCount, Mode=OneWay, Converter={StaticResource Int}}" />







            </DataGrid.Columns>

            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseMove" Handler="dg_PreviewMouseMove" />


                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <!--<Setter Property="IsEnabled" Value="{Binding Exists}" />-->
                    <Setter Property="FontWeight" Value="Normal" />
                    <!--<Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}" />-->
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="Foreground" Value="Brown" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exists}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                     
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>
            <!--<DataGrid.RowStyle>
                <Style TargetType="{x:Type DataGridRow}">
                    <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                </Style>
            </DataGrid.RowStyle>-->
            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=main, UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />



                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <!--<EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />-->
                    <Setter Property="BorderThickness" Value="0" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />

                </Style>
            </DataGrid.RowStyle>

        </l:EnhancedDataGrid>
        <ContentControl Name="Cctl" Grid.Row="1" >
            <DockPanel Grid.Row="1" Name="dp_status" >
                <!--<TextBlock DockPanel.Dock="Bottom" Text="{Binding NbAlbumMovedDesc}" />-->
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMovedUnavailable,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,4,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbEmpeached,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,4,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMoved,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,10,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left"  Text="{Binding AutoResume,UpdateSourceTrigger=PropertyChanged}" FontWeight="DemiBold" FontSize="11" Margin="0,0,10,0"/>



                <TextBlock DockPanel.Dock="Bottom" FontSize="11" Text="{Binding Resume}" Background="{Binding TV, Converter={StaticResource colorExport00}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
            </DockPanel>
        </ContentControl>
    </Grid>

</UserControl>
]]></content>
  </file>
  <file path="\PieceDb.Consolid\CLegacyListWriter.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using pdb.gen.conf;
using pdb.obj;
using pdb.util;
using pdb.gen.Tuning;
using pdb.gen.albums;
namespace pdb.gen
{

    public class CLegacyListWriter
    {
        private List<Piece> m_list = new List<Piece>();
        private List<Piece> m_listIni = null;
        private IEnumerable<Piece> m_enum;
        private int m_rotPeriod = -1;
        private static CPieceInListComparer c_comparer = new CPieceInListComparer();
        private bool m_bIni = false;
        private static DateTime now = DateTime.Now;
        private static Logger logger = Logger.getLogger("gen", true);
        public CLegacyListWriter(IList<Piece> a_pieceEnumerator)
        {
            m_enum = a_pieceEnumerator;
            //    this.sortByAlbum = sortByAlbum; 

            foreach (Piece l_piece in m_enum)
            {
                m_list.Add(l_piece);
            }
            m_listIni = new List<Piece>(m_list);

        }


        private ICollection<ListWriterMgr> writers = new List<ListWriterMgr>();
        public void addWriter(IListWriter writer) { writers.Add(new ListWriterMgr(writer)); }


        public void reset()
        {

            const int MIN_DURATION = 10 * 3600;
            m_list.Clear();
            m_listIni.Clear();
            foreach (Piece l_piece in m_enum)
            {
                m_list.Add(l_piece);
            }
            if (!m_bIni)
            {
                m_bIni = true;
                m_listIni = new List<Piece>(m_list);

            }
            double l_totalDuration = getDuration(1, null);
            while (l_totalDuration < MIN_DURATION && ListSelection.Scale > 0.01)
            {
                ListSelection.Scale *= 0.9;
                l_totalDuration = getDuration(1, null);
            }

            // If CConf.Sort.Quality.Mode = listMode.substract Then CPiece.Scale *= 0.1


        }
        public void writeRot(int a_base)
        {
            logger.log("write rot" + a_base);
            List<Piece> l_listPieceCLass = new List<Piece>();
            foreach (Piece l_piece in m_list)
            {
                if (l_piece.QRank > 0 && ListSelection.canPlay(l_piece, a_base))
                {
                    l_listPieceCLass.Add(l_piece);
                }
            }
            l_listPieceCLass.Sort(c_comparer);
            m_list = l_listPieceCLass;

            writePlayList("rot" + a_base, l_listPieceCLass, false, true);
        }

        //public bool SortByAlbum { set { sortByAlbum = value; } }
        //private bool sortByAlbum = true; 
        public void writeGen(ExtendToNative<datesMode> mode, ExtendToNative<double> nbHours, string baseName, bool onlyEvol, bool sortByAlbum)
        {
            try
            {
                var conf = CConf.ConfGen;
                logger.log("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol);
                bool withTimeOrder = mode.extendTimeOrder && nbHours.extendTimeOrder;

                var timeRestLimit = 0m;
                if (nbHours.level)
                {
                    CRank fictif = new CRank();
                    fictif.Quality = 1;
                    fictif.Lenght = 1;
                    fictif.Twice = 1;
                    DateTime dtFictif = DateTime.Now.AddDays(-nbHours.item);
                    List<DateTime> lfictif = new List<DateTime> { dtFictif };
                    timeRestLimit = CalcDate.getRest(lfictif, fictif);
                    logger.log("Limite {0} => {1} {2} ", nbHours.item, timeRestLimit, conf.Vie.TotalDays() * timeRestLimit);
                }

                List<Piece> l_listPieceCLass = new List<Piece>();
                foreach (Piece l_piece in m_listIni)
                {
                    if (l_piece.QRank > 0)
                    {

                        if (!(string.IsNullOrEmpty(l_piece.ClassEvol) && onlyEvol))
                        {
                            if (l_piece.Enabled || !conf.OnlyEnabled)
                                l_listPieceCLass.Add(l_piece);
                        }

                    }
                }
                l_listPieceCLass.Sort(new PieceRestComparer());


                TimeSpan limit = TimeSpan.FromHours(nbHours.item);
                TimeSpan current = new TimeSpan();

                List<Piece> ret = new List<Piece>(l_listPieceCLass.Count);
                // string lastClassement = "";
                bool rejet = false;

                foreach (Piece piece in l_listPieceCLass)
                {
                    if (nbHours.level)
                    {
                        if (piece.Rank.TimeRest <= timeRestLimit)
                            ret.Add(piece);
                    }
                    else if (nbHours.item == 0)
                    {
                        if (piece.Rank.TimeRest == 0)
                            ret.Add(piece);
                    }
                    else
                    {
                        current += piece.Duration;
                        if (current > limit || rejet)
                        {
                            if (!rejet)
                                logger.log("writeGen rejet {0} {1} {2} {3} {4} {5} {6}", mode, nbHours, baseName, onlyEvol, piece.ClassNameAndRating, piece, piece.Rank.TimeRest);
                            rejet = true;
                            //if (piece.ClassNameAndRating.Equals(lastClassement))
                            //{
                            //    log.log("writeGen {0} {1} {2} {3} {4} récupéré par {5}", mode, nbHours, baseName, onlyEvol, piece, lastClassement);
                            //}
                            //else
                            break;
                        }
                        ret.Add(piece);
                        // log.log("writeGen {0} {1} {2} {3} {4} {5} {6}", mode, nbHours, baseName, onlyEvol, piece.ClassNameAndRating, piece, piece.Rank.TimeRest);
                        // rejet = false; 
                        // lastClassement = piece.ClassNameAndRating;
                    }
                }

                if (withTimeOrder)
                    ret.Sort(new PieceRestComparer());
                else
                {
                    if (sortByAlbum)
                        ret.Sort(new AllPieceComparer2());
                    else
                    {
                        ret.Sort(new CPieceComparerByQualityAndLength2());
                        ret.Reverse();
                    }
                    // extension des listes normales
                    if (CConf.ConfGen.Anticipation && !nbHours.level && nbHours.item != 0 && ret.Count > 0)
                    {
                        Piece first = ret[0];
                        var listlecture = new List<Piece>(l_listPieceCLass);
                        listlecture.Sort(new PieceSortComparerList());
                        listlecture.Reverse();
                        while (true)
                        {
                            // que se passe-t-il quand le premier élément de la liste est consommé (g1)
                            // si on refait le calcul

                            int indexLecture = listlecture.IndexOf(first);
                            if (indexLecture < 0)
                                break;
                            int indexPrecedentLecture = indexLecture - 1;
                            if (indexPrecedentLecture < 0)
                                break;
                            Piece precedentLecture = listlecture[indexPrecedentLecture];
                            if (ret.Contains(precedentLecture))
                                break;
                            // si le précedent dans l'ordre de la lecture est aussi le précédent dans l'ordre reste, on le conserve 

                            int indexRest = l_listPieceCLass.IndexOf(first);
                            if (indexRest < 0)
                                break;
                            int indexRestSuivant = indexRest + 1;
                            if (indexRestSuivant >= l_listPieceCLass.Count)
                                break;

                            Piece suivantRest = l_listPieceCLass[indexRestSuivant];
                            if (ret.Contains(suivantRest))
                                break;
                            if (suivantRest != precedentLecture)
                            {
                                int indexLecture2 = listlecture.IndexOf(suivantRest);
                                if (indexLecture2 > indexLecture)
                                    break;
                            }

                            ret.Add(precedentLecture);
                            first = precedentLecture;


                        }

                        if (withTimeOrder)
                            ret.Sort(new PieceRestComparer());
                        else
                        {
                            if (sortByAlbum)
                                ret.Sort(new AllPieceComparer2());
                            else
                            {
                                ret.Sort(new CPieceComparerByQualityAndLength2());
                                ret.Reverse();
                            }
                        }

                        //ret.Sort(new PieceSortComparerList());
                        //ret.Reverse();
                    }

                }
                // 

                var large = ret;

                if (conf.GenLarge)
                    large = getLarge(ret);
                //ret.Reverse();
                //large.Reverse();

                // var hash = new HashList<Piece>(ret); 

                bool extendToNative = mode.extend && nbHours.extend;
                bool withOrder = conf.WithOrder && (nbHours.item > 0 || conf.OrderZero);
                withOrder = withOrder || withTimeOrder;
                string strLevel = "";
                if (nbHours.level)
                    strLevel = "_";
                writePlayList(mode.ToString(), baseName + strLevel + nbHours, ret, withOrder, extendToNative);

                withOrder = withOrder && conf.OrderLarge;
                if (conf.GenLarge)
                    writePlayList(mode.ToString(), baseName + strLevel + nbHours + "+", large, withOrder, extendToNative);

                //var writeGrouping = CConf.ConfGen.WriteGrouping;
                //if (writeGrouping > writeGrouping.none && (nbHours.item > 0 || conf.WriteGroupingZero))
                //{
                //    foreach (var piece in ret)
                //    {
                //        piece.MarkAsUpdateGrouping();
                //    }

                //    if (conf.GenLarge)
                //    {
                //        foreach (var piece in large)
                //        {
                //            piece.MarkAsUpdateGrouping();
                //        }
                //    }
                //}
            }
            catch (Exception ex)
            {
                misc.logError(string.Format("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol), ex);
            }
        }


        internal void writeGen(Albums albums, ExtendToNative<datesMode> mode, ExtendToNative<double> nbHours, string baseName, bool onlyEvol)
        {
            try
            {
                logger.log("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol);
                bool withTimeOrder = mode != null && nbHours != null && mode.extendTimeOrder && nbHours.extendTimeOrder;

                var timeRestLimit = 0m;
                if (nbHours != null && nbHours.level)
                {
                    CRank fictif = new CRank();
                    fictif.Quality = 1;
                    fictif.Lenght = 1;
                    fictif.Twice = 1;
                    DateTime dtFictif = DateTime.Now.AddDays(-nbHours.item);
                    List<DateTime> lfictif = new List<DateTime> { dtFictif };
                    timeRestLimit = CalcDate.getRest(lfictif, fictif);
                    logger.log("Limite {0} => {1} {2} ", nbHours.item, timeRestLimit, CConf.ConfGen.Vie.TotalDays() * timeRestLimit);
                }

                var list = albums.makeSelection();



                TimeSpan limit = new TimeSpan();
                if (nbHours != null)
                    limit = TimeSpan.FromHours(nbHours.item);
                TimeSpan current = new TimeSpan();

                List<Album> retAlbum = new List<Album>();


                foreach (Album album in list)
                {
                    if (!album.Classed)
                        continue;
                    if (!album.AtLeastOneEnabled)
                        continue;
                    if (nbHours == null)
                        retAlbum.Add(album);
                    else if (nbHours.level)
                    {
                        if (album.Rank.TimeRest <= timeRestLimit)
                            retAlbum.Add(album);
                    }
                    else if (nbHours.item == 0)
                    {
                        if (album.Rank.TimeRest == 0)
                            retAlbum.Add(album);
                    }
                    else
                    {
                        retAlbum.Add(album);
                        current += album.Duration;
                        if (current > limit)
                        {
                            break;
                        }
                    }
                }

                //retAlbum.Sort(new AlbumSortComparer());
                //retAlbum.Reverse(); 

                var ret = new List<Piece>();
                foreach (Album album in retAlbum)
                {
                    ret.AddRange(album.Sort());
                }


                // if (!CConf.ConfGen.AlbumOrdo)

                //ret.Sort(new AllPieceComparer());
                //ret.Reverse();

                ret.Sort(new AllPieceComparer2());

                // var hash = new HashList<Piece>(ret); 
                var conf = CConf.ConfGen;
                bool extendToNative = mode != null && mode.extend && nbHours != null && nbHours.extend;
                bool withOrder = conf.WithOrder && ((nbHours != null && nbHours.item > 0) || conf.OrderZero);
                withOrder = withOrder || withTimeOrder;
                string strLevel = "";
                if (nbHours == null)
                    strLevel = "";
                else if (nbHours.level)
                    strLevel = "_";
                writePlayList("album\\" + mode, baseName + strLevel + nbHours, ret, CConf.ConfGen.AlbumOrdo, extendToNative);
                //IList<Piece> large = ret;

                //large = getLarge(ret);
                //withOrder = withOrder && conf.OrderLarge;
                //writePlayList(mode.ToString(), baseName + strLevel + nbHours + "+", large, withOrder, extendToNative);

                //var writeGrouping = CConf.ConfGen.WriteGrouping;
                //if (writeGrouping > writeGrouping.none && ((nbHours != null && nbHours.item > 0) || conf.WriteGroupingZero))
                //{
                //    foreach (var piece in ret)
                //    {
                //        piece.MarkAsUpdateGrouping();
                //    }

                //    //if (conf.GenLarge)
                //    //{
                //    //    foreach (var piece in large)
                //    //    {
                //    //        piece.MarkAsUpdateGrouping();
                //    //    }
                //    //}
                //}
            }
            catch (Exception ex)
            {
                misc.logError(string.Format("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol), ex);
            }
        }




        public void writePrecisionClassement(string baseName, int precision, bool onlyEvol, bool extendToNative)
        {
            logger.log("writePrecisionClassement" + precision);
            List<Piece> l_listPieceCLass = new List<Piece>();
            foreach (Piece l_piece in m_listIni)
            {
                if (l_piece.QRank > 0)
                {
                    if (!(string.IsNullOrEmpty(l_piece.ClassEvol) && onlyEvol))
                        l_listPieceCLass.Add(l_piece);
                }
            }

            List<Piece> ret = new List<Piece>(l_listPieceCLass.Count);

            foreach (Piece piece in l_listPieceCLass)
            {
                if (piece.classPrecision() <= precision)
                    ret.Add(piece);
            }



            writePlayList("precision", baseName + precision, ret, false, extendToNative);
            var large = getLarge(ret);
            writePlayList("precision", baseName + precision + "+", large, false, extendToNative);


        }


        public void writeCheckClassement(int a_base)
        {
            logger.log("write check Classement " + a_base);
            List<Piece> l_listPieceCLass = new List<Piece>();

            if (a_base == 0)
            {
                foreach (Piece l_piece in m_listIni)
                {
                    if (l_piece.ClassEvol != "")
                    {
                        l_listPieceCLass.Add(l_piece);
                    }
                }
            }
            else
            {

                foreach (Piece l_piece in m_listIni)
                {
                    if (l_piece.QRank > 0 && ListSelection.mustPlayToPreciseClassement(l_piece, now, a_base)) // l_piece.mustPlayToPreciseClassement(now, a_base))
                    {
                        l_listPieceCLass.Add(l_piece);
                    }
                }
            }
            l_listPieceCLass.Sort(c_comparer);

            writePlayList("check" + a_base, l_listPieceCLass, false, true);
            var l_large = getLarge(l_listPieceCLass);
            writePlayList("_check" + a_base, l_large, false, true);
        }


        public void writeRotMin(int a_hDuration)
        {
            log("rotMax " + a_hDuration);
            int l_duration = 3600 * a_hDuration;
            m_list = writeRotMin_(l_duration);
            string l_name = a_hDuration.ToString();
            if (a_hDuration < 0)
                l_name = "all";

            string l_name0 = "rotMax" + l_name;
            string l_nameLarge = "_" + l_name0;


            writePlayList(l_name0, m_list, CConf.ConfGen.WithOrder, true);
            var l_large = getLarge(m_list);
            writePlayList(l_nameLarge, l_large, CConf.ConfGen.WithOrder, true);

        }
        /// <summary>
        /// écit une liste basée sur une durée max
        /// </summary>
        /// <param name="a_ms">durée totale de la liste, en ms</param>
        /// <remarks></remarks>
        private List<Piece> writeRotMin_(int a_ms)
        {
            double l_totalDuration = 0;
            int l_durationTarget = a_ms;
            int l_iEnd = 100 * ListSelection.Period;

            List<Piece> l_list = null;
            List<Piece> l_Oldlist = null;
            int l_period = m_rotPeriod;

            do
            {
                l_totalDuration = 0;
                l_Oldlist = l_list;

                l_list = new List<Piece>();

                l_period += 1;


                l_totalDuration = getDuration(l_period, l_list);

                //For Each l_piece As CPiece In m_list
                //    If l_piece.Rank > 0 AndAlso l_piece.canPlay(l_period) Then
                //        l_list.Add(l_piece)
                //        l_totalDuration += l_piece.Duration
                //    End If
                //Next

                m_list = l_list;
                //   log("period " + l_period.ToString() + " " + m_list.Count + "/" + (l_totalDuration / 60000).ToString(".") + " min");
            } while (l_totalDuration > l_durationTarget && l_period < l_iEnd && l_durationTarget > 0);
            m_rotPeriod = l_period - 1;

            if (l_Oldlist == null)
                l_Oldlist = l_list;
            l_Oldlist.Sort(c_comparer);
            return l_Oldlist;




        }

        private double getDuration(int a_base, IList a_list)
        {
            double l_totalDuration = 0;
            foreach (Piece l_piece in m_list)
            {
                if (l_piece.QRank > 0 && ListSelection.canPlay(l_piece, a_base))
                {
                    if (a_list != null)
                        a_list.Add(l_piece);
                    l_totalDuration += l_piece.Duration.TotalSeconds;
                }
            }
            return l_totalDuration;
        }

        private List<Piece> getLarge(IList<Piece> a_list)
        {
            var conf = CConf.ConfGen;

            HashList<Piece> l_large = new HashList<Piece>();
            var listClassEnabled = Consolid.QLClassed.FindAll(p => !conf.OnlyEnabled || p.Enabled);
            HashList<Piece> l_ref = new HashList<Piece>(listClassEnabled);
            int l_deltaBefore = CConf.Before;
            int l_deleteAfter = CConf.After;
            foreach (Piece l_piece in a_list)
            {
                int l_current = l_ref.IndexOf(l_piece); //l_piece.QLRank - 1;
                if (l_current < 0)
                    continue;
                int l_iBefore = l_current + l_deltaBefore;
                int l_after = l_current - l_deleteAfter;

                for (int l_iIndex = l_iBefore; l_iIndex >= l_after; l_iIndex--)
                {
                    if (l_iIndex >= 0 && l_iIndex < l_ref.Count)
                    {
                        var piece = l_ref[l_iIndex];
                        if ((!conf.OnlyEnabled || piece.Enabled) && !l_large.Contains(piece))
                            l_large.Add(piece);
                    }
                }
            }
            return l_large.List;
        }
        private void log(String txt)
        {
            logger.log(txt);
        }

        private void writePlayList(string folder, string a_fileName, List<Piece> a_list, bool withOrder, bool extendToNative)
        {

            //    BgDictString<object> dict = new BgDictString<object>();

            //if (max < a_list.Count)
            //{
            //    a_list = new List<Piece>(a_list);
            //    a_list.Reverse();
            //}
            List<IFile> list = new List<IFile>();

            //int nb = 0;
            //int nbAfterRead = -1; 
            foreach (IFile file in a_list)
            {
                //if (dict.ContainsKey(file.Location))
                //{
                //    logger.log("déjà présent '{0}'\\{1}\\{2} ", folder, a_fileName, file.Location);
                //}

                //else
                //{
                //    dict.Add(file.Location, file);
                list.Add(file);
                //nb++;
                //nbAfterRead++; 
                //if (nb >= max && nbAfterRead >= maxAfterRead)
                //    break;
                //   }

            }
            string GEN = "gen";
            if (!string.IsNullOrEmpty(folder) && !folder.EndsWith("\\"))
                GEN += "\\" + folder;
            foreach (ListWriterMgr writer in writers)
            {

                writer.writePlayList(GEN, a_fileName, list, withOrder);
                if (!extendToNative)
                    return;
            }
        }


        private void writePlayList(string a_fileName, List<Piece> a_list, bool withOrder, bool extendToNative)
        {
            writePlayList(null, a_fileName, a_list, withOrder, extendToNative);

        }

        //private class FileImpl : IFile
        //{
        //    private string location;
        //    private int id;


        //    public FileImpl(IFile file)
        //    {
        //        this.location = file.Location;
        //        this.id = file.PieceId;

        //    }

        //    #region IFile Members

        //    public string Location
        //    {
        //        get { return location; }
        //    }

        //    public override bool Equals(object obj)
        //    {
        //        var o = obj as IFile;
        //        if (o == null)
        //            return false;
        //        return location.Equals(o.Location);

        //    }

        //    public override int GetHashCode()
        //    {
        //        return location.GetHashCode();
        //    }

        //    public override string ToString()
        //    {
        //        return location;
        //    }

        //    #endregion


        //    public int PieceId
        //    {
        //        get { return id; }
        //    }
        //}
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;
using pdb.gen.Virtuel;
using pdb.gen.Tuning;

namespace pdb.gen
{
    /// <summary>
    /// G�re l'application propri�taire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private static Logger logger = Logger.getLogger("gen", true);
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des données consolidées morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        private List<Piece> allClassedInAlbumEnabled = new List<Piece>();
        private List<Piece> all = new List<Piece>();
        /// <summary>
        /// Liste des données morceux dupliqués 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        private Albums albums; // = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private static volatile object _lock = new object();
        private bool _consolidEnCours;


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private CPlayList root = new CPlayList("root", null, creator);
        public CPlayList Root { get { return root; } }
        private CPlayList musique;
        private CPlayList classement;
        private CPlayList listes;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new CPlayList("musique", root, creator);
            classement = new CPlayList("classement", root, creator);
            listes = new CPlayList("listes", root, creator);
            albums = new Albums(this);
        }

        private void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating;
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        public void buildClassTree()
        {
            buildClassTree(classement);
        }


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }
        private bool _fisrtConsolid = true;
        public Albums Albums { get { return albums; } }
        public void MakeConsolid(IEnumerable<ITrackNativeDates> dbList, bool makeSort)
        {
            try
            {
                waitForConsolid();
                logger.log("consolid");
                listPiece = new List<Piece>();
                listPieceInAlbum = new List<Piece>();
                all = new List<Piece>();

                // albums = new Albums(this);
                VirtualPiece.init();
                m_listTrackClassed = new List<Piece>();
                allClassed = new List<Piece>();
                allClassedInAlbumEnabled = new List<Piece>();
                //  htIds = new BgDict<int, Piece>();
                foreach (ITrackNativeDates track in dbList)
                {

                    if (!track.isPodcast)
                    {
                        Piece piece = null;
                        int pieceId = track.PieceId;
                        if (htIds.ContainsKey(pieceId))
                        {
                            piece = htIds[pieceId];
                            piece.initRank();
                        }
                        else
                        {
                            piece = new Piece(track);
                            htIds.Add(pieceId, piece);
                        }

                        all.Add(piece);

                    }
                }
                // link
                foreach (Piece piece in all)
                {
                    int parentId = piece.PieceParentId;
                    if (parentId > 0)
                    {
                        piece.Parent = htIds[parentId];
                    }
                }

                // liste FORT + albums

                albums.checkBuild();
                logger.log("build albums");
                foreach (Piece piece in all)
                {
                    if (piece.Parent == null)
                    {
                        listPiece.Add(piece);
                        foreach (Piece p in piece)
                        {
                            if (albums.check(p))
                                listPieceInAlbum.Add(p);
                        }
                    }
                }

                if (_albumVirtual && _fisrtConsolid)
                {
                    logger.log("build albums virtuels");
                    var listCandidat = new List<Piece>();
                    var dictTmp = new BgDictString<Album>();
                    foreach (Piece piece in all)
                    {
                        if (piece.Parent == null)
                        {
                            piece.buildVirtualAlbums(listCandidat);
                        }
                    }
                    foreach (Piece p in listCandidat)
                        albums.checkVirtual(p, dictTmp);
                    var listAlbums = new List<Album>(dictTmp.Values);
                    listAlbums.Sort(new VirtualAlbumComparer());
                    albums.checkVirtuals(listAlbums, listPieceInAlbum);

                }

                albums.buildDone();



                StackAlbum.Instance.init(all);



                foreach (Piece piece in listPieceInAlbum)
                {
                    if (!string.IsNullOrEmpty(piece.ClassName))
                    {
                        allClassed.Add(piece);
                        if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                            allClassedInAlbumEnabled.Add(piece);
                    }
                }

                if (_fisrtConsolid)
                    albums.sortVirtual();
                Ranking(makeSort);
            }
            finally
            {
                lock (_lock)
                {
                    _fisrtConsolid = false;
                    _consolidEnCours = false;
                }
            }

        }

        public void buildMusique()
        {
            var d = new HashSet<int>();
            foreach (Piece piece in all)
            {
                if (d.Add(piece.PieceId))
                    musique.addObj(piece);
            }


            foreach (Piece piece in listPieceInAlbum)
            {
                if (d.Add(piece.PieceId))
                    musique.addObj(piece);
            }


#if GEN_ALBUM

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.TrackByNumber;

                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }
#endif

        }

        public void buildLists(CPlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(CPlayList mine, CPlayList ext)
        {
            foreach (PlComponent c in ext)
            {
                if (c is CPlayList)
                {
                    var subExt = c as CPlayList;
                    var sub = new CPlayList(subExt.Name, mine);
                    sub.ID = subExt.ID;
                    // mine.add(sub);
                    buildList(sub, subExt);
                }
                else
                {
                    var t = c as IFile;
                    var piece = htIds[t.PieceId];
                    mine.add(new TrackList(piece));
                }
            }
        }

        internal Album getAlbum(TrackList track)
        {
            return albums.getAlbum(track);
        }

        public HashList<Piece> getTracksAlbum(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return new HashList<Piece>();
            return album.Tracks;
        }

        public List<Piece> getTracksAlbumReverse(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackSortedByExportPriority.List;
        }

        public List<Piece> getTracksAlbumByNumber(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackByNumber;
        }

        //public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        //{
        //    var album = getAlbum(track);
        //    if (album == null)
        //        return;
        //    foreach (var p in album.Tracks)
        //    {
        //        container.Add(p);
        //    }
        //}

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();

                var list = new List<Piece>();
                var d = new HashSet<int>();
                foreach (Piece piece in all)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                foreach (Piece piece in listPieceInAlbum)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                list.Sort(new AllPieceComparer2());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking(bool makeSort)
        {
            albums.buildStack(); 
            QRanking();
            LRanking();
            QLRanking();


            var list = new List<Piece>(listPiece);
            //logger.log("setTuningDateValues");
          

            //foreach (Piece piece in list)
            //{
            //    piece.Rank.TimeRest = -1;
            //}
            //foreach (Piece piece in list)
            //{
            //    piece.FirstClass = false;
            //    CRank rank = piece.Rank;
            //    var sortValue = CTuning.Calc(rank, CConf.Sort);
            //    rank.SortValue = sortValue;

            //    ListSelection.setTuningDateValues(piece);
            //}

            logger.log("PieceRestComparer->RankRest ");
            list.Sort(new PieceRestComparer());

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            logger.log("list.Sort(new PieceDeltaComparer());");
            list.Sort(new PieceDeltaComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankDelta = i + 1;
            }

            logger.log("PieceSortComparer->Sort ");
            list.Sort(new PieceSortComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            logger.log("AlbumsSort ");
            var all = new List<Piece>(listPieceInAlbum);
            if (makeSort)
                albums.makeSort();
            logger.log("AllPieceComparer->RankAllAlbum ");
            all.Sort(new AllPieceComparer());
            for (int i = 0; i < all.Count; i++)
            {
                all[i].RankAllAlbum = i + 1;
            }

            CTuning.Total = listPieceInAlbum.Count;

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackNativeDates> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackNativeDates track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux not�s
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.ClassementValueDecimal);
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                logger.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                logger.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        logger.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating);
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                logger.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    logger.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    logger.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    logger.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    logger.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                logger.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    logger.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            logger.log("Qranking");



            CPieceComparerByGoodness l_pieceComparer = new CPieceComparerByGoodness();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }


            //on ordonne les morceaux top-down => sont privil�gi�s les plus en vue
            listPiece.Sort(l_pieceComparer);

            //compactage de la liste en tenant compte des mieux not�s
            m_list = new CListPiece(listPiece);

            logger.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.ClassName != "")
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            logger.log("Qranking:track classed :" + m_listTrackClassed.Count);
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }

            Console.WriteLine("Qranking:total class�s : " + m_listTrackClassed.Count);

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                    break;
            }
            return Convert.ToInt32(qRank);
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur longueur
        /// </summary>
        /// <remarks></remarks>
        private void LRanking()
        {
            logger.log("LRanking");
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByLenght());
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.LRank = l_iIndex + 1;
            }
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur qualit� +longueur en cas d'�galit�
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            logger.log("QLRanking");
            m_listQL = new List<Piece>(m_listTrackClassed);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByQualityAndLength());
            int count = l_aux.Count;
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.QLRank = l_iIndex + 1;
            }

            l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.Rank.TwiceInv = l_iIndex + 1;
            }

            if (CConf.Condensation)
            {
                var l = new List<Piece>(this.listPiece);
                l.Sort(new CPieceComparerByQualityAndLength2());
                new Condenseur(m_listQL).gener2();

            }

        }

        public void builStats(Action rappel)
        {
            try
            {
                bool generDistrib = step % 10 == 0;

                if (_albumSortMode.createCourant)
                {
                    var unselected = m_listQL.FindAll(t => !t.Enabled);
                    new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("courant4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("courant4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createInter)
                {
                    var unselected = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent); //  ( CalcDate.getLastModif(t.DatesClassement) > _albumSortMode.lastModif && t.ClassementProvisoire));
                    new StatBuilder(unselected).gener3("stats3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("stats4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("stats4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createAll)
                {
                    new StatBuilder(m_listQL).gener3("all.txt", generDistrib);


                    //  new StatBuilder(m_listQL).gener3(generDistrib);
                    var stat = new StatBuilder(m_listQL) { Loupe = 1 };
                    stat.gener4("all.txt");
                    stat = new StatBuilder(m_listQL) { Loupe = 2 };
                    stat.gener4("all.txt");
                    //stat = new StatBuilder(m_listQL) { Loupe = 3 };
                    //stat.gener4("stats4.txt");
                }


            }
            catch (Exception ex)
            {
                logger.log(ex.ToString());
            }
            finally
            {
                if (rappel != null)
                    rappel();
            }
        }


        public DynamicStat generStat(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).gener(className);
        }

        public List<Piece> getTracks(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).getPieces(className);
        }



        //public void timeRanking()
        //{
        //    logger.log("timeRanking");
        //    foreach (var piece in allClassed)
        //        piece.Rank.TimeRest = -1;
        //    foreach (var piece in allClassed)
        //        ListSelection.setTuningDateValues(piece);


        //}

        ///// <summary>
        ///// redirection des index metier de la table m�tier vers la table locale
        ///// Copie des valeurs pertinentes(classlist)
        ///// </summary>
        ///// <remarks></remarks>
        //public void eraseGrouping()
        //{
        //    thCommentGo = false;
        //    thGroupingGo = false;
        //    logger.log("eraseGrouping");
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        piece.setGrouping("", false);
        //        piece.Comment = "";
        //    }
        //}
        //public void writeGrouping()
        //{
        //    logger.log("writeGrouping");
        //    var list = new List<Piece>(listPieceInAlbum);
        //    // list.Sort(new CPieceComparerByQualityAndLength());
        //    list.Sort(new AllPieceComparer2());

        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}


        //private bool thGroupingGo;
        //private bool thCommentGo;

        //public bool GroupinGO
        //{
        //    set
        //    {
        //        thGroupingGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}
        //public bool CommentGo
        //{
        //    set
        //    {
        //        thCommentGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}



        //private void writeGroupingAsync()
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        try
        //        {
        //            if (!thGroupingGo)
        //                return;
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}

        //private void writeCommentAsync()
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in listPiece)
        //    {
        //        try
        //        {
        //            if (!thCommentGo)
        //                return;
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeComment::" + ex.ToString());
        //        }
        //    }
        //}

        //public void writeGrouping(Piece piece)
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    piece.writeGrouping(writeGrouping);

        //}
        // private bool _sortByAlbum = true;
        //   public bool SortByAlbum { get { return _albumSortMode.Enabled; } }

        private ConfAlbumSort _albumSortMode;
        public ConfAlbumSort SortAlbumMode { set { _albumSortMode = value; } get { return _albumSortMode; } }

        private bool _albumVirtual = CConf.ConfGen.AlbumVirtual;
        public bool AlbumVirtual { get { return _albumVirtual; } set { _albumVirtual = value; } }

        //public void writeComment()
        //{
        //    logger.log("writeComment");
        //    var list = new List<Piece>(listPiece);
        //    list.Sort(new CPieceComparerByQualityAndLength());

        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeComment::" + ex.ToString());
        //        }
        //    }




        //}

        //public void writeComment(Piece piece)
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    try
        //    {
        //        piece.writeComment(writeComment);
        //    }
        //    catch (Exception ex)
        //    {
        //        logger.log("writeComment::" + ex.ToString());
        //    }
        //}



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter m_listWriterAlb;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public static object Lock { get { return _lock; } }
        public void createRot(string a_baseName, params IListWriter[] writers)
        {
            lock (_lock)
            {
                var conf = CConf.ConfGen;

                logger.log("Clegacy:createRot {0}", a_baseName);
                List<Piece> l_list = new List<Piece>(m_listTrackClassed);
                List<Piece> l_listAlb = new List<Piece>(allClassedInAlbumEnabled);
                var l_all = new List<Piece>(listPieceInAlbum);
                //  List<Piece> source = null;
                ////  if (SortByAlbum)
                //      source = allClassedInAlbumEnabled;
                //  else
                //      source = m_listTrackClassed;
                //  foreach (Piece l_piece in source)
                //  {
                //      //if (l_piece.belongsTo(a_baseName))
                //      //{
                //      l_list.Add(l_piece);
                //      // }
                //  }





                listWriterAll = new CLegacyListWriter(l_all);






                //      m_listWriter.reset();
                m_listWriter = new CLegacyListWriter(l_list);
                foreach (IListWriter writer in writers)
                    m_listWriter.addWriter(writer);
                //    logger.log("fin creation des writers 0");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {
                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriter.writeGen(mode, duration, "g", false, false);
                            if (conf.GenE)
                                m_listWriter.writeGen(mode, duration, "e", true, false);
                        }
                    }
                }

                if (conf.GenCheck)
                    m_listWriter.writeCheckClassement(0);

                for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
                {
                    m_listWriter.writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                    if (conf.GenE)
                        m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
                }
                m_listWriterAlb = new CLegacyListWriter(l_listAlb);

                foreach (IListWriter writer in writers)
                    m_listWriterAlb.addWriter(writer);

                //  logger.log("fin creation des writers alb");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {

                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriterAlb.writeGen(albums, mode, duration, "g", false);
                        }
                    }
                }

                foreach (IListWriter writer in writers)
                    listWriterAll.addWriter(writer);
                listWriterAll.writeGen(albums, null, null, "all", false);
                //  misc.log("Clegacy:fin createRot {0}", a_baseName);
                return;

                writeRot(1);

                m_listWriter.writeCheckClassement(1);

                m_listWriter.reset();
                writeRotMin(-1);
                writeRotMin(10);
                writeRotMin(1);
            }
        }
        private void writeRotMin(int a_nbHour)
        {
            logger.log("----------------------");
            m_listWriter.writeRotMin(a_nbHour);
        }
        private void writeRot(int a_base)
        {
            m_listWriter.writeRot(a_base);

        }
        #endregion
    }
}



]]></content>
  </file>
  <file path="\PieceDb.Consolid\Piece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;
using System.Linq;
using System.Text.RegularExpressions;
using System.Diagnostics;

namespace pdb.gen
{
    public enum infoMedianne : short
    {
        none = 0,
        med = 1,
        medLight = 2,
        border = 4,
        borderEff = 8,
        borderMin = 16
    }
    /// <summary>
    /// Ajout de données utiles Ranq
    /// </summary>
    public class Piece : ITrackMetaData, IFile, ITrackNativeDates, IEnumerable<Piece>
    {
        private ITrackNativeDates track;
        public bool Virtual { get { return PieceId < 0; } }
        public virtual bool VirtualByArtist { get { return false; } }
        // private String className = "";
        private static CultureInfo en = new CultureInfo("en-US");
        //  private static List<displayCategory> minCategories;

        protected static Consolid gen;
        public static Consolid Gen { set { gen = value; } }

        static Piece()
        {
            //   minCategories = new List<displayCategory> { displayCategory.rankTime, displayCategory.timeValue, displayCategory.dates, displayCategory.pertinentDates };
        }

        public ITrackNativeDates Track { get { return track; } }

        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank
        {
            get
            {
                if (parent == null)
                    return m_rank;
                return parent.m_rank;
            }
        }

        private infoMedianne _infoMedianne;
        public void eraseInfoMedianne() { _infoMedianne = infoMedianne.none; }
        public infoMedianne InfoMedianne { get { return _infoMedianne; } }
        public bool Medianne
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.med);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Medianne)
                    return;
                _infoMedianne |= infoMedianne.med;
            }
        }
        public bool MedianneLight
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.medLight);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (MedianneLight)
                    return;
                _infoMedianne |= infoMedianne.medLight;
            }
        }

        public bool Border
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.border);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Border)
                    return;
                _infoMedianne |= infoMedianne.border;
            }
        }

        public bool BorderEffect
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderEff);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderEffect)
                    return;
                _infoMedianne |= infoMedianne.borderEff;
            }
        }

        public bool BorderMin
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderMin);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderMin)
                    return;
                _infoMedianne |= infoMedianne.borderMin;
            }
        }


        public virtual void initRank()
        {
            //  _classementCache = null; 
            //_infoMedianne = infoMedianne.none;
            // _classementProvisoireRecent = null;

            // _lnClassement = int.MinValue; 
            Rank.init();
        }

        public int QRank
        {
            get { return Rank.Quality; }
            set { Rank.Quality = value; }
        }

        public int LRank
        {
            get { return Rank.Lenght; }
            set { Rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return Rank.Twice; }
            set { Rank.Twice = value; }
        }

        public int RankAllAlbum
        {
            get { return m_rank.RankAllAlbum; }
            set { m_rank.RankAllAlbum = value; }
        }

        public int RankAlbum { get { if (album == null) return 0; return album.Rank.Sort; } }

        public bool AlbumAbsent { get { if (album == null) return true; return album.Absent; } }

        //public int nbInAlbum(exportState state ) { if (album == null) return -1; return album.nbInAlbum(state);  }
        public int NbExportPresents { get { if (album == null) return -1; return album.NbExportPresents; } }

        //public bool SameAlbum(Piece x)
        //{
        //    if (x == null)
        //        return false; 
        //    return album == x.album; 
        //}

        public int IndexExport { get { if (album == null) return -1; return album.IndexExport(this); } }

        //  public TuningData TuningData { get { return m_rank.Rest; } set { m_rank.Rest = value; } }
        #endregion



        public bool FirstClass { get { return track.FirstClass; } set { track.FirstClass = value; } }
        private Album album;

        public Album PieceAlbum { get { return album; } set { album = value; } }
        public int StackValue { get { if (album == null) return 0; return album.StackValue; } }
        public int StackIndex { get { if (album == null) return 0; return album.StackIndex; } }
        public bool Moved { get { if (album == null) return false; return album.Moved && SelectedMotif == selectedCoeff.noCoeff; } set { if (album != null) album.Moved = value; } }
        public bool MovedM
        {
            get
            {
                if (album == null) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return album.Moved;
                    default:
                        return false;
                }
            }
        }

        public bool isEmpeached()
        {
             if (album == null) return false; 
            return album.Empeached; 
        }
        
        public bool Empeached { get { if (album == null) return false; return album.Empeached && SelectedMotif == selectedCoeff.noCoeff; } set { if (album != null) album.Empeached = value; } }
        public bool EmpeachedM
        {
            get
            {
                if (album == null) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return album.Empeached;
                    default:
                        return false;
                }
            }
        }
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get { if (album == null) return false; return album.Empeached1 && this == album.Next; } set { if (album != null) album.Empeached1 = value; } }
        public bool AlmostFree { get { if (album == null) return false; return album.AlmostFree && this == album.Next; } }
        public bool AlmostFree1 { get { if (album == null) return false; return album.AlmostFree1 && this == album.Next; } }

        public bool AlbumRecentlyUpdated { get { return StackValue > 0 && SelectedMotif == selectedCoeff.noCoeff; } }
        public bool AlbumRecentlyUpdatedMain
        {
            get
            {
                if (StackValue == 0) return false; 
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return true; 
                    default:
                        return false;
                }
            }
        }
       

        //private static int _sID = 0;
        //private int _dID;
        internal Piece(ITrackNativeDates track)
        {
            //_sID++;
            //_dID = _sID;
            if (track == null)
                Debugger.Launch();
            this.track = track; initRank();

#if VOL
            int volumeMin = CConf.VolumeMin;
            if (Volume < volumeMin)
                Volume = volumeMin;
#endif
        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList()
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        public String ClassName { get { return track.ClassName; } set { track.ClassName = value; } }

        public void setClassement(string className, int rating)
        {
            if (className == null)
                return;
            track.setClassement(className, rating);
            invalidateCache();

        }
        private static ClassementHash classementHash = new ClassementHash();
        private ClassementCache _classementCache;
        private ClassementCache ClassementCache
        {
            get
            {


                if (_classementCache == null)
                {
                    if (parent != null)
                        _classementCache = parent.ClassementCache;
                    if (_classementCache == null)
                        _classementCache = classementHash.getCache(track.ClassName, track.Rating);
                }
                return _classementCache;
            }
        }
        public virtual void invalidateCache()
        {

            //_classNameAndRating = null;
            //_classementValueDecimal = -1;
            //_rapportClassement = -1;
            //  _classementProvisoireRecent = null;

            if (parent != null)
                parent.invalidateCache();
            else
            {
                _classementCache = null;
                foreach (Piece p in childs)
                {
                    p._classementCache = null;
                }
            }


        }

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in track.PLayLists)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        #region CPieceComparer compatibilité
        public List<CPlayList> ClassPlayLists
        {
            get { return track.ClassPlayLists; }
        }
        /// <summary>
        /// ClassList principale
        /// </summary>
        public CPlayList ClassPlayList
        {
            get
            {
                List<CPlayList> classLists = track.ClassPlayLists;
                if (classLists.Count > 0)
                    return classLists[0];
                return null;
            }
        }


        public int RatingCmp
        {
            get
            {
                int rating = track.Rating;
                if (rating < 0)
                    return 0;
                return rating;
            }
        }
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return ClassName.isInteger();
            }
        }

        // private string _classNameAndRating;
        public String ClassNameAndRating
        {
            get
            {
                return ClassementCache.ClassNameAndRating;
            }
        }

        // private decimal _classementValueDecimal = -1;
        public decimal ClassementValueDecimal
        {
            get
            {
                return ClassementCache.ClassementValueDecimal;
            }
        }
        //private double _classementValue = -1; 
        //public double ClassementValue
        //{
        //    get
        //    {
        //        if (_classementValue == -1)
        //        {
        //            if (!isClassListNumeric)
        //                _classementValue = 0;
        //            else
        //            {
        //                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
        //                _classementValue= Convert.ToDouble(classNameAndRating);
        //            }
        //        }

        //        return _classementValue; 
        //    }
        //}

        public static decimal getRapport(decimal base6)
        {
            string str = base6.ToString("0.######").Replace(",", "");
            return getRapport(str);
        }

        public static decimal getRapport(string classNameAndRating)
        {
            decimal resultat = 0m;
            char[] tab = classNameAndRating.ToCharArray();

            decimal K = 1;
            int count = tab.GetLength(0);


            for (int i = 0; i < count; i++)
            {
                K = K * 6;
                int c = Convert.ToInt32(tab[i].ToString());
                resultat += (decimal)c / K;
            }

            return resultat;
        }

        // private decimal _rapportClassement = -1;
        public decimal RapportClassement
        {
            get
            {
                return ClassementCache.RapportClassement;
                //if (parent != null)
                //    return parent.RapportClassement;
                //if (_rapportClassement != -1)
                //    return _rapportClassement;

                //decimal resultat = 0;
                //try
                //{
                //    return getRapport(ClassNameAndRating);
                //}
                //catch
                //{
                //}
                //_rapportClassement = resultat;
                //// _classementVirtuel = resultat; 
                //return _rapportClassement;
            }
        }


        //private decimal _lnClassement = -1;
        //public decimal LnClassement
        //{
        //    get
        //    {
        //        if (_lnClassement == int.MinValue)
        //        {
        //            var rapport = RapportClassement;
        //            if (rapport <= 0m)
        //                _lnClassement = 0m;
        //            else
        //                _lnClassement = Math.Log10(rapport) + 10;
        //        }
        //        return _lnClassement; 
        //    }
        //}
        static int NB_DEC = 4;
        public static string getReadableCl(string str)
        {
            int count = str.Length;
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {
                        if (i >= NB_DEC)
                        {
                            i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();
        }

        public static string getClassementEquiv(decimal valRapport)
        {
            if (valRapport < 0)
                return "";
            if (valRapport == 0m)
                return "0";
            decimal v = 0;
            decimal r = valRapport;
            StringBuilder sb = new StringBuilder();
            int _ok = Int16.MaxValue;

            for (int i = 0; i < 13; i++)
            {
                v = 6 * r;
                int a = (int)(v + 0.0001m);
                if (a > 0 && i < _ok)
                {
                    _ok = i;
                }
                r = v - a;
                if (r < 0)
                    r = 0;
                sb.Append(a);


                if (i >= _ok + 4)
                    break;
            }
            var str = sb.ToString();
            str = str.Insert(str.Length - 1, ".");
            return getReadableCl(str);
        }




        public decimal RapportClassementDecimal
        {
            get
            {
                if (parent != null)
                    return parent.RapportClassementDecimal;
                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1m;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                return resultat;
            }
        }

        public int classPrecision()
        {
            string classNameAndRating = ClassNameAndRating;
            int precision = 0;
            char[] tab = classNameAndRating.ToCharArray();
            int count = tab.GetLength(0);

            int iIndexDepart = -1;
            int iIndexFin = -1;
            for (int i = 0; i < count; i++)
            {
                Char c = tab[i];
                if (iIndexDepart < 0)
                {
                    if (c != '0')
                        iIndexDepart = i;
                }

                if (c != '0')
                    iIndexFin = i;
            }

            precision = iIndexFin - iIndexDepart + 1;

            return precision;
        }
        #endregion

        #region compatibilité CList
        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackIdentity other)
        //{
        //    //return track.Location == other.Location; 
        //    String location = track.Location;
        //    return (location.Equals((other.Location)) || CUtil.DefinedEquals(track.Artist, track.Album, track.Name, track.TrackNumber, other.Artist, other.Album, other.Name, other.TrackNumber));
        //}
        #endregion

        #region ITrackNative Membres

        public string Artist
        {
            get
            {
                return track.Artist;
            }
            set
            {
                if (track.Artist != value)
                {
                    try
                    {
                        //                 misc.log("change artist from '{0}' to'{1}'", track.Artist, value);
                        track.Artist = value;
                    }
                    catch { misc.log("unable to change artist {0}  {1}", track.Artist, value); }
                }
            }
        }

        public virtual string Album
        {
            get
            {
                return track.Album;
            }
            set
            {
                if (track.Album != value)
                {
                    try
                    {
                        //                   misc.log("change Album from '{0}' to'{1}'", track.Album, value);
                        track.Album = value;
                    }
                    catch { misc.log("unable to change album {0}  {1}", track.Album, value); }
                }
            }
        }

        public string Name
        {
            get
            {
                return track.Name;
            }
            set
            {
                if (track.Name != value)
                {
                    try
                    {
                        //                 misc.log("change Name from '{0}' to'{1}'", track.Name, value);
                        track.Name = value;
                    }
                    catch { misc.log("unable to change name {0}  {1}", track.Name, value); }
                }
            }
        }

        public virtual int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (track.TrackNumber != value)
                {
                    try
                    {
                        //              misc.log("change TrackNumber from '{0}' to'{1}'", track.TrackNumber, value);
                        track.TrackNumber = value;
                    }
                    catch { misc.log("unable to change TrackNumber {0}  {1}", track.TrackNumber, value); }
                }
            }
        }

        public int Rating
        {
            get
            {
                return track.Rating;
            }
            set
            {
                if (track.Rating != value)
                {
                    try
                    {
                        //                misc.log("change Rating from '{0}' to'{1}'", track.Rating, value);
                        track.Rating = value;
                    }
                    catch { misc.log("unable to change Rating {0}  {1}", track.Rating, value); }
                }
            }
        }

        public int Year
        {
            get
            {
                return track.Year;
            }
            set
            {
                if (track.Year != value)
                {
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Year = value;
                    }
                    catch { misc.log("unable to change Year {0}  {1}", track.Year, value); }
                }
            }
        }

#if VOL
        public int Volume
        {
            get
            {
                int volumeMin = CConf.VolumeMin;
                int trackVolume = track.Volume;
                if (trackVolume < volumeMin)
                {
                    Volume = volumeMin;
                }
                return trackVolume;
            }
            set
            {
                if (track.Volume != value)
                {
                    int volumeMin = CConf.VolumeMin;
                    int _value = Math.Max(value, volumeMin);
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Volume = _value;
                    }
                    catch { misc.log("unable to change Volume {0}  {1}", track.Volume, _value); }
                }
            }
        }
#endif

        //public string Comment
        //{
        //    get
        //    {
        //        //if (string.IsNullOrEmpty(track.Comment))
        //        //    gen.writeComment(this);
        //        return track.Comment;
        //    }
        //    set
        //    {
        //        //if (track.Comment != value)
        //        //{
        //        try
        //        {
        //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //            track.Comment = value;
        //        }
        //        catch { misc.log("unable to change Comment {0}  {1}", track.Comment, value); }
        //        //}
        //    }
        //}

        //public virtual string Grouping
        //{
        //    get
        //    {
        //        if (string.IsNullOrEmpty(track.Grouping))
        //        {
        //            gen.writeGrouping(this);
        //        }
        //        return track.Grouping;
        //    }
        //    //set
        //    //{
        //    //    //if (track.Grouping != value)
        //    //    //{
        //    //        try
        //    //        {
        //    //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //    //            track.Grouping = value;
        //    //        }
        //    //        catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        //    //    //}
        //    //}

        //}





        //public virtual void setGrouping(string value, bool prior)
        //{
        //    try
        //    {
        //        //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //        track.setGrouping(value, prior);
        //    }
        //    catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        //}

        public bool Enabled
        {
            get
            {
                return track.Enabled;
            }
            set
            {
                if (track.Enabled != value)
                {
                    try
                    {
                        //      misc.log("change Enabled from '{0}' to'{1}'", track.Enabled, value);
                        track.Enabled = value;
                    }
                    catch { misc.log("unable to change Enabled {0}  {1}", track.Enabled, value); }
                }
            }
        }



        public bool isPodcast
        {
            get { return track.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return track.PlayedDate; }
        }

        public string Location
        {
            get { return track.Location; }
        }
        public string getLocation()
        {
            return track.getLocation();
        }

        public TimeSpan Duration
        {
            get { return track.Duration; }
            set { track.Duration = value; }
        }

        #endregion

        public List<DateTime> Dates
        {
            get { return track.Dates; }
        }
        public string ArtWork
        {
            get { return track.ArtWork; }
            set { track.ArtWork = value; }
        }

        public DateTime FirstAcces
        {
            get
            {
                var min = DateTime.MaxValue;
                foreach (DateTime dt in Dates)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt;
                }
                foreach (DateTime dt in DatesClassementBrut)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt;
                }

                return min;
            }
        }

        public DateTime Added
        {
            get
            {
                return track.Added;
            }
        }

        public virtual DateTime AlbumAdded
        {
            get
            {
                return album.AlbumAdded;
            }
        }

        public List<DateTime> DatesClassement { get { return track.DatesClassement; } }
        public DateTime? UpdateClassement
        {
            get
            {

                var dc = CalcDate.getLastModif(DatesClassement);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public bool LastClassementRecent
        {
            get
            {

                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > Piece.SeuilProvisoire)
                        return true;
                }
                return false;

            }
        }
        public DateTime? AlbumUpdateClassement
        {
            get
            {
                if (album == null)
                    return null;
                return album.UpdateClassement;
            }
        }

        public DateTime? LastRead
        {
            get
            {

                var dc = CalcDate.getLastModif(Dates);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public DateTime? AlbumLastRead
        {
            get
            {
                if (album == null)
                    return null;
                return album.LastRead;
            }
        }

        public String ClassEvol { get { return track.ClassEvol; } }

     


        //public void writeCommentGrouping()
        //{
        //    var mode = CConf.ConfGen.WriteComment;
        //    writeComment(mode);
        //    var modeg = CConf.ConfGen.WriteGrouping;
        //    writeGrouping(modeg);

        //}

        //public List<CPlayList> PLayLists
        //{
        //    get { return track.PLayLists; }
        //}

        /// <summary>
        /// Calculer le commentaire
        /// </summary>
        //public void writeComment(writeGrouping mode)
        //{
        //    if (parent != null)
        //        return;
        //    if (mode == Tuning.writeGrouping.none)
        //        return;


        //    if (mode == Tuning.writeGrouping.mix)
        //    {
        //        StringBuilder sbEnd = new StringBuilder();

        //        sbEnd.Append(ClassName);
        //        sbEnd.Append(".");
        //        sbEnd.Append((RatingCmp / 20).ToString());
        //        sbEnd.Append(ClassEvol);
        //        string strEnd = sbEnd.ToString();
        //        string found = "";

        //        string[] tab = Comment.Split(' ');
        //        int count = tab.GetLength(0);
        //        if (count > 0)
        //        {
        //            found = tab[count - 1];
        //            if (found.Equals(strEnd))
        //                return;
        //        }
        //        writeComment(Tuning.writeGrouping.all);
        //    }

        //    StringBuilder sb = new StringBuilder();
        //    //string l_pref = "";
        //    //string l_str = "";

        //    string l_strList = ClassName;
        //    //if (ClassPlayList != null)
        //    //    l_strList = ClassName;

        //    ////if (m_classement.Imported)
        //    ////{
        //    //if (l_strList != ClassName)
        //    //{
        //    //    sb.Append("m (");
        //    //    sb.Append(ClassName);
        //    //    sb.Append(") "); 
        //    //  //  l_pref = "m (" + ClassName + ") ";
        //    //}
        //    ////}
        //    int l_rank = Rank.Twice;

        //    if (l_rank > 0)
        //    {
        //        CTuning.format(sb, l_rank);
        //        sb.Append(" ");
        //        //    if (l_rank < 1000)
        //        //    {
        //        //        if (CTuning.Total > 1000)
        //        //        {
        //        //            l_str += "0";
        //        //        }
        //        //        if (l_rank < 100)
        //        //        {
        //        //            l_str += "0";
        //        //            if (l_rank < 10)
        //        //            {
        //        //                l_str += "0";
        //        //            }
        //        //        }
        //        //    }


        //        var r = CTuning.Rapport(Rank.Quality);






        //        var quality = CConf.Select.Quality;
        //        //if (quality.Mode != listMode.substract || quality.Exp != 1 || quality.Offset != 0 || CConf.Select.TimePriority != 0)
        //        //{
        //        double tx0 = Convert.ToInt32(1000 * r);
        //        sb.Append(tx0.ToString());
        //        sb.Append(" ");
        //        //}

        //        //  double l_tx = Convert.ToInt32(1000 * CTuning.Calc(m_rank, CConf.Select)); //   RapportNorm(m_rank.Quality, CConf.Sort.Quality));
        //        var l_tx = CConf.ConfGen.Vie.TotalDays() / CTuning.Calc(m_rank, CConf.Select);
        //        //  double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
        //        //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
        //        //getTx(m_rank.Lenght)
        //        //     l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();


        //        sb.Append(l_tx.FormatCustom(3, 4)); //   ToString("G2", en));
        //        //if (l_tx < 100 || l_tx >= 1000)
        //        //    sb.Append(l_tx.ToString("G2", en));
        //        //else
        //        //    sb.Append(Convert.ToInt64(l_tx).ToString("D", en)); 



        //        sb.Append(" ");
        //        var rest = r;

        //        for (int i = 0; i < 4; i++)
        //        {
        //            var ee = rest * 6.0m;
        //            int e = (int)System.Math.Floor(ee);
        //            rest = ee - e;
        //            sb.Append(e);
        //        }



        //        sb.Append(" ");


        //        //sb.Append(l_tx2.ToString());
        //        //sb.Append(" ");
        //        //sb.Append((100 * m_rank.SortValue).ToString("0"));
        //        //sb.Append(" ");

        //        //sb.Append(Dates.Count.ToString()); sb.Append(" ");

        //        //sb.Append(DatesClassement.Count.ToString()); sb.Append(" ");

        //        //sb.Append(ListSelection.buildListReadOrClassementModified(this).Count.ToString()); sb.Append(" ");

        //        //   sb.Append((100 * m_rank.TimeRest).ToString("0")); sb.Append(" ");



        //        sb.Append(l_strList);
        //        sb.Append(".");
        //        sb.Append((RatingCmp / 20).ToString());

        //    }

        //    sb.Append(ClassEvol);



        //    Comment = sb.ToString();
        //    //Comment = l_pref + l_str + ClassEvol;
        //}

        public override string ToString()
        {
            return track.ToString();
        }

        public override bool Equals(object obj)
        {
            Piece p = obj as Piece;
            if (p == null)
                return false;
            return PieceId.Equals(p.PieceId);
        }

        private decimal _classementVirtuel;

        public string ClassementVirtuel { get { return Piece.getClassementEquiv(_classementVirtuel); } }
        public decimal VirtualClassement { get { return _classementVirtuel; } }
        public void setClassementVirtuel(decimal virt)
        {
            _classementVirtuel = virt;
        }

        public decimal CoeffVirtuel
        {
            get
            {
                if (_classementVirtuel == 0)
                    return 0;
                return RapportClassement / _classementVirtuel;
            }
        }

        private decimal _classementVirtuel2;

        public string ClassementVirtuel2 { get { return Piece.getClassementEquiv(_classementVirtuel2); } }
        public decimal VirtualClassement2 { get { return _classementVirtuel2; } }
        public void setClassementVirtuel2(decimal virt)
        {
            _classementVirtuel2 = virt;
        }

        public decimal CoeffVirtuel2
        {
            get
            {
                if (_classementVirtuel2 == 0)
                    return 0;
                return RapportClassement / _classementVirtuel2;
            }
        }

        public override int GetHashCode()
        {
            return PieceId.GetHashCode();
        }

        //private bool haveToUpdateGrouping = false;
        //public void MarkAsUpdateGrouping() { haveToUpdateGrouping = true; }

        //public void writeGrouping(writeGrouping writeGrouping)
        //{
        //    var cat = CConf.ConfGen.DisplayCategories;
        //    //if (!CConf.ConfGen.WithOrder)
        //    //    cat = minCategories; 
        //    if (writeGrouping == Tuning.writeGrouping.none)
        //        return;

        //    //if (m_rank.Twice <= 0)
        //    //    return;
        //    if (haveToUpdateGrouping)
        //    {
        //        setGrouping(getGroup(cat), true);
        //    }

        //    else if (writeGrouping == Tuning.writeGrouping.mix)
        //    {
        //        bool haveToUpdate = false;
        //        string org = Grouping;
        //        if (org != null)
        //        {
        //            string[] data = org.Split(' ');

        //            try
        //            {
        //                foreach (datesMode mode in Enum.GetValues(typeof(datesMode))) //  CConf.ConfGen.Modes) //  Enum.GetValues(typeof(datesMode)))
        //                {
        //                    DisplayGrouping found = cat.Find(c => (int)c.category == (int)mode);
        //                    //displayCategory found = cat.Find(c => (int)c == (int)mode);
        //                    if (found != null)
        //                    {
        //                        int indexOfTime = cat.IndexOf(found);

        //                        string timeValue = data[indexOfTime];
        //                        string newValue = getTimeValue(mode, found.mode);
        //                        if (!newValue.Equals(timeValue))
        //                        {
        //                            haveToUpdate = true;
        //                            break;
        //                        }
        //                    }
        //                }
        //            }
        //            catch
        //            {
        //                haveToUpdate = true;
        //            }
        //        }
        //        else
        //        {
        //            haveToUpdate = true;
        //        }
        //        if (haveToUpdate)
        //            setGrouping(getGroup(cat), true);
        //    }
        //    else
        //        setGrouping(getGroup(cat), false);
        //}



        private string getTimeValue(datesMode modeDates, timeMode modeTime)
        {
            switch (modeTime)
            {
                case timeMode.simple: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates)).FormatCustomTs(2);
                case timeMode.complex: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustomTs(2);
                case timeMode.last:
                case timeMode.equiv:
                case timeMode.equivNorm:
                    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    if (modeTime == timeMode.equivNorm)
                        return ts.FormatCustomTs(3, 2, 4);
                    return ts.FormatCustomTs(2);

                case timeMode.delta:
                case timeMode.deltaNorm:

                    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
                    var delta = tsf - ts0;
                    delta = delta * 100;
                    //if (modeTime == timeMode.deltaNorm)
                    //    return delta.FormatCustom(3, 2, 4);
                    return "(" + delta.FormatCustomTs(2) + ")";
                default:
                    throw new NotImplementedException();

            }

            //if (modeTime == timeMode.complex)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustom(2);
            //else if (modeTime == Tuning.timeMode.simple)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates)).FormatCustom(2);
            ////   return m_rank.TimeRest.FormatCustom(2); //.ToString("G2", en); 
            //else if (modeTime == timeMode.equiv || modeTime == timeMode.equivNorm)
            //{
            //    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);

            //    if (modeTime == timeMode.equivNorm || modeTime == timeMode.deltaNorm)
            //        return ts.FormatCustom(3, 2, 4);
            //    return ts.FormatCustom(2);
            //}
            //else
            //{
            //    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
            //    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
            //    var delta = tsf - ts0;

            //    if (modeTime == timeMode.equivNorm)
            //        return delta.FormatCustom(3, 2, 4);
            //    return delta.FormatCustom(2);
            //}
        }

        public int RankAlbumReverse
        {
            get
            {
                if (album != null)
                {
                    int rank = album.Rank.Sort;
                    rank = 1 + gen.Albums.Count - rank;
                    return rank;
                }
                return 0;
            }
        }

        private string getGroup(List<DisplayGrouping> categories)
        {
            StringBuilder sb = new StringBuilder();

            bool begin = false;

            displayCategory last = displayCategory.none;
            foreach (var category in categories)
            {
                try
                {
                    if (begin //&& (int)category.category <= (int)displayCategory.pipe
                        && last != displayCategory.croc1 && last != displayCategory.par1
                        && category.category != displayCategory.croc2 && category.category != displayCategory.par2)
                        sb.Append(" ");
                    begin = true;

                    switch (category.category)
                    {
                        case displayCategory.rankSort:
                            CTuning.format(sb, Rank.Sort); break;
                        case displayCategory.rankDelta:
                            CTuning.format(sb, Rank.RankDelta); break;
                        case displayCategory.rankTime:
                            CTuning.format(sb, Rank.RankRest); break;
                        case displayCategory.rankAllAlbum:
                            CTuning.format(sb, RankAllAlbum); break;
                        case displayCategory.rankAlbum:
                            if (album != null)
                                sb.Append(album.Rank.Sort); break;
                        case displayCategory.rankAlbumReverse:
                            sb.Append(RankAlbumReverse);
                            break;
                        case displayCategory.rankEquiv:
                            if (album != null)
                                sb.Append(album.Equiv);
                            break;
                        case displayCategory.rankEquivLight:
                            if (album != null)
                                sb.Append(album.EquivLight);
                            break;
                        case displayCategory.rankEquivLight0:
                            if (album != null)
                                sb.Append(album.EquivLight0);
                            break;
                        case displayCategory.albumMoy:
                            if (album != null)
                            {
                                sb.Append(album.Moyenne);
                            }
                            break;
                        case displayCategory.lenght:
                            sb.Append(Convert.ToInt32(100 * CTuning.Rapport(Rank.Lenght))); break; //   CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length))); break;
                        case displayCategory.sortValue:
                            sb.Append((1000 * Rank.SortValue).ToString("####", en)); break;
                        case displayCategory.tplay:
                            sb.Append(getTimeValue(datesMode.play, category.mode)); break;
                        case displayCategory.tclass:
                            sb.Append(getTimeValue(datesMode.@class, category.mode)); break;
                        case displayCategory.tclassMin:
                            sb.Append(getTimeValue(datesMode.classMin, category.mode)); break;
                        case displayCategory.tmix:
                            sb.Append(getTimeValue(datesMode.mix, category.mode)); break;
                        case displayCategory.tmixMin:
                            sb.Append(getTimeValue(datesMode.mixMin, category.mode)); break;
                        case displayCategory.timeCoeff:
                            sb.Append((100 * Rank.TimeCoeff).ToString("G3", en)); break;
                        case displayCategory.dplay:
                            sb.Append(ListSelection.getPlayDates(this).Count.ToString()); break;
                        case displayCategory.dclass:
                            sb.Append(ListSelection.getDatesClassement(this).Count.ToString());
                            break;
                        case displayCategory.dclassMin:
                            sb.Append(ListSelection.getClassDatesMin(this).Count.ToString()); break;
                        case displayCategory.dmix:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, false).Count.ToString());
                            break;
                        case displayCategory.dmixMin:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, true).Count.ToString());
                            break;
                        case displayCategory.pipe:
                            sb.Append("|");
                            break;
                        case displayCategory.par1: sb.Append("("); break;
                        case displayCategory.par2: sb.Append(")"); break;
                        case displayCategory.croc1: sb.Append("["); break;
                        case displayCategory.croc2: sb.Append("]"); break;

                        default:
                            break;
                    }


                    last = category.category;
                }

                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }
            }
            return sb.ToString();
        }

        public virtual int PieceId
        {
            get
            {
                return track.PieceId;
            }
        }

        public void albumMustRefresh()
        {
            foreach (Piece p in Master)
            {
                if (p.album != null)
                    p.album.mustRefresh();
            }
        }


        protected Piece parent;
        public virtual Piece Parent
        {
            get { return parent; }
            set
            {
                if (value == parent)
                    return;
                var old = parent;
                if (old != null)
                    old.albumMustRefresh();
                parent = value;
                if (parent == null)
                {
                    if (old != null)
                    {
                        old.removeChild(this);
                        this.PieceParentId = -1;
                    }
                }
                else
                {
                    parent = parent.Master;
                    this.PieceParentId = value.MasterId;
                    parent.addChild(this);
                }
                if (album != null)
                    this.album.mustRefresh();
            }
        }
        public Piece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        public int MasterId { get { return Master.PieceId; } }

        private List<Piece> childs = new List<Piece>();
        public List<Piece> Childs { get { return childs; } }
        protected void addChild(Piece child)
        {
            if (child != null && parent != null)
                throw new ApplicationException(string.Format("on ne doit pas affecter un enfant à un non-maitre. enfant:{0} parent {1}", child, parent));

            //if (childs.Contains(child))
            //{
            //    throw new ApplicationException("enfant déjà enregistré"));
            //}
            childs.Add(child);
        }

        public void consolidChild()
        {
            if (parent != null)
            {
                parent.addChild(this);
            }
        }

        private void removeChild(Piece child)
        {
            childs.Remove(child);
        }

        public virtual int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public exportState ExportStatus
        {
            get
            {
                return track.ExportStatus; // exportState;
            }
            set
            {
                track.ExportStatus = value;
            }
        }




        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public void buildVirtualAlbums(List<Piece> list)
        {

            foreach (var path in track.RelativesPath)
            {

                var tab = path.Split('\\');
                var sb = new StringBuilder();

                sb.Append(@"\");
                var count = tab.GetLength(0);
                for (int i = 0; i < count; i++)
                {
                    var _s = tab[i];
                    if (string.IsNullOrEmpty(_s))
                        continue;

                    var virt = createVirtualAlbum(sb.ToString(), false);

                    if (virt != null)
                        list.Add(virt);

                    if (i > 0)
                        sb.Append(@"\");
                    sb.Append(_s);




                }
            }

            if (CConf.ConfGen.ArtistVirtual)
            {
                foreach (Piece p in this)
                {
                    var virt = createVirtualAlbum(p.Artist, true);
                    if (virt == null)
                        continue;
                    list.Add(virt);
                }

            }

        }

        private Piece createVirtualAlbum(string path, bool artist)
        {
            if (string.IsNullOrEmpty(path))
                return null;
            if (path.Length < 2)
                return null;
            var virt = new VirtualAlbumPiece(track, Master, path, artist);
            return virt;
        }



        public bool IsNext
        {
            get
            {
                if (album == null)
                    return false;
                return this == album.Next;
            }
        }
        const int NB_CHAR_COMPLETE = 4;

        //public bool AutoCoeff1 { get { if (album == null) return false; return album.SelectedByCoeff; } }
        //public bool AutoCoeff2 { get { if (album == null) return false; return album.SelectedByCoeff2; } }
        public selectedCoeff SelectedMotif
        {
            get
            {
                if (album == null || !IsNext) return selectedCoeff.none;
                return album.SelectedCoeff;
            }
        }


        public static DateTime SeuilProvisoire;
        // private bool? _classementProvisoireRecent;
        public bool ClassementProvisoireRecent
        {
            get
            {
                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > SeuilProvisoire)
                        return true;
                }
                return false;
                //return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        //private bool getClassementProvisoireRecent()
        //{
        //    if (!ClassementProvisoire)
        //        return false;
        //    var list = DatesClassement;
        //    var last = CalcDate.getLastModif(list);
        //    if (last > SeuilProvisoire)
        //        return true;
        //    return false;
        //}

        public int NbClass { get { return DatesClassement.Count<DateTime>(t => t >= Piece.SeuilProvisoire); } }

        public bool ClassementProvisoire
        {
            get
            {
                if (RapportClassement == 0)
                    return false;
                var str = ClassName;
                int count = str.Length;
                if (count < 4)
                    return true;
                if (count >= 8)
                    return false;

                var tab = str.ToCharArray();
                int nb = 0;
                for (int i = 0; i < count; i++)
                {
                    if (nb > 0)
                        nb++;
                    else
                    {
                        if (tab[i] != '0')
                        {
                            nb++;
                        }
                    }
                }
                if (nb >= NB_CHAR_COMPLETE)
                    return false;

                return true;

            }
        }

        private class PieceEnumerator : IEnumerator<Piece>
        {
            private IEnumerator<Piece> childEnumerator;
            private Piece current;
            private Piece piece;

            public PieceEnumerator(Piece piece) { this.piece = piece; }
            public Piece Current
            {
                get { return current; }
            }

            public void Dispose()
            {
                if (childEnumerator != null)
                    childEnumerator.Dispose();
            }

            object System.Collections.IEnumerator.Current
            {
                get { return current; }
            }

            public bool MoveNext()
            {
                if (childEnumerator == null)
                {
                    childEnumerator = piece.childs.GetEnumerator();
                    current = piece;
                    return true;
                }
                var ret = childEnumerator.MoveNext();
                if (!ret)
                    return false;
                current = childEnumerator.Current;
                return true;
            }

            public void Reset()
            {
                if (childEnumerator != null)
                    childEnumerator.Reset();
                childEnumerator = null;
            }
        }


        public IEnumerator<Piece> GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }
    }




}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\TrackList.cs">
    <content><![CDATA[
using System;
using System.Collections.Generic;
using pdb.obj;
using System.Diagnostics;

namespace pdb.gen
{
    public class TrackListCreator : IComponentFactor
    {
        public PlComponent create(object source)
        {
            if (source is Piece)
                return new TrackList(source as Piece);
            else
                throw new ApplicationException(source + " n'est pas du bon type");
        }
    }
    public class TrackList : PlComponent, ITrackMetaData, IFile, ITrackNativeDates
    {

        private Piece piece;
        public TrackList(Piece piece)
        {
            if (piece == null)
                Debugger.Launch();
            this.piece = piece;
        }
        public override string ToString()
        {
            var parent = Parent;
            if (parent == null)
                return piece.ToString();

            return parent.getPath() + " " + piece.ToString();
        }
        public Piece Piece { get { return piece; } }

        public string Name { get { return piece.Name; } set { piece.Name = value; } }
        public override string Location { get { return piece.Location; } }
        public bool Enabled { get { return piece.Enabled; } set { piece.Enabled = value; } }
        public bool Virtual { get { return piece.Virtual; } }

        public string ClassName
        {
            get
            {
                return piece.ClassName;
            }
            set
            {
                piece.ClassName = value;
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
            }
        }

        //public string Comment
        //{
        //    get
        //    {
        //        return piece.Comment;
        //    }
        //    set
        //    {
        //        piece.Comment = value;
        //    }
        //}

        bool ITrackMetaData.Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
            }
        }

        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return piece.PlayedDate; }
        }

        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set { piece.Duration = value; }

        }

        public string ArtWork
        {
            get
            {
                return piece.ArtWork;
            }
            set
            {
                piece.ArtWork = value;
            }
        }

        //public string Grouping
        //{
        //    get { return piece.Grouping; }
        //}

        //public void setGrouping(string value, bool prior)
        //{
        //    piece.setGrouping(value, prior);
        //}



        public bool FirstClass { get { return piece.FirstClass; } set { piece.FirstClass = value; } }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
            }
        }

        public string Album
        {
            get
            {
                return piece.Album;
            }
            set
            {
                piece.Album = value;
            }
        }

        string ITrackReference.Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
            }
        }

        public int TrackNumber
        {
            get
            {
                return piece.TrackNumber;
            }
            set
            {
                piece.TrackNumber = value;
            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.ClassPlayLists; }
        }

        //public void AddPlayList(CPlayList a_playList)
        //{
        //    piece.AddPlayList(a_playList);
        //}

        //public void removePlayList(CPlayList list)
        //{
        //    piece.removePlayList(list);
        //}

        public int PieceId
        {
            get { return piece.PieceId; }
        }


        public int PieceParentId
        {
            get { return piece.PieceParentId; }
            set { piece.PieceParentId = value; }
        }




        public TrackIdentity Key
        {
            get { return piece.Key; }
        }

        public void setClassement(string className, int rating)
        {
            piece.setClassement(className, rating);
        }

        public List<DateTime> Dates
        {
            get { return piece.Dates; }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return piece.ClassEvol; }
        }

        public List<string> RelativesPath
        {
            get { return piece.RelativesPath; }
        }


        public exportState ExportStatus
        {
            get
            {
                return piece.ExportStatus;
            }
            set
            {
                piece.ExportStatus = value;
            }
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return piece.DatesClassementBrut;
            }
        }


        public string getLocation()
        {
            return piece.getLocation() ;
        }


        public DateTime Added
        {
            get { return piece.Added;  }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\ConfGen.cs">
    <content><![CDATA[using System;
using System.Xml;
using pdb.gen.conf;
using pdb.util;
using System.Collections.Generic;
using pdb.gen.albums;

namespace pdb.gen.Tuning
{
    public enum writeGrouping
    {
        none = 0,
        selected = 1,
        mix = 2,
        all = 3,

    }

    public enum datesMode
    {
        play = 1,
        @class = 2,
        classMin = 3,
        mix = 4,
        mixMin = 5

    }

    public class ExtendToNative<T>
    {
        public readonly T item;
        public readonly bool extend;
        public readonly bool extendTimeOrder;
        public readonly bool level;

        public ExtendToNative(T item, bool extend, bool extendTimeOrder, bool level)
        {
            this.item = item;
            this.extend = extend;
            this.extendTimeOrder = extendTimeOrder;
            this.level = level;
        }

        public override string ToString()
        {
            return item.ToString();
        }
    }
    public class ConfGen
    {

        private CConfQL confCourbe = new CConfQL();

        private TimeSpan vie = TimeSpan.FromDays(365);
        datesMode dates;
        private List<ExtendToNative<double>> listes = new List<ExtendToNative<double>>();
        private decimal exp = 1;
        private bool withOrder;
        private bool orderZero;
        private bool orderLarge;
        private bool genE;
        private bool genLarge;
        private bool writeGroupingZero;
        private bool genCheck;
        bool albumOrdo;
        bool onlyEnabled;
        /// <summary>
        /// Simuler la conso du premier élément
        /// </summary>
        private bool anticipation;

        //private double equivDelta = 0.00001;
        //private int equivStep = 100000; 
        private writeGrouping writeGrouping = writeGrouping.selected;
        private writeGrouping writeComment = writeGrouping.all;

        private GroupingDisplay groupingDisplay = new GroupingDisplay(null);

        private DateTime minPlayDate = DateTime.MinValue;
        private DateTime minClassDate = DateTime.MinValue;
        private int offsetPlayDate = 0;
        private int offsetClassDate = 0;
        private int offsetClassMin = 1;
        private int listLimit = int.MaxValue;
        private int listReaderAfter = 0;
        private int listReaderBefore = 0;
      //  private decimal medianne = 0.5m;
        private decimal albumMoyOffset = 0m;

        private List<ExtendToNative<datesMode>> cat = new List<ExtendToNative<datesMode>>();
        private ExtendToNative<int> precisionMin = new ExtendToNative<int>(-1, false, false, false);
        private ExtendToNative<int> precisionMax = new ExtendToNative<int>(-1, false, false, false);

        private ConfAlbumSort albumSortMode = new ConfAlbumSort(); 

     
        private bool albumVirtual = false;
        private bool artistVirtual = false;
        private bool navAuto = false; 

        public ConfGen()
        {
        }
        public ConfGen(XmlElement a_xml)
        {
            if (a_xml == null)
                return;
            XMLTool l_xml = new XMLTool(a_xml);
            XmlElement xmlQuality = l_xml.NodeLookUp("courbe");
            
            confCourbe = new CConfQL(xmlQuality);

            var str = l_xml.getNodeValue("dates");
            if (!string.IsNullOrEmpty(str))
                dates = (datesMode)Enum.Parse(typeof(datesMode), str, true);
            var xTime = l_xml.NodeLookUp("time");
            if (xTime != null)
            {
                var _xtime = new XMLTool(xTime);
                string l_str = _xtime.getNodeValue("vie").Trim();
                if (!string.IsNullOrEmpty(l_str))
                    vie = TimeSpan.FromDays(Convert.ToDouble(l_str));

                l_str = _xtime.getNodeValue("exp").Trim();
                if (!string.IsNullOrEmpty(l_str))
                    exp = Convert.ToDecimal(l_str);
            }

            var xLists = l_xml.NodeLookUp("lists");
            if (xLists != null)
            {
                foreach (XmlNode xList in xLists.ChildNodes)
                {
                    if (xList is XmlElement)
                    {

                        double iList = Convert.ToDouble(xList.InnerText);
                        bool extend = false;
                        var att = xList.Attributes["nat"];
                        if (att != null && att.Value == "true")
                            extend = true;

                        bool extendtimeOrder = false;
                        att = xList.Attributes["timeOrder"];
                        if (att != null && att.Value == "true")
                            extendtimeOrder = true;

                        bool _level = false;
                        att = xList.Attributes["level"];
                        if (att != null && att.Value == "true")
                            _level = true;

                        ExtendToNative<double> e = new ExtendToNative<double>(iList, extend, extendtimeOrder, _level);
                        listes.Add(e);
                    }
                }
            }

            str = l_xml.getNodeValue("writeGrouping");
            if (!string.IsNullOrEmpty(str))
                writeGrouping = (writeGrouping)Enum.Parse(typeof(writeGrouping), str);

            str = l_xml.getNodeValue("writeComment");
            if (!string.IsNullOrEmpty(str))
                writeComment = (writeGrouping)Enum.Parse(typeof(writeGrouping), str);

            str = l_xml.getNodeValue("equivDelta");
            if (!string.IsNullOrEmpty(str))
                CalcEquiv.coeffDelta = Convert.ToDecimal(str);

            str = l_xml.getNodeValue("equivStep");
            if (!string.IsNullOrEmpty(str))
                CalcEquiv.MAX_STEP = Convert.ToInt32(str);

            var l_display = l_xml.NodeLookUp("display");
            groupingDisplay = new GroupingDisplay(l_display);

            withOrder = l_xml.getBoolValue("withOrder");
            orderLarge = l_xml.getBoolValue("orderLarge");
            orderZero = l_xml.getBoolValue("orderZero");
            genE = l_xml.getBoolValue("genE");
            genLarge = l_xml.getBoolValue("genLarge");
            writeGroupingZero = l_xml.getBoolValue("writeGroupingZero");
            genCheck = l_xml.getBoolValue("genCheck");
            anticipation = l_xml.getBoolValue("anticipation");
            albumOrdo = l_xml.getBoolValue("albumOrdo");
            onlyEnabled = l_xml.getBoolValue("onlyEnabled");
           
            albumVirtual = l_xml.getBoolValue("albumVirtual", albumVirtual);
            artistVirtual = l_xml.getBoolValue("artistVirtual", artistVirtual);
            navAuto = l_xml.getBoolValue("navAuto", navAuto);

            str = l_xml.getNodeValue("minPlayDate");
            if (!string.IsNullOrEmpty(str))
                minPlayDate = Convert.ToDateTime(str);

            str = l_xml.getNodeValue("minClassDate");
            if (!string.IsNullOrEmpty(str))
                minClassDate = Convert.ToDateTime(str);

            str = l_xml.getNodeValue("offsetPlayDate");
            if (!string.IsNullOrEmpty(str))
                offsetPlayDate = Convert.ToInt32(str);

            str = l_xml.getNodeValue("offsetClassDate");
            if (!string.IsNullOrEmpty(str))
                offsetClassDate = Convert.ToInt32(str);

            str = l_xml.getNodeValue("offsetClassMin");
            if (!string.IsNullOrEmpty(str))
                offsetClassMin = Convert.ToInt32(str);

            str = l_xml.getNodeValue("listLimit");
            if (!string.IsNullOrEmpty(str))
                listLimit = Convert.ToInt32(str);

            str = l_xml.getNodeValue("listReaderAfter");
            if (!string.IsNullOrEmpty(str))
                listReaderAfter = Convert.ToInt32(str);

            str = l_xml.getNodeValue("listReaderBefore");
            if (!string.IsNullOrEmpty(str))
                listReaderBefore = Convert.ToInt32(str);

            str = l_xml.getNodeValue("albumMoyOffset");
            if (!string.IsNullOrEmpty(str))
                albumMoyOffset = Convert.ToDecimal(str);
            var xalbumSort = l_xml.NodeLookUp("albumSort");

            albumSortMode = new ConfAlbumSort(xalbumSort); 
        

            var xDir = l_xml.NodeLookUp("dir");
            if (xDir != null)
            {
                foreach (XmlNode xSub in xDir.ChildNodes)
                {
                    if (xSub is XmlElement)
                    {
                        if (xSub.Name == "precision")
                        {
                            var _precisionMin = Convert.ToInt32(xSub.Attributes["min"].Value);
                            bool _extend = false;

                            var att = xSub.Attributes["nat"];
                            if (att != null && att.Value == "true")
                                _extend = true;

                            bool _extendtimeOrder = false;
                            att = xSub.Attributes["timeOrder"];
                            if (att != null && att.Value == "true")
                                _extendtimeOrder = true;
                            var _precisionMax = Convert.ToInt32(xSub.Attributes["max"].Value);

                            bool _level = false;
                            att = xSub.Attributes["level"];
                            if (att != null && att.Value == "true")
                                _level = true;


                            precisionMin = new ExtendToNative<int>(_precisionMin, _extend, _extendtimeOrder, _level);
                            precisionMax = new ExtendToNative<int>(_precisionMax, _extend, _extendtimeOrder, _level);
                        }
                        else
                        {
                            datesMode item = (datesMode)(Enum.Parse(typeof(datesMode), xSub.Name, true));
                            bool extend = false;
                            var att = xSub.Attributes["nat"];
                            if (att != null && att.Value == "true")
                                extend = true;

                            bool _extendtimeOrder = false;
                            att = xSub.Attributes["timeOrder"];
                            if (att != null && att.Value == "true")
                                _extendtimeOrder = true;

                            bool _level = false;
                            att = xSub.Attributes["level"];
                            if (att != null && att.Value == "true")
                                _level = true;

                            cat.Add(new ExtendToNative<datesMode>(item, extend, _extendtimeOrder, _level));

                        }
                    }

                }
            }

        }

        public CConfQL Courbe { get { return confCourbe; } }

        public decimal Exp { get { return exp; } }
        public TimeSpan Vie { get { return vie; } }
        public datesMode Dates { get { return dates; } }
        public List<ExtendToNative<double>> Listes { get { return listes; } }

        //public writeGrouping WriteGrouping { get { return writeGrouping; } }
        //public writeGrouping WriteComment { get { return writeComment; } }
        public timeMode TimeMode { get { return groupingDisplay.TimeMode; } }
        public List<DisplayGrouping> DisplayCategories
        {
            get
            {
                var list = groupingDisplay.Categories;
                var found = list.Find(c => c.category == displayCategory.timeValue);

                int indexCurrentTimeValue = -1; 
                if (found != null)
                    indexCurrentTimeValue = list.IndexOf(found);
                if (indexCurrentTimeValue >= 0)
                {
                    list[indexCurrentTimeValue].category = (displayCategory)dates;
                }

                return list;
            }
        }
        public bool WithOrder { get { return withOrder; } }
        public bool OrderLarge { get { return orderLarge; } }
        public bool OrderZero { get { return orderZero; } }
        public bool GenE { get { return genE; } }
        public bool GenLarge { get { return genLarge; } }
        public bool GenCheck { get { return genCheck; } }
        public bool Anticipation { get { return anticipation; } }
        public bool WriteGroupingZero { get { return writeGroupingZero; } }
        public bool AlbumOrdo { get { return albumOrdo; } }
        public bool OnlyEnabled { get { return onlyEnabled; } }


        public DateTime MinPlayDate { get { return minPlayDate; } }
        public DateTime MinClassDate { get { return minClassDate; } }

        public int OffsetPlayDate { get { return offsetPlayDate; } }
        public int OffsetClassDate { get { return offsetClassDate; } }
        public int OffsetClassMin { get { return offsetClassMin; } }
        public override string ToString()
        {
            return string.Format(" vie:{0} exp:{1} quality:{2} onlyPlayed:{3} writeGrouping:{4} display:{5}", vie, exp, confCourbe, dates, writeGrouping, groupingDisplay);
        }

        public List<ExtendToNative<datesMode>> Modes { get { return cat; } }
        public ExtendToNative<int> PrecisionMin { get { return precisionMin; } }
        public ExtendToNative<int> PrecisionMax { get { return precisionMax; } }
        public int ListLimit { get { return listLimit; } }
        public int ListReaderAfter { get { return listReaderAfter; } }
        public int ListReaderBefore { get { return listReaderBefore; } }
        public decimal AlbumMoyOffset { get { return albumMoyOffset; } }
        public ConfAlbumSort AlbumSort { get { return albumSortMode; } }
        public bool AlbumVirtual { get { return albumVirtual; } }
        public bool ArtistVirtual { get { return artistVirtual; } }
        public bool NavAuto { get { return navAuto; } }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Virtuel\VirtualPiece.cs">
    <content><![CDATA[using pdb.obj;

namespace pdb.gen.Virtuel
{
    class VirtualPiece : Piece
    {
        public static void init()
        {
            idSeq = -10;
        }
        public static int idSeq = -10;
        public int vid;
        public int vparentId = -1;
        protected Piece _real;
        public VirtualPiece(ITrackNativeDates track, Piece _real)
            : base(track)
        {
            this._real = _real;
            this.Parent = _real;
            idSeq--;
            vid = idSeq;
        }

        public override int PieceId
        {
            get
            {
                return vid;
            }
        }

        public override int PieceParentId
        {
            get
            {
                return _real.PieceId;
            }
            set
            {

            }
        }

        //private string _grouping = "";
        //public override void setGrouping(string value, bool prior)
        //{
        //    _grouping = value;
        //}
        //public override string Grouping
        //{
        //    get
        //    {
        //        //if (string.IsNullOrEmpty(_grouping))
        //        //{
        //            gen.writeGrouping(this);
        //        //}
        //        return _grouping;
        //    }
        //}

        //public override bool Equals(object obj)
        //{
        //    Piece p = obj as Piece;
        //    if (p == null)
        //        return false;
        //    return MasterId.Equals(p.MasterId);
        //}

        //public override int GetHashCode()
        //{
        //    return MasterId.GetHashCode();
        //}

        public override Piece Parent
        {
            get { return parent; }
            set
            {
                parent = value;
            }
        }

        public override void initRank()
        {
            base.initRank();
         //   _grouping = "";
        }

        public override void invalidateCache()
        {
           // _grouping = "";
            base.invalidateCache();
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\TrackList.cs">
    <content><![CDATA[using pdb.db.obj;
using pdb.obj;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.db
{
    public class TrackListCreator : IComponentFactor
    {
        public PlComponent create(object source)
        {
            return new TrackList(source as CPiece);
        }
    }
    public class TrackList : PlComponent, ITrackInfoItunes
    {

        private CPiece piece;
        public TrackList(CPiece piece)
        { this.piece = piece; }
        public override string ToString()
        {
            var parent = Parent;
            if (parent == null)
                return piece.ToString();

            return parent.getPath() + " " + piece.ToString();
        }
        public CPiece Piece { get { return piece; } }

        public string Name { get { return piece.Name; } set { piece.Name = value; } }
        public override string Location { get { return piece.Location; } }
        public bool Enabled { get { return piece.Enabled; } set { piece.Enabled = value; } }

        public string ClassName
        {
            get
            {
                return piece.ClassName;
            }
            set
            {
                piece.ClassName = value;
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
            }
        }

        //public string Comment
        //{
        //    get
        //    {
        //        return piece.Comment;
        //    }
        //    set
        //    {
        //        piece.Comment = value;
        //    }
        //}

        bool ITrackMetaData.Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
            }
        }

        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return piece.PlayedDate; }
        }

        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set { piece.Duration = value; }

        }

        public string ArtWork
        {
            get
            {
                return piece.ArtWork;
            }
            set
            {
                piece.ArtWork = value;
            }
        }

        //public string Grouping
        //{
        //    get { return piece.Grouping; }
        //}

        //public void setGrouping(string value, bool prior)
        //{
        //    piece.setGrouping(value, prior);
        //}



        public bool FirstClass { get { return piece.FirstClass; } set { piece.FirstClass = value; } }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
            }
        }

        public string Album
        {
            get
            {
                return piece.Album;
            }
            set
            {
                piece.Album = value;
            }
        }

        string ITrackReference.Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
            }
        }

        public int TrackNumber
        {
            get
            {
                return piece.TrackNumber;
            }
            set
            {
                piece.TrackNumber = value;
            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.ClassPlayLists; }
        }

        public void AddPlayList(CPlayList a_playList)
        {
            piece.AddPlayList(a_playList);
        }

        public void removePlayList(CPlayList list)
        {
            piece.removePlayList(list);
        }

        public int PieceId
        {
            get { return piece.PieceId; }
        }


        public int PieceParentId
        {
            get { return piece.PieceParentId; }
            set { piece.PieceParentId = value; }
        }


        public TrackIdentity Key
        {
            get { return piece.Key;  }
        }


        public string getLocation()
        {
            return piece.getLocation(); 
        }


        public DateTime Added
        {
            get { return piece.Added; }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CPiece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.db.piece.data;
using pdb.db.piece.type;
using pdb.obj;
using pdb.util;
using pdb.db.piece;
using System.Diagnostics;


namespace pdb.db.obj
{

    /// <summary>
    /// Métadonnées d'un fichier
    /// </summary>
    /// <remarks>On veut pouvoir merger les modifications venant de deux sources
    /// exemeple : un modifie le classement, l'autre l'année
    /// Pour cela, il est envisagé d'enregistrer pour chaque modification effectué par le client
    /// tout simplement la date de cette modification
    /// le merge se baserait ainsi sur la comparaison entre les dates de modification
    /// source 1 date modif d1' pour classement > d1
    /// source 2 date modif d2' pour année > d2
    /// 
    /// On pourrait aussi se baser sur un flag => mettre à jour
    /// ainsi on gagnerait de la place, mais on perdrait la date de derniere mise à jour
    /// et se poserait aussi la question de quand retirer le flaf "mettre à jour"
    /// 
    /// On peut aussi établir un historique
    ///
    ///</remarks>
    /// 

    public enum Bool
    {
        not_defined = 0,
        False = 1,
        True = 2
    }

    public class CPiece : IData, ITrackMetaData, ITrackNativeDates, ITrackPlayListRecorder, ITrackPlayListReport, IDataObserver, ITrackInfoItunes
    {
        private static Logger logTrack = Logger.getLogger("Track");
        //  private static NullTrack NullTrack = new NullTrack();
        private const string TOKEN_PIECE = "piece";

        private const string TOKEN_DISABLED = "disabled";
        private const string TOKEN_ARTWORK = "artWork";
        private const string TOKEN_DURATION = "duration";
        private const string TOKEN_ADDED = "added"; 

        #region "Composants"
        private CListDate m_dates;
        private CListFile m_files;
        private CPieceReference m_ref;
        private CPieceInfo m_infos;
        private CPieceClassement m_classement;
        //durée en ms du titre
        private TimeSpan m_duration = new TimeSpan();
        private DateTime added; 
        private CPieceChecked m_Enabled = new CPieceChecked();


        //private String m_comment = "";
        //private string grouping = ""; 
        private string artWork = "";
        #endregion

        //private class StringEventArgs : EventArgs
        //{
        //    public StringEventArgs(String value) { this.Value = value; }
        //    readonly public String Value;
        //}


        public DateTime Added { get { return added; } }
        public void setAdded(DateTime dt) { added = dt; }

        private void checkNative()
        {
            //if (native == null)
            //{
            //    StackTrace st = new StackTrace();
            //    logTrack.logNoDate("native null " + this + " " + st.ToString());
            //}
        }
        //   public void makeFirstClass() { if (native == null) return; native.makeFirstClass(); }
        public bool FirstClass
        {
            get
            {
                if (native == null) return false;
                return native.FirstClass;
            }
            set { if (native == null) return; native.FirstClass = value; }
        }
        public bool HasNoNative { get { return native == null; } }
        //private void OnCommentChange(String value)
        //{
        //    checkNative();
        //    if (native == null)
        //        return;
        //    native.Comment = value;
        //}
        //private void OnGroupingChange(String value, bool prior)
        //{
        //    checkNative();
        //    if (native == null)
        //        return;
        //    native.setGrouping(value, prior);
        //}
        private void OnNameChange(string value) { if (native == null) return; native.Name = value; }
        private void OnAlbumChanged(String value) { if (native == null) return; native.Album = value; }
        private void OnArtistChanged(String value) { if (native == null) return; native.Artist = value; }
        private void OnUncheck() { if (native == null) return; native.Enabled = false; }



        //private EventHandler<StringEventArgs> commentChanged;
        //private EventHandler<StringEventArgs> groupingChanged;
        //private EventHandler<StringEventArgs> albumChanged;
        //private EventHandler<StringEventArgs> artistChanged;


        private List<IReference> referenceObs = new List<IReference>();
        public void addReferenceObs(IReference obs) { if (!referenceObs.Contains(obs)) referenceObs.Add(obs); }
        public void removeReferenceObs(IReference obs) { referenceObs.Remove(obs); }
        private void OnReferenceChanged() { for (int i = 0; i < referenceObs.Count; i++) { referenceObs[i].referenceChange(this); } }


        #region logs
        private void valueChangedHandler()
        {

            //m_ref.AlbumData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Album", args); };
            //m_ref.ArtistData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Artist", args); };
            //m_ref.NameData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Name", args); };
            //m_infos.YearData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Year", args); };
            //Classement.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Classement", args); };

            //m_ref.AlbumData.changeLocalValueByNative += (o, args) => { langChangeByNative("Album", args); };
            //m_ref.ArtistData.changeLocalValueByNative += (o, args) => { langChangeByNative("Artist", args); };
            //m_ref.NameData.changeLocalValueByNative += (o, args) => { langChangeByNative("Name", args); };
            //m_infos.YearData.changeLocalValueByNative += (o, args) => { langChangeByNative("Year", args); };
            //Classement.changeLocalValueByNative += (o, args) => { langChangeByNative("Classement", args); };

            //m_ref.AlbumData.change += new EventHandler(Ref_change);
            //m_ref.NameData.change += new EventHandler(Ref_change);
            //m_ref.ArtistData.change += new EventHandler(Ref_change);
            //m_ref.TrackData.change += new EventHandler(Ref_change);
            Files.Observer = this;
            m_ref.Observer = this;
            m_infos.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
        }


        private void logChange(String typeChange, String typeData, object Old, object New)
        {
            logTrack.log("{0}:{1} from '{2}' to '{3}' {4}", typeChange, typeData, Old, New, this);
        }
        //private void logChangeByRemote(String typeData, object Old, object New)
        //{
        //    logChange("change by remote", typeData, Old, New);
        //}
        //private void langChangeByNative(String typeData, object Old, object New)
        //{
        //    logChange("change by native", typeData, Old, New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}

        //private void langChangeByNative(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}

        #endregion


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        public void keyGener()
        {
            try
            {
                key = new TrackIdentity(this);
            }
            catch
            {
                logTrack.log("pb de clé " + this);
                throw;
            }
        }

        #endregion

        #region constructeurs





        /// <summary>
        /// création d'un morceau vide
        /// </summary>
        /// <remarks></remarks>
        public CPiece()
        {

            m_dates = new CListDate();
            m_files = new CListFile();
            m_ref = new CPieceReference();
            m_infos = new CPieceInfo();
            m_classement = new CPieceClassement();
            valueChangedHandler();
        }

        public CPiece(string location, string baseClassement)
            : this()
        {
            m_files.add(new CFile(location));
            m_classement = new CPieceClassement(baseClassement);
            valueChangedHandler();
        }

        public CPiece(string location)
            : this()
        {
            m_files.add(new CFile(location));
            valueChangedHandler();
        }

        public void initClassementIfEmpty(string classement)
        {
            m_classement.initClassementIfEmpty(classement);
        }


        public void eraseClassement()
        {
            m_classement.eraseClassement();
        }


        private ITrackInfoItunes native = null;

        public void recordJustReadTrack()
        {
            ListDates.check(DateTime.Now);
        }

        public CPiece(ITrackInfoItunes ext)
        {
            native = ext;
            //  ext.registerDependency(this); 

            m_classPlayLists = ext.ClassPlayLists;
            //m_playList = ext.PLayLists;

            string className = ext.ClassName; // getClassName(ext); 

            m_dates = new CListDate();
            ListDates.check(ext.PlayedDate);

            m_files = new CListFile();
            Files.add(new CFile(ext.Location));
            m_ref = new CPieceReference(ext.Artist, ext.Album, ext.Name, ext.TrackNumber);
#if VOL
            m_infos = new CPieceInfo(ext.Year, ext.Volume);
#else
            m_infos = new CPieceInfo(ext.Year);
#endif
            this.artWork = ext.ArtWork;

            m_classement = new CPieceClassement(className, ext.Rating);
            //m_comment = ext.Comment;
            //grouping = ext.Grouping; 

            m_duration = ext.Duration;

            bool enabled = ext.Enabled;
            if (enabled)
                Checked.Enable();
            else
                Checked.Disable();

            //m_ref.AlbumData.changeNativeValue += (o, args) =>  { if (native == null) return; native.Album = args.Value; };
            //m_ref.ArtistData.changeNativeValue += (o, args) => { if (native == null) return; native.Artist = args.Value; };
            //m_ref.NameData.changeNativeValue += (o, args) => { if (native == null) return; native.Name = args.Value; };
            //m_ref.TrackData.changeNativeValue += (o, args) => { if (native == null) return; native.TrackNumber = args.Value; };
            //m_infos.YearData.changeNativeValue += (o, args) => { if (native == null) return; native.Year = args.Value; };
            //Classement.changeNativeValue += (o, args) => { if (native == null) return; native.Rating = args.Value.Rating; native.ClassName = args.Value.ClassList; };

            m_ref.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
            //  m_Enabled.checkedChanged += (o, args) => { if (native == null) return; native.Enabled = false; };





            valueChangedHandler();


        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList(ITrackNative track)
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        /// <summary>
        /// construction à partir de la base maison 
        /// </summary>
        /// <param name="a_xml"></param>
        /// <remarks></remarks>
        public CPiece(XmlElement a_xml)
        {
            var xmlTool = new XMLTool(a_xml);
            m_id = xmlTool.getIntAttValue("id");
            deleted = xmlTool.getBoolAttValue("deleted");
            m_ref = new CPieceReference(a_xml);
            m_infos = new CPieceInfo(a_xml);

            parentID = xmlTool.getIntAttValue("parent");
            if (parentID < 0)
            {
                m_dates = new CListDate(a_xml);
                m_files = new CListFile(a_xml);
                m_classement = new CPieceClassement(a_xml);
                var xDisabled = xmlTool.NodeLookUp(TOKEN_DISABLED);
                {
                    if (xDisabled != null)
                    {
                        if (xDisabled.InnerText == "false")
                            Checked.Enable();
                        else
                            Checked.Disable(); 
                    }
                }
            }
            else
            {
                m_dates = new CListDate();
                m_files = new CListFile();
                m_classement = new CPieceClassement();

            }





            var xtool = new XMLTool(a_xml);
            artWork = xtool.getNodeValue(TOKEN_ARTWORK);
            //Comment = xtool.getNodeValue("classement");
            //_grouping = xtool.getNodeValue("grouping");
            string strDur = "";
            var attDuration = a_xml.Attributes[TOKEN_DURATION];
            if (attDuration != null)
                strDur = attDuration.Value;
            else
                strDur = xtool.getNodeValue(TOKEN_DURATION);

          


            if (!string.IsNullOrEmpty(strDur))
            {
                var ms = Convert.ToDouble(strDur);
                if (ms > 1)
                    m_duration = TimeSpan.FromMilliseconds(ms);
            }

            string strAdded = "";
            var attAdded = a_xml.Attributes[TOKEN_ADDED];
            if (attAdded != null)
                strAdded = attAdded.Value;
            else
                strAdded = xtool.getNodeValue(TOKEN_ADDED);

            if (!string.IsNullOrEmpty(strAdded))
            {
                try
                {
                    added = Convert.ToDateTime(strAdded);
                }
                catch (Exception ex)
                {
                    log(string.Format("impossible de parser {0} {1} {2}", strAdded, this,ex)); 
                }
            }

          
            m_ref.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
            valueChangedHandler();

        }


        ///// <summary>
        ///// construction à partir de la base propriétaire
        ///// </summary>
        ///// <param name="a_ref"></param>
        ///// <param name="a_file"></param>
        ///// <param name="a_info"></param>
        ///// <param name="a_rating"></param>
        ///// <param name="a_date"></param>
        ///// <remarks></remarks>
        //public CPiece(CPieceReference a_ref, string a_file, CPieceInfo a_info, int a_rating, System.DateTime a_date, TimeSpan a_duration, bool a_bEnabled)
        //{

        //    m_dates = new CListDate();
        //    ListDates.check(a_date);

        //    m_files = new CListFile();
        //    Files.@add(new CFile(a_file));

        //    m_ref = a_ref;
        //    m_infos = a_info;

        //    m_classement = new CPieceClassement(a_rating);
        //    m_duration = a_duration;
        //    if (a_bEnabled)
        //    {
        //        m_Enabled.True();
        //    }
        //    else
        //    {
        //        m_Enabled.False();
        //    }
        //    valueChangedHandler();

        //}

        #endregion


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackMetaData other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.Location) || m_ref.DefinedEquals(other.Artist, other.Album, other.Name, other.TrackNumber));
        //}


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(CPiece other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.m_files) || m_ref.DefinedEquals(other.m_ref));
        //}

        public bool checkFile(CPiece other)
        {
            return Files.HasOnePathInCommonWith(other.Files);
        }



        private void raiseChangeRefEvent()
        {
            if (isRefchanged)
            {
                isRefchanged = false;
                OnReferenceChanged();
            }
        }

        /// <summary>
        /// rapatrie les info d'une piece vers l'autre
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>cas d'égalité enre les deux : doublons de la même liste</remarks>

        public void merge(CPiece other)
        {

            if (!m_ref.AlbumData.choose(other.m_ref.AlbumData))
            {
                log("merge album between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.AlbumData.mergeManual(other.m_ref.AlbumData);
            }

            if (!m_ref.ArtistData.choose(other.m_ref.ArtistData))
            {
                log("merge artist between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.ArtistData.mergeManual(other.m_ref.ArtistData);
            }
            if (!m_ref.NameData.choose(other.m_ref.NameData))
            {
                log("merge name between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.NameData.mergeManual(other.m_ref.NameData);
            }
            if (!m_ref.TrackData.choose(other.m_ref.TrackData))
            {
                log("merge trackNumber between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.TrackData.mergeManual(other.m_ref.TrackData);
            }




            if (!m_infos.YearData.choose(other.m_infos.YearData))
            {
                log("merge infos between " + this.ToString() + "[" + this.Year + "]" + " and " + other.ToString() + "[" + other.Year + "]");
                m_infos.YearData.mergeManual(other.m_infos.YearData);
            }

            if (!Classement.choose(other.Classement))
            {
                log("merge classement between " + this.ToString() + "[" + this.ClassList + ":" + this.Rating + "]" + " and " + other.ToString() + "[" + other.ClassList + ":" + other.Rating + "]");
                Classement.mergeManual(other.Classement);
            }

            addData(other);
            raiseChangeRefEvent();
        }


        /// <summary>
        /// Simple ajout de données venant du doublon
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>Utilisé par legacy pour génération d'une liste propre à partir de la liste native
        /// Les fichiers auront préalablement été triés par classement</remarks>
        public void mergeDataFrom(CPiece other)
        {
            try
            {
                m_ref.mergeDataFrom(other.m_ref);
                m_infos.YearData.mergeAll(other.m_infos.YearData, mergePriority.none);
                Classement.mergeAll(other.Classement, mergePriority.none);

                addData(other);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + @"\r\n" + other.ToString() + @"\r\n" + e.ToString());
            }
        }


        // <summary>
        // addition sans collision des dates et fichiers
        // </summary>

        // <remarks></remarks>

        public void addData(CPiece other)
        {
            ListDates.merge(other.ListDates);
            other.ListDates.merge(ListDates);

            Files.merge(other.Files);
            other.Files.merge(Files);
        }


        private void addDataLink(CPiece other)
        {
            m_dates.merge(other.m_dates);
            other.m_dates.merge(m_dates);

            m_files.merge(other.m_files);
            other.m_files.merge(m_files);
        }




        public void consolid(CPiece remote, mergePriority a_priority)
        {

            try
            {
                m_ref.consolid(remote.m_ref, a_priority);
                Classement.Consolid(remote.Classement, a_priority);
                m_infos.consolid(remote.m_infos, a_priority);

                Checked.Consolid(remote.Checked, a_priority);

                if (m_duration.TotalMilliseconds < 2)
                    this.m_duration = remote.m_duration;
                else if (remote.m_duration.TotalMilliseconds < 2)
                    remote.m_duration = this.m_duration;
                else if (a_priority == mergePriority.right)
                    m_duration = remote.m_duration;

                addData(remote);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + "\r\n" + remote.ToString() + "\r\n" + e.ToString());
            }
        }


        public mergePriority checklegacyModifString(CPieceData<String> data, String native)
        {

            mergePriority l_consistencyComp = data.Value.compareByConsistency(native);
            if (l_consistencyComp != mergePriority.none)
                return l_consistencyComp;

            if (data.Imported) return mergePriority.right;
            return mergePriority.left;
        }


        /// <summary>
        /// piece de la liste native consolidée ou mise à jour 
        /// suivant le cas par le fichier maison
        /// </summary>
        /// <param name="native"></param>
        /// <remarks></remarks>
        public void legacyConsolid(CPiece l_native)
        {



            //TODO éviter de créer un objet juste pour la comparaison
            //en fait très complexe de casser le modèle. A la place, on abonne le track natif aux modifications éventuelles de la DB



            //this.grouping = l_native.Grouping;
            //this.m_comment = l_native.Comment; 







            l_native.m_ref.legacyConsolid(this.m_ref);
            l_native.m_infos.legacyConsolid(this.m_infos);

            l_native.setClassPlayList(this);
            l_native.Classement.LegacyConsolid(this.Classement);
            l_native.Checked.LegacyConsolid(this.Checked);

            //   native.synchroLegacy(this);  //plus besoin de synchro dans l'autre sens, on n'utilise pas l'objet créé ==> en fait si : on modifie directement le track

            addData(l_native);

            this.m_playList = l_native.PLayLists;
            this.m_classPlayLists = l_native.ClassPlayLists;
            this.m_duration = l_native.Duration;
            raiseChangeRefEvent();

            //On court-circuite la liste intermédiaire pour toujours pointer directement vers le trackInfoItunes
            this.native = l_native.native;

            checkNative();
        }

        /// <summary>
        /// Synchro directe entre la Db et le track Itunes (mode daemon)
        /// </summary>
        public void SynchroNative()
        {
            checkNative();
            if (native == null)
                return;

            m_ref.SynchroNative(native);
#if VOL
            m_infos.SynchroNative(native.Year, native.Volume);
#else
            m_infos.SynchroNative(native.Year);
#endif
            var newClassList = getClassName(native);
            Classement newCl = new Classement(newClassList, native.Rating);
            Classement.SynchroNative(newCl);
            Checked.SynchroNative(native.Enabled);

            this.ListDates.merge(native.PlayedDate);



            //  this.m_playList = native.PLayLists;
            this.m_classPlayLists = native.ClassPlayLists;
            if (native.Duration.TotalMilliseconds > 1)
                this.m_duration = native.Duration;
            raiseChangeRefEvent();
        }

        public void removeVersions()
        {
            m_ref.removeVersions();
            Classement.removeVersions();
        }

      

        public void Menage()
        {
            //  misc.log("ménage {0}", this); 
            Classement.Menage(this);
        }




        //public void synchroLegacy(CPiece native)
        //{
        //    this.m_classPlayLists = native.m_classPlayLists;

        //    this.ID = native.ID;
        //}

        private List<CPlayList> m_classPlayLists = new List<CPlayList>();
        private List<CPlayList> m_playList = new List<CPlayList>();
        public void AddPlayList(CPlayList a_playList)
        {
            if (a_playList.isClassSubList())
            {
                m_classPlayLists.Add(a_playList);
            }
            m_playList.Add(a_playList);
        }
        public void removePlayList(CPlayList list)
        {
            if (list.isClassSubList())
                m_classPlayLists.Remove(list);
            m_playList.Remove(list);
        }

        public bool belongsTo(string a_list)
        {
            foreach (CPlayList l_pl in m_playList)
            {
                if (l_pl.isSubList(a_list))
                    return true;
            }
            return false;
        }

        ////définit la liste qui le classe
        //public void setClassPlayList()
        //{
        //    int count =  m_classPlayLists.Count; 
        //    if (count > 0)
        //    {
        //        if (count > 1)
        //        {
        //            m_classPlayLists.Sort(new CPlayListComparer());
        //        }
        //        Classement.ClassList = m_classPlayLists[0].Name;
        //    }
        //}


        private void setClassPlayList(ITrackNative pieceDb)
        {
            string dbClasslist = pieceDb.ClassName;
            int count = m_classPlayLists.Count;
            if (count > 0)
            {
                string className = m_classPlayLists[0].Name;
                if (count > 1)
                {
                    m_classPlayLists.Sort(new CPlayListComparer());
                    foreach (var list in m_classPlayLists)
                    {
                        className = list.Name;
                        if (className == dbClasslist)
                            continue;
                        break;
                    }
                }

                if (!className.Equals(Classement.Value.ClassList) && className.Equals(Classement.LastValue.ClassList))
                {
                    misc.log("Classement:setClassPlayList {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
                    return;
                }

                Classement.ClassList = className;

            }
        }

        public string getClassName(ITrackNative native)
        {
            string dbClasslist = this.ClassName;
            var firstStep = getClassName_(native);
            if (!firstStep.Equals(Classement.Value.ClassList) && firstStep.Equals(Classement.LastValue.ClassList))
            {
                misc.log("Classement:getClassName {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
                return dbClasslist;
            }
            else
                return firstStep;
        }

        public string getClassName_(ITrackNative native)
        {
            string dbClasslist = this.ClassName;
            string className = dbClasslist;
            int count = native.ClassPlayLists.Count;
            if (count > 0)
            {
                className = native.ClassPlayLists[0].Name;
                if (count > 1)
                {
                    native.ClassPlayLists.Sort(new CPlayListComparer());
                    foreach (var list in native.ClassPlayLists)
                    {
                        className = list.Name;
                        if (className.Equals(dbClasslist))
                            continue;
                        break;
                    }
                }
            }
            return className;
        }

        //utilisé par le player maison
        public void setClassPlayList(String name)
        {
            Classement.ClassList = name;
            // TODO Gérer l'absence de classList
        }

        private CPlayList ClassPlayList
        {
            get
            {
                if (m_classPlayLists.Count > 0)
                    return m_classPlayLists[0];
                return null;
            }
        }

        public List<CPlayList> PLayLists { get { return m_playList; } }

        public String ClassName { get { return Classement.ClassList; } set { } }

        public List<CPlayList> ClassPlayLists
        {
            get
            {
                return m_classPlayLists;
            }
        }



        /// <summary>
        /// 
        /// </summary>
        /// <param name="a_sw"></param>
        /// <remarks></remarks>
        /// 
        #region IData Members
        public void write(ITextWriter a_sw)
        {
            XMLTool.openBalise(a_sw, TOKEN_PIECE);

            m_ref.write(a_sw);
            m_infos.write(a_sw);

            Classement.write(a_sw);

            Files.write(a_sw);
            ListDates.write(a_sw);

            if (!Checked.Enabled)
                XMLTool.writeValue(a_sw, TOKEN_DISABLED, true.ToString());
            if (artWork.NotNullOrEmpty())
                XMLTool.writeValue(a_sw, TOKEN_ARTWORK, artWork);
            if (m_duration.TotalMilliseconds > 1)
                XMLTool.writeValue(a_sw, TOKEN_DURATION, (int)m_duration.TotalMilliseconds);
            if (added > DateTime.MinValue)
                XMLTool.writeValue(a_sw, TOKEN_ADDED, added.ToString()); 

            XMLTool.closeBalise(a_sw, TOKEN_PIECE);
        }




        public void write(XmlWriter w)
        {           
            try
            {
                w.WriteStartElement(TOKEN_PIECE);
                if (PieceId > 0)
                    w.WriteAttributeString("id", PieceId.ToString());
                if (parent != null)
                    w.WriteAttributeString("parent", parent.PieceId.ToString());
                if (added > DateTime.MinValue)
                    w.WriteAttributeString(TOKEN_ADDED, added.ToString());
                if (parent == null)
                {
                    if (m_duration.TotalMilliseconds > 1)
                        w.WriteAttributeString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
                }

                m_ref.write(w);
                m_infos.write(w);

                if (parent == null)
                {
                    Classement.write(w);
                    Files.write(w);
                    ListDates.write(w);

                    if (!Checked.Enabled)
                        w.WriteElementString(TOKEN_DISABLED, "");
                }

             

                if (artWork.NotNullOrEmpty())
                    w.WriteElementString(TOKEN_ARTWORK, artWork);
              


                w.WriteEndElement();
            }
            catch (Exception ex)
            {
                misc.log("immpossible de sérialiser {0}", this);
                throw;
            }
        }

    
        public void writeDeleted(XmlWriter w)
        {
            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            w.WriteAttributeString("deleted", "true");
            w.WriteEndElement();

        }

        public void writeDiff(XmlWriter w, CPiece lastFull)
        {
            if (lastFull == null)
            {
                write(w);
                return;
            }

            if (!HasChange(lastFull))
                return;

            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            if (parent != null)
                w.WriteAttributeString("parent", parent.PieceId.ToString());

            m_ref.writeDiff(w, lastFull.m_ref);
            m_infos.writeDiff(w, lastFull.m_infos);

            if (parent == null)
            {
                Classement.writeDiff(w, lastFull.Classement);
                Files.writeDiff(w, lastFull.Files);
                ListDates.writeDiff(w, lastFull.ListDates);

                if (!Checked.Enabled && lastFull.Checked.Enabled)
                    w.WriteElementString(TOKEN_DISABLED, "");

                if (Checked.Enabled && !lastFull.Checked.Enabled)
                    w.WriteElementString(TOKEN_DISABLED, "false");

                if (Duration.TotalMilliseconds > 1 && lastFull.DurationInSec != DurationInSec)
                    w.WriteElementString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
            }

            


          

            w.WriteEndElement();
        }

        public bool HasChange(CPiece lastFull)
        {
            if (lastFull == null)
            {
                return true;
            }
            if (PieceParentId != lastFull.PieceParentId)
                return true;

            if (m_ref.HasChanged(lastFull.m_ref))
                return true;
            if (m_infos.HasChange(lastFull.m_infos))
                return true;

            if (parent == null)
            {
                if (Classement.HasChange(lastFull.Classement))
                    return true;
                if (Files.HasChange(lastFull.Files))
                    return true;
                if (ListDates.HasChange(lastFull.ListDates))
                    return true;
            }

            if (Checked.Enabled != lastFull.Checked.Enabled)
                return true;


            if (m_duration.TotalMilliseconds > 1 && (int)lastFull.m_duration.TotalMilliseconds != (int)m_duration.TotalMilliseconds)
                return true;

            return false;
        }

        #endregion

        public void setClassement(string strClassement)
        {
            var cl = pdb.db.piece.type.Classement.create(strClassement);
            if (cl == null)
                throw new ApplicationException("input classement invalide " + strClassement);
            if (cl.Equals(Classement.Value))
                return;
            Classement.Value = cl;

        }

        


        public CListFile Files
        {
            get { if (parent == null)return m_files; return parent.m_files; }
        }


        public IList<DateTime> Dates
        {
            get { return ListDates.Dates; }
        }

        public DateTime PlayedDate
        {
            get { return ListDates.LastModif; }
        }

        public string ClassList
        {
            get { return Classement.ClassList; }
        }

        public int Rating
        {
            get { return Classement.Rating; }
            set { Classement.Rating = value; }
        }

        public int RatingCmp
        {
            get
            {
                if (Rating < 0)
                    return 0;
                return Rating;
            }
        }
        public CPieceReference Reference
        {
            get { return m_ref; }
        }
        public string Name
        {
            get { return m_ref.Name; }
            set { m_ref.Name = value; }
        }
        public string Album
        {
            get { return m_ref.Album; }
            set
            {
                if (!m_ref.Album.Equals(value))
                {
                    m_ref.Album = value;
                    OnAlbumChanged(value);
                }
            }
        }
        public string Artist
        {
            get { return m_ref.Artist; }
            set
            {
                if (!m_ref.Artist.Equals(value))
                {
                    m_ref.Artist = value;
                    OnArtistChanged(value);
                }
            }
        }
        public int TrackNumber { get { return m_ref.TrackNumber; } set { m_ref.TrackNumber = value; } }
        public int DurationInSec
        {
            get { return Convert.ToInt32(Duration.TotalSeconds); }
        }
        //public TimeSpan Duration
        //{
        //    get { return m_duration; }
        //    set
        //    {
        //        if (value.TotalMilliseconds > 1)
        //            m_duration = value;
        //    }
        //}
        public int Year
        {
            get { return m_infos.Year; }
            set { m_infos.Year = value; }
        }
#if VOL
        public int Volume { get { return m_infos.Volume; } set { m_infos.Volume = value; } }
#endif
        public bool Enabled
        {
            get { return Checked.Enabled; }
            set
            {
                if (value)
                    Checked.Enable();
                else
                    Checked.Disable();
            }
        }
        public CPieceInfo Infos
        {
            get { return m_infos; }
        }

        public string ArtWork { get { return artWork; } set { artWork = value; } }


        /// <summary>
        /// ID interne
        /// </summary>
        /// <remarks></remarks>
        private int m_id = -1;
        private int parentID = -1;
        public int PieceId
        {
            get { return m_id; }
        }

        public int PieceParentId
        {
            get { return parentID; }
            set { parentID = value; }
        }

        public int MasterId
        {
            get
            {
                if (parentID < 0)
                    return m_id;
                return parentID;
            }
        }

        public CPiece Master
        {
            get
            {
                if (parent == null)
                    return this; 
                return parent;
            }
        }


        public void setId(int value)
        {
            if (m_id < 0)
            {
                m_id = value;
            }
        }

        public CPieceClassement Classement { get { if (parent == null) return m_classement; return parent.m_classement; } }
        public TimeSpan Duration
        {
            get { if (parent == null) return m_duration; return parent.m_duration; }
            set
            {
                if (value.TotalMilliseconds > 1)
                {
                    if (parent == null)
                        m_duration = value;
                    else
                        parent.m_duration = value; 
                }
            }
        }
        public CListDate ListDates { get { if (parent == null) return m_dates; return parent.m_dates; } }
        private CPieceChecked Checked { get { if (parent == null) return m_Enabled; return parent.m_Enabled; } }
        //  private CListFile Files { get { if (parent == null) return m_files; return parent.m_files; } }
        public Classement getClassement() { return Classement.Value; }


       


        //Sub synchroClassFrom(ByVal a_list As CListPiece)
        //    Dim l_piece As CPiece = a_list.getPiece(Me)
        //    m_classement = l_piece.m_classement
        //End Sub

        public override string ToString()
        {
            var parent = " ";
            if (PieceParentId >= 0)
                parent = string.Format(" ({0}) ", PieceParentId); 
            return string.Format("{0} {1}{2}{3} {4} {5}", Classement.Value, PieceId, parent, Name, Album, getLocation()); 
            //String location = Location;
            //return location == "" ? Files.File : location;
        }
        //public string File
        //{
        //    get { return Files.File; }
        //}
        public string PathAndRef
        {
            get { return getLocation() + " " + m_ref.ToString(); }
        }
        //private string _location;
        public string Location
        {

            get
            {
                return Files.Path; 
                //if (_location == null)
                //_location =  Files.Path;
                //return _location; 


            }
        }
        public string getLocation()
        {
            return Files.getLocation(); 
        }

        public bool Exists { get { return Files.Exists; } }

        //public bool classListToUpdate()
        //{
        //    string l_strList = "";
        //    if (ClassPlayList != null)
        //        l_strList = ClassPlayList.Name;

        //    //if (Classement.Imported)
        //    //{
        //    if (l_strList != ClassList)
        //    {
        //        return true;
        //    }
        //    //}
        //    return false;
        //}

        //private string _comment;
        //public string Comment
        //{
        //    get
        //    {
        //        if (parent != null)
        //            return "";
        //        if (_comment == null)
        //        {
        //            if (native != null)
        //                _comment = native.Comment;
        //        }
        //        return _comment;

        //        //string l_pref = "";
        //        //string l_str = "";

        //        //string l_strList = "";
        //        //if (ClassPlayList != null)
        //        //    l_strList = ClassPlayList.Name;

        //        //if (Classement.Imported)
        //        //{
        //        //    if (l_strList != ClassList)
        //        //    {
        //        //        l_pref = "m (" + ClassList + ") ";
        //        //    }
        //        //}
        //        //int l_rank = m_rank.Twice;
        //        //if (l_rank > 0)
        //        //{
        //        //    if (l_rank < 1000)
        //        //    {
        //        //        if (CTuning.Total > 1000)
        //        //        {
        //        //            l_str += "0";
        //        //        }
        //        //        if (l_rank < 100)
        //        //        {
        //        //            l_str += "0";
        //        //            if (l_rank < 10)
        //        //            {
        //        //                l_str += "0";
        //        //            }
        //        //        }
        //        //    }

        //        //    double l_tx = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Goodness, CConf.Sort.Quality));
        //        //    double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
        //        //    //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
        //        //    //getTx(m_rank.Lenght)
        //        //    l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();
        //        //}

        //        //return l_pref + l_str + getClassementEvol();

        //    }
        //    set
        //    {
        //        if (parent != null)
        //            return;
        //        if (value != _comment)
        //        {
        //            _comment = value;
        //            //if (value != Comment)
        //            //{
        //            // m_comment = value;
        //            OnCommentChange(value);
        //        }
        //        // }
        //    }
        //}
        //private string _grouping;
        //public string Grouping
        //{
        //    get
        //    {
        //        if (_grouping == null)
        //        {
        //            if (native != null)

        //                _grouping = native.Grouping;
        //        }
        //        return _grouping;
        //    }
        //    //set
        //    //{
        //    //    //if (value != Grouping)
        //    //    //{
        //    //    //  grouping = value;
        //    //    OnGroupingChange(value);
        //    //    //}
        //    //}
        //}

        //public void setGrouping(string value, bool prior)
        //{
        //    if (value != _grouping)
        //    {
        //        _grouping = value;
        //        OnGroupingChange(value, prior);
        //    }
        //}

        //private static double getTx(int rank)
        //{
        //    if (rank <= 0)
        //        return 0;
        //    return (Math.Log(Convert.ToDouble(CTuning.Total) / Convert.ToDouble(rank)) / Math.Log(2));
        //}

        //public int QRank
        //{
        //    get { return m_rank.Goodness; }
        //    set { m_rank.Goodness = value; }
        //}

        //public int LRank
        //{
        //    get { return m_rank.Lenght; }
        //    set { m_rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return m_rank.Twice; }
        //    set { m_rank.Twice = value; }
        //}




        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return Classement.isClassListNumeric;
            }
        }

        //  public String ClassNameAndRating { get { return Classement.ClassNameAndRating; } }



        #region "calcul liste dynamiques"
        // Private m_bCanPlay As Boolean = True
        public delegate bool canPlayDel(int a_base);
        //public bool canPlay(int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    if (a_base <= 0)
        //        return true;
        //    DateTime now = DateTime.Now;
        //    bool l_bRet = ListDates.canPlay(now, Delta, a_base);
        //    if (!l_bRet)
        //    {
        //        Console.WriteLine(" " + Comment + " " + Location);
        //    }

        //    return l_bRet;
        //}

        // private CListDate m_datesModifClassement = null;
        private CListDate DatesClassement_
        {
            get
            {
                //if (m_datesModifClassement == null)
                //    m_datesModifClassement = Classement.Dates;
                return Classement.Dates;
            }
        }

        //public bool mustPlayToPreciseClassement(DateTime now, int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    bool bRet = !DatesClassement.canPlay(now, Delta, a_base);
        //    bool bLastModif = DatesClassement.LastModif > DatesPlayed.LastModif;


        //    if (CConf.CheckModifStrict)
        //        // on ne retient que s'i n'a pas été lu depuis la dernière modif.
        //        // encore en cours : j'écoute puis je modifie
        //        bRet = bRet && bLastModif;

        //    if (a_base == 0)
        //        return bLastModif;
        //    return bRet;
        //}

        public String getClassementEvol()
        {
            DateTime playedCorr = ListDates.LastModif;
            try
            {
                if (playedCorr > DateTime.MinValue)
                    playedCorr -= m_duration;
            }
            catch (Exception)
            {
                logTrack.log("{0} impossible de corriger la date jouée {1} avec la durée {2}", this, ListDates.LastModif, m_duration);
            }
            if (DatesClassement_.LastModif > playedCorr)
            {
                return Classement.Evol;
            }
            return "";

        }

        public static double LogBase = 2.0;
        public static double Scale = 0.1;
        //private TimeSpan Delta
        //{

        //    get
        //    {
        //        if (m_rank.Goodness < 0)
        //            return TimeSpan.MaxValue;
        //        long l_ticks = Convert.ToInt64(new TimeSpan(1, 0, 0, 0).Ticks * Scale);

        //        double r = CPieceInListComparer.Calc(this, CConf.Select);
        //        //     Rapport(m_rank.Goodness, CConf.Sort.Quality)
        //        if (r == -1)
        //            return TimeSpan.MaxValue;

        //        long l_nt = long.MaxValue;
        //        try
        //        {
        //            l_nt = Convert.ToInt64(l_ticks / r);
        //        }
        //        catch (Exception ex)
        //        {
        //        }

        //        return new TimeSpan(l_nt);
        //    }
        //}



        //Sub reinitCanPlay()
        //    m_bCanPlay = True
        //End Sub

        #endregion

        #region "COM"

        //public void checkComRating(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        if (Rating < 0)
        //            return;
        //        //if (!Classement.Imported)
        //        //    return;

        //        int l_trackRating = a_track.Rating;
        //        if (l_trackRating != Rating)
        //        {
        //            log("change rating from " + l_trackRating + " to " + Rating + " " + Location);
        //            a_track.Rating = Rating;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Rating {0} for {1}", Rating, this);
        //    }

        //}


        //public void checkComInfo(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        //if (!m_infos.YearData.Imported)
        //        //    return;
        //        if (Year <= 0) return;
        //        if (a_track.Year != Year)
        //        {
        //            log("change year from " + a_track.Year + " to " + Year + " " + Location);
        //            a_track.Year = Year;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Year {0} for {1}", Year, this);
        //    }

        //}

        //public void checkComRef(ITrackMetaData a_track)
        //{

        //    if (m_ref == null)
        //        return;


        //    string l_trackArtist = a_track.Artist.TrimSafe();
        //    string l_trackAlbum = a_track.Album.TrimSafe();
        //    string l_trackName = a_track.Name.TrimSafe();
        //    int l_trackNumber = a_track.TrackNumber;

        //    if (l_trackArtist != m_ref.Artist)// && m_ref.ArtistData.Imported)
        //    {
        //        log("change Artist from " + l_trackArtist + " to " + m_ref.Artist + " " + Location);
        //        try { a_track.Artist = m_ref.Artist.TrimSafe(); }
        //        catch { misc.log("unable to change Artist {0} for {1}", Artist, this); }
        //    }
        //    if (l_trackAlbum != m_ref.Album) // && m_ref.AlbumData.Imported)
        //    {
        //        log("change Album from " + l_trackAlbum + " to " + m_ref.Album + " " + Location);
        //        try { a_track.Album = m_ref.Album; }
        //        catch { misc.log("unable to change Album {0} for {1}", Album, this); }
        //    }
        //    if (l_trackName != m_ref.Name) // && m_ref.NameData.Imported)
        //    {
        //        log("change Name from " + l_trackName + " to " + m_ref.Name + " " + Location);
        //        try
        //        {
        //            a_track.Name = m_ref.Name.TrimSafe();
        //        }
        //        catch { misc.log("unable to change Name {0} for {1}", Name, this); }
        //    }
        //    if (l_trackNumber != m_ref.TrackNumber && TrackNumber >= 0)//&& m_ref.TrackData.Imported)
        //    {
        //        log("change Track from " + l_trackNumber + " to " + m_ref.TrackNumber + " " + Location);
        //        try { a_track.TrackNumber = TrackNumber; }
        //        catch { misc.log("unable to change TrackNumber {0} for {1}", TrackNumber, this); }
        //    }


        //}


        //public void checkComComment(ITrackMetaData a_track)
        //{
        //    try
        //    {

        //        string l_pieceComment = Comment.Trim();
        //        String l_trackComment = a_track.Comment;
        //        if (l_trackComment == null) l_trackComment = "";
        //        l_trackComment = l_trackComment.Trim();
        //        if (l_trackComment != l_pieceComment)
        //        {
        //            misc.logNoDate("write comment from " + a_track.Comment + " to " + l_pieceComment + " " + Location);
        //            // If l_pieceComment.Trim = "" Then Throw New ApplicationException(Me.ToString() & " set comment to null")
        //            a_track.Comment = l_pieceComment;
        //        }

        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Comments {0} for {1}", Comment, this);
        //    }
        //}

        //public void checkComEnabled(ITrackMetaData a_track)
        //{
        //    if (m_Enabled.isFalse && a_track.Enabled)
        //    {
        //        misc.log("disable {0}", this);
        //        a_track.Enabled = false;
        //    }
        //}

        //public void checkComDate(ITrackInfo a_track)
        //{
        //    //Dim l_date As String = a_track.EQ

        //}
        #endregion


        public bool isPodcast
        {
            get { return Files.isPodcast; }
        }
        private void log(String txt)
        {
            logTrack.log(txt);
        }



        List<DateTime> ITrackPlayedDates.Dates
        {
            get { return new List<DateTime>(ListDates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return new List<DateTime>(DatesClassement_.Dates); }
        }

        public DateTime LastModifClass { get { return m_classement.LastModif; } }

        public string ClassEvol
        {
            get { return getClassementEvol(); }
        }





        public void changeNativeValueAlbum(string value)
        {
            if (native == null)
                return;
            native.Album = value;
        }

        public void changeNativeValueArtist(string value)
        {
            if (native == null) return; native.Artist = value;
        }

        public void changeNativeValueName(string value)
        {
            if (native == null) return; native.Name = value;
        }

        public void changeNativeValueTrack(int value)
        {
            if (native == null) return; native.TrackNumber = value;
        }

        public void changeNativeValueYear(int value)
        {
            if (native == null) return; native.Year = value;
        }

        public void changeNativeValueClassement(Classement value)
        {
            if (native == null)
                return;
            native.Rating = value.Rating; native.ClassName = value.ClassList;
        }
#if VOL
        public void changeNativeValueVolume(int value)
        {
            if (native == null) return;
            native.Volume = value;
        }
#endif

        public void changeByRemote(string type, object Old, object New)
        {
            logChange("change by remote", type, Old, New);
        }

        public void changeByNative(string type, object Old, object New)
        {
            logChange("change by native", type, Old, New);
        }

        private bool isRefchanged;
        public void RefChange()
        {
            isRefchanged = true;
        }

        public void unCheck()
        {
            if (native == null) return; native.Enabled = false;
        }

        public void changeLocalValueByRemoteAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void change()
        {
            throw new NotImplementedException();
        }

        public void setClassement(string className, int rating)
        {
            Classement.setClassement(className, rating);
        }

        public string StrClassement
        {
            get
            {
                return Classement.ToString();
            }
            set
            {
                setClassement(value);
            }
        }

        public long Size
        {
            get
            {
                var ret = Files.Size;
                if (ret <= 0)
                    return 0;
                return ret;
            }
        }

      
        private CPiece parent;

        public void setParent(CPiece parent)
        {
            this.parent = parent; 
        }
        public CPiece Parent
        {
            get { return parent; }
            set
            {
                var _oldParent = parent;

                if (value == null)
                {
                    parent = null;
                    PieceParentId = -1;
                    if (_oldParent != null)
                    {
                        addDataLink(_oldParent);
                    }
                    return;
                }
                else
                {
                    parent = value.Master; 
                }
                parent.addDataLink(this);
                PieceParentId = parent.PieceId;

            }
        }

        private bool deleted;
        public bool Deleted
        {
            get { return deleted; }
            set
            {
                if (value != deleted)
                {
                    if (value)
                        misc.log("Suppression de {0}", this);
                    deleted = value;
                }
            }
        }

        private List<string> _RelativesPath;
        public List<string> RelativesPath
        {
            get
            {
                if (_RelativesPath == null)
                {
                    _RelativesPath = new List<string>();
                    foreach (CFile f in m_files)
                    {
                        _RelativesPath.Add(f.File);
                    }
                }
                return _RelativesPath;
            }
        }


        private exportState _exportState; 
        public exportState ExportStatus
        {
            get
            {
                return _exportState; 
            }
            set
            {
                _exportState = value; 
            }
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return Classement.getDates(); 
            }
        }
    }
}






]]></content>
  </file>
  <file path="\pieceDb.iT\NoTrack.cs">
    <content><![CDATA[using System;
using iTunesLib;
using pdb.obj;
using pdb.util;

namespace pdb.it
{
   public class NoTrack : IITFileOrCDTrack
    {
        private ITrackMetaData meta;
        public NoTrack(ITrackMetaData meta) { this.meta = meta; }
        public IITArtwork AddArtworkFromFile(string filePath)
        {
            return null;
        }

        public string Album
        {
            get
            {
                return meta.Album;
            }
            set
            {
                meta.Album = value;
            }
        }

        public string AlbumArtist
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int AlbumRating
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public ITRatingKind AlbumRatingKind
        {
            get { return ITRatingKind.ITRatingKindUser; }
        }

        public string Artist
        {
            get
            {
                return meta.Artist;
            }
            set
            {
                meta.Artist = value;
            }
        }

        public IITArtworkCollection Artwork
        {
            get { return null; }
        }

        public int BPM
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public int BitRate
        {
            get { return 0; }
        }

        public int BookmarkTime
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public string Category
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Comment
        {
            get
            {
                return "";  //meta.Comment;
            }
            set
            {
                //meta.Comment = value;
            }
        }

        public bool Compilation
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public string Composer
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public DateTime DateAdded
        {
            get { return DateTime.MinValue; }
        }

        public void Delete()
        {

        }

        public string Description
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int DiscCount
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public int DiscNumber
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public int Duration
        {
            get { return (int)meta.Duration.TotalSeconds; }
        }

        public string EQ
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public bool Enabled
        {
            get
            {
                return meta.Enabled;
            }
            set
            {
                meta.Enabled = value;
            }
        }

        public string EpisodeID
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int EpisodeNumber
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public bool ExcludeFromShuffle
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public int Finish
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public string Genre
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public void GetITObjectIDs(out int sourceID, out int playlistID, out int trackID, out int databaseID)
        {
            throw new NotImplementedException();
        }

        public string Grouping
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int Index
        {
            get { return 0; }
        }

        public ITTrackKind Kind
        {
            get { return ITTrackKind.ITTrackKindFile; }
        }

        public string KindAsString
        {
            get { return ""; }
        }

        public string Location
        {
            get
            {
                return meta.Location;
            }
            set
            {

            }
        }

        public string LongDescription
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Lyrics
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public DateTime ModificationDate
        {
            get { return DateTime.MinValue; }
        }

        public string Name
        {
            get
            {
                return meta.Name;
            }
            set
            {
                meta.Name = value;
            }
        }

        public bool PartOfGaplessAlbum
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public void Play()
        {

        }

        public int PlayOrderIndex
        {
            get { return 0; }
        }

        public int PlayedCount
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public DateTime PlayedDate
        {
            get
            {
                return DateTime.MinValue;
            }
            set
            {

            }
        }

        public IITPlaylist Playlist
        {
            get { return null; }
        }

        public IITPlaylistCollection Playlists
        {
            get { return null; }
        }

        public bool Podcast
        {
            get { return meta.isPodcast; }
        }

        public int Rating
        {
            get
            {
                return meta.Rating;
            }
            set
            {
                meta.Rating = value;
            }
        }

        public DateTime ReleaseDate
        {
            get { return DateTime.MinValue; }
        }

        public bool RememberBookmark
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public void Reveal()
        {

        }

        public int SampleRate
        {
            get { return 0; }
        }

        public int SeasonNumber
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public string Show
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int Size
        {
            get { return 0; }
        }

        public int Size64High
        {
            get { return 0; }
        }

        public int Size64Low
        {
            get { return 0; }
        }

        public int SkippedCount
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public DateTime SkippedDate
        {
            get
            {
                return DateTime.MinValue;
            }
            set
            {

            }
        }

        public string SortAlbum
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string SortAlbumArtist
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string SortArtist
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string SortComposer
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string SortName
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string SortShow
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int Start
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public string Time
        {
            get { return ""; }
        }

        public int TrackCount
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public int TrackDatabaseID
        {
            get { return 0; }
        }

        public int TrackNumber
        {
            get
            {
                return meta.TrackNumber;
            }
            set
            {
                meta.TrackNumber = value;
            }
        }

        public bool Unplayed
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public void UpdateInfoFromFile()
        {

        }

        public void UpdatePodcastFeed()
        {

        }

        public ITVideoKind VideoKind
        {
            get
            {
                return ITVideoKind.ITVideoKindNone;
            }
            set
            {

            }
        }

        public int VolumeAdjustment
        {
            get
            {
#if VOL
                return meta.Volume; 
#else
                return 0;
#endif
            }
            set
            {

            }
        }


        public int Year
        {
            get
            {
                return meta.Year;
            }
            set
            {
                meta.Year = value;
            }
        }

        public int playlistID
        {
            get { return 0; }
        }

        public ITRatingKind ratingKind
        {
            get { return ITRatingKind.ITRatingKindUser; }
        }

        public int sourceID
        {
            get { return 0; }
        }

        public int trackID
        {
            get { return 0; }
        }
    }



    class DeletedTrack : IITFileOrCDTrack
    {
        const string DUMMY = "DummyDeletedTrack";
        string location;
        public DeletedTrack(string location) { this.location = location; }
        public IITArtwork AddArtworkFromFile(string filePath)
        {
            return null;
        }

        public string Album
        {
            get
            {
                return DUMMY;
            }
            set
            {

            }
        }

        public string AlbumArtist
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int AlbumRating
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public ITRatingKind AlbumRatingKind
        {
            get { return ITRatingKind.ITRatingKindUser; }
        }

        public string Artist
        {
            get
            {
                return DUMMY;
            }
            set
            {

            }
        }

        public IITArtworkCollection Artwork
        {
            get { return null; }
        }

        public int BPM
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public int BitRate
        {
            get { return 0; }
        }

        public int BookmarkTime
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public string Category
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Comment
        {
            get
            {
                return DUMMY;
            }
            set
            {

            }
        }

        public bool Compilation
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public string Composer
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public DateTime DateAdded
        {
            get { return DateTime.MinValue; }
        }

        public void Delete()
        {

        }

        public string Description
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int DiscCount
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public int DiscNumber
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public int Duration
        {
            get { return 0; }
        }

        public string EQ
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public bool Enabled
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public string EpisodeID
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int EpisodeNumber
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public bool ExcludeFromShuffle
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public int Finish
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public string Genre
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public void GetITObjectIDs(out int sourceID, out int playlistID, out int trackID, out int databaseID)
        {
            throw new NotImplementedException();
        }

        public string Grouping
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int Index
        {
            get { return 0; }
        }

        public ITTrackKind Kind
        {
            get { return ITTrackKind.ITTrackKindFile; }
        }

        public string KindAsString
        {
            get { return ""; }
        }

        public string Location
        {
            get
            {
                return location;
            }
            set
            {

            }
        }

        public string LongDescription
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Lyrics
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public DateTime ModificationDate
        {
            get { return DateTime.MinValue; }
        }

        public string Name
        {
            get
            {
                return DUMMY;
            }
            set
            {

            }
        }

        public bool PartOfGaplessAlbum
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public void Play()
        {

        }

        public int PlayOrderIndex
        {
            get { return 0; }
        }

        public int PlayedCount
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public DateTime PlayedDate
        {
            get
            {
                return DateTime.MinValue;
            }
            set
            {

            }
        }

        public IITPlaylist Playlist
        {
            get { return null; }
        }

        public IITPlaylistCollection Playlists
        {
            get { return null; }
        }

        public bool Podcast
        {
            get { return false; }
        }

        public int Rating
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public DateTime ReleaseDate
        {
            get { return DateTime.MinValue; }
        }

        public bool RememberBookmark
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public void Reveal()
        {

        }

        public int SampleRate
        {
            get { return 0; }
        }

        public int SeasonNumber
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public string Show
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int Size
        {
            get { return 0; }
        }

        public int Size64High
        {
            get { return 0; }
        }

        public int Size64Low
        {
            get { return 0; }
        }

        public int SkippedCount
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public DateTime SkippedDate
        {
            get
            {
                return DateTime.MinValue;
            }
            set
            {

            }
        }

        public string SortAlbum
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string SortAlbumArtist
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string SortArtist
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string SortComposer
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string SortName
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string SortShow
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int Start
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public string Time
        {
            get { return ""; }
        }

        public int TrackCount
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }

        public int TrackDatabaseID
        {
            get { return 0; }
        }

        public int TrackNumber
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public bool Unplayed
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public void UpdateInfoFromFile()
        {

        }

        public void UpdatePodcastFeed()
        {

        }

        public ITVideoKind VideoKind
        {
            get
            {
                return ITVideoKind.ITVideoKindNone;
            }
            set
            {

            }
        }

        public int VolumeAdjustment
        {
            get
            {
#if VOL
                return meta.Volume; 
#else
                return 0;
#endif
            }
            set
            {

            }
        }


        public int Year
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public int playlistID
        {
            get { return 0; }
        }

        public ITRatingKind ratingKind
        {
            get { return ITRatingKind.ITRatingKindUser; }
        }

        public int sourceID
        {
            get { return 0; }
        }

        public int trackID
        {
            get { return 0; }
        }
    }

   }
]]></content>
  </file>
  <file path="\PieceDb.obj\Interfaces.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;

namespace pdb.obj
{

    public enum exportState
    {
        none = 0,
        miss = 1,
        present = 2,
        copy = 3,
        delete = 4
    }

    /// <summary>
    /// définit chemin d'un fichier
    /// </summary>
    public interface IFile
    {
        String Location { get; }
        string getLocation();
        int PieceId { get; }
    }

    /// <summary>
    /// carte d'identité d'un morceau
    /// </summary>
    public interface ITrackReference
    {
        String Artist { get; set; }
        String Album { get; set; }
        String Name { get; set; }
        int TrackNumber { get; set; }
    }

    // définition non ambigue d'un morceau
    public interface ITrackIdentity : IFile, ITrackReference
    {

        int PieceParentId { get; set; }
        TrackIdentity Key { get; }
    }


    /// <summary>
    /// infos de base du morceau :métafonnées de la piste
    /// </summary> 
    public interface ITrackMetaData : ITrackIdentity
    {

        int Rating { get; set; }
        int Year { get; set; }
     //   String Comment { get; set; }
        bool Enabled { get; set; }
        bool isPodcast { get; }
        DateTime PlayedDate { get; }
        DateTime Added { get; }
        TimeSpan Duration { get; set; }
        string ArtWork { get; set; }
     //   string Grouping { get; }
      //  void setGrouping(string value,bool prior);
        bool FirstClass { get; set; }
#if VOL
        int Volume { get; set; }
#endif 
    }

    /// <summary>
    /// Supplément d'infos fournies par Db. liste de dates
    /// </summary>
    public interface ITrackPlayedDates
    {
        List<DateTime> Dates { get; }
        List<DateTime> DatesClassement { get; }
        List<DateTime> DatesClassementBrut { get; }
        String ClassEvol { get; }
    }

    /// <summary>
    /// infos max récupérées de iTunes: 
    /// Métadonnées + listes
    /// 
    /// </summary>
    public interface ITrackNative : ITrackMetaData, ITrackPlayListReport
    {
        String ClassName { get; set; }

      //  void registerDependency(ITrackNative local);
     //   void releaseDependency();
    }

    /// <summary>
    /// infos de base + liste de dates
    /// Infos que Db met à dispo
    /// </summary>
    public interface ITrackNativeDates : ITrackNative, ITrackPlayedDates
    {
        void setClassement(string className, int rating);
        List<string> RelativesPath { get; }
        exportState ExportStatus { get; set;}
        
    }

    /// <summary>
    /// Enregistrement des playlists associées au morceau
    /// </summary>
    public interface ITrackPlayListRecorder
    {
        void AddPlayList(CPlayList a_playList);
        void removePlayList(CPlayList list);
    }

    /// <summary>
    /// récupération des infos PlayList du morceau
    /// </summary>
    public interface ITrackPlayListReport
    {
       // List<CPlayList> PLayLists { get; }
        List<CPlayList> ClassPlayLists { get; }
    }

    /// <summary>
    /// abstraction de trackInfoItunes
    /// </summary>
    public interface ITrackInfoItunes : ITrackNative, ITrackPlayListRecorder
    {
       
       
    }

    public class NullTrack : ITrackNative
    {

        #region ITrackNative Members

        public string ClassName
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public void registerDependency(ITrackNative local) { }
       public void releaseDependency() { }

        #endregion

        #region ITrackMetaData Members

        public int Rating
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public int Year
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public string Comment
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public bool Enabled
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public bool isPodcast
        {
            get { return false; }
        }

        public DateTime PlayedDate
        {
            get { return DateTime.MinValue; }
        }

        public TimeSpan Duration
        {
            get { return new TimeSpan();  }
            set { }
        }

        public string ArtWork
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Grouping
        {
            get
            {
                return "";
            }
            
        }
            
        public void setGrouping(string value, bool prior) { }


        public int Volume { get { return 0; } set { } }

        #endregion

        #region IFile Members

        public string Location
        {
            get { return ""; }
        }

        public string getLocation()
        {
            return "";
        }

        #endregion

        #region ITrackReference Members

        public string Artist
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Album
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Name
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int TrackNumber
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        #endregion

        #region ITrackPlayListReport Members

        public List<CPlayList> PLayLists
        {
            get { return new List<CPlayList>(); }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return new List<CPlayList>(); }
        }

        #endregion

        public bool FirstClass { get { return false; } set {  } }

        public int PieceId
        {
            get { return -1;  }
        }

        public int PieceParentId
        {
            get { return -1; }
            set { }
        }



        public TrackIdentity Key
        {
            get { return new TrackIdentity(this);  }
        }


        public DateTime Added
        {
            get { return DateTime.MinValue; }
        }
    }





}


]]></content>
  </file>
</db>
