<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\pdb.podcast\pdb.podcast.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{6503C759-0373-4B68-A28B-1CB5FF0E6208}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.podcast</RootNamespace>
    <AssemblyName>pdb.podcast</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <TargetFrameworkProfile>
    </TargetFrameworkProfile>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;vendee_</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;MOVE_</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.podcast.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.podcast.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <OutputPath>bin\</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <OutputPath>bin\Release\</OutputPath>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Interop.iTunesLib">
      <HintPath>..\pieceDb.iT\bin\Interop.iTunesLib.dll</HintPath>
      <EmbedInteropTypes>True</EmbedInteropTypes>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Auto\AutoBuilder.cs" />
    <Compile Include="Auto\AutoBuilderItem.cs" />
    <Compile Include="DB\Db.cs" />
    <Compile Include="Selection\CauseData.cs" />
    <Compile Include="Auto\Interfaces.cs" />
    <Compile Include="Auto\TrackBorderItem.cs" />
    <Compile Include="Build\FilePub.cs" />
    <Compile Include="Build\IPub.cs" />
    <Compile Include="Build\PubLoader.cs" />
    <Compile Include="Delta\Memory.cs" />
    <Compile Include="Exporter.cs" />
    <Compile Include="Load\LimitItemLoader.cs" />
    <Compile Include="Load\LimitLoader.cs" />
    <Compile Include="Load\LimitsLoader.cs" />
    <Compile Include="Menage.cs" />
    <Compile Include="Feed.cs" />
    <Compile Include="Feeds.cs" />
    <Compile Include="Load\FeedsLoader.cs" />
    <Compile Include="Load\FeedLimitItemLoader.cs" />
    <Compile Include="Report\DirStat.cs" />
    <Compile Include="Report\FeedLimitItemStat.cs" />
    <Compile Include="Report\FeedsLimitItemStat.cs" />
    <Compile Include="Report\FeedStat.cs" />
    <Compile Include="Report\GroupStat.cs" />
    <Compile Include="Report\IStat.cs" />
    <Compile Include="Report\LimitItemStat.cs" />
    <Compile Include="Report\LimitStat.cs" />
    <Compile Include="Report\Stat.cs" />
    <Compile Include="Loader.cs" />
    <Compile Include="PlayListFilter.cs" />
    <Compile Include="PodcastComparer.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Report\DoubleStat.cs" />
    <Compile Include="Report\StatFloat.cs" />
    <Compile Include="Report\TrackConteneur.cs" />
    <Compile Include="Report\TripleStat.cs" />
    <Compile Include="Selection\CauseItem.cs" />
    <Compile Include="Selection\CauseRegister.cs" />
    <Compile Include="Selection\Causes.cs" />
    <Compile Include="Selection\Conv.cs" />
    <Compile Include="TrackInfoItunes.cs" />
    <Compile Include="Tuning\Auto.cs" />
    <Compile Include="Tuning\Conf.cs" />
    <Compile Include="Tuning\ConfDate.cs" />
    <Compile Include="Tuning\DirConf.cs" />
    <Compile Include="Tuning\Export.cs" />
    <Compile Include="Tuning\Html.cs" />
    <Compile Include="Tuning\Journal.cs" />
    <Compile Include="Tuning\Limit.cs" />
    <Compile Include="Tuning\LimitItem.cs" />
    <Compile Include="Tuning\LimitItemBase.cs" />
    <Compile Include="Tuning\Limits.cs" />
    <Compile Include="Tuning\Move.cs" />
    <Compile Include="Tuning\SelectParam.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823D1D-851C-456B-AC4C-B0BEEC173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\pieceDb.iT\pdb.it.csproj">
      <Project>{CF5DB63F-4790-4351-9050-B30DED32F052}</Project>
      <Name>pdb.it</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <Content Include="conf.xml">
      <SubType>Designer</SubType>
    </Content>
  </ItemGroup>
  <ItemGroup>
    <None Include="app.config" />
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\pdb.podcast\Program.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using iTunesLib;
using pdb.it;
using pdb.obj;
using pdb.ordo;
using pdb.podcast.Auto;
using pdb.podcast.Load;
using pdb.podcast.Report;
using pdb.podcast.Tuning;
using pdb.util;
using Conf = pdb.podcast.Tuning.Conf;

namespace pdb.podcast
{
    /// <summary>
    /// crée des listes de lecture pour les Podcasts
    /// </summary>
    class Program : IAbortTask
    {
        //const char DIR_SEP = Path.DirectorySeparatorChar; 
        static Loader loader;
        //private Feeds feeds;
        public static Logger log;
        public static Logger logAuto; 
        static int step = -1;
        static Program _instance = new Program();
       
        private static AsyncFileWriter asyncFw = new AsyncFileWriter();
        private static Chrono chrono = new Chrono();
        private static Logger logChrono; 



        private static XmlWriter writer;
        //DirConf root;
        //DirConf oldRoot;

        private string _empreinte;

        static void Main(string[] args)
        {

            Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
            log = Logger.getLogger("Program");
            logChrono = Logger.getLogger("Chrono",true);
            logAuto = Logger.getLogger("Auto", true);
            logAuto.NoReset = true; 

            FileRegister.init(new BgDictString0<FileValue>());
            _instance.go(args);
        }

        void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            Console.WriteLine("\nThe read operation has been interrupted.");
            Console.WriteLine("  Key pressed: {0}", e.SpecialKey);
            Console.WriteLine("  Cancel property: {0}", e.Cancel);
            if (loader == null)
                return;
            e.Cancel = true;


            if (e.SpecialKey == ConsoleSpecialKey.ControlC)
            {
                _end = true; 
                PlayList.AbortOpe();
                BackGroundTaskMgr.AbortSpecial();
                BackGroundTaskMgr.Reset();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
                Console.WriteLine("\nFin de l'opération d'enregistrement.");
                MemUtil.End();
                Logger.End();
                DisposableCounter.DisposeAll();
                Locker.releaseSingleProcess();
                AsyncFileWriter.End();
                Exporter.Abort(); 
                Environment.Exit(0);
            }
            else
            {
                BackGroundTaskMgr.PlayPause();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
            }
        }

        //private void scandir(string dir)
        //{
        //    scanFiles(new DirectoryInfo(dir));
        //}

        //private void scanFiles(DirectoryInfo dir)
        //{
        //    log.log("scan " + dir.FullName);
        //    foreach (FileInfo file in dir.GetFiles())
        //    {
        //        //if (dict.ContainsKey(file.FullName))
        //        //    continue;

        //        // log.log("try to build track from " + file.FullName);

        //        try
        //        {
        //            var t = loader.createTrack(-1, file.FullName);
        //            if (t == null)
        //                continue;
        //            TrackInfoItunes track = t as TrackInfoItunes;

        //            if (track == null)
        //                continue;
        //            //if (!track.isPodcast)
        //            //    continue;

        //            log.log("\t==>track créé:" + track);
        //            feeds.checkAll(track);

        //        }
        //        catch (Exception ex)
        //        {
        //            log.log(ex.ToString());
        //        }
        //    }

        //    foreach (DirectoryInfo sub in dir.GetDirectories())
        //        scanFiles(sub);
        //}


        public void go(string[] args)
        {
            int countArgs = args.GetLength(0);
            string confFile = "conf.xml";
            if (countArgs > 0)
                confFile = args[0];
            try
            {
                //BackGroundTaskMgr.Sens = - 1; 
                Thread.CurrentThread.Name = "Main";
                Console.CancelKeyPress += Console_CancelKeyPress;
                ThreadUtil.Log = false;
                misc.init(Logger.getLogger);
                MemUtil.Start();




                Conf.Instance.setConfFile(confFile);
                var xelt = Conf.Instance.load(false);
                if (Conf.Menage != menage.none)
                {
                    new Menage().go();
                    return;
                }
                BackGroundTaskMgr.Conf = Conf.Ordo;
                TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                TrackInfoItunes.MaxPlayed = Conf.PlayedDates;
                var itConf = new pdb.it.Conf(xelt);
               
                // loader = new Loader(itConf, true);

                loader = new Loader(itConf,
                    () =>
                    {
                        misc.Pre = "[Load " + step + "] ";

                        PlayList.AbortOpe();
                        BackGroundTaskMgr.AbortSpecial();
                        //   Thread.Sleep(1000); 
                        //  BackGroundTaskMgr.Start(); 
                    })

               ;
                loader.init();
                TrackInfoItunes.DefaultFolder = loader.DefaultFolder; 


                string ziqueOrg = loader.DefaultFolder;
                loader.PlayListFilter = new PlayListFilter(Conf.RootIt);

                BackGroundTaskMgr.Start();
                List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();
                List<TrackInfoItunes> list = new List<TrackInfoItunes>();

                // var bgClass = BackGroundTaskMgr.getMgr("Classement", 0);

                do
                {
                    try
                    {
                        chrono.end();
                        logChrono.log(chrono.display(3, "{0}:{1:#}")); 
                        chrono.reset("Program"); 
                         
                        step++;
                        Logger.Pre = "[" + step + "] ";
                        Logger.CreateNullLoggers = false;
                        xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                        loader.Conf = new it.Conf(xelt);
                       // AutoBuilder.Log();
                        BackGroundTaskMgr.Conf = Conf.Ordo;
                        TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                        ziqueOrg = loader.DefaultFolder;

#if vendee
                        listTrack = new List<ITrackInfoItunes>();
                        loader.reset(step == 0);

                        loader.ModeXml = false;
                        loader.loadTracks(listTrack);

                        var listV = new ArrayList();
                        loader.getNatives(listV);

                        new Vendee().go(listV);

                        return;

#endif

                        chrono.bip("debut"); 
                       
                        if (step == 0 || !Conf.Simulation)
                        {

                            loader.reset(step == 0, AutoBuilder.MustUpdate);
                            BackGroundTaskMgr.recordMsProc();
                            loader.Aborted = true;

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.Reset();
                            loader.saveIds();
                            BackGroundTaskMgr.recordMsProc();
                            Logger.Reset();
                            BackGroundTaskMgr.Start();


                            misc.Pre = "[" + step + "] ";


                            listTrack = new List<ITrackInfoItunes>();


                            xelt = Conf.Instance.load(false);
                            loader.Conf = new it.Conf(xelt);
                          //  AutoBuilder.Log();
                            BackGroundTaskMgr.Conf = Conf.Ordo;
                            TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            //xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            //loader.Conf = new it.Conf(xelt);
                            //BackGroundTaskMgr.Conf = Conf.Ordo;
                            //TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            if (Conf.DeleteDoublon)
                            {
                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            if (Conf.GetDescription)
                            {
                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            string copyAll = Conf.CopyAll;
                            if (!string.IsNullOrEmpty(copyAll))
                            {
                                loader.loadTracks(listTrack);
                                List<TrackInfoItunes> listToCopy = new List<TrackInfoItunes>();
                                foreach (ITrackInfoItunes _track in listTrack)
                                {

                                    if (_track.isPodcast)
                                    {
                                        var t = _track as TrackInfoItunes;
                                        listToCopy.Add(t);
                                    }


                                }
                                int count = listToCopy.Count;
                                int i = 0;
                                foreach (TrackInfoItunes track in listToCopy)
                                {
                                    i++;
                                    track.copy(copyAll, string.Format("{0}/{1}", i, count));
                                }
                                return;
                            }


                            loader.loadTracks(listTrack);

#if menage
                // var listC = new Dict<string, FileInfo>();
                var listD = new Dict<string, FileInfo>();

                Dict<string,ITrackInfoItunes> dict = new Dict<string, ITrackInfoItunes>();
                foreach (var track in listTrack)
                    dict[track.Location] = track;

               
                listFiles(listD, new DirectoryInfo(@"D:\zique\podcasts"));

                foreach (FileInfo file in listD)
                {
                    string location = file.FullName.Replace("D:", "C:");
                    FileInfo C = new FileInfo(location);
                    if (C.Exists)
                    {
                        //TrackInfoItunes track = dict[file.FullName] as TrackInfoItunes;
                        //if (track != null)
                        //{
                        //    log.log("suppression track" + track);
                        //    track.Delete();
                        //}
                        //else
                        //{
                            log.log("suppression simple de " + file.FullName);
                            file.Delete();
                        //}
                    }

                }

                return; 

#elif build

                            list = new List<TrackInfoItunes>();

                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location) || !File.Exists(location))
                                    {
                                        log.log("phase load :: tres bizarre sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }

                                    list.Add(t);
                                }

                            }
                            int nbIntegre = 0;
                            int nbSuppr = 0;
                            scanFiles(list, new DirectoryInfo(@"C:\zique\podcasts"), ref nbIntegre, ref nbSuppr);
                            log.log("fin scan : {0} intégrés, {1} supprimmés", nbIntegre, nbSuppr);
                            BackGroundTaskMgr.End();
                            return;
                        }
                    }


                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                }
                while (true);

#else
                            list = new List<TrackInfoItunes>();
                            Dict<string, TrackInfoItunes> dictLoc = new Dict<string, TrackInfoItunes>();
                            GroupStat trackStat = new GroupStat();
                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location) || !FileRegister.Exist(location)) //  File.Exists(location))
                                    {
                                        //log.log("phase load :: suppression du track sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }

                                    dictLoc[t.Location] = t;
                                    list.Add(t);
                                    if (!t.Played)
                                        trackStat.recordTrack(t, typeState.all);
                                    trackStat.recordTrack(t, typeState.all);
                                }
                            }

                            var fileExport = Conf.Export.fOut;
                            if (!string.IsNullOrEmpty(fileExport))
                            {
                                ITextWriter sb = new StringBuilder();
                                Exporter.RecordTracks(list, sb);
                                sb.Flush();
                                asyncFw.post(fileExport, sb.ToString());
                            }

                            chrono.bip("loadTracks"); 

                            var descTrack = DescBuilder.create("Tracks");

                            LimitItem.includeDetail = true;
                            trackStat.report(descTrack);
                            log.log(descTrack.ToString());

                            var sbT = new StringBuilder();

                            //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\tracks.txt")))
                            //{
                            var trackFile = DescBuilder.create("Tracks", sbT);
                            trackStat.report(trackFile);
                            sbT.Flush();

                            asyncFw.post(@"..\Logs\tracks.txt", sbT.ToString());
                            //}
                            chrono.bip("desc tracks");
                            Logger.LogConsole = false; 
                            loader.loadLists();
                            Logger.LogConsole = true; 
                            chrono.bip("load list"); 

                        }

                        DirConf root = null;
                        while (true)
                        {

                            chrono.end();
                            logChrono.log(chrono.display(3, "{0}:{1:#}"));
                            chrono.reset("Program"); 

                            xelt = Conf.Instance.load(false);
                            loader.Conf = new it.Conf(xelt);
                            PlayList.StartOpe();
                            loader.Aborted = false;

                            Logger.CreateNullLoggers = !Conf.LogGen;


                            BackGroundTaskMgr.Conf = Conf.Ordo;
                            var list2 = new List<TrackInfoItunes>(list.Count); 
                            foreach (TrackInfoItunes track in list)
                            {
                                var copy = TrackInfoItunes.createCopy(track);
                                list2.Add(copy); 
                                //track.clearLists(); // = selectMode.none;
                            }
                            chrono.bip("track.clearLists");
                            // Feeds.createInstance();
                            root = Conf.DirConf;
                            var feeds = root.Feeds; 
                           

                            var fAuto = loader.TreePlayList.getComposite(Conf.RootIt);
                            if (Conf.GenFeed)
                            {
                                var fFeeds = fAuto.getComposite("Feed");

                                if (fFeeds != null)
                                {
                                    scanFeedsForRecordEmptyLists(feeds, fFeeds);
                                }
                            }

                            foreach (TrackInfoItunes track in list2)
                            {
                                feeds.check(track);
                            }
                            chrono.bip("feeds"); 

                            //if (Conf.Single)
                            //{
                            //    var listS = new List<TrackInfoItunes>();
                            //    for (int i = 0; i < Limits.NB; i++)
                            //    {
                            //        var list0 = feeds.getTracks(i, int.MaxValue, int.MaxValue, null, null, 1, null); //feeds.ListTrackSingle;
                            //        foreach (var t in list0)
                            //        {
                            //            if (!listS.Contains(t))
                            //                listS.Add(t);
                            //        }

                            //    }

                            //    string[] folder = new string[] { "Select", "tmp" };
                            //    buildList("_auto", listS, 0, folder);
                            //}

                            //var sb = DescBuilder.create();

                            //Création des listes
                            //  oldRoot = root;
                            
                            Exporter.TopRecord();
                            //***************** Lancement "pour de vrai" ***************************************
                            LimitItemLoader.ModeSelection = true; 
                            AutoBuilder.init(true);
                            loadCandidat(root);
                            // standAlone(root); 
                            phase2(root);
                            Selection(root);
                            //**********************************************************************************
                            //***************** Lancement "pour de faux" ***************************************
                            AutoBuilder.Init3(); 
                            LimitItemLoader.ModeSelection = false;
                            phase2(root);
                            Selection(root);
                            LimitItemLoader.ModeSelection = true;
                            //**********************************************************************************
                            Exporter.TopCopy();
                            chrono.bip("selection"); 
                            foreach (TrackInfoItunes s in feeds.getSelectedTracks())
                            {
                                var items = s.Providers;
                                int count = items.Count;
                                foreach (LimitItem item in items)
                                {
                                    item.recordTrackMoy(s, count);
                                    if (count == 1)
                                        s.Exclu = item;
                                }
                            }
                            chrono.bip("selection exclu"); 


                            //****************************************
                            // lancement des sorties xml et html en asynchrone
                            postReport(root); 
                            //****************************************
                           
                           

                            //mem0.load();
                            //var listSe = feeds.getSelectedTracks(); 
                            //if (mem0.FileExists)
                            //{
                            //    foreach (TrackInfoItunes s in listSe)
                            //    {
                            //        var key = s.Location;
                            //        if (!mem0.dict.ContainsKey(key))
                            //            log.log("delta virtuel ajouté {0} ==> {1}", s, s.GetProvider());
                            //    }

                            //    foreach (string key in mem0.dict.Keys)
                            //    {
                            //        if (!feeds.existSelected(key))
                            //            log.log("delta virtuel supprimé {0}",mem0.dict[key]);
                            //    }
                            //}
                            //mem0.save(listSe); 

                          //  AutoBuilder.Log();
                            AutoBuilder.init(false);
                            bool cangoAuto = AutoBuilder.Check(feeds);
                            chrono.bip("AutoBuilder"); 
                            AutoBuilder.Log();
                            if (!cangoAuto && Conf.AutoBlock)
                            {
                                logAuto.log("arret par auto");
                                //Thread.Sleep(1000);
                                continue;
                            }
                            else
                            {
                                string newEmpreinte = Conf.DirConf.getEmpreinte();
                                if (newEmpreinte == _empreinte && !AutoBuilder.Stable)
                                {
                                    logAuto.log("arret par empreinte");
                                    continue;
                                }

                                _empreinte = newEmpreinte;

                                Logger.LogAll("****************************************************************************************");
                                Logger.LogAll("arret");
                                Logger.LogAll("****************************************************************************************");



                                // BackGroundTaskMgr.End();

                                Logger.Pre = "";

                                //   log.log(sb.ToString());
                                var sb2 = DescBuilder.create();

                                if (Conf.Simulation)
                                {
                                    Logger.LogAll("****************************************************************************************");
                                    Logger.LogAll("TEST");
                                    Logger.LogAll("****************************************************************************************");
                                }

                                var feedsRapport = new StringBuilder();
                                feeds.rapport(feedsRapport);
                                Logger.LogConsole = false; 
                                log.log(feedsRapport.ToString());
                                Logger.LogConsole = true; 
                                var tw = new StringBuilder();
                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\history.txt")))
                                //{
                                feeds.rapportSelected(tw);
                                asyncFw.post(@"..\Logs\history.txt", tw.ToString());
                                // }

                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\historyPre.txt")))
                                //{
                                tw = new StringBuilder();
                                feeds.rapportPreSelected(tw);
                                asyncFw.post(@"..\Logs\historyPre.txt", tw.ToString());
                                //}

                                // rapport détaillé
                                LimitItem.includeDetail = true;
                                Conf.DirConf.rapport(sb2);
                                Logger.LogConsole = false; 
                                log.log(sb2.ToString());
                                Logger.LogConsole = true; 


                                // rapport plus concis
                                var sb3 = DescBuilder.create();
                                LimitItem.includeDetail = false;
                                Conf.DirConf.rapport(sb3);
                                Logger.LogConsole = false; 
                                log.log(sb3.ToString());
                                Logger.LogConsole = true; 
                                chrono.bip("rapport"); 
                                break;
                            }
                        }

                        //mem1.load();

                        //if (mem1.FileExists)
                        //{
                        //    foreach (TrackInfoItunes s in listSe)
                        //    {
                        //        var key = s.Location;
                        //        if (!mem1.dict.ContainsKey(key))
                        //            log.log("delta reel ajouté {0} ==> {1}", s, s.GetProvider());
                        //    }

                        //    foreach (string key in mem1.dict.Keys)
                        //    {
                        //        if (!feeds.existSelected(key))
                        //            log.log("delta reel supprimé {0}", mem1.dict[key]);
                        //    }
                        //}
                        //mem1.save(listSe); 


                        Logger.CreateNullLoggers = false;
                        WritePlayList(root);

                       


                        // Sélection du dernier podcast de chaque album
                        if (!Conf.Single)
                        {
                            var feeds = root.Feeds;
                            int prior = 2;
                            var listP = Conf.SelectParams;

                            var listS = new List<TrackInfoItunes>();
                            string[] folder = null;
                            foreach (SelectParam p in listP)
                            {
                                if (p.etendue.Contains("s"))
                                {
                                    listS = new List<TrackInfoItunes>();
                                    folder = new string[] { "select", "tmp", p.name };
                                    feeds.getFirstSelectedTracks(listS, p);
                                    buildList("_select", listS, prior, folder);
                                }
                            }

                            for (int level = 0; level < Limits.NB; level++)
                            {
                                foreach (SelectParam p in listP)
                                {
                                    if (p.etendue.Contains(level.ToString()))
                                    {
                                        p.level = level;
                                        folder = new string[] { "select", "tmp", p.name };
                                        listS = new List<TrackInfoItunes>();
                                        feeds.buildFirstSelectedTrackLevel(listS, p);  //true, true, false, false);
                                        buildList("_" + level, listS, prior, folder);
                                    }
                                }
                            }

                        }

                        var journal = Conf.Journal;
                        if (journal != null)
                        {
                            var feeds = root.Feeds;
                            for (int j = 1; j <= Journal.NB_JOUR_MAX; j++)
                            {
                                List<TrackInfoItunes> listJ = null;
                                if (journal.NbJour >= j)
                                {
                                    listJ = feeds.buildJournal(journal);
                                }
                                else
                                    listJ = new List<TrackInfoItunes>();

                                var name = j.ToString();
                                if (j < 10)
                                    name = "0" + name;
                                buildList(name, listJ, 3, "journal");

                            }
                        }

                        if (Conf.GenFeed)
                        {
                            var feeds = root.Feeds;
                            var prior = Conf.GenFeedPrior;
                            foreach (Feed feed in feeds.List)
                            {
                                var list0 = feed.getSelectedTracks;
                                buildList(feed.Name, list0, prior, "Feed");
                            }
                        }

                        string zique = Conf.Move.Zique;



                        BackGroundTaskMgr trackMgr = BackGroundTaskMgr.getMgr("Track", 12);
                        var trackList = BackGroundTaskMgr.getMgr("TrackList", 0);


                        int ii = 0;
                        while (!BackGroundTaskMgr.ConfirmEnd(20000, 10))
                        {
                            ii++;
                            if (ii == 60)
                                ii = 0;
                            if (ii == 0)
                            {
                                ITextWriter sb = new StringBuilder();

                                log.log("Attente Classement " + sb.ToString());
                            }
                            Thread.Sleep(100);
                        }

                        // BackGroundTaskMgr.End();


                        misc.Pre = "[ OK " + step + "] ";
                        Logger.LogAll("*****************************************************************************************************");
                        Logger.LogAll("Pile Classement finie, attente nouvelle version");
                        Logger.LogAll("*****************************************************************************************************");



                        Logger.LogAll("****************************************************************************************");
                        Logger.LogAll("arret 2");
                        Logger.LogAll("****************************************************************************************");

                        DateTime limit = DateTime.Now.AddDays(-Conf.Move.Delta);

                        if (!string.IsNullOrEmpty(zique))
                        {
                            foreach (TrackInfoItunes track in list)
                            {
                                track.move(ziqueOrg, zique, limit);
                            }
                            return;
                        }
                        if (!Conf.Simulation)
                        {

                            Logger.Pre = "[ OK " + step + "] ";
                            Logger.LogAll("*****************************************************************************************************");
                            Logger.LogAll("attente nouvelle version");
                            Logger.LogAll("*****************************************************************************************************");
                        }
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                        Thread.Sleep(1000);
                    }


                }
                while (true);




#endif

                //while (!BackGroundTaskMgr.Finished)
                //    Thread.Sleep(30);
                //log.log("****************************************************************************************");
                //loader.SynchronizePodcast(); 
                //log.log("fin");
                //log.log("****************************************************************************************");
            }

            catch (Exception ex)
            {
                log.log(ex.ToString());
            }


        }

        #region report asynchrone

        private DirConf _attenteWriteHtml; 
        private volatile object _lockReportHtml = new object();
        private bool _end;
        ThreadUtil thReport ;

        private void postReport(DirConf dir)
        {
            if (thReport == null)
            {
                lock (_lockReportHtml)
                {
                    if (thReport == null)
                    {
                        thReport = new ThreadUtil(loopReportHtml, "ReportHtml");
                        thReport.Start(); 
                    }
                }
            }

            lock (_lockReportHtml)
                _attenteWriteHtml = dir; 
        }

        private void loopReportHtml()
        {
            DirConf traite = null; 
            while (!_end)
            {
                Thread.Sleep(30);
                if (_attenteWriteHtml == null)
                    continue;
                lock (_lockReportHtml)
                {
                    if (_attenteWriteHtml == null)
                        continue;
                    traite = _attenteWriteHtml;
                    _attenteWriteHtml = null; 
                }
                reportHtml(traite); 
            }
        }


        private void reportHtml(DirConf root)
        {
            try
            {

                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = System.Text.Encoding.UTF8;
                var _sb = new System.Text.StringBuilder();
                using (writer = XmlWriter.Create(_sb, settings))
                {
                    LimitsLoader.Writer = new WriterXml(writer);
                    DoubleStat.ModeHtml = false;
                    writer.WriteStartElement("tracks");
                    WriteTracks(root);
                    writer.WriteEndDocument();
                    writer.Flush();
                }

                asyncFw.post(@"..\tracks.xml", _sb.ToString());
             //   chrono.bip("xml");

                string html = @"..\tracks.html";
                //if (File.Exists(html))
                //    File.Delete(html);
                var sbHtml = new StringBuilder();
                //using (pdb.util.TextWriter sbHtml = new pdb.util.TextWriter(new StreamWriter(File.OpenWrite(html), System.Text.Encoding.UTF8)))
                //{
                LimitsLoader.Writer = new WriterHtml(sbHtml);
                DoubleStat.ModeHtml = true;
                sbHtml.Append(@"<!DOCTYPE html>
<html>
<head>
	<title>"
+ Environment.CurrentDirectory + @"</title>
	
	<style type='text/css'>
		body{
			margin:10px 30px;
			font-family:verdana;
			font-size:12px;
		}
		h1{
			font-family:verdana;
			font-size:14px;
			font-weight:bold;
			text-decoration:underline;
		}
        .low {
			color: rgb(0,125,255);
		}

        .med {
			font-weight:bold;
			color: rgb(0,140,0);
		}

        .high {
			font-weight:bold;
			font-size:14px;
			color: rgb(240,155,0);
		}
        
		.big {
			font-weight:bold;
			font-size:14px;
			text-decoration:underline;
			color: rgb(255,32,0);
		}

        .album {
			color: rgb(0,125,255);
		}
        .track {
            font-weight:bold;
			color: rgb(0,40,80);
		}
		div.tree div {
			padding-left:16px;
		}
		div.tree div.parent div {
			 display:none;
			 cursor:default;
		}
		div.tree div.parent {
			 cursor:pointer !important;
			 background:transparent url(plus.gif) no-repeat top left;
		}
		div.tree div.expanded {
			background:transparent url(moins.gif) no-repeat top left;
		}
	</style>
	<link rel='stylesheet' type='text/css' href='treeview.css' media='screen' /> 
	<script type='text/javascript' src='jquery.js'></script>
	<script type='text/javascript'>
	$(function() {
		$('div.tree div:has(div)').addClass('parent');
		$('div.tree div').click(function() {
			var o = $(this);
			o.children('div').toggle();
			o.filter('.parent').toggleClass('expanded');
			return false;
		});
	});
	</script>
</head>
<body>");
                WriteTracks(root);
                sbHtml.Append(@"</body>
</html>");

                sbHtml.Flush();

                //}
                asyncFw.post(html, sbHtml.ToString());
              //  chrono.bip("html");
            }
            catch (Exception ex)
            {
                log.log(ex.ToString()); 
            }
        }

        #endregion


        public static void buildList(string name, List<TrackInfoItunes> list_, List<string> folders)
        {
            buildList(name, list_, int.MaxValue, folders);
        }

        public static void buildListPrior(string name, List<TrackInfoItunes> list_, List<string> folders, int prior)
        {
            buildList(name, list_, prior, folders);
        }


        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, params string[] folders)
        {
            var lfolders = new List<string>(folders);
            buildList(name, list_, prior, lfolders);
        }

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, List<string> folders)
        {
            if (Conf.Simulation)
                return;
            //   log.log("build list {0}",name);
            var list = new List<IFile>(list_);
            var folder = loader.TreePlayList.getComposite(Conf.RootIt);
            folders = new List<string>(folders);

            var nname = name;
            if (name.Contains(Path.DirectorySeparatorChar.ToString()))
            {
                var tab = name.Split(Path.DirectorySeparatorChar);
                string str = null;
                for (int i = 0; i < tab.GetLength(0); i++)
                {
                    if (str != null)
                        folders.Add(str);
                    if (!string.IsNullOrEmpty(tab[i]))
                        str = tab[i];
                }
                if (!string.IsNullOrEmpty(str))
                    nname = str;
            }

            for (int i = 0; i < folders.Count; i++)
            {
                var aux = folder;
                folder = folder.getComposite(folders[i]);
                if (folder == null)
                    folder = loader.getOrCreateFolder(aux, folders[i], list.Count > 0);
                if (folder == null)
                    return;
            }

            //  var folder = loader.root.getComposite("auto").getComposite("PODUtil"); 
            var playlist = loader.getPlayList(folder, nname, list.Count > 0);
            if (playlist != null)
            {
                if (prior < int.MaxValue && prior >= 0)
                    playlist.setPrior(prior);
                //if (list.Count > 0)
                loader.mergeList(playlist, list, false, _instance, null);
                //else
                //    loader.removeList(folder, name);
            }



            //log.log("clear list {0}", name); 
            //loader.ClearList(playlist);
            //log.log("add items {0}", name); 
            //foreach (TrackInfoItunes track in list)
            //    loader.addItemToList(playlist, track); 


        }



        delegate void actionList(DirConf dir);
        private void recursif(DirConf dir, action pre, action post)
        {
            var fLoader = dir.Loader;
            //if (pre > action.none && pre < action.writeTracksPre)
            //    log.log("{0} {1}", pre, dir.getPath());
            fLoader.Action(pre);

            //Construction récursive sur l'arbre
            foreach (DirConf child in dir)
            {
                // DescBuilder sub = sb.createChild(child.getPath());
                recursif(child, pre, post);
            }
            //if (post > action.none && post < action.writeTracksPre)
            //    log.log("{0} {1}", post, dir.getPath());
            fLoader.Action(post);


        }

        private void loadCandidat(DirConf dir)
        {
            recursif(dir, action.loadCandidat, action.none);
        }


        //private void standAlone(DirConf dir)
        //{
        //    recursif(dir, action.standAlone, action.none); 
        //}

        private void phase2(DirConf dir)
        {
            recursif(dir, action.none, action.phase2);
        }



        /// <summary>
        /// Constitution d'un répertoire
        /// </summary>
        /// <param name="dir"></param>
        /// <param name="sb"></param>
        private void Selection(DirConf dir)
        {
            recursif(dir, action.selectionPre, action.selectionPost);

            // ne sert pas
            //dir.TransmissionListToParent();

        }

        private void WritePlayList(DirConf dir)
        {
            recursif(dir, action.writeLists, action.none);
        }

        private void WriteTracks(DirConf dir)
        {
            recursif(dir, action.writeTracksPre, action.writeTracksPost);
        }
#if build
        public void scanFiles(List<TrackInfoItunes> list, DirectoryInfo dir, ref int nbIntegre, ref int nbSuppr)
        {
            string album = dir.Name;
            var files = dir.GetFiles();
            if (files.GetLength(0) > 0)
            {
                foreach (FileInfo file in dir.GetFiles())
                {
                    string location = file.FullName.ToLower();
                    var trackByLocation = list.Find(t => t.Location != null && t.Location.ToLower().Equals(location));

                    if (trackByLocation != null)
                        continue;
                    var filePub = new FilePub(file.FullName);
                    new PubLoader(filePub).setPub();

                    TrackInfoItunes track = null;

                    foreach (TrackInfoItunes t in list)
                    {
                        if (album.Equals(t.Album))
                        {
                            if (filePub.Pub.Date == t.Pub.Date)
                            {
                                track = t;
                                break;
                            }
                        }
                    }
                    //  var track = list.Find(t => album.Equals(t) && filePub.Pub.Date.Equals(t.Pub.Date));
                    if (track == null)
                    {
                       
                        log.log("création Track à partir de " + file.FullName);
                        track = loader.createTrack(file.FullName) as TrackInfoItunes;

                        if (track == null)
                            continue;

                        // verif pub; 
                        TrackInfoItunes track2Verif = null;

                        if (track.Pub > TrackInfoItunes.MIN)
                        {
                            foreach (TrackInfoItunes t in list)
                            {
                                if (album.Equals(t.Album))
                                {
                                    if (track.Pub.Date == t.Pub.Date)
                                    {
                                        track2Verif = t;
                                        break;
                                    }
                                }
                            }
                        }

                        if (track2Verif != null)
                        {
                            log.log("Track créé {0} {1} {2} {3} MAIS doublon avec  {4} {5} {7} {8} {9} intégrés {10} supprimés", track.Name, track.Album, track.Pub, track.Location, 
                                track2Verif.Name, track2Verif.Album, track2Verif.Pub, track2Verif.Location, nbIntegre, nbSuppr);
                            track2Verif.Delete();
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                            nbSuppr++;
                            continue; 

                        }
                        log.log("Track créé {0} {1} {2} {3} {4} intégrés {5} supprimés", track.Name, track.Album, track.Pub, track.Location,nbIntegre,nbSuppr );
                        nbIntegre++;
                        list.Add(track);
                    }
                    else
                    {
                        if (track.Pub.DayOfYear > 1)
                        {
                            nbSuppr++;
                            log.log("suppression du track sur {0} en doublon avec {1} {2} {3} {4} {5} int�gr�s {6} supprim�s", file.FullName, track.Name, track.Album, track.Pub, track.Location, nbIntegre, nbSuppr);
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                        }
                    }

                }
                log.log("fin scan {0}: {1} intégrés, {2} supprimmés", album, nbIntegre, nbSuppr);
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                scanFiles(list, subDir, ref nbIntegre, ref nbSuppr);
            }
        }
#endif

#if menage

        private void listFiles(Dict<string, FileInfo> dict, DirectoryInfo dir)
        {
           
            foreach (FileInfo file in dir.GetFiles())
            {
                dict[file.FullName] = file;
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                listFiles(dict, subDir);
            }
        }
#endif

        /// <summary>
        /// A checkquer
        /// </summary>
        /// <param name="feeds"></param>
        /// <param name="current"></param>
        private void scanFeedsForRecordEmptyLists(Feeds feeds, PlayListComposite current)
        {
            foreach (PlComponent pl in current)
            {
                var plC = pl as PlayListComposite;
                if (plC == null)
                {
                    // log.log("{0} {1} pas un PlayListComposite", pl, pl.GetType());
                    continue;
                }

                if (plC.LeafsCount > 0)
                {
                    string album = plC.Name;
                    feeds.check(album);
                }

                scanFeedsForRecordEmptyLists(feeds, plC);

            }
        }




        #region IAbortTask Members

        public bool Aborted
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        #endregion


        private class Vendee
        {
            //  "Emission du 02/11/2008"
            private static Regex regex1 = new Regex(@".*(\d\d\/\d\d\/\d\d\d\d).*");
            private static Regex regex2 = new Regex(@".*(\d\d\/\d\d\/\d\d).*");
            private static Regex regex3 = new Regex(@".*(\d\d\/\d\d).*");
            private enum vendeeType
            {
                none,
                vacation,
                hebdo,
                chronique,
                ponton

            }
            public void go(ArrayList list)
            {
                var listV = new ArrayList();
                string VENDEE = "vendee ";
                foreach (IITFileOrCDTrack t in list)
                {
                    if (t.Album.Contains("Vendée Globe") || t.Album.Contains(VENDEE))
                        listV.Add(t);
                }

                // listTrack.FindAll(t => t.Album.Contains("Vendee Globe"));



                foreach (IITFileOrCDTrack track in listV)
                {
                    string name = track.Name.ToLower();
                    vendeeType _type = vendeeType.none;
                    foreach (vendeeType type in Enum.GetValues(typeof(vendeeType)))
                    {
                        if (name.Contains(type.ToString()))
                        {
                            track.Album = VENDEE + type.ToString();
                            _type = type;
                            break;
                        }
                    }

                    DateTime? dt = null;
                    dt = getDate(track.Name);

                    if (!dt.HasValue)
                        dt = getDate(track.Description);

                    if (!dt.HasValue)
                        dt = getDate(track.LongDescription);

                    if (dt.HasValue)
                    {
                        string _comment = dt.Value.ToString("yyyy/MM/dd");
                        string plus = "";
                        switch (_type)
                        {
                            case vendeeType.none:
                                break;
                            case vendeeType.vacation:
                            case vendeeType.ponton: plus = " 11:00"; break;
                            case vendeeType.hebdo: plus = " 14:00"; break;
                            case vendeeType.chronique: plus = " 12:00"; break;

                        }
                        track.Comment = _comment + plus;
                        track.Year = dt.Value.Year;
                    }



                }
            }

            private DateTime? getDate(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return null;
                string[] words = input.Split(' '); int count = words.GetLength(0);

                DateTime? ret = null;
                StringBuilder sb = null;
                int word = 0;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                        word++;

                        try
                        {
                            ret = Convert.ToDateTime(sb.ToString());
                        }
                        catch
                        {
                        }

                        if (ret.HasValue)
                        {
                            int month = ret.Value.Month;
                            int year = 2008;
                            if (month < 6)
                                year = 2009;
                            return new DateTime(year, month, ret.Value.Day);
                        }
                    }
                }
                try
                {
                    DateTime dt = Convert.ToDateTime(sb.ToString());
                    if (dt.Year < 2008 || dt.Year > 2009)
                        dt = new DateTime(2008, dt.Month, dt.Day);
                    return dt;
                }
                catch
                {
                    return null;
                }
                //if (regex1.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //else if (regex2.IsMatch(_input))
                //    return Convert.ToDateTime(regex2.Match(_input).Groups[1].Value); 
                //else if (regex3.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //return null; 
            }

            private string getDateString(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return "";
                string[] words = input.Split(' '); int count = words.GetLength(0);


                StringBuilder sb = null;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                    }
                }

                if (sb == null)
                    return input;

                return sb.ToString().Replace(".", "");
            }


        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using iTunesLib;
using pdb.ordo;
using pdb.podcast.Build;
using pdb.util;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util.list;

namespace pdb.podcast
{
    public enum selectMode
    {
        none = 0,
        standAlone = 1,
        simple = 2,
        serial = 3,
        histo = 4
    }

    public class TrackInfoItunes : pdb.it.TrackInfoItunes, IPub
    {
        private int albumRating;
        private bool ratingComputed;

        private static volatile object _lock = new object();
        private static int volumeMin = int.MinValue;
        public static int VolumeMin { set { volumeMin = value; } }
        protected static string defaultFolder;
        public static string DefaultFolder
        {
            set
            {
                if (defaultFolder == null)
                {
                    defaultFolder = value;
                    if (!defaultFolder.EndsWith("\\"))
                        defaultFolder += ("\\");
                }
            }
            get { return defaultFolder; }
        }

        private int _dbId;

        public int DbId { get { return _dbId; } set { if (_dbId <=0) _dbId = value; } }

        private static BackGroundTaskMgr bgMove;  //new BackGroundTaskMgr("Move"); 

        private SequentialDictString<LimitItem> listSelected = new SequentialDictString<LimitItem>();
        //public List<LimitItem> Providers { get { return listSelected; } }

        private SequentialDictString<LimitItem> listLoad0 = new SequentialDictString<LimitItem>();
        private SequentialDictString<LimitItem> listStandAlone = new SequentialDictString<LimitItem>();
        // public List<LimitItem> Providers0 { get { return listLoad0; } }

        //private List<LimitItem> listLoadRecursif = new List<LimitItem>();
        //public List<LimitItem> ProvidersRecursif { get { return listLoadRecursif; } }

        //private List<LimitItem> listLoadGuest = new List<LimitItem>();
        //public List<LimitItem> ProvidersGuest { get { return listLoadGuest; } }



        /// <summary>
        /// Seule limite contenant le track
        /// </summary>
        private LimitItem exclu;
        public LimitItem Exclu { get { return exclu; } set { exclu = value; } }

        public void addPhase1(LimitItem item)
        {
            var key = item.ID;
            if (!listLoad0.ContainsKey(key))
                listLoad0.Add(key, item);
        }
        public bool containsload(LimitItem item)
        {
            var key = item.ID;
            return listLoad0.ContainsKey(key);
        }

        //public bool containsStandAlone(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listStandAlone.ContainsKey(key);
        //}

        public bool containsSelect(LimitItem item)
        {
            var key = item.ID;
            return listSelected.ContainsKey(key);
        }
        public bool isPreselected { get { return listLoad0.Count > 0; } }
        public ICollection<LimitItem> Providers1 { get { return listStandAlone.Values; } }
        public ICollection<LimitItem> Providers { get { return listSelected.Values; } }
        public LimitItem Provider
        {
            get
            {
                if (listSelected.Count == 0)
                    return null;
                return listSelected.List[0];
            }
        }
        public string GetProvider()
        {
            var provider = Provider;
            if (provider == null)
                return "";
            return provider.ToString();
        }

        public void addRecursif(LimitItem item)
        {
            //if (!listLoadRecursif.Contains(item))
            //    listLoadRecursif.Add(item);
        }

        public void addGuest(LimitItem item)
        {
            //if (!listLoadGuest.Contains(item))
            //    listLoadGuest.Add(item);
        }

        public static TrackInfoItunes createCopy(TrackInfoItunes org)
        {
            var copy = org.MemberwiseClone() as TrackInfoItunes;
            copy.clearLists();
            return copy;
        }

        const string REFONTE = "v1";
        public override void build(IITFileOrCDTrack track)
        {
            base.build(track);

            if (Strange)
                return;

            this.albumRating = track.AlbumRating;
            this.ratingComputed = track.ratingKind == ITRatingKind.ITRatingKindComputed;

#if MOVE
            var loc = track.Location;
            FileInfo file = new FileInfo(loc);
            if (loc.StartsWith("Y:"))
                return;
            string dest = "Y" + loc.Substring(1);


            try
            {
                misc.log("deplacer " + loc);
                string newDest = file.moveTree(dest, false);
                misc.log("-------> " + newDest);
                track.Location = newDest;
                //try
                //{
                //    File.Delete(loc);
                //}

                //catch (Exception del)
                //{

                //    misc.log(del.ToString());
                //}

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
#else

            if (!isPodcast)
                return;

            duree = new util.timeSpan(Duration);

            if (track.PlayedCount > 0)
            {
                played = markAsPlayed(Rating, PlayedDate);
            }

            var loc = track.Location;
            //if (loc.ToUpper().Contains("FABRIQUE"))
            //{
            //    int toto = 0; 
            //}
            bool target = true;
            var cuDtFileFormat = new DateTimeFormatInfo();
            cuDtFileFormat.FullDateTimePattern = "yyyy.MM.dd_HH.mm";
            string[] tab = loc.Split('_');
            var count = tab.GetLength(0);
            if (count >= 2)
            {
                var part = tab[0] + "_" + tab[1];
                DateTime dtFile;
                bool fileIsDate = DateTime.TryParse(part, cuDtFileFormat, DateTimeStyles.None, out dtFile);
                target = !fileIsDate;
            }


            //bool target = loc.ToUpper().Contains(@"D:\ZIQUE\PODCASTS\LA FABRIQUE DE L") && loc.ToUpper().Contains("HISTOIRE");

            try
            {

                pub = track.ReleaseDate;

                var cuDtFormat = new DateTimeFormatInfo();
                cuDtFormat.FullDateTimePattern = "yyyy/MM/dd";

                var cuDtFormat2 = new DateTimeFormatInfo();
                cuDtFormat2.FullDateTimePattern = "yyyy/MM/dd HH:mm";

                if (pub > MIN)
                {
                    string commentByReleaseDate = pub.ToString(cuDtFormat2.FullDateTimePattern);
                    if (Comment != commentByReleaseDate)
                    {
                        misc.log("chgt Comment � partir de releaseDate {0} de {1} vers {2} {3}", pub, Comment, commentByReleaseDate, this);
                        Comment = commentByReleaseDate;
                    }

                    return;
                }

                // ici pas de release Date

                string comment = track.Comment;

                try
                {
                    string partDate = comment.Split(' ')[0];
                    DateTime dtComment = DateTime.MinValue;

                    bool dtCommentBuild = false;

                    dtCommentBuild = DateTime.TryParse(partDate, cuDtFormat, DateTimeStyles.None, out dtComment);

                    bool dtCommentBuild2 = false;
                    if (dtCommentBuild)
                        dtCommentBuild2 = DateTime.TryParse(comment, cuDtFormat2, DateTimeStyles.None, out dtComment);


                    //if (dtComment.DayOfYear > 1)
                    //    return;

                    Regex reg = new Regex(@"(\d{2}.\d{2}.\d{4})");
                    string description = track.Description;

                    if (string.IsNullOrEmpty(description))
                        description = "";

                    DateTime dtDesc = DateTime.MinValue;
                    if (reg.IsMatch(description))
                    {
                        string strDescriptionDate = reg.Match(description).Groups[1].Value;

                        dtDesc = Convert.ToDateTime(strDescriptionDate);
                    }

                    if (dtDesc > DateTime.MinValue)
                    {
                        string newComment = dtDesc.ToString(cuDtFormat2.FullDateTimePattern);
                        if (newComment != track.Comment)
                        {
                            if (dtCommentBuild2 && dtComment.Minute != 0)
                                return;
                            misc.log("chgt Comment � partir de description {0} de {1} vers {2} {3}", description, comment, newComment, this);
                            track.Comment = newComment;
                        }
                    }
                    else if (dtCommentBuild2)
                    {

                    }






                }
                catch (Exception ex)
                {
                    misc.logError("impossible de g�rer " + this, ex);
                }
            }
            finally
            {

                if (target)
                {

                    FileInfo file = new FileInfo(loc);
                    DirectoryInfo dirTrack = file.Directory;
                    DirectoryInfo dirPodcast = dirTrack.Parent;
                    if (!dirPodcast.Name.Equals(REFONTE))
                    {
                        DirectoryInfo dirV1 = new DirectoryInfo(dirPodcast.FullName + Path.DirectorySeparatorChar + REFONTE);
                        if (!dirV1.Exists)
                            dirV1.Create();

                        string dest = dirV1.FullName + Path.DirectorySeparatorChar + dirTrack.Name + Path.DirectorySeparatorChar + file.Name;  // loc.Replace(@"D:\", @"E:\");

                        string dirDest = Path.GetDirectoryName(dest);
                        string fileName = Path.GetFileName(dest);
                        fileName = pub.ToString("yyyy.MM.dd_HH.mm") + "_" + fileName;

                        dest = dirDest + Path.DirectorySeparatorChar + fileName;
                        try
                        {
                            misc.log("deplacer " + loc);
                            string newDest = file.copyTree(dest, null);
                            misc.log("-------> " + newDest);
                            track.Location = newDest;
                            try
                            {
                                File.Delete(loc);
                            }

                            catch (Exception del)
                            {

                                misc.log(del.ToString());
                            }

                        }
                        catch (Exception ex)
                        {
                            misc.log(ex.ToString());
                        }
                    }
                }

            }
#endif

        }


        private static IDictionary<int, DateTime> maxPlayed = new Dictionary<int, DateTime>();
        public static IDictionary<int, DateTime> MaxPlayed { set { maxPlayed = value; } }
        public static bool markAsPlayed(int rating, DateTime date)
        {
            if (maxPlayed.ContainsKey(rating))
                return date > maxPlayed[rating];
            return true;
        }
        public override void build(XmlNode xTrack)
        {
            base.build(xTrack);
            //if (Name.Contains("Aubenas"))
            //{
            //    int toto = 0;
            //}
            if (!isPodcast)
                return;
            if (Strange)
                return;
            string key = "";

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Rating Computed")
                        ratingComputed = true;
                    continue;
                }

                if (string.IsNullOrEmpty(value))
                    continue;
                switch (key)
                {
                    case "Date Added": added = Convert.ToDateTime(value); break;
                    case "Release Date": pub = Convert.ToDateTime(value); break;
                    case "Play Count": int playCount = Convert.ToInt32(value);
                        if (playCount > 0)
                            played = markAsPlayed(Rating, PlayedDate);
                        break;
                    case "Album Rating": albumRating = Convert.ToInt32(value); break;
                }

            }

            //for (int i = 0; i < xTrack.ChildNodes.Count; i += 2)
            //{
            //    XmlNode xKey = xTrack.ChildNodes[i];
            //    string value = xTrack.ChildNodes[i + 1].InnerText;
            //    string key = xKey.InnerText;

            //    if (string.IsNullOrEmpty(value))
            //        continue;
            //    switch (xKey.InnerText)
            //    {
            //        case "Date Added": added = Convert.ToDateTime(value); break;
            //        case "Release Date": pub = Convert.ToDateTime(value); break;
            //        case "Play Count": int playCount = Convert.ToInt32(value); if (playCount > 0) played = true; break;
            //        case "Album Rating": albumRating = Convert.ToInt32(value); break;


            //    }
            //}


            new PubLoader(this).setPub();

            #region move vers pubLoader
            //
            //string _comment = Comment;
            //DateTime dateComment = DateTime.MinValue;

            //try
            //{
            //    dateComment = Convert.ToDateTime(_comment);
            //}
            //catch
            //{
            //}

            //if ((pub < MIN || pub.DayOfYear == 1)  && (dateComment > MIN && dateComment.DayOfYear > 1))
            //{
            //    pub = dateComment; 
            //}
            //string name = Name;
            //checkDate1(name);
            //checkDate2(name);
            //checkDate3(name);

            //bool pubYear = false;

            //if (!string.IsNullOrEmpty(Location))
            //{
            //    string fileName = Path.GetFileName(Location);
            //    checkDate1(fileName);
            //    checkDate2(fileName);
            //    checkDate3(fileName);
            //}

            //if (pub <= MIN)
            //{
            //    if (Year > 1970)
            //    {
            //        DateTime dtYear = new DateTime(Year, 1, 1);
            //        pub = dtYear;
            //        pubYear = true;
            //    }
            //}



            //if (added < MIN) added = MIN;

            //// DateTime dt_ = pub;
            //if (pub <= MIN)
            //    pub = added;
            //string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
            //if (pubYear)
            //    comment = getFileNameCmp(comment);
            //if (this.Comment != comment)
            //{
            //    try
            //    {
            //        string commentFound = this.Comment;
            //        string truc = commentFound;
            //        if (truc.Contains("_")) 
            //        {
            //            //d�j� fait
            //            return; 
            //        }
            //          //  truc = truc.Split('_')[0];

            //        DateTime iComment = Convert.ToDateTime(truc);
            //        if (iComment.DayOfYear != 1 && pub.DayOfYear == 1)
            //        {
            //            pub = iComment;
            //        }
            //        else
            //        {

            //            this.Comment = comment;
            //        }
            //    }
            //    catch
            //    {
            //        this.Comment = comment;
            //    }
            //}


            //

            #endregion




            duree = new util.timeSpan(Duration);
        }



        public static DateTime MIN = new DateTime(1970, 1, 1);
        #region move verspubLoader

        //
        //private static Regex regex1 = new Regex(@".*(\d\d\.\d\d\.\d\d\d\d).*");
        //private static Regex regex2 = new Regex(@".*(\d\d\d\d)(\d\d)(\d\d).*");
        //private static Regex regex3 = new Regex(@".*(\d\d)\.(\d\d)\.(\d\d)_(\d\d)\.(\d\d)_.*");

        //private string getFileNameCmp(string comment)
        //{
        //    string fileName = Path.GetFileNameWithoutExtension(location);

        //    if (fileName.Contains(" "))
        //    {
        //        var tab = fileName.Split(' ');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Contains("_"))
        //    {
        //        var tab = fileName.Split('_');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Length > 3)
        //        return comment;

        //    int nb = 0;
        //    bool isNum = Int32.TryParse(fileName, out nb);

        //    if (!isNum)
        //        return comment;

        //    while (fileName.Length < 3)
        //    {
        //        fileName = "0" + fileName;
        //    }
        //    return comment + "_" + fileName;
        //}
        //private void checkDate1(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex1.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex1.Match(info);
        //            string strDate = m.Groups[1].Value;
        //            DateTime dt = Convert.ToDateTime(strDate);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate2(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex2.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            DateTime dt = new DateTime(year, month, day);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate3(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex3.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            int hh = Convert.ToInt16(m.Groups[4].Value);
        //            int mm = Convert.ToInt16(m.Groups[5].Value);

        //            DateTime dt = new DateTime(year, month, day, hh, mm, 0);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        #endregion

        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{
        //    this.track = track;
        //    this.artist = track.Artist;
        //    this.album = track.Album;
        //    this.name = track.Name;
        //    this.trackNumber = track.TrackNumber;
        //    this.rating = track.Rating;
        //    this.year = track.Year;
        //    this.comment = track.Comment;
        //    this.enabled = track.Enabled;
        //    this._isPodCast = track.Podcast;
        //    this.playedDate = track.PlayedDate;
        //    this.location = track.Location;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.played = track.PlayedCount > 0;
        //    this.pub = track.ReleaseDate;

        //    checkDate1(name);
        //    checkDate2(name);

        //    if (!string.IsNullOrEmpty(location))
        //    {
        //        string fileName = Path.GetFileName(location);
        //        checkDate1(fileName);
        //        checkDate2(fileName);
        //    }

        //    if (pub <= MIN)
        //    {
        //        if (year > 1970)
        //        {
        //            DateTime dtYear = new DateTime(year, 1, 1);
        //            pub = dtYear;
        //        }
        //    }


        //    this.added = track.DateAdded;
        //    if (added < MIN) added = MIN;

        //    // DateTime dt_ = pub;
        //    if (pub <= MIN)
        //        pub = added;
        //    string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
        //    if (track.Comment != comment)
        //        track.Comment = comment;

        //}




        //public int TrackId { get { return track.trackID; } }
        //public int ID { get { return track.TrackDatabaseID; } }

        //public IITFileOrCDTrack Track { get { return track; } }


        #region ITrackNative Membres




        /// <summary>
        /// Date de publication
        /// </summary>
        private DateTime pub;
        public DateTime Pub { get { return pub; } }

        /// <summary>
        /// date d'ajout
        /// </summary>
        private DateTime added;
        public DateTime Added { get { return added; } }

        /// <summary>
        /// Podcast de type info
        /// </summary>
        private bool info;

        public bool Info
        {
            get { return info; }
            set { if (value) info = true; }
        }

        /// <summary>
        /// Podcast rare (moins de trois fois par semaine)
        /// </summary>
        private bool rare;
        public bool Rare
        {
            get { return rare; }
            set { if (value) rare = true; }
        }

        private bool played;
        public bool Played { get { return played; } }

        //private string feed;
        //public string Feed { get { return feed; } set { feed = value; } }

        private selectMode selected;
        private bool inJournal = false;

        public bool FreeInJournal { get { return Selected && !inJournal; } }
        public void markInJournal() { inJournal = true; }
        //    public bool StandAlone { get { return selected > selectMode.none; } }
        public bool Selected { get { return selected >= selectMode.simple; } }
        public bool Histo { get { return selected == selectMode.histo; } }
        public bool Serial { get { return selected == selectMode.serial; } }
        // public selectMode Select { get { return selected; } }


        private void clearLists()
        {
            selected = selectMode.none;
            exclu = null;
            inJournal = false;
            listSelected = new SequentialDictString<LimitItem>();
            listLoad0 = new SequentialDictString<LimitItem>();
            listStandAlone = new SequentialDictString<LimitItem>();
            //listLoadGuest.Clear();
            //listLoadRecursif.Clear();

        }

        private static Regex regInfoShort = new Regex(@".+(\d\d\.\d\d\.\d\d)");
        public void select(selectMode value, LimitItem limit)
        {

            var key = limit.ID;

            if (value == selectMode.standAlone)
            {
                if (!listStandAlone.ContainsKey(key))
                    listStandAlone.Add(key, limit);
            }
            else
            {
                if (!listSelected.ContainsKey(key))
                    listSelected.Add(key, limit);
            }


            if (selected == value)
                return;

            if (value > selectMode.standAlone)
            {

                selected = value;
                int volume = Volume;
                if (Album.Contains("RFI"))
                {
                    if (volume != -20)
                        Volume = -20;
                }
                else
                {
                    if (volume < volumeMin)
                        Volume = volumeMin;
                }


                if (pub > MIN)
                {


                    string infoShort = pub.ToString("dd.MM.yy");
                    string infoPubName = pub.ToString("dd.MM.yyyy");
                    string infoPubName2 = pub.ToString("dd/MM/yyyy");
                    string infoPubName3 = pub.ToString("dd/MM/yy");
                    string infoYear = Year.ToString();
                    if (pub.DayOfYear == 1)
                    {
                        infoPubName = pub.Year.ToString();
                        infoPubName2 = infoPubName;
                        infoPubName3 = infoPubName;
                        infoShort = infoPubName;
                    }

                    string name = Name;
                    string str = name;

                    if (regInfoShort.IsMatch(str))
                    {
                        var strdate = regInfoShort.Match(str).Groups[1].Value;
                        str = str.Replace(strdate, "");
                    }






                    if (str.Contains(infoPubName))
                        str = str.Replace(infoPubName, infoShort);
                    else if (name.Contains(infoPubName2))
                        str = str.Replace(infoPubName2, infoShort);

                    else
                    {
                        if (!str.Contains(infoShort))
                        {
                            str = str + " " + infoShort;
                        }
                        else
                        {
                            if (Year > 1980 && str.Contains(infoYear))
                                str = str.Replace(infoYear, "").Trim();
                        }
                    }
                    var strBUG = "30.12.99";
                    if (str.Contains(strBUG))
                        str = str.Replace(strBUG, "");

                    str = str.Replace("  ", " ");
                    str = str.Replace("  ", " ");
                    str = str.Replace("  ", " ").Trim();

                    if (!str.Equals(name))
                        Name = str;
                }

            }

        }


        #endregion

        public override string ToString()
        {
            int level = Rating / 20;
            string strPub = pub > MIN ? pub.ToShortDateString() : "";
            string strYear = Year > 0 ? Year.ToString() : "";
            return level.ToString() + " " + Album + " " + Name + " " + strYear + " " + strPub;
        }

        public void copy(string ziqueDest, string log)
        {
            if (string.IsNullOrEmpty(location))
                return;

            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                string strPub1 = pub.ToString("dd.MM.yyyy");
                string strPub2 = pub.ToString("yy.MM.dd");

                string fileName = Path.GetFileName(location);

                if (pub > MIN && !fileName.StartsWith(strPub1) && !fileName.StartsWith(strPub2))
                    fileName = strPub2 + "_" + fileName;

                string strDir = dir.Name;
                if (!string.IsNullOrEmpty(Album))
                    strDir = Album;



                string dest = ziqueDest + Path.DirectorySeparatorChar + strDir + Path.DirectorySeparatorChar + fileName;
                misc.log(" {0} {1} à copier vers {2}", log, location, dest);
                try
                {
                    string newDest = file.copyTree(dest, false);

                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

        }

        public void move(string ziqueOrg, string ziqueDest, DateTime limit)
        {
            if (pub >= limit)
                return;

            if (string.IsNullOrEmpty(location))
                return;
            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                if (location.StartsWith(ziqueOrg + @"Podcasts"))
                {
                    misc.log(" � d�placer" + location);
                    string dest = location.Replace(ziqueOrg, ziqueDest);

                    string dirDest = Path.GetDirectoryName(dest);
                    string fileName = Path.GetFileName(dest);
                    fileName = pub.ToString("yy.MM.dd_HH.mm") + "_" + fileName;

                    dest = dirDest + Path.DirectorySeparatorChar + fileName;
                    try
                    {
                        string newDest = file.copyTree(dest, false);
                        if (bgMove == null)
                        {
                            lock (_lock)
                            {
                                if (bgMove == null)
                                    bgMove = BackGroundTaskMgr.getMgrlarge("Move");
                            }
                        }
                        //  file.CopyTo(dest, true);
                        bgMove.add(new BgTaskCopy(this, location, newDest));
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }
                }
            }


        }

        private class BgTaskCopy : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskCopy(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Location = value;

                    misc.log("copie effectu�e " + value);
                    try
                    {
                        File.Delete(Desc);
                    }
                    catch (Exception ex)
                    {
                        misc.log("impossible de supprimer " + Desc + " " + ex.ToString());
                    }
                    success = true;
                }
                catch (Exception e)
                { misc.log("NIET " + e.Message); }

                if (!success && info.Track != null)
                {
                    //misc.log("invalidation track " + info);
                    ////  info.track = null;
                }

            }
        }



        DateTime IPub.Pub
        {
            get
            {
                return pub;
            }
            set
            {
                pub = value;
            }
        }

        string IPub.Comment
        {
            get
            {
                return Comment;
            }
            set
            {
                setGrouping(this.Comment, true);
                Comment = value;
            }
        }

        string IPub.Name
        {
            get { return Name; }
        }

        string IPub.Location
        {
            get { return location; }
        }

        int IPub.Year
        {
            get { return Year; }
        }

        DateTime IPub.Added
        {
            get
            {
                return added;
            }
            set
            {
                added = value;
            }
        }
        private pdb.util.timeSpan duree;
        public pdb.util.timeSpan Duree { get { return duree; } }


    }
}



]]></content>
  </file>
  <file path="\pdb.podcast\DB\Db.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.Xml;
using pdb.util.Generic.Parse;

namespace pdb.podcast.DB
{
    class Db
    {
        public const int CURRENT_VERSION = 1;
        const string SEQ_PIECE = "seq";
        private static int pieceSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private BgDictString<TrackInfoItunes> dict = new BgDictString<TrackInfoItunes>();
        private XmlSerializer xmlSerializer;

        public Db()
        {
            xmlSerializer = new XmlSerializer()
            {
                FillLists = false,
                ManageListsWithArbo= false,
                IncludeDeclaration = true,
                ClearEmpy = true,             
                DateFormat = "dd/MM/yyyy HH:mm:ss",  
            };

          
        }


        public void write(string file)
        {
            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;
            using (XmlWriter writer = XmlWriter.Create(file + ".tmp", settings))
            {
                writer.WriteStartElement("db");
                writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                foreach (TrackInfoItunes track in dict.Values)
                {
                    
                }
                writer.WriteEndDocument();
                writer.Flush();
            }

            File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
        }

        private void write(TrackInfoItunes track)
        {
            xmlSerializer.Serialize(
        }
      
    }
}
]]></content>
  </file>
  <file path="\pdb.util\ILogger.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.util
{
    public interface ILogger
    {
        void log(string txt);
        void logNoDate(string txt); 
        void log(string txt, params object[] other);
        void logNoDate(String txt, params object[] other);
        void Error(string txt);
        void Error(string txt, params object[] other);
        string Pre { set; }
    }
    public delegate ILogger getDefaultLogger(); 
    

    public class DefaultLogger : ILogger
    {
        private string pre = "";
        public string Pre { set { pre = value; } }

        #region ILogger Membres

        public void log(string txt, params object[] other)
        {
            Console.WriteLine(DateTime.Now + " " + txt, other); 
        }

        public void logNoDate(string txt, params object[] other)
        {
            Console.WriteLine(pre + txt, other); 
        }

           public void log(string txt)
        {
           Console.WriteLine(DateTime.Now + " " + pre +  txt); 
        }

        public void logNoDate(string txt)
        {
             Console.WriteLine(pre + txt); 
        }

        #endregion


        public void Error(string txt)
        {
            log("Error " +txt); 
        }

        public void Error(string txt, params object[] other)
        {
           log("Error " +txt, other); 
        }
    }

      public class NullLogger : ILogger
    {

        public void log(string txt)
        {
           
        }

        public void logNoDate(string txt)
        {
           
        }

        public void log(string txt, params object[] other)
        {
           
        }

        public void logNoDate(string txt, params object[] other)
        {
           
        }

        public string Pre
        {
            set { }
        }


        public void Error(string txt)
        {
          
        }

        public void Error(string txt, params object[] other)
        {
           
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Logger.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;

namespace pdb.util
{
    /// <summary>
    /// Logger
    /// </summary>
    public class Logger : ILogger
    {

        /// <summary>
        /// Thread de dépilage
        /// </summary>
        private static Thread th;
        /// <summary>
        /// Thread de cloture des flux
        /// </summary>
        private static Thread thDispose;
        /// <summary>
        /// Queue de logs à écrire
        /// </summary>
        private static Queue<KeyString> queue = new Queue<KeyString>();

        private static Queue<Logger> queueDispose = new Queue<Logger>();
        /// <summary>
        /// flux du log
        /// </summary>
        private StreamWriter sw;
        /// <summary>
        /// Chemin relatif du log
        /// </summary>
        private string logPath;
        /// <summary>
        /// Objet de synchro
        /// </summary>
        private static volatile object _lock = new object();
        /// <summary>
        /// Registre des logs
        /// </summary>
        private static Dict<string, Logger> loggers = new Dict<string, Logger>();
        /// <summary>
        /// Log par défaut
        /// </summary>
        private static Logger defaultLogger; //= new Logger("log");
        /// <summary>
        /// Log universel pour répercution sur tous les logs des principaux évènements
        /// </summary>
        private static Logger all = new Logger("all");

        private static LoggerConsole console = new LoggerConsole();

        private bool logConsole = true;

        private bool noReset;
        public static bool  LogConsole = true; 
       // public bool LogConsole { get { return logConsole; } set { logConsole = value; } }
        public bool NoReset { get { return noReset; } set { noReset = value; } }

        /// <summary>
        /// Logger aboné en sus
        /// </summary>
        private Logger parent;

        private static bool createNullLoggers;
        private readonly bool isNull;
        public static bool CreateNullLoggers { get { return createNullLoggers; } set { createNullLoggers = value; } }


        /// <summary>
        /// Constructeur statique fait le ménage dans les logs
        /// </summary>
        public static void init(string name)
        {
            Locker.waitForSingleProcess(name);
            try
            {
                DirectoryInfo dir = new DirectoryInfo(@"..\Logs");
                new Thread(() =>
                {
                    misc.DeleteDir(dir);
                    Thread.Sleep(1000);
                    defaultLogger = getLogger("log", true);
                }).Start();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex);
            }
        }



        /// <summary>
        /// Création ou récupération d'un logger
        /// </summary>
        /// <param name="logPath"></param>
        /// <returns></returns>
        public static Logger getLogger(string logPath)
        {
            return getLogger(logPath, defaultLogger);
        }


        /// <summary>
        /// Création ou récupération d'un logger
        /// </summary>
        /// <param name="logPath"></param>
        /// <returns></returns>
        public static Logger getLogger(string logPath, bool logConsole)
        {
            var log = getLogger(logPath, defaultLogger);
            log.logConsole = logConsole;
            return log;
        }


        /// <summary>
        /// Création ou récupération d'un logger
        /// </summary>
        /// <param name="logPath"></param>
        /// <returns></returns>
        public static Logger getLogger(string logPath, Logger parent)
        {
            return getLogger(logPath, parent, null);
        }


        /// <summary>
        /// Création ou récupération d'un logger
        /// </summary>
        /// <param name="logPath"></param>
        /// <returns></returns>
        public static Logger getLogger(string logPath, Logger parent, bool? logConsole)
        {
            Logger log = loggers[logPath];
            if (log == null)
            {
                lock (_lock)
                {
                    if (loggers[logPath] == null)
                    {
                        log = new Logger(logPath);
                        if (logConsole.HasValue)
                            log.logConsole = logConsole.Value;
                        else if (parent != null)
                            log.logConsole = parent.logConsole;
                        log.parent = parent;
                        loggers[logPath] = log;
                    }
                }
            }
            return log;
        }

        private static ILogger _def = new DefaultLogger();
        public static ILogger getLogger()
        {
            if (defaultLogger == null)
                return _def;
            return defaultLogger;
        }

        /// <summary>
        /// Création du flux si besoin
        /// </summary>
        private void checkStream()
        {
            if (!_resetting && sw != null)
                return;
            lock (this)
            {
                if (!_resetting && sw != null)
                    return;
                if (_resetting)
                    return;
            }

            var _logPat = logPath;
            try
            {

                //foreach (char c in Path.GetInvalidPathChars())
                //    _logPat = _logPat.Replace(c, '_');
                //foreach (char c in Path.GetInvalidFileNameChars())
                //    _logPat = _logPat.Replace(c, '_');


                byte[] tempBytes;
                tempBytes = System.Text.Encoding.GetEncoding("ISO-8859-8").GetBytes(logPath);
                _logPat = System.Text.Encoding.UTF8.GetString(tempBytes);

                foreach (char c in Path.GetInvalidPathChars())
                    _logPat = _logPat.Replace(c, '_');

                //  _logPat = logPath.Normalize(System.Text.NormalizationForm.FormC).Normalize(System.Text.NormalizationForm.FormD);
                //FileInfo file = new FileInfo(@"..\Logs\" + _logPat + ".log");
                string fileBase = @"..\Logs\" + _logPat + ".log";

                String[] dirs = fileBase.Split(Path.DirectorySeparatorChar);

                for (int i = 0; i < dirs.GetLength(0); i++)
                {
                    string dir = dirs[i];
                    tempBytes = System.Text.Encoding.GetEncoding("ISO-8859-8").GetBytes(dir);
                    dir = System.Text.Encoding.UTF8.GetString(tempBytes);

                    foreach (char c in Path.GetInvalidFileNameChars())
                        dir = dir.Replace(c, '_');
                    dirs[i] = dir;
                }

                DirectoryInfo root = new DirectoryInfo(dirs[0] + Path.DirectorySeparatorChar);
                for (int i = 1; i < dirs.GetLength(0) - 1; i++)
                {
                    String strDir0 = dirs[i] + Path.DirectorySeparatorChar;
                    String StrDir = root.FullName + strDir0;
                    DirectoryInfo dir = new DirectoryInfo(StrDir);
                    if (!dir.Exists)
                        dir.Create();
                    root = dir;
                }
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < dirs.GetLength(0); i++)
                {
                    if (i > 0)
                        sb.Append(Path.DirectorySeparatorChar);
                    sb.Append(dirs[i]);
                }

                try
                {

                    sw = new StreamWriter(sb.ToString(), false);
                    sw.AutoFlush = true;
                    DisposableCounter.add(sw, logPath);
                }
                catch
                {
                    return;
                }
            }
            catch (Exception ex)
            {
                try
                {
                    Console.WriteLine("impossible de créer le flux " + logPath + "(" + _logPat + ") " + ex.ToString());
                    defaultLogger.log_("impossible de créer le flux " + logPath + "(" + _logPat + ") " + ex.ToString());
                }

                catch
                {
                }
            }

            return;

        }



        /// <summary>
        /// Constructeur privé. Initie la boucle de dépilage. bof
        /// </summary>
        /// <param name="logPath"></param>
        private Logger(string logPath)
        {
            this.logPath = logPath;
            if (createNullLoggers)
                isNull = true; 

            if (th == null)
            {
                lock (_lock)
                {
                    if (th == null)
                    {
                        th = new Thread(_loop);
                        th.Start();

                        thDispose = new Thread(_loopDispose);
                        thDispose.Start();
                    }
                }
            }




        }

        /// <summary>
        /// Ecrit la ligne
        /// </summary>
        /// <param name="txt"></param>
        private void log_(string txt)
        {
            if (isNull)
                return; 
            if (_end)
                return; 
            try
            {
                checkStream();
                if (sw == null || _resetting)
                {
                    relog(txt);
                    return;
                }
                lock (this)
                {
                    if (sw == null || _resetting)
                    {
                        relog(txt);
                        return;
                    }
                    sw.WriteLine(txt);
                    sw.Flush();
                }
            }
            catch (Exception ex)
            {
                console.log(ex.ToString());
                sw = null;
            }
        }

        private void relog(string txt)
        {
            if (isNull)
                return; 
            var ks = new KeyString(logPath, txt, false,false);
            lock (this)
                queue.EnQueue(ks);

        }

        /// <summary>
        /// Ecrit sur tous les loggers
        /// </summary>
        /// <param name="txt"></param>
        public static void LogAll(string txt)
        {
            all.log(txt);
        }

        private static void _loopDispose()
        {
            while (!_end)
            {
                try
                {
                    Thread.Sleep(30);
                    Logger log = queueDispose.Dequeue();
                    if (log != null)
                        Console.WriteLine("close " + log.logPath);
                    while (log != null)
                    {
                        if (_end)
                            return; 
                        try
                        {
                            var st = log.sw;
                            if (st != null)
                                st.Close();
                        }
                        catch (Exception ex1)
                        {
                            Console.WriteLine(ex1.ToString());
                            Thread.Sleep(1000);
                        }
                        lock (log)
                        {
                            log.sw = null;
                            log._resetting = false;
                        }
                        log = queueDispose.Dequeue();

                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.ToString());
                    Thread.Sleep(1000);
                }
            }
        }


        /// <summary>
        /// Boucle de dépilage
        /// </summary>
        private static void _loop()
        {
            while (!_end)
            {

                try
                {
                    Thread.Sleep(30);
                    // BOF
                    KeyString ks = null;
                    //lock (_lock)
                    //{
                    ks = queue.Dequeue();
                    //}

                    if (_end)
                        return; 
                    while (ks != null)
                    {
                        string defaultLog = ks.txt;  // ToString();

                    //    bool bLogConsole = ks.LogConsole; 

                        string key = ks.key;
                        // Cas log universel
                        if ("all".Equals(key))
                        {
                          //  bLogConsole = true;
                            List<Logger> list = null;
                            lock (_lock)
                            {
                                list = new List<Logger>(loggers.Values);
                            }
                            foreach (Logger _log in list)
                            {
                                if (_log.sw != null)
                                    _log.log_(ks.txt);

                            }
                        }
                        // cas standard : on indentifie le logger
                        else
                        {
                            Logger logger_ = loggers[key];
                            //if (logger_ != null)
                            //    bLogConsole = ks.LogConsole; // logger_.logConsole;
                            while (logger_ != null)
                            {
                                logger_.log_(ks.txt);
                                logger_ = logger_.parent;
                            }
                            //if (defaultLogger != logger)
                            //    defaultLogger.log_(defaultLog);
                        }

                        //lock (_lock)
                        //{

                        if (ks.LogConsole && ks.FirstTry)
                            console.log(defaultLog);
                        ks = queue.Dequeue();
                        //}
                    }
                }
                catch (Exception ex)
                {
                    console.log(ex.ToString());
                    Thread.Sleep(1000);
                }


            }
        }
        #region ILogger Membres

        private static string pre = "";
        public static string Pre { set { pre = value; } }

        private string getThreadName()
        {
            Thread th = Thread.CurrentThread;
            string name = th.Name;
            if (name == null)
                name = th.ManagedThreadId.ToString();
            return string.Format(" [{0}] ", name);
        }



        public void log(string txt)
        {
            if (isNull)
                return; 
            put(pre + DateTime.Now.ToLongTimeString() + getThreadName() + txt);
        }

        public void log(string txt, params object[] other)
        {
            if (isNull)
                return; 
            put(pre + DateTime.Now.ToLongTimeString() + getThreadName() + txt, other);
        }
        public void logNoDate(string txt, params object[] other)
        {
            if (isNull)
                return; 
            put(pre + getThreadName() + txt, other);
        }
        public void logNoDate(string txt)
        {
            if (isNull)
                return; 
            put(pre + getThreadName() + txt);
        }
        private void put(string txt, params object[] other)
        {
            if (isNull)
                return; 
            //string realTxt = txt; 
            // if (other.GetLength(0) == 0)
            //{ realTxt = txt; }
            //else
            //{   realTxt = String.Format(txt, other);}

            //log_(realTxt); 
            //Console.WriteLine(realTxt); 
            //return; 



            if (_end)
                return; 

            lock (this)
            {
                try
                {

                    if (other.GetLength(0) == 0)
                        queue.EnQueue(new KeyString(logPath, txt, true, logConsole && LogConsole));
                    else
                        queue.EnQueue(new KeyString(logPath, String.Format(txt, other), true, logConsole && LogConsole));
                }
                catch (Exception e)
                {
                    Console.WriteLine(e.ToString());
                    var sb = new StringBuilder();
                    sb.Append(txt); sb.Append(":");
                    foreach (object o in other)
                        sb.Append(o); sb.Append(",");
                    queue.EnQueue(new KeyString(logPath, sb.ToString(), true,logConsole && LogConsole));

                }
            }
        }

        #endregion



        string ILogger.Pre
        {
            set { pre = value; }
        }

        private void end()
        {
            lock (this)
            {
                Console.WriteLine("end " + logPath);
                if (sw == null)
                    return;
                sw.Flush();
                sw.Dispose();
                DisposableCounter.remove(sw);
                sw = null;
            }
        }

        private bool _resetting;
        public void reset()
        {
            if (!noReset)
            {
                lock (this)
                {
                    _resetting = true;
                    queueDispose.EnQueue(this);
                }
            }
        }

        public static void Reset()
        {
            lock (_lock)
            {
                Console.WriteLine("logger::Reset");
                foreach (Logger logger in new List<Logger>(loggers.Values))
                    logger.reset();
                Console.WriteLine("logger::Reset OK");
            }
        }

        private static bool _end; 
        public static void End()
        {
            _end = true; 
            lock (_lock)
            {
                queueDispose.Clear(); 
                Console.WriteLine("logger::End");
                foreach (Logger logger in new List<Logger>(loggers.Values))
                    logger.end();
                Console.WriteLine("logger::End OK");
            }

        }


        public void Error(string txt)
        {
            log("Error " + txt);
        }

        public void Error(string txt, params object[] other)
        {
            log("Error " + txt, other);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\pdb.util.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.util</RootNamespace>
    <AssemblyName>pdb.util</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Debug\pdb.util.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.util.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="AsyncFileWriter.cs" />
    <Compile Include="BgDict.cs" />
    <Compile Include="Chrono.cs" />
    <Compile Include="CustomFormat.cs" />
    <Compile Include="CUtil.cs" />
    <Compile Include="DateUtil.cs" />
    <Compile Include="DescBuilder.cs" />
    <Compile Include="Dict.cs" />
    <Compile Include="FileRegister.cs" />
    <Compile Include="Generic\Attributs\AttributeHelper.cs" />
    <Compile Include="Generic\Attributs\CustomAttribute.cs" />
    <Compile Include="Generic\Attributs\Db\DbAttributes.cs" />
    <Compile Include="Generic\Attributs\Db\SbAttributes.cs" />
    <Compile Include="Generic\Attributs\GlobalAttributes.cs" />
    <Compile Include="Generic\Attributs\Json\GlobalAttributes.cs" />
    <Compile Include="Generic\Attributs\NameAttributeBase.cs" />
    <Compile Include="Generic\Attributs\Sp\GlobalAttributes.cs" />
    <Compile Include="Generic\Attributs\Xml\XmlAttributes.cs" />
    <Compile Include="Generic\Encode\Getters.cs" />
    <Compile Include="Generic\Encode\JSON.cs" />
    <Compile Include="Generic\Encode\JsonEncoder.cs" />
    <Compile Include="Generic\Encode\JsonParser.cs" />
    <Compile Include="Generic\Encode\JsonSerializer.cs" />
    <Compile Include="Generic\Encode\JsonXmlEncoder.cs" />
    <Compile Include="Generic\Encode\SafeDictionary.cs" />
    <Compile Include="Generic\INode.cs" />
    <Compile Include="Generic\MappingException.cs" />
    <Compile Include="Generic\Parse\DbParser.cs" />
    <Compile Include="Generic\Parse\DbWrapper.cs" />
    <Compile Include="Generic\Parse\JsonParser.cs" />
    <Compile Include="Generic\Parse\Json\JsonBuilder.cs" />
    <Compile Include="Generic\Parse\Json\JsonParseException.cs" />
    <Compile Include="Generic\Parse\Json\JsonState.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateDeuxPoints.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateFinal.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateIni.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateName.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateValue.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateValueIni.cs" />
    <Compile Include="Generic\Parse\Json\JsonWrapper.cs" />
    <Compile Include="Generic\Parse\Node.cs" />
    <Compile Include="Generic\Parse\Parser.cs" />
    <Compile Include="Generic\Parse\ParserBase.cs" />
    <Compile Include="Generic\Parse\XmlParser.cs" />
    <Compile Include="Generic\Parse\XmlSerializer.cs" />
    <Compile Include="Generic\Parse\XmlWrapper.cs" />
    <Compile Include="Generic\TypeInfo.cs" />
    <Compile Include="Generic\Utils.cs" />
    <Compile Include="Generic\XmlParser.cs" />
    <Compile Include="Generic\XmlSerializer.cs" />
    <Compile Include="list\DictList.cs" />
    <Compile Include="DictLocation.cs" />
    <Compile Include="DisposableCounter.cs" />
    <Compile Include="FileUtil.cs" />
    <Compile Include="HashList.cs" />
    <Compile Include="ILogger.cs" />
    <Compile Include="list\LinkedList.cs" />
    <Compile Include="list\SequentialDict.cs" />
    <Compile Include="list\SequentialDictString.cs" />
    <Compile Include="Locker.cs" />
    <Compile Include="Logger.cs" />
    <Compile Include="LoggerConsole.cs" />
    <Compile Include="Medianne.cs" />
    <Compile Include="MemUtil.cs" />
    <Compile Include="misc.cs" />
    <Compile Include="OutputRecorder.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Queue.cs" />
    <Compile Include="serialize\Serializer.cs" />
    <Compile Include="serialize\TextSerializer.cs" />
    <Compile Include="StringUtil.cs" />
    <Compile Include="TextWriter.cs" />
    <Compile Include="ThreadUtil.cs" />
    <Compile Include="TimeSpan.cs" />
    <Compile Include="TuningBase.cs" />
    <Compile Include="XMLTool.cs" />
    <Compile Include="ZipUtil.cs" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\pdb.util\Generic\INode.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.util.Generic
{
    /// <summary>
    /// abstraction d'un Noeud Xml. Généralisation du parsing aux flux autres que Xml.
    /// représente un champ de base de donnée (Property d'un objet) aussi bien qu'un objet complexe (DataRow) ou un dataSet
    /// </summary>
    public interface INode
    {
        /// <summary>
        /// Ensemble des noeuds composant le noeud
        /// Pour un dataSet, l'ensemble des tables, pour une dataTable, l'ensemble des lignes, pour une dataRow, l'ensemble des colonnes.
        /// Pour un XmlElement, l'ensemble des XmlNode qui sont XmlElement
        /// </summary>
        ICollection<INode> ChildNodes { get; }
        /// <summary>
        /// Type de données reflétée par le noeud
        /// </summary>
        System.Type Type { get; set; }
        /// <summary>
        /// Après l'affectation du type, récupération du contenu
        /// </summary>
        object Content { get; }
        /// <summary>
        /// Quand on parse un flux de données (Xml, BDD...) on se sert du nom pour identifier l'objet sous-jacent
        /// </summary>
        string Name { get; }
        /// <summary>
        /// Représentation Xml du noeud pour info/debug
        /// </summary>
        string OuterXml { get; }
    }

    public interface IExtend
    {
        /// <summary>
        /// Ajout d'un noeud non référencé par l'objet dans la phase de parsing
        /// </summary>
        /// <param name="node"></param>
        void addExtend(INode node);
        /// <summary>
        /// Récupération pour écriture dans le flux de sortie
        /// </summary>
        ICollection<INode> getExtendedNodes();
    }

}
]]></content>
  </file>
  <file path="\pdb.util\Generic\MappingException.cs">
    <content><![CDATA[using System;
using System.Text;

namespace pdb.util.Generic
{
    public class MappingException :ApplicationException
    {
        public readonly Exception Inner; 
        public MappingException(string s) : base(s) { }
        public MappingException(Exception e) : this("",e) { }
       // public MappingException(string s, int code) : base(s) { Code = code; }
        public MappingException(string s, Exception e) : base(s, e) {
			//Exception _inner = base.GetBaseException();
			//if (_inner != e)
			//    Inner = _inner; 
        }
      //  public MappingException(string s, int code, Exception e) : base(s, e) { Code = code; }
      //  public MappingException(int code, Exception e) : base(e) { Code = code; }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(Message);
            sb.Append(" ");
            sb.Append(StackTrace);
            if (Inner != null)
            {
                sb.Append(" "); 
                sb.Append(Inner.ToString()); 
            }
            return sb.ToString(); 
        }

    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\TypeInfo.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Reflection;

namespace pdb.util.Generic
{
    /// <summary>
    /// Rassemble les infos importantes pour générer et récupérer les values
    /// Isprimary : String, date, int, double et les nullables associés
    /// IsList : Liste d'objets
    /// Crée le cas échéant la liste typée correspondante
    /// </summary>
    public class TypeInfo
    {
        /// <summary>
        /// indique si le type est fonctionnellement primaire ==> string, date, int...
        /// </summary>
        private bool _primary;
        /// <summary>
        /// indique si le type est une énumération
        /// </summary>
        private bool _enum;
        /// <summary>
        /// Dans le cas d'une liste, Type d'un élément de la liste
        /// </summary>
        private System.Type subType;
        /// <summary>
        /// Type 
        /// </summary>
        private System.Type type;
        /// <summary>
        /// Dans le cas d'une liste, Type de la liste générique
        /// </summary>
        private System.Type constructed;
        /// <summary>
        /// Liste instanciée
        /// </summary>
        private object listInstance;


        public TypeInfo(System.Type type)
        {
            this.type = type;
            if (type.IsEnum)
            {
                _primary = true;
                _enum = true;
            }

            else if (type.IsPrimitive) _primary = true;
            else if (type.Name.ToLower().StartsWith("nullable")) _primary = true;
            else if (type.Name.ToLower() == "string") _primary = true;
            else if (type.Name.ToLower() == "datetime") _primary = true;
            else if (type.BaseType.Name == "Enum") _primary = true;
            else if (type.IsGenericType)
            {
                subType = type.GetGenericArguments()[0];
                System.Type listType = type.GetGenericTypeDefinition();
                constructed = listType.MakeGenericType(new System.Type[] { subType });
            }
        }
        /// <summary>
        /// Isprimary : String, date, int, double et les nullables associés + Enum
        /// </summary>
        public bool IsPrimary { get { return _primary; } }
        /// <summary>
        /// Est une énumération
        /// </summary>
        public bool isEnum { get { return _enum; } }
        /// <summary>
        /// Liste d'objets
        /// </summary>
        public bool IsList { get { return subType != null; } }
        /// <summary>
        /// type contenu dans la liste générique
        /// </summary>
        public System.Type SubType { get { return subType; } }
        /// <summary>
        /// Type initial
        /// </summary>
        public System.Type Type { get { return type; } }

        public bool isString { get { return type == typeof(string); } }
        public bool isInt { get { return getUnderlyingType() == typeof(int); } }
        public bool isDate { get { return getUnderlyingType() == typeof(DateTime); } }
        public bool isDouble { get { return getUnderlyingType() == typeof(double); } }
        public bool isLong { get { return getUnderlyingType() == typeof(long); } }
        public bool isFloat { get { return getUnderlyingType() == typeof(long); } }

        public bool isNumber { get { return isInt || isDouble || isLong || isFloat; } }

        private System.Type getUnderlyingType()
        {
            return GetUnderlyingType(type);
        }

        public static System.Type GetUnderlyingType(System.Type type)
        {
            return (Nullable.GetUnderlyingType(type) ?? type);
        }



        /// <summary>
        /// Retourne en créant si besoin une liste générique vide pouvant contenir des objets de type subType
        /// </summary>
        /// <returns></returns>
        public object getListInstance()
        {
            if (listInstance == null)
                listInstance = Activator.CreateInstance(constructed);
            return listInstance;
        }

        /// <summary>
        /// Ajout d'un élément à la liste générique
        /// </summary>
        /// <param name="item"></param>
        public void Add(object item) { constructed.GetMethod("Add").Invoke(getListInstance(), new object[] { item }); }

        /// <summary>
        /// Ajout direct d'un élément de liste à l'objet propriétaire
        /// </summary>
        /// <param name="parent">Objet propriétaire : la liste</param>
        /// <param name="item">item à ajouter</param>
        public void Add(object parent, object item)
        {
            constructed.GetMethod("Add").Invoke(parent, new object[] { item });
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(type.Name);
            sb.Append(" ");
            if (_primary) sb.Append("primaire");
            else
            {
                if (subType == null)
                    sb.Append("non-primaire");
                else
                {
                    sb.Append("liste, subtype=");
                    sb.Append(subType.Name);
                }

            }
            return sb.ToString();
        }

        public IEnumerable<PropInfo> Props()
        {
            foreach (PropertyInfo p in this.Type.GetProperties())
                yield return new PropInfo(p);
        }





    }
    /// <summary>
    /// Contient les informations sur la Propriété
    /// </summary>
    public class PropInfo : TypeInfo
    {
        private PropertyInfo property;
        public PropInfo(PropertyInfo prop)
            : base(prop.PropertyType)
        {
            this.property = prop;
        }
        /// <summary>
        /// Propriété initiale
        /// </summary>
        public PropertyInfo Property { get { return property; } }
        public override string ToString()
        {
            return property.Name + " " + base.ToString();
        }

        public string Name { get { return property.Name; } }
        public void SetValue(object o, object value)
        {
            property.SetValue(o, value, null);
        }

        public object GetValue(object o)
        {
            return property.GetValue(o, null);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Utils.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;

namespace pdb.util.Generic
{
    public static class Utils
    {
        public static String FromString(this object o)
        {
            if (o == null) return string.Empty;
            if (o is DBNull) return string.Empty;
            return o.ToString();
        }

        public static int? FromInt(this object o)
        {
            if (o == null) return null;
            var str = o.ToString();
            if (string.IsNullOrEmpty(str))
                return null;
            return Convert.ToInt32(o);
        }

        public static object getPropValue(this object o, string propertyName)
        {
            if (o == null)
                return null;
            PropertyInfo p = null;
            foreach (PropertyInfo prop in o.GetType().GetProperties())
            {
                if (prop.Name.Equals(propertyName))
                {
                    p = prop;
                    break;
                }
            }

            if (p == null)
                return null;
            return p.GetValue(o, null);

        }

        public static void setPropValue(this object o, object value, string propertyName)
        {
            if (o == null)
                return;
            PropertyInfo p = null;
            foreach (PropertyInfo prop in o.GetType().GetProperties())
            {
                if (prop.Name.Equals(propertyName))
                {
                    p = prop;
                    break;
                }
            }

            if (p == null)
                return;
            p.SetValue(o, value, null);
        }

    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\XmlParser.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;

using System.Globalization;
using pdb.util.Generic.Parse;
using pdb.util.Generic.Attributs.Xml;
using pdb.util.Generic.Parse;

namespace pdb.util.Generic
{
    /// <summary>
    /// Helper permettant de construire des collections d'objets à partir d'une collection de noeuds Xml
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class XmlParserGen<T> where T : new()
    {
        private ILogger logger;
        XmlParser parser;

        public XmlParserGen(ILogger logger)
        {
            this.logger = logger;
            parser = new XmlParser(logger);
        }

        /// <summary>
        /// Renvoi d'une collection avec interruption en cas d'erreur
        /// </summary>
        /// <param name="xml"></param>
        /// <returns></returns>
        public List<T> getCollection(XmlNodeList xml)
        {
            return getCollection(xml, false);
        }

        /// <summary>
        /// Création d'un collection
        /// </summary>
        /// <param name="xml"></param>
        /// <param name="continueAfterError">si true, on continue (adapté aux traitements Batch)</param>
        /// <returns></returns>
        public List<T> getCollection(XmlNodeList xml, bool continueAfterError)
        {
            List<T> list = new List<T>();
            for (int i = 0; i < xml.Count; i++)
            {
                XmlNode subXml = xml[i];
                T item = new T();
                try
                {
                    parser.Fill(item, subXml);
                }
                catch (Exception e)
                {
                    logger.Error("impossible de parser le noeud n°{0} {1}", i, subXml.InnerXml, e);
                    if (continueAfterError)
                    {
                        continue;
                    }
                    throw;

                }
                list.Add(item);
            }
            return list;
        }

    }

    /// <summary>
    /// Parseur Xml pour constitution des objets à l'aide de leur représentation xml 
    /// </summary>
    public class XmlParser : Parser
    {
        public XmlParser() : base() { }
        public XmlParser(ILogger logger) : base(logger) { }

        /// <summary>
        /// Ajout des attributs par défaut
        /// </summary>
        public override void setDefaultAttributes()
        {
            base.setDefaultAttributes();
            addExclusion(typeof(XmlIgnore));
            addExclusion(typeof(XmlInputIgnore));

            addAttributeName(typeof(XmlNameAttribute));
            addAttributeName(typeof(XmlInputNameAttribute));

            XmlWrapper.DateFormatProvider = new CultureInfo("fr-FR");

        }

        /// <summary>
        /// Remplit l'objet value depuis le noeud xml correspondant
        /// </summary>
        /// <param name="o"></param>
        /// <param name="xml"></param>
        public void Fill(Object o, XmlNode xml)
        {
            Fill_(o, new XmlWrapper(xml, logger));
        }

        /// <summary>
        /// Helper réaliser le parsing d'un champ Date
        /// </summary>
        /// <param name="xml"></param>
        /// <returns></returns>
        public DateTime? toDateNullable(XmlNode xml)
        {
            var wrapper = new XmlWrapper(xml, null);
            return wrapper.toDateNullable();
        }

    }

}
]]></content>
  </file>
  <file path="\pdb.util\Generic\XmlSerializer.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Linq;
using pdb.util.Generic;
using System.Collections.Generic;
using pdb.util.Generic.Attributs.Xml;

namespace pdb.util.Generic
{
	/// <summary>
	/// Sérialise un objet au format Xml
	/// </summary>
	/// <
	public class XmlSerializer
	{
		/// <summary>
		/// gère les listes de sous éléments regroupés (true) ou à plat (false) dans le xml
		/// </summary>
		private bool manageListsWithArbo = true;
		/// <summary>
		/// affichage des types primaires
		/// </summary>
		private bool withType;

		private bool serializeList = true;  

		public bool ManageListsWithArbo { get { return manageListsWithArbo; } set { manageListsWithArbo = true; } }
		public bool WithInfoType { get { return withType; } set { withType = value; } }
		public bool SerializeList { set { serializeList = value; } }

		private List<Type> Exclusions = new List<Type>();
		/// <summary>
		/// Ajout d'un attribut permettant d'exclure des champs
		/// </summary>
		/// <param name="type"></param>
		public void addExclusion(Type type) { Exclusions.Add(type); }

		/// <summary>
		/// Par défaut on ne prend pas en compte l'attribut OutPutXmlIgnore
		/// </summary>
		public XmlSerializer()
		{
            addExclusion(typeof(XmlOutputIgnore));
		}


		/// <summary>
		/// Renvoie le document correspondant à l'objet
		/// </summary>
		/// <param name="value">objet à sérialiser</param>
		/// <param name="withType">affichage des types primaires</param>
		/// <returns>document Xml de l'objet</returns>
		/// 
		public XmlDocument Serialize(object value)
		{
			XmlDocument doc = new XmlDocument() { PreserveWhitespace= false };
			var root = doc.CreateElement(value.GetType().Name);
			doc.AppendChild(root);
			Serialize(doc, root, value);
			return doc;
		}

		/// <summary>
		/// Renvoi le contenu Xml de l'objet correctement formaté
		/// </summary>
		/// <param name="value">objet à sérialiser</param>
		/// <param name="withType">affichage des types primaires</param>
		/// <returns>contenu Xml</returns>
		/// <remarks>le Xml obtenu nativement est insatisfaisant car trop verbeux et peu lisible: 
		/// les balises vides sont rendues avec un saut de ligne</remarks>
		public string SaveXml(object value)
		{

			var doc = Serialize(value);
			return FormatXml(doc); 

		}

		public static string FormatXml(XmlDocument doc)
		{
			doc.PreserveWhitespace = false;
			MemoryStream ms = new MemoryStream();
			doc.Save(ms); ms.Position = 0;
			string content;

			using(StreamReader sr = new StreamReader(ms))
			{
				content = sr.ReadToEnd();
			}

			content = Regex.Replace(content, @"<([^\/]*)>\r\n\W*</(.*)>", delegate(Match m)
			{
				string un = m.Groups[1].Value;
				string deux = m.Groups[2].Value;
				return "<"+ un + "></" + deux + "/>";
			});
			content = Regex.Replace(content, @"<(.*)></.*>", "<$1 />");

			return content;
		}

		/// <summary>
		/// Sérialisation progressive d'un objet
		/// </summary>
		/// <param name="doc">document Xml de l'objet</param>
		/// <param name="parent">Noeud courant</param>
		/// <param name="withType">affichage des types primaires</param>
		/// <param name="value">objet à sérialiser</param>
		public void Serialize(XmlDocument doc, XmlElement parent, object value)
		{
			System.Type type = value.GetType();

			foreach(PropertyInfo prop in type.GetProperties())
			{
				// champs non pris en compte

				if(exclusion(prop))
					continue;

				object subvalue = prop.GetValue(value, null);
				PropInfo subInfo = new PropInfo(prop);

				if(subInfo.IsList && !serializeList)
					continue; 

				// Création du noeud correspondant à la property
				XmlElement subXml = doc.CreateElement(subInfo.Property.Name);
				parent.AppendChild(subXml);

				// si la property est primaire (string, double?, dateTime...), on écrit directement le noeud
				if(subInfo.IsPrimary)
				{
					//Affichage éventuel des infos de type
					if(withType)
					{
						XmlAttribute attType = doc.CreateAttribute("type");
						Type subType = subInfo.Type;
						string typeName = subType.Name;
						if(subType.BaseType == typeof(Enum))
							typeName = "Enum";
						if(subType.IsGenericType && subType.GetGenericTypeDefinition() == typeof(Nullable<>))
							typeName = Nullable.GetUnderlyingType(subType).Name;


						attType.Value = typeName;
						subXml.Attributes.Append(attType);
					}
					//Astuce pour obtenir les dates au format ISO 8601
					XElement xel = new XElement(subInfo.Property.Name, subvalue);
					subXml.InnerText = xel.Value;


				}
				//Si la property est une liste d'objets
				else if(subInfo.IsList)
				{
					if(serializeList)
					{
						IList list = subvalue as IList;
						foreach(object oListValue in list)
						{
							// appel récursif sur chaque élément de la liste
							var xmloListValue = doc.CreateElement(oListValue.GetType().Name);

							subXml.AppendChild(xmloListValue);

							Serialize(doc, xmloListValue, oListValue);
						}
					}

				}
				//property est un autre objet Value : appel récursif
				else
				{

					if(!subvalue.GetType().Namespace.StartsWith("System.Runtime.Serialization"))
					{
						Serialize(doc, subXml, subvalue);
					}
				}

			}
		}

		public bool exclusion(PropertyInfo prop)
		{
			bool exclusion = false;
			foreach(Type exclu in Exclusions)
			{
				if(prop.GetCustomAttributes(exclu, true).GetLength(0) == 1)
				{
					exclusion = true;
					break;
				}
			}
			return exclusion;
		}
	}
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Attributs\AttributeHelper.cs">
    <content><![CDATA[using System;
using System.Reflection;
using System.Collections;
using System.Collections.Generic; 

namespace pdb.util.Generic.Attributs
{
    /// <summary>
    /// Helper permettant d'exploiter les attributs
    /// </summary>
    public static class AttributeHelper
    {
        /// <summary>
        /// Le membre a t-il un attribut personnalisé
        /// </summary>
        /// <param name="meth">membre</param>
        /// <param name="attributeType">type attendu</param>
        /// <returns></returns>
        public static bool HasAttribute(this MemberInfo mem, System.Type attributeType)
        {
            if (mem == null)
                return false;
            object[] atts = mem.GetCustomAttributes(attributeType, true);
            return atts.GetLength(0) > 0;
        }

        /// <summary>
        /// Renvoie le nom éventuellement modifié par l'attribut du membre
        /// </summary>
        /// <param name="mem">Membre</param>
        /// <param name="attributeType">Type de l'attribut</param>
        /// <returns></returns>
        public static string CustomName(this MemberInfo mem, System.Type attributeType)
        {
            if (mem == null)
                throw new ArgumentException("le membre ne peut être null");
            string name = mem.Name;
            object[] atts = mem.GetCustomAttributes(attributeType, true);
            if (atts.GetLength(0) > 0)
            {
                if (attributeType.GetInterface(typeof(IAttributeName).Name) != null)
                {
                    name = (atts[0] as IAttributeName).Name;
                }
                else
                    throw new ArgumentException("l'attribut doit implémenter IAttributeName");
            }
            return name;

        }


        /// <summary>
        /// Renvoie le type modifié
        /// </summary>
        /// <param name="mem">Membre</param>
        /// <param name="attributeType">Type de l'attribut</param>
        /// <returns></returns>
        public static IAttributeType CustomType(this MemberInfo mem, System.Type attributeType)
        {
            if (mem == null)
                throw new ArgumentException("le membre ne peut être null");
           
            object[] atts = mem.GetCustomAttributes(attributeType, true);
            if (atts.GetLength(0) > 0)
            {
                if (attributeType.GetInterface(typeof(IAttributeType).Name) != null)
                {
                    return atts[0] as IAttributeType; 
                }
                else
                    throw new ArgumentException("l'attribut doit implémenter IAttributeName");
            }
            return null;

        }

        public static ICustomAttribute Custom(this MemberInfo mem, System.Type attributeType)
        {
            if (mem == null)
                throw new ArgumentException("le membre ne peut être null");
          
            object[] atts = mem.GetCustomAttributes(attributeType, true);
            if (atts.GetLength(0) > 0)
            {
                if (attributeType.GetInterface(typeof(ICustomAttribute).Name) != null)
                {
                    return atts[0] as ICustomAttribute; 
                }
                else
                    throw new ArgumentException("l'attribut doit implémenter ICustomAttribute");
            }
            return null; 
        }

    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Attributs\CustomAttribute.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.util.Generic.Attributs
{
    public interface ICustomAttribute 
    {
        string Name { get; }
        object Value { get; }
    }
    public class CustomAttribute : Attribute, ICustomAttribute
    { 
        public readonly string name;
        public readonly object _value;
        public CustomAttribute(string Name, object Value)
        {
            this.name = Name;
            this._value = Value; 
        }

        public string Name
        {
            get { return name;  }
        }

        public object Value
        {
            get { return _value;  }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Attributs\GlobalAttributes.cs">
    <content><![CDATA[using System;

///
// Ensemble d'attributs générique dédiés à la sérialisation et la désérialisation
///
namespace pdb.util.Generic.Attributs
{
	/// <summary>
	/// Attribut personnalidé permettant d'ignorer un champ lors de la sérialisation
	/// </summary>
	public class OutputIgnore : Attribute
	{

	}
    /// <summary>
    /// Attribut personnalidé permettant d'ignorer un champ lors de la mise à jour
    /// </summary>
    public class UpdateIgnore : Attribute
    {

    }

	/// <summary>
	/// Attribut personnalidé permettant d'ignorer un champ lors de la désérialisation
	/// </summary>
	public class InputIgnore : Attribute
	{

	}


	/// <summary>
	/// Attribut personnalidé permettant d'ignorer un champ lors de la sérialisation et la désérialisation
	/// </summary>
	public class Ignore : Attribute
	{

	}

   

	

	/// <summary>
	/// Attribut personnalisé cumulant les attributs InputFormatName et OutputFormatName
	/// </summary>
	public class NameAttribute : NameAttributeBase
	{
		public NameAttribute(string name) : base(name) { }
	}


	/// <summary>
	/// Attribut personnalisé permettant de modifier le nom des champs du flux de sortie
	/// </summary>
	public class OutputNameAttribute : NameAttributeBase
	{
		public OutputNameAttribute(string name) : base(name) { }
	}


	/// <summary>
	/// Attribut personnalisé permettant de prendre en compte un champ dont le nom ne correspond au nom de la property correspondante
	/// au moment de la désérialisation du flux d'entrée
	/// </summary>

	public class InputNameAttribute : NameAttributeBase
	{
		public InputNameAttribute(string name) : base(name) { }
	}



	/// <summary>
	/// Attribut personnalisé permettant de limiter le flux de sortie aux informations de date
	/// </summary>
	public class OutputFormatDateOnlyAttribute : Attribute
	{
		public readonly bool DateOnly;
		public OutputFormatDateOnlyAttribute()
		{
			DateOnly = true;
		}
		public OutputFormatDateOnlyAttribute(bool dateOnly)
		{
			this.DateOnly = dateOnly;
		}
	}


    public class EnumAsIntAttribute : Attribute
    {
    }

    public class InputEnumAsIntAttribute : Attribute
    {
    }

    public class OutputEnumAsIntAttribute : Attribute
    {
      
    }

    /// <summary>
    /// Attribut personalisé modifiant le type dans le flux d'entre 
    /// </summary>
    public class DateTimeAsString : Attribute
    {

    }

    /// <summary>
    /// Attribut personalisé modifiant le type dans le flux de sortie 
    /// </summary>
    public class StringAsDateTime : Attribute
    {

    }


	/// <summary>
	/// Attribut personnalisé permettant de remplacer un objet mono-Property par sa valeur dans le flux de sortie
	/// </summary>
	public class OutPutFormatFirstPropertyAsValueAttribute : Attribute
	{
		/// <summary>
		/// Si true, l'objet est remplacé par la valeur de son membre dans le flux de sortie
		/// </summary>
		public readonly bool FirstPropertyAsValue;
		public OutPutFormatFirstPropertyAsValueAttribute(bool firstPropertyAsValue)
		{
			this.FirstPropertyAsValue = firstPropertyAsValue;
		}
		public OutPutFormatFirstPropertyAsValueAttribute()
		{
			this.FirstPropertyAsValue = true;
		}

	}

    public class IntAsString : Attribute
    {
    }
    public class InputIntAsString : Attribute
    {
    }
    public class OutputIntAsString : Attribute
    {
    }
    /// <summary>
    ///  Attribut personnalisé permettant de signaler un champs indexé
    /// </summary>
    public class IndexedAttribute : Attribute
    {
    }

    /// <summary>
    /// Attribut personnalisé permettant de forcer l'écriture d'un champ même vide
    /// </summary>
    public class AlwaysWriteAttribute : Attribute
    {
    }

   


	


}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Attributs\NameAttributeBase.cs">
    <content><![CDATA[using System;

namespace pdb.util.Generic.Attributs
{
	/// <summary>
	/// Implémentation de IAttributeName par une classe d'attribut
	/// </summary>
	public abstract class NameAttributeBase : Attribute, IAttributeName
	{
		private string _name;
		public NameAttributeBase(string name)
		{
			if(string.IsNullOrEmpty(name))
				throw new ArgumentNullException();
			if(name.Trim() == string.Empty)
				throw new ArgumentException(); 
			this._name = name; 
		}
		public string Name { get { return _name; } }
	}

	/// <summary>
	/// Interface permettant de récupérer le nom modifié d'un membre
	/// </summary>
	public interface IAttributeName
	{
		string Name { get; }
	}

    public interface IAttributeType
    {
        string Type { get; }
    }

    public abstract class TypeAttributeBase : Attribute, IAttributeType
    {
        private string _type;
        public TypeAttributeBase(string type)
        {
            if (string.IsNullOrEmpty(type))
                throw new ArgumentNullException();
            if (type.Trim() == string.Empty)
                throw new ArgumentException();
            this._type = type;
        }
        public string Type { get { return _type; } }
    }

}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Attributs\Db\DbAttributes.cs">
    <content><![CDATA[using System;

///
// Ensemble d'attributs dédiés au parsing Db 
///
namespace pdb.util.Generic.Attributs.Db
{
	
	/// <summary>
	/// Attribut personnalidé permettant d'ignorer un champ lors de la creation de la requete d'insertion de données vers une base de données
	/// </summary>
	public class DbOutputIgnore : Attribute
	{

	}

	/// <summary>
	/// Attribut personnalidé permettant d'ignorer un champ lors de la récupération de données à partir d'une base de données
	/// </summary>
	public class DbInputIgnore : Attribute
	{

	}


	/// <summary>
	/// Attribut personnalidé permettant d'ignorer un champ lors de la récupération et l'insertion de données à partir de/vers une base de données
	/// </summary>
	public class DbIgnore : Attribute
	{

	}


	/// <summary>
	/// Attribut personnalisé cumulant les attributs DbInputFormatName et DbOutputFormatName
	/// </summary>
	public class DbNameAttribute : NameAttributeBase
	{
		public DbNameAttribute(string name) : base(name) { }
	}


	/// <summary>
	/// Attribut personnalisé permettant de modifier le nom des champs du flux de sortie ==> cas de génération des paramètres de proc stock
	/// </summary>
	public class DbOutputNameAttribute : NameAttributeBase
	{
		public DbOutputNameAttribute(string name) : base(name) { }
	}


	/// <summary>
	/// Attribut personnalisé permettant de prendre en compte un champ de base de données dont le nom ne correspond au nom de la property correspondante
	/// au moment de la désérialisation du flux d'entrée
	/// </summary>

	public class DbInputNameAttribute : NameAttributeBase
	{
		public DbInputNameAttribute(string name) : base(name) { }
	}

    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de sortie
    /// </summary>
    public class DbOutputEnumAsInt : Attribute
    {

    }

    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de sortie
    /// </summary>
    public class DbInputEnumAsInt : Attribute
    {

    }

    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de sortie
    /// </summary>
    public class DbEnumAsInt : Attribute
    {

    }

    /// <summary>
    /// Attribut personnalisé permettant d'indiquer un paramètre out
    /// </summary>
    public class DbParameterOutput : Attribute
    {
    }

    /// <summary>
    /// Attribut personnalisé permettant d'indiquer un paramètre In/out
    /// </summary>
    public class DbParameterInputOutput : Attribute
    {
    }

    







}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Attributs\Db\SbAttributes.cs">
    <content><![CDATA[using System;

///
// Ensemble d'attributs dédiés au parsing Sb 
///
namespace pdb.util.Generic.Attributs.Db
{
	
	/// <summary>
	/// Attribut personnalidé permettant d'ignorer un champ lors de la creation de la requete d'insertion de données vers une base de données
	/// </summary>
	public class SbOutputIgnore : Attribute
	{

	}

	/// <summary>
	/// Attribut personnalidé permettant d'ignorer un champ lors de la récupération de données à partir d'une base de données
	/// </summary>
	public class SbInputIgnore : Attribute
	{

	}


	/// <summary>
	/// Attribut personnalidé permettant d'ignorer un champ lors de la récupération et l'insertion de données à partir de/vers une base de données
	/// </summary>
	public class SbIgnore : Attribute
	{

	}


	/// <summary>
	/// Attribut personnalisé cumulant les attributs SbInputFormatName et SbOutputFormatName
	/// </summary>
	public class SbNameAttribute : NameAttributeBase
	{
		public SbNameAttribute(string name) : base(name) { }
	}


	/// <summary>
	/// Attribut personnalisé permettant de modifier le nom des champs du flux de sortie ==> cas de génération des paramètres de proc stock
	/// </summary>
	public class SbOutputNameAttribute : NameAttributeBase
	{
		public SbOutputNameAttribute(string name) : base(name) { }
	}


	/// <summary>
	/// Attribut personnalisé permettant de prendre en compte un champ de base de données dont le nom ne correspond au nom de la property correspondante
	/// au moment de la désérialisation du flux d'entrée
	/// </summary>

	public class SbInputNameAttribute : NameAttributeBase
	{
		public SbInputNameAttribute(string name) : base(name) { }
	}

    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de sortie
    /// </summary>
    public class SbOutputEnumAsInt : Attribute
    {

    }

    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de sortie
    /// </summary>
    public class SbInputEnumAsInt : Attribute
    {

    }

    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de sortie
    /// </summary>
    public class SbEnumAsInt : Attribute
    {

    }

    /// <summary>
    /// Attribut personnalisé permettant d'indiquer un paramètre out
    /// </summary>
    public class SbParameterOutput : Attribute
    {
    }

    /// <summary>
    /// Attribut personnalisé permettant d'indiquer un paramètre In/out
    /// </summary>
    public class SbParameterInputOutput : Attribute
    {
    }

    







}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Attributs\Json\GlobalAttributes.cs">
    <content><![CDATA[using System;

///
// Ensemble d'attributs générique dédiés à la sérialisation et la désérialisation
///
namespace pdb.util.Generic.Attributs.Json
{
	/// <summary>
	/// Attribut personnalidé permettant d'ignorer un champ lors de la sérialisation
	/// </summary>
    public class JsonOutputIgnore : Attribute
	{

	}

    /// <summary>
    /// Attribut personnalidé permettant d'ignorer un champ lors de la lecture
    /// </summary>
    public class JsonInputIgnore : Attribute
    {

    }

    /// <summary>
    /// Attribut personnalidé permettant d'ignorer un champ
    /// </summary>
    public class JsonIgnore : Attribute
    {

    }

  

	


	/// <summary>
	/// Attribut personnalisé modifiant de le nom dans le flux de sortie
	/// </summary>
	public class JsonOutputName : NameAttributeBase
	{
        public JsonOutputName(string name) : base(name) { }
	}


    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de lecture
    /// </summary>
    public class JsonInputName : NameAttributeBase
    {
        public JsonInputName(string name) : base(name) { }
    }

    /// <summary>
    /// Attribut personnalisé cumulant les attributs InputFormatName et OutputFormatName
    /// </summary>
    public class JsonName : NameAttributeBase
    {
        public JsonName(string name) : base(name) { }
    }


    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de sortie
    /// </summary>
    public class JsonOutputEnumAsInt : Attribute
    {
       
    }

    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de sortie
    /// </summary>
    public class JsonInputEnumAsInt : Attribute
    {

    }

    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de sortie
    /// </summary>
    public class JsonEnumAsInt : Attribute
    {

    }




}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Attributs\Sp\GlobalAttributes.cs">
    <content><![CDATA[using System;

///
// Ensemble d'attributs générique dédiés à la sérialisation et la désérialisation
///
namespace pdb.util.Generic.Attributs.Sp
{
	/// <summary>
	/// Attribut personnalidé permettant d'ignorer un champ lors de la sérialisation
	/// </summary>
    public class SpOutputIgnore : Attribute
	{

	}

    /// <summary>
    /// Attribut personnalidé permettant d'ignorer un champ lors de la mise à jour
    /// </summary>
    public class SpUpdateIgnore : Attribute
    {

    }

    /// <summary>
    /// Attribut personnalidé permettant d'ignorer un champ lors de la lecture
    /// </summary>
    public class SpInputIgnore : Attribute
    {

    }

    /// <summary>
    /// Attribut personnalidé permettant d'ignorer un champ
    /// </summary>
    public class SpIgnore : Attribute
    {

    }

	


	/// <summary>
	/// Attribut personnalisé modifiant de le nom dans le flux de sortie
	/// </summary>
	public class SpOutputName : NameAttributeBase
	{
        public SpOutputName(string name) : base(name) { }
	}

    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de lecture
    /// </summary>
    public class SpInputName : NameAttributeBase
    {
        public SpInputName(string name) : base(name) { }
    }

    /// <summary>
    /// Attribut personnalisé cumulant les attributs InputFormatName et OutputFormatName
    /// </summary>
    public class SpName : NameAttributeBase
    {
        public SpName(string name) : base(name) { }
    }

    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de sortie
    /// </summary>
    public class SpOutputEnumAsInt : Attribute
    {

    }

    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de sortie
    /// </summary>
    public class SpInputEnumAsInt : Attribute
    {

    }

    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de sortie
    /// </summary>
    public class SpEnumAsInt : Attribute
    {

    }
    /// <summary>
    /// Attribut personnalisé permettant de préciser le type Sp associé
    /// </summary>
    public class SpType : TypeAttributeBase
    {
        public SpType(string type)
            : base(type)
        {
        }
    }

 

    


}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Attributs\Xml\XmlAttributes.cs">
    <content><![CDATA[using System;
///
// Ensemble d'attributs dédiés au parsing Xml
///
namespace pdb.util.Generic.Attributs.Xml
{
	/// <summary>
	/// Attribut personnalidé permettant d'ignorer un champ lors de la Sérialisation Xml de l'objet
	/// </summary>
	public class XmlOutputIgnore : Attribute
	{

	}

	/// <summary>
	/// Attribut personnalidé permettant d'ignorer un champ lors de la désérialisation de l'objet
	/// </summary>
	public class XmlInputIgnore : Attribute
	{

	}


	/// <summary>
	/// Attribut personnalidé permettant d'ignorer un champ lors de la sérialisation et la désérialisation de l'objet
	/// </summary>
	public class XmlIgnore : Attribute
	{

	}

	/// <summary>
	/// Attribut personnalisé cumulant les attributs XmlInputFormatName et XmlOutputFormatName
	/// </summary>
	public class XmlNameAttribute : NameAttributeBase
	{
		public XmlNameAttribute(string name) : base(name) {}
	}


	/// <summary>
	/// Attribut personnalisé permettant de modifier le nom des champs du flux de sortie
	/// </summary>
	public class XmlOutputNameAttribute : NameAttributeBase
	{
		public XmlOutputNameAttribute(string name) : base(name) { }
	}


	/// <summary>
	/// Attribut personnalisé permettant de prendre en compte un champ dont le nom ne correspond au nom de la property correspondante
	/// au moment de la désérialisation du flux d'entrée
	/// </summary>

	public class XmlInputNameAttribute: NameAttributeBase
	{
		public XmlInputNameAttribute(string name) : base(name) { }
	}


    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de sortie
    /// </summary>
    public class XmlOutputEnumAsInt : Attribute
    {

    }

    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de sortie
    /// </summary>
    public class XmlInputEnumAsInt : Attribute
    {

    }

    /// <summary>
    /// Attribut personnalisé modifiant de le nom dans le flux de sortie
    /// </summary>
    public class XmlEnumAsInt : Attribute
    {

    }



}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Encode\Getters.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Reflection;

namespace pdb.util.Generic.Encode
{
    internal class Getters
    {
       // public string Name;
        public JSON.GenericGetter Getter;
      //  public Type propertyType;
        public PropertyInfo PropertyInfo;
        public string Name { get { return PropertyInfo.Name; } }
        public Type propertyType { get { return PropertyInfo.PropertyType; } }
    }

    public class DatasetSchema
    {
        public List<string> Info { get; set; }
        public string Name { get; set; }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Encode\JSON.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;

namespace pdb.util.Generic.Encode
{
	public class JSON
	{
		public readonly static JSON Instance = new JSON();

		private JSON()
		{
		}
		public bool UseOptimizedDatasetSchema = true;
		public bool UseFastGuid = true;
		public bool UseSerializerExtension = true;
		public bool SerializeNullValues = true;

		public string ToJSON(object obj)
		{
			return ToJSON(obj, UseSerializerExtension, UseFastGuid, UseOptimizedDatasetSchema, SerializeNullValues);
		}

		public string ToJSON(object obj,
		                     bool enableSerializerExtensions)
		{
			return ToJSON(obj, enableSerializerExtensions, UseFastGuid, UseOptimizedDatasetSchema, SerializeNullValues);
		}

		public string ToJSON(object obj,
		                     bool enableSerializerExtensions,
		                     bool enableFastGuid)
		{
			return ToJSON(obj, enableSerializerExtensions, enableFastGuid, UseOptimizedDatasetSchema, SerializeNullValues);
		}

		public string ToJSON(object obj,
		                     bool enableSerializerExtensions,
		                     bool enableFastGuid,
		                     bool enableOptimizedDatasetSchema,
		                     bool serializeNullValues)
		{
			return new JSONSerializer(enableOptimizedDatasetSchema, enableFastGuid, enableSerializerExtensions, serializeNullValues).ConvertToJSON(obj);
		}

		public object Parse(string json)
		{
			return new JsonParser(json).Decode();
		}

		public T ToObject<T>(string json)
		{
			return (T)ToObject(json, typeof(T));
		}

		public object ToObject(string json)
		{
			return ToObject(json, null);
		}

		public object ToObject(string json, Type type)
		{
			Dictionary<string, object> ht = new JsonParser(json).Decode() as Dictionary<string, object>;
			if (ht == null) return null;

			return ParseDictionary(ht, type);
		}

		#region [   PROPERTY GET SET CACHE   ]
		SafeDictionary<Type, string> _tyname = new SafeDictionary<Type, string>();
		internal string GetTypeAssemblyName(Type t)
		{
			string val = "";
			if (_tyname.TryGetValue(t, out val))
				return val;
			else
			{
				string s = t.AssemblyQualifiedName;
				_tyname.Add(t, s);
				return s;
			}
		}

		SafeDictionary<string, Type> _typecache = new SafeDictionary<string, Type>();
		private Type GetTypeFromCache(string typename)
		{
			Type val = null;
			if (_typecache.TryGetValue(typename, out val))
				return val;
			else
			{
				Type t = Type.GetType(typename);
				_typecache.Add(typename, t);
				return t;
			}
		}

		SafeDictionary<Type, CreateObject> _constrcache = new SafeDictionary<Type, CreateObject>();
		private delegate object CreateObject();
		private object FastCreateInstance(Type objtype)
		{
			CreateObject c = null;
			if (_constrcache.TryGetValue(objtype, out c))
			{
				return c();
			}
			else
			{
				DynamicMethod dynMethod = new DynamicMethod("_", objtype, null);
				ILGenerator ilGen = dynMethod.GetILGenerator();

				ilGen.Emit(OpCodes.Newobj, objtype.GetConstructor(Type.EmptyTypes));
				ilGen.Emit(OpCodes.Ret);
				c = (CreateObject)dynMethod.CreateDelegate(typeof(CreateObject));
				_constrcache.Add(objtype, c);
				return c();
			}
		}

		internal struct myPropInfo
		{
			public bool filled;
			public Type pt;
			public Type bt;
			public Type changeType;
			public bool isDictionary;
			public bool isValueType;
			public bool isGenericType;
			public bool isArray;
			public bool isByteArray;
			public bool isGuid;
			public bool isDataSet;
			public bool isHashtable;
			public GenericSetter setter;
			public bool isEnum;
			public bool isDateTime;
			public Type[] GenericTypes;
			public bool isInt;
			public bool isLong;
			public bool isString;
			public bool isBool;
			public bool isClass;
			public GenericGetter getter;
			public bool isStringDictionary;
			public string Name;
		}

		SafeDictionary<string, SafeDictionary<string, myPropInfo>> _propertycache = new SafeDictionary<string, SafeDictionary<string, myPropInfo>>();
		internal  SafeDictionary<string, myPropInfo> Getproperties(Type type, string typename)
		{
			SafeDictionary<string, myPropInfo> sd = null;
			if (_propertycache.TryGetValue(typename, out sd))
			{
				return sd;
			}
			else
			{
				sd = new SafeDictionary<string, myPropInfo>();
				PropertyInfo[] pr = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);
				foreach (PropertyInfo p in pr)
				{
					myPropInfo d = new myPropInfo();
					d.filled = true;
					d.pt = p.PropertyType;
					d.Name = p.Name;
					d.isDictionary = p.PropertyType.Name.Contains("Dictionary");
					if (d.isDictionary)
						d.GenericTypes = p.PropertyType.GetGenericArguments();
					d.isValueType = p.PropertyType.IsValueType;
					d.isGenericType = p.PropertyType.IsGenericType;
					d.isArray = p.PropertyType.IsArray;
					if (d.isArray)
						d.bt = p.PropertyType.GetElementType();
					if (d.isGenericType)
						d.bt = p.PropertyType.GetGenericArguments()[0];
					d.isByteArray = p.PropertyType == typeof(byte[]);
					d.isGuid = (p.PropertyType == typeof(Guid) || p.PropertyType == typeof(Guid?));
					d.isHashtable = p.PropertyType == typeof(Hashtable);
					d.isDataSet = p.PropertyType == typeof(DataSet);
					d.setter = CreateSetMethod(p);
					d.changeType = GetChangeType(p.PropertyType);
					d.isEnum = p.PropertyType.IsEnum;
					d.isDateTime = p.PropertyType == typeof(DateTime) || p.PropertyType == typeof(DateTime?);
					d.isInt = p.PropertyType == typeof(int) || p.PropertyType == typeof(int?);
					d.isLong = p.PropertyType == typeof(long) || p.PropertyType == typeof(long?);
					d.isString = p.PropertyType == typeof(string);
					d.isBool = p.PropertyType == typeof(bool) || p.PropertyType == typeof(bool?);
					d.isClass = p.PropertyType.IsClass;
					d.getter = CreateGetMethod(p);

                    if(d.isDictionary && d.GenericTypes[0] == typeof(string) && d.GenericTypes[1]== typeof(string))
                        d.isStringDictionary = true;
					
					sd.Add(p.Name, d);
				}
				_propertycache.Add(typename, sd);
				return sd;
			}
		}
		internal delegate void GenericSetter(object target, object value);

		private static GenericSetter CreateSetMethod(PropertyInfo propertyInfo)
		{
			MethodInfo setMethod = propertyInfo.GetSetMethod();
			if (setMethod == null)
				return null;

			Type[] arguments = new Type[2];
			arguments[0] = arguments[1] = typeof(object);

			DynamicMethod setter = new DynamicMethod("_", typeof(void), arguments);
			ILGenerator il = setter.GetILGenerator();
			il.Emit(OpCodes.Ldarg_0);
			il.Emit(OpCodes.Castclass, propertyInfo.DeclaringType);
			il.Emit(OpCodes.Ldarg_1);

			if (propertyInfo.PropertyType.IsClass)
				il.Emit(OpCodes.Castclass, propertyInfo.PropertyType);
			else
				il.Emit(OpCodes.Unbox_Any, propertyInfo.PropertyType);

			il.EmitCall(OpCodes.Callvirt, setMethod, null);
			il.Emit(OpCodes.Ret);

			return (GenericSetter)setter.CreateDelegate(typeof(GenericSetter));
		}

		internal delegate object GenericGetter(object obj);

		private GenericGetter CreateGetMethod(PropertyInfo propertyInfo)
		{
			MethodInfo getMethod = propertyInfo.GetGetMethod();
			if (getMethod == null)
				return null;

			Type[] arguments = new Type[1];
			arguments[0] = typeof(object);

			DynamicMethod getter = new DynamicMethod("_", typeof(object), arguments);
			ILGenerator il = getter.GetILGenerator();
			il.Emit(OpCodes.Ldarg_0);
			il.Emit(OpCodes.Castclass, propertyInfo.DeclaringType);
			il.EmitCall(OpCodes.Callvirt, getMethod, null);

			if (!propertyInfo.PropertyType.IsClass)
				il.Emit(OpCodes.Box, propertyInfo.PropertyType);

			il.Emit(OpCodes.Ret);

			return (GenericGetter)getter.CreateDelegate(typeof(GenericGetter));
		}

        readonly SafeDictionary<Type, List<Getters>> _getterscache = new SafeDictionary<Type, List<Getters>>();
        internal List<Getters> GetGetters(Type type)
        {
            List<Getters> val = null;
            if (_getterscache.TryGetValue(type, out val))
                return val;

            PropertyInfo[] props = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);
            List<Getters> getters = new List<Getters>();
            foreach (PropertyInfo p in props)
            {
                if (!p.CanWrite) continue;
                
                object[] att = p.GetCustomAttributes(typeof(System.Xml.Serialization.XmlIgnoreAttribute),false);
                if(att!=null && att.Length>0)
                	continue;
                
                JSON.GenericGetter g = CreateGetMethod(p);
                if (g != null)
                {
                    Getters gg = new Getters();
                  //  gg.Name = p.Name;
                    gg.Getter = g;
                 //   gg.propertyType = p.PropertyType;
                    gg.PropertyInfo = p; 
                    getters.Add(gg);
                }

            }
            _getterscache.Add(type, getters);
            return getters;
        }

		private object ChangeType(object value, Type conversionType)
		{
			if (conversionType == typeof(int))
				return (int)CreateLong((string)value);

			else if (conversionType == typeof(long))
				return CreateLong((string)value);

			else if (conversionType == typeof(string))
				return (string)value;
        
            else if (conversionType == typeof(Guid))
                return CreateGuid((string)value);                    

			return Convert.ChangeType(value, conversionType, CultureInfo.InvariantCulture);
		}
		#endregion


		private object ParseDictionary(Dictionary<string, object> d, Type type)
		{
			object tn = "";
			bool found = d.TryGetValue("$type", out tn);
			if (found == false && type == typeof(System.Object))
			{
				return CreateDataset(d);
			}

			if (found)
				type = GetTypeFromCache((string)tn);

			if (type == null)
				throw new Exception("Cannot determine type");

			string typename = type.Name;
			object o = FastCreateInstance(type);
			SafeDictionary<string, myPropInfo> props = Getproperties(type, typename);
			foreach (string name in d.Keys)
			{
				if (name == "$map")
				{
					ProcessMap(o, props, (Dictionary<string, object>)d[name]);
					continue;
				}
				myPropInfo pi;
				if (props.TryGetValue(name, out pi) == false)
					continue;
				if (pi.filled == true)
				{
					object v = d[name];

					if (v != null)
					{
						object oset = null;

						if (pi.isInt)
							oset = (int)CreateLong((string)v);

						else if (pi.isLong)
							oset = CreateLong((string)v);

						else if (pi.isString)
							oset = (string)v;

						else if (pi.isBool)
							oset = (bool)v;

						else if (pi.isGenericType && pi.isValueType == false && pi.isDictionary == false)
							oset = CreateGenericList((ArrayList)v, pi.pt, pi.bt);

						else if (pi.isByteArray)
							oset = Convert.FromBase64String((string)v);

						else if (pi.isArray && pi.isValueType == false)
							oset = CreateArray((ArrayList)v, pi.pt, pi.bt);

						else if (pi.isGuid)
							oset = CreateGuid((string)v);

						else if (pi.isDataSet)
							oset = CreateDataset((Dictionary<string, object>)v);
						
						else if (pi.isStringDictionary )
							oset = CreateStringKeyDictionary((Dictionary<string, object>)v, pi.pt, pi.GenericTypes);

						else if (pi.isDictionary || pi.isHashtable)
							oset = CreateDictionary((ArrayList)v, pi.pt, pi.GenericTypes);

						else if (pi.isEnum)
							oset = CreateEnum(pi.pt, (string)v);

						else if (pi.isDateTime)
							oset = CreateDateTime((string)v);

						else if (pi.isClass && v is Dictionary<string, object>)
							oset = ParseDictionary((Dictionary<string, object>)v, pi.pt);

						else if (pi.isValueType)
							oset = ChangeType(v, pi.changeType);

						else if (v is ArrayList)
							oset = CreateArray((ArrayList)v, pi.pt, typeof(object));

						else
							oset = v;

						pi.setter(o, oset);
					}
				}
			}
			return o;
		}

		private void ProcessMap(object obj, SafeDictionary<string, JSON.myPropInfo> props, Dictionary<string, object> dic)
		{
			foreach (KeyValuePair<string, object> kv in dic)
			{
				myPropInfo p = props[kv.Key];
				object o = p.getter(obj);
				Type t = Type.GetType((string)kv.Value);
				if (t == typeof(Guid))
					p.setter(obj, CreateGuid((string)o));
			}
		}

		private long CreateLong(string s)
		{
			long num = 0;
			bool neg = false;
			foreach (char cc in s)
			{
				if (cc == '-')
					neg = true;
				else if (cc == '+')
					neg = false;
				else
				{
					num *= 10;
					num += (int)(cc - '0');
				}
			}

			return neg ? -num : num;
		}

		private object CreateEnum(Type pt, string v)
		{
			// TODO : optimize create enum
			return Enum.Parse(pt, v);
		}

		private Guid CreateGuid(string s)
		{
			if (s.Length > 30)
				return new Guid(s);
			else
				return new Guid(Convert.FromBase64String(s));
		}

		private DateTime CreateDateTime(string value)
		{
			//                   0123456789012345678
			// datetime format = yyyy-MM-dd HH:mm:ss
			int year = (int)CreateLong(value.Substring(0, 4));
			int month = (int)CreateLong(value.Substring(5, 2));
			int day = (int)CreateLong(value.Substring(8, 2));
			int hour = (int)CreateLong(value.Substring(11, 2));
			int min = (int)CreateLong(value.Substring(14, 2));
			int sec = (int)CreateLong(value.Substring(17, 2));
			return new DateTime(year, month, day, hour, min, sec);
		}

		private object CreateArray(ArrayList data, Type pt, Type bt)
		{
			ArrayList col = new ArrayList();
			// create an array of objects
			foreach (object ob in data)
			{
				if (ob is IDictionary)
					col.Add(ParseDictionary((Dictionary<string, object>)ob, bt));
				else
					col.Add(ChangeType(ob, bt));
			}
			return col.ToArray(bt);
		}

		private object CreateGenericList(ArrayList data, Type pt, Type bt)
		{
			IList col = (IList)FastCreateInstance(pt);
			// create an array of objects
			foreach (object ob in data)
			{
				if (ob is IDictionary)
					col.Add(ParseDictionary((Dictionary<string, object>)ob, bt));
				else if (ob is ArrayList)
					col.Add(((ArrayList)ob).ToArray());
				else
					col.Add(ChangeType(ob, bt));
			}
			return col;
		}
		
		private object CreateStringKeyDictionary(Dictionary<string, object> reader, Type pt, Type[] types)
		{
			var col = (IDictionary)FastCreateInstance(pt);
			Type t1 = null;
			Type t2 = null;
			if (types != null)
			{
				t1 = types[0];
				t2 = types[1];
			}

			foreach (KeyValuePair<string, object> values in reader)
			{
				var key = values.Key;//ChangeType(values.Key, t1);
				var val = ChangeType(values.Value, t2);
				col.Add(key, val);
			}

			return col;
		}

		private object CreateDictionary(ArrayList reader, Type pt, Type[] types)
		{
			IDictionary col = (IDictionary)FastCreateInstance(pt);
			Type t1 = null;
			Type t2 = null;
			if (types != null)
			{
				t1 = types[0];
				t2 = types[1];
			}

			foreach (Dictionary<string, object> values in reader)
			{
				object key = values["k"];
				object val = values["v"];

				if (key is Dictionary<string, object>)
					key = ParseDictionary((Dictionary<string, object>)key, t1);
				else
					key = ChangeType(key, t1);

				if (val is Dictionary<string, object>)
					val = ParseDictionary((Dictionary<string, object>)val, t2);
				else
					val = ChangeType(val, t2);

				col.Add(key, val);
			}

			return col;
		}

		private Type GetChangeType(Type conversionType)
		{
			if (conversionType.IsGenericType && conversionType.GetGenericTypeDefinition().Equals(typeof(Nullable<>)))
				return conversionType.GetGenericArguments()[0];

			return conversionType;
		}

		private DataSet CreateDataset(Dictionary<string, object> reader)
		{
			DataSet ds = new DataSet();
			ds.EnforceConstraints = false;
			ds.BeginInit();

			// read dataset schema here
			var schema = reader["$schema"];

			if (schema is string)
			{
				TextReader tr = new StringReader((string)schema);
				ds.ReadXmlSchema(tr);
			}
			else
			{
				DatasetSchema ms = (DatasetSchema)ParseDictionary((Dictionary<string, object>)schema, typeof(DatasetSchema));
				ds.DataSetName = ms.Name;
				for (int i = 0; i < ms.Info.Count; i += 3)
				{
					if (ds.Tables.Contains(ms.Info[i]) == false)
						ds.Tables.Add(ms.Info[i]);
					ds.Tables[ms.Info[i]].Columns.Add(ms.Info[i + 1], Type.GetType(ms.Info[i + 2]));
				}
			}

			foreach (KeyValuePair<string, object> pair in reader)
			{
				if (pair.Key == "$type" || pair.Key == "$schema") continue;

				ArrayList rows = (ArrayList)pair.Value;
				if (rows == null) continue;

				DataTable dt = ds.Tables[pair.Key];
				dt.BeginInit();
				dt.BeginLoadData();
				List<int> guidcols = new List<int>();

				foreach (DataColumn c in dt.Columns)
					if (c.DataType == typeof(Guid) || c.DataType == typeof(Guid?))
						guidcols.Add(c.Ordinal);

				foreach (ArrayList row in rows)
				{
					object[] v = new object[row.Count];
					row.CopyTo(v, 0);
					foreach (int i in guidcols)
					{
						string s = (string)v[i];
						if (s != null && s.Length < 36)
							v[i] = new Guid(Convert.FromBase64String(s));
					}
					dt.Rows.Add(v);
				}

				dt.EndLoadData();
				dt.EndInit();
			}

			ds.EndInit();

			return ds;

		}
	}
}]]></content>
  </file>
  <file path="\pdb.util\Generic\Encode\JsonEncoder.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using pdb.util;

namespace pdb.util.Generic.Encode
{
    /// <summary>
    /// Sérialisation Json des résultats
    /// </summary>
    public static class JsonEncoder
    {

        private static readonly pdb.util.ILogger logError = Logger.getLogger("Error");
        /// <summary>
        /// Encodage d'un résultat
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        public static string encode(object o)
        {
            StringBuilder sb = new StringBuilder();

            try
            {
                // int count = 1;
                ICollection list = o as ICollection;
                var listAux = new ArrayList();
                if (list != null)
                {
                    foreach (object obj in list)
                    {
                        if (obj == null)
                            continue;
                        listAux.Add(obj);
                    }
                }
                else if (o != null)
                    listAux.Add(o);


                sb.Append("{total:");
                sb.Append(listAux.Count);
                sb.Append(", success:true, results:[");
                bool begin = false;

                foreach (var objet in listAux)
                {
                    if (begin)
                        sb.Append(",");
                    begin = true;
                    sb.Append(JsonEncode(objet));

                }
                sb.Append("]}");

            }
            catch (Exception ex)
            {
                logError.Error("Impossible de sérialiser " + o, ex);
            }
            return sb.ToString();


        }

        public static string encodeError(string code, IEnumerable args)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("{'success': false, 'message':'");
            sb.Append(code);
            sb.Append("',");
            sb.Append("'messageError': [");
            bool begin = false;
            foreach (object arg in args)
            {
                if (begin)
                    sb.Append(",");
                begin = true;
                sb.Append(JsonEncode(arg));
            }
            sb.Append("]}");
            return sb.ToString();
        }

        public static string encodeErrorParams(string code, bool blockingError, IEnumerable messages, IEnumerable errors)
        {
            StringBuilder sb = new StringBuilder();
            try
            {
                sb.Append("{'success': false, 'message':'");
                sb.Append(code);
                sb.Append("',");

                if (!blockingError)
                    sb.Append("'blockingError':false,");

                bool begin = false;

                foreach (object pm in messages)
                {
                    var opm = pm; 
                    if (pm == null)
                        opm = ""; 
                    if (begin)
                        sb.Append(",");
                    else
                        sb.Append("'messageParams':[");
                    begin = true;

                    sb.Append(JsonEncode(opm));
                }

                if (begin)
                    sb.Append("],");
                begin = false;
         
                foreach (object arg in errors)
                {
                    var oarg = arg; 
                    if (arg == null)
                        oarg = "" ; 
                    if (begin)
                        sb.Append(",");
                    else
                        sb.Append("'messageError': [");
                    begin = true;
                    sb.Append(JsonEncode(oarg));
                }
                if (begin)
                    sb.Append("]");
                sb.Append("}");
            }

            catch (Exception ex)
            {
                logError.Error("Impossible de sérialiser l'erreur", ex);
            }
            return sb.ToString();
        }
        /// <summary>
        /// encodage Json d'un objet
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        private static String JsonEncode(object o)
        {
            return JSON.Instance.ToJSON(o, false);
        }
    }
}

]]></content>
  </file>
  <file path="\pdb.util\Generic\Encode\JsonParser.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using StringBuilder = System.Text.StringBuilder;

namespace pdb.util.Generic.Encode
{
    /// <summary>
    /// This class encodes and decodes JSON strings.
    /// Spec. details, see http://www.json.org/
    /// 
    /// JSON uses Arrays and Objects. These correspond here to the datatypes ArrayList and Hashtable.
    /// All numbers are parsed to doubles.
    /// </summary>
    internal class JsonParser
    {
        enum Token
        {
            None = -1,           // Used to denote no Lookahead available
            Curly_Open,
            Curly_Close,
            Squared_Open,
            Squared_Close,
            Colon,
            Comma,
            String,
            Number,
            True,
            False,
            Null
        }

        readonly char[] json;
        readonly System.Text.StringBuilder s = new System.Text.StringBuilder();
        Token lookAheadToken = Token.None;
        int index;

        internal JsonParser(string json)
        {
            this.json = json.ToCharArray();
        }

        public object Decode()
        {
            return ParseValue();
        }

        private Dictionary<string, object> ParseObject()
        {
            Dictionary<string, object> table = new Dictionary<string, object>();

            ConsumeToken(); // {

            while (true)
            {
                switch (LookAhead())
                {

                    case Token.Comma:
                        ConsumeToken();
                        break;

                    case Token.Curly_Close:
                        ConsumeToken();
                        return table;

                    default:
                        {

                            // name
                            string name = ParseString();

                            // :
                            if (NextToken() != Token.Colon)
                            {
                                throw new Exception("Expected colon at index " + index);
                            }

                            // value
                            object value = ParseValue();

                            table[name] = value;
                        }
                        break;
                }
            }
        }

        private ArrayList ParseArray()
        {
            ArrayList array = new ArrayList();

            ConsumeToken(); // [

            while (true)
            {
                switch (LookAhead())
                {

                    case Token.Comma:
                        ConsumeToken();
                        break;

                    case Token.Squared_Close:
                        ConsumeToken();
                        return array;

                    default:
                        {
                            array.Add(ParseValue());
                        }
                        break;
                }
            }
        }

        private object ParseValue()
        {
            switch (LookAhead())
            {
                case Token.Number:
                    return ParseNumber();

                case Token.String:
                    return ParseString();

                case Token.Curly_Open:
                    return ParseObject();

                case Token.Squared_Open:
                    return ParseArray();

                case Token.True:
                    ConsumeToken();
                    return true;

                case Token.False:
                    ConsumeToken();
                    return false;

                case Token.Null:
                    ConsumeToken();
                    return null;
            }

            throw new Exception("Unrecognized token at index" + index);
        }

        private string ParseString()
        {
            ConsumeToken(); // "

            s.Length = 0;

            int runIndex = -1;

            while (index < json.Length)
            {
                var c = json[index++];

                if (c == '"')
                {
                    if (runIndex != -1)
                    {
                        if (s.Length == 0)
                            return new string(json, runIndex, index - runIndex - 1);

                        s.Append(json, runIndex, index - runIndex - 1);
                    }
                    return s.ToString();
                }

                if (c != '\\')
                {
                    if (runIndex == -1)
                        runIndex = index - 1;

                    continue;
                }

                if (index == json.Length) break;

                if (runIndex != -1)
                {
                    s.Append(json, runIndex, index - runIndex - 1);
                    runIndex = -1;
                }

                switch (json[index++])
                {
                    case '"':
                        s.Append('"');
                        break;

                    case '\\':
                        s.Append('\\');
                        break;

                    case '/':
                        s.Append('/');
                        break;

                    case 'b':
                        s.Append('\b');
                        break;

                    case 'f':
                        s.Append('\f');
                        break;

                    case 'n':
                        s.Append('\n');
                        break;

                    case 'r':
                        s.Append('\r');
                        break;

                    case 't':
                        s.Append('\t');
                        break;

                    case 'u':
                        {
                            int remainingLength = json.Length - index;
                            if (remainingLength < 4) break;

                            // parse the 32 bit hex into an integer codepoint
                            uint codePoint = ParseUnicode(json[index], json[index + 1], json[index + 2], json[index + 3]);
                            s.Append((char)codePoint);

                            // skip 4 chars
                            index += 4;
                        }
                        break;
                }
            }

            throw new Exception("Unexpectedly reached end of string");
        }

        private uint ParseSingleChar(char c1, uint multipliyer)
        {
            uint p1 = 0;
            if (c1 >= '0' && c1 <= '9')
                p1 = (uint)(c1 - '0') * multipliyer;
            else if (c1 >= 'A' && c1 <= 'F')
                p1 = (uint)((c1 - 'A') + 10) * multipliyer;
            else if (c1 >= 'a' && c1 <= 'f')
                p1 = (uint)((c1 - 'a') + 10) * multipliyer;
            return p1;
        }

        private uint ParseUnicode(char c1, char c2, char c3, char c4)
        {
            uint p1 = ParseSingleChar(c1, 0x1000);
            uint p2 = ParseSingleChar(c2, 0x100);
            uint p3 = ParseSingleChar(c3, 0x10);
            uint p4 = ParseSingleChar(c4, 1);

            return p1 + p2 + p3 + p4;
        }

        private string ParseNumber()
        {
            ConsumeToken();

            // Need to start back one place because the first digit is also a token and would have been consumed
            var startIndex = index - 1;

            do
            {
                var c = json[index];

                if ((c >= '0' && c <= '9') || c == '.' || c == '-' || c == '+' || c == 'e' || c == 'E')
                {
                    if (++index == json.Length) throw new Exception("Unexpected end of string whilst parsing number");
                    continue;
                }

                break;
            } while (true);

            return new string(json, startIndex, index - startIndex);
        }

        private Token LookAhead()
        {
            if (lookAheadToken != Token.None) return lookAheadToken;

            return lookAheadToken = NextTokenCore();
        }

        private void ConsumeToken()
        {
            lookAheadToken = Token.None;
        }

        private Token NextToken()
        {
            var result = lookAheadToken != Token.None ? lookAheadToken : NextTokenCore();

            lookAheadToken = Token.None;

            return result;
        }

        private Token NextTokenCore()
        {
            char c;

            // Skip past whitespace
            do
            {
                c = json[index];

                if (c > ' ') break;
                if (c != ' ' && c != '\t' && c != '\n' && c != '\r') break;

            } while (++index < json.Length);

            if (index == json.Length)
            {
                throw new Exception("Reached end of string unexpectedly");
            }

            c = json[index];

            index++;

            //if (c >= '0' && c <= '9')
            //    return Token.Number;

            switch (c)
            {
                case '{':
                    return Token.Curly_Open;

                case '}':
                    return Token.Curly_Close;

                case '[':
                    return Token.Squared_Open;

                case ']':
                    return Token.Squared_Close;

                case ',':
                    return Token.Comma;

                case '"':
                    return Token.String;

				case '0': case '1': case '2': case '3': case '4':
				case '5': case '6': case '7': case '8': case '9':
                case '-':
                    return Token.Number;

                case ':':
                    return Token.Colon;

                case 'f':
                    if (json.Length - index >= 4 &&
                        json[index + 0] == 'a' &&
                        json[index + 1] == 'l' &&
                        json[index + 2] == 's' &&
                        json[index + 3] == 'e')
                    {
                        index += 4;
                        return Token.False;
                    }
                    break;

                case 't':
                    if (json.Length - index >= 3 &&
                        json[index + 0] == 'r' &&
                        json[index + 1] == 'u' &&
                        json[index + 2] == 'e')
                    {
                        index += 3;
                        return Token.True;
                    }
                    break;

                case 'n':
                    if (json.Length - index >= 3 &&
                        json[index + 0] == 'u' &&
                        json[index + 1] == 'l' &&
                        json[index + 2] == 'l')
                    {
                        index += 3;
                        return Token.Null;
                    }
                    break;

            }

            throw new Exception("Could not find token at index " + --index);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Encode\JsonSerializer.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Reflection;
using pdb.util.Generic.Attributs;
using pdb.util.Generic.Attributs.Json;
using pdb.util.Generic.Parse;


namespace pdb.util.Generic.Encode
{
    internal class JSONSerializer : ParserBase
    {

        private readonly System.Text. StringBuilder _output = new System.Text.StringBuilder();
        readonly bool useMinimalDataSetSchema;
        readonly bool fastguid = true;
        readonly bool useExtension = true;
        readonly bool serializeNulls = true;
        readonly int _MAX_DEPTH = 10;
        int _current_depth = 0;

        public override void setDefaultAttributes()
        {
            base.setDefaultAttributes();

            addAttributeName(typeof(OutputNameAttribute));
            addEnumAsInt(typeof(OutputEnumAsIntAttribute));
            addEnumAsInt(typeof(EnumAsIntAttribute));
           
            addAttributeName(typeof(JsonOutputName));
            addAttributeName(typeof(JsonName));
            addDateTimeAsString(typeof(DateTimeAsString));



            addExclusion(typeof(JsonIgnore));
            addExclusion(typeof(JsonOutputIgnore));

           
            addExclusion(typeof(OutputIgnore));
            
        }

        internal JSONSerializer(bool UseMinimalDataSetSchema, bool UseFastGuid, bool UseExtensions, bool SerializeNulls)
            : base()
        {
            this.useMinimalDataSetSchema = UseMinimalDataSetSchema;
            this.fastguid = UseFastGuid;
            this.useExtension = UseExtensions;
            this.serializeNulls = SerializeNulls;
        }

        internal string ConvertToJSON(object obj)
        {
            if (obj == null)
                return "null";
            if (obj is String)
                WriteString(obj as String);
            else if (obj != null && obj.GetType().IsEnum)
                WriteString(obj.ToString());
            else
                WriteValue(null, obj);

            return _output.ToString();
        }

        private void WriteValue(PropertyInfo prop, object obj)
        {
            if (obj == null)
            {
                _output.Append("null");
                return;
            }


            object[] attributes = obj.GetType().GetCustomAttributes(typeof(OutPutFormatFirstPropertyAsValueAttribute), true);
            if (attributes.GetLength(0) > 0)
            {
                OutPutFormatFirstPropertyAsValueAttribute format = attributes[0] as OutPutFormatFirstPropertyAsValueAttribute;
                if (format.FirstPropertyAsValue)
                {
                    PropertyInfo subProp = obj.GetType().GetProperties()[0];
                    object subObj = subProp.GetValue(obj, null);
                    WriteValue(subProp, subObj);
                    return;
                }
            }

            if (serializeNulls && (obj == null || obj is DBNull))
                _output.Append("null");



            else if (obj is string || obj is char)
                WriteString((string)obj);


            else if (obj is Guid)
                WriteGuid((Guid)obj);

            else if (obj is bool)
                _output.Append(((bool)obj) ? "true" : "false"); // conform to standard

            else if (
                obj is int || obj is long || obj is double ||
                obj is decimal || obj is float ||
                obj is byte || obj is short ||
                obj is sbyte || obj is ushort ||
                obj is uint || obj is ulong
            )
                _output.Append(((IConvertible)obj).ToString(NumberFormatInfo.InvariantInfo));

            else if (obj is DateTime)
            {

                WriteDateTime(prop, (DateTime)obj);

                //if (ConsiderAsString(prop))
                //{
                //    //WriteString(obj.ToString());
                //    WriteDateTime(prop, (DateTime)obj);
                //}
                //else

            }

            else if (obj is IDictionary<string, string>)
                WriteStringDictionary((IDictionary)obj);

            else if (obj is IDictionary)
                WriteDictionary(prop, (IDictionary)obj);

            else if (obj is DataSet)
                WriteDataset(prop, (DataSet)obj);

            else if (obj is byte[])
                WriteBytes((byte[])obj);

            else if (obj is Array || obj is IList || obj is ICollection)
                WriteArray(prop, (IEnumerable)obj);

            else if (obj is Enum)
            {
                if (ConsiderAsInt(prop))
                    WriteValue(prop, (int)obj);
                else
                    WriteEnum((Enum)obj);
            }

            else
                WriteObject(obj);
        }

        private void WriteEnum(Enum e)
        {
            // TODO : optimize enum write
            WriteStringFast(e.ToString());
        }

        private void WriteGuid(Guid g)
        {
            if (fastguid == false)
                WriteStringFast(g.ToString());
            else
                WriteBytes(g.ToByteArray());
        }

        private void WriteBytes(byte[] bytes)
        {
            WriteStringFast(Convert.ToBase64String(bytes, 0, bytes.Length, Base64FormattingOptions.None));
        }

        private void WriteDateTime(PropertyInfo prop, DateTime dateTime)
        {

            _output.Append("\"");
            _output.Append(dateTime.Day.ToString("00", NumberFormatInfo.InvariantInfo));
            _output.Append("-");
            _output.Append(dateTime.Month.ToString("00", NumberFormatInfo.InvariantInfo));
            _output.Append("-");
            _output.Append(dateTime.Year.ToString("0000", NumberFormatInfo.InvariantInfo));


            bool withInfoTime = true;
            if (prop != null)
            {
                object[] attsDate = prop.GetCustomAttributes(typeof(OutputFormatDateOnlyAttribute), true);
                if (attsDate.GetLength(0) == 1)
                {
                    OutputFormatDateOnlyAttribute att = attsDate[0] as OutputFormatDateOnlyAttribute;
                    if (att.DateOnly)
                    {
                        withInfoTime = false;
                    }
                }

            }
            if (withInfoTime)
            {
                _output.Append(" ");
                _output.Append(dateTime.Hour.ToString("00", NumberFormatInfo.InvariantInfo));
                _output.Append(":");
                _output.Append(dateTime.Minute.ToString("00", NumberFormatInfo.InvariantInfo));
                _output.Append(":");
                _output.Append(dateTime.Second.ToString("00", NumberFormatInfo.InvariantInfo));
            }
            _output.Append("\"");

        }

        private DatasetSchema GetSchema(DataSet ds)
        {
            if (ds == null) return null;

            DatasetSchema m = new DatasetSchema();
            m.Info = new List<string>();
            m.Name = ds.DataSetName;

            foreach (DataTable t in ds.Tables)
            {
                foreach (DataColumn c in t.Columns)
                {
                    m.Info.Add(t.TableName);
                    m.Info.Add(c.ColumnName);
                    m.Info.Add(c.DataType.ToString());
                }
            }
            // TODO : serialize relations and constraints here

            return m;
        }

        private void WriteDataset(PropertyInfo prop, DataSet ds)
        {
            _output.Append('{');
            if (useExtension)
            {
                WritePair(prop, "$schema", useMinimalDataSetSchema ? (object)GetSchema(ds) : ds.GetXmlSchema());
                _output.Append(',');
            }
            foreach (DataTable table in ds.Tables)
            {
                _output.Append('\"');
                _output.Append(table.TableName);
                _output.Append("\":[");
                DataColumnCollection cols = table.Columns;
                foreach (DataRow row in table.Rows)
                {
                    _output.Append('[');

                    bool pendingSeperator = false;
                    foreach (DataColumn column in cols)
                    {
                        if (pendingSeperator) _output.Append(',');
                        WriteValue(prop, row[column]);
                        pendingSeperator = true;
                    }
                    _output.Append(']');
                }

                _output.Append(']');
            }
            // end dataset
            _output.Append('}');
        }

        private void WriteObject(object obj)
        {
            _current_depth++;
            if (_current_depth > _MAX_DEPTH)
                throw new Exception("Serializer encountered maximum depth of " + _MAX_DEPTH);

            _output.Append('{');
            Dictionary<string, string> map = new Dictionary<string, string>();
            Type t = obj.GetType();
            bool append = false;
            if (useExtension)
            {
                WritePairFast("$type", JSON.Instance.GetTypeAssemblyName(t));
                append = true;
            }



            List<Getters> g = JSON.Instance.GetGetters(t);
            foreach (var p in g)
            {
                // cas Property a l'attribut Ignore

                if (!Consider(p.PropertyInfo))
                    continue;
                //	if(p.PropertyInfo.HasAttribute(typeof(JsonOutputIgnore)))

                //if (p.PropertyInfo.GetCustomAttributes(typeof(OutPutFormatIgnoreAttribute), true).GetLength(0) == 1)
                //    continue ; 

                if (append)
                    _output.Append(',');

                WritePair(p, obj);
                object o = p.Getter(obj);
                //    WritePair(p.Name, o);
                if (o != null && useExtension)
                {
                    Type tt = o.GetType();
                    if (tt == typeof(System.Object))
                        map.Add(p.Name, tt.ToString());
                }
                append = true;
            }
            if (map.Count > 0 && useExtension)
            {
                _output.Append(",\"$map\":");
                WriteStringDictionary(map);
            }
            _output.Append('}');
            _current_depth--;
        }

        private void WritePairFast(string name, string value)
        {
            WriteStringFast(name);

            _output.Append(':');

            WriteStringFast(value);
        }

        private void WritePair(Getters g, object parent)
        {
            if (g == null)
                return; 
            object value = g.Getter(parent);
            string formatName = g.Name;

            // Si un attribut est posé, on prend sa valeur
            if (HasAttributeName(g.PropertyInfo))
                formatName = getName(g.PropertyInfo);

            //else if(value is ICollection && (!useExtension))
            //{

            //    //BDS Grosse Magouille pour fournir à Michel le type des éléments du tableau et non pas le nom de la liste
            //    //TODO appliquer les attributs

            //    // ancienne méthode DossierCredit
            //    Type type = value.GetType();


            //    Type elementType;
            //    if(value is Array)
            //        elementType = type.GetElementType();
            //    else
            //        elementType = type.GetGenericArguments()[0];
            //    formatName = elementType.Name;

            //}

            WritePair(g.PropertyInfo, formatName, value);
        }

        private void WritePair(PropertyInfo prop, string name, object value)
        {

            WriteStringFast(name);

            _output.Append(':');

            WriteValue(prop, value);
        }

        private void WriteArray(PropertyInfo prop, IEnumerable array)
        {
            _output.Append('[');

            bool pendingSeperator = false;

            foreach (object obj in array)
            {
                if (pendingSeperator) _output.Append(',');

                if (ConsiderIntAsString(prop))
                    WriteValue(prop, obj.ToString());
                else
                    WriteValue(prop, obj);

                pendingSeperator = true;
            }

            _output.Append(']');
        }

        private void WriteStringDictionary(IDictionary dic)
        {
            _output.Append('{');

            bool pendingSeparator = false;

            foreach (DictionaryEntry entry in dic)
            {
                if (pendingSeparator) _output.Append(',');

                WritePairFast((string)entry.Key, (string)entry.Value);

                pendingSeparator = true;
            }

            _output.Append('}');
        }

        private void WriteDictionary(PropertyInfo prop, IDictionary dic)
        {
            _output.Append('[');

            bool pendingSeparator = false;

            foreach (DictionaryEntry entry in dic)
            {
                if (pendingSeparator) _output.Append(',');

                _output.Append('{');
                WritePair(prop, "k", entry.Key);
                _output.Append(",");
                WritePair(prop, "v", entry.Value);
                _output.Append('}');

                pendingSeparator = true;
            }
            _output.Append(']');
        }

        private void WriteStringFast(string s)
        {
            _output.Append('\"');
            _output.Append(s);
            _output.Append('\"');
        }

        private void WriteString(string s)
        {
            _output.Append('\"');

            int runIndex = -1;

            for (var index = 0; index < s.Length; ++index)
            {
                var c = s[index];

                if (c >= ' ' && c < 128 && c != '\"' && c != '\\' && c != '\'')
                {
                    if (runIndex == -1)
                    {
                        runIndex = index;
                    }

                    continue;
                }

                if (runIndex != -1)
                {
                    _output.Append(s, runIndex, index - runIndex);
                    runIndex = -1;
                }

                switch (c)
                {
                    case '\t': _output.Append("\\t"); break;
                    case '\r': _output.Append("\\r"); break;
                    case '\n': _output.Append("\\n"); break;
                    case '"':
                    case '\'':
                    case '\\': _output.Append('\\'); _output.Append(c); break;
                    default:
                        _output.Append(c);
                        //_output.Append("\\u");
                        //_output.Append(((int)c).ToString("X4", NumberFormatInfo.InvariantInfo));
                        break;
                }
            }

            if (runIndex != -1)
            {
                _output.Append(s, runIndex, s.Length - runIndex);
            }

            _output.Append('\"');
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Encode\JsonXmlEncoder.cs">
    <content><![CDATA[using System;
using System.Text;
using System.Xml;

namespace pdb.util.Generic.Encode
{
    public class JsonXmlEncoder
    {
        private StringBuilder sb;
        public String encode(XmlNode xml)
        {
            sb = new StringBuilder();
            _encode(xml);
            return sb.ToString();
        }

        private void _encode(XmlNode xml)
        {
            if (xml is XmlElement)
            {
                if (xml.FirstChild is XmlElement)
                {
                    sb.Append("{");
                    for (int i = 0; i < xml.ChildNodes.Count; i++)
                    {
                        XmlNode sub = xml.ChildNodes[i];
                        if (sub is XmlElement)
                        {
                            sb.Append("\"");
                            sb.Append(sub.Name);
                            sb.Append("\"");
                            sb.Append(":");

                        }
                        _encode(sub);
                        if (i < xml.ChildNodes.Count - 1)
                            sb.Append(",");
                    }
                    sb.Append("}");
                }
                else
                {

                    sb.Append("\"");
                    sb.Append(xml.InnerText);
                    sb.Append("\"");

                }


            }




        }


    }
}

]]></content>
  </file>
  <file path="\pdb.util\Generic\Encode\SafeDictionary.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;

namespace pdb.util.Generic.Encode
{
    internal class SafeDictionary<TKey, TValue>
    {
        private readonly object _Padlock = new object();
        private readonly Dictionary<TKey, TValue> _Dictionary = new Dictionary<TKey, TValue>();


        public bool TryGetValue(TKey key, out TValue value)
        {
            return _Dictionary.TryGetValue(key, out value);
        }

        public TValue this[TKey key]
        {
            get
            {
                return _Dictionary[key];
            }
        }
        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
            return ((ICollection<KeyValuePair<TKey, TValue>>)_Dictionary).GetEnumerator();
        }

        public void Add(TKey key, TValue value)
        {
            lock (_Padlock)
            {
                if (_Dictionary.ContainsKey(key) == false)
                    _Dictionary.Add(key, value);
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\DbParser.cs">
    <content><![CDATA[using System;
using System.Data;
using pdb.util.Generic.Attributs.Db;
using pdb.util.Generic.Parse;

namespace pdb.util.Generic.Parse
{
	/// <summary>
	/// Parseur permettant de construire des objets à partir d'une base de données
	/// </summary>
	public class DbParser : Parser
	{

		public override void setDefaultAttributes()
		{
			base.setDefaultAttributes();
			addExclusion(typeof(DbIgnore));
			addExclusion(typeof(DbInputIgnore));

			addAttributeName(typeof(DbNameAttribute));
			addAttributeName(typeof(DbInputNameAttribute));

		}
		/// <summary>
		/// Remplit l'objet value depuis un DataSet
		/// </summary>
		/// <param name="o"></param>
		/// <param name="ds"></param>
		public void Fill(Object o, DataSet ds)
		{
			var wrapper = new DbDataSet(ds);

			Fill_(o, wrapper);
			logger.log(wrapper.OuterXml);
		}

		/// <summary>
		/// Remplit un objet ou une collection d'objet depuis une table
		/// </summary>
		/// <param name="o"></param>
		/// <param name="dt"></param>
		public void Fill(Object o, DataTable dt)
		{
			var wrapper = new DbTable(dt);
			Fill_(o, wrapper); 
		}

	}
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\DbWrapper.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Data;
using pdb.util.Generic;

namespace pdb.util.Generic.Parse
{
	/// <summary>
	/// Enveloppe de champ de BDD
	/// </summary>
	class DbField : Node
	{
		string name = "";
		object content = DBNull.Value;

		public DbField() { }
		public DbField(string name, object content) { this.name = name; this.content = content; }

		
		#region INode Membres

		public override string Name
		{
			get { return name; }
		}
		public override string OuterXml
		{
			get { return string.Format("<{0}>{1}</{0}>", name, content); }
		}
		#endregion
		#region Node Membres
		protected override object parse()
		{
			if(content == null)
				return null;
			if(content is DBNull)
				return null;
			if(type == typeof(string))
				return content;
			if(content.ToString().Trim().Equals(string.Empty))
				return null;
			if(type == typeof(bool) || type == typeof(bool?))
				return getBool(content.ToString());
			if(type == typeof(int) || type == typeof(int?))
				return Convert.ToInt32(content);
			if(type == typeof(Int64) || type == typeof(Int64?))
				return Convert.ToInt64(content);
			if(type == typeof(double) || type == typeof(double?))
				return Convert.ToDouble(content);
			if(type == typeof(float) || type == typeof(float?))
				return Convert.ToSingle(content);
			return content;
		}
		#endregion
	}


	/// <summary>
	/// Enveloppe de ligne de base de données
	/// </summary>
	class DbRow : Node
	{
		private DataRow row;
		public DbRow(DataRow row)
		{
			this.row = row;
		}

		#region INode Membres


		public override string Name
		{
			get { return row.Table.TableName; }
		}

		public override ICollection<INode> ChildNodes
		{
			get
			{
				var list = new List<INode>();
				object[] datas = row.ItemArray;
				for(int i=0; i< datas.GetLength(0); i++)
				{
					//var type = row.Table.Columns[i].DataType; 
					DbField field = new DbField(row.Table.Columns[i].ColumnName, datas[i]);
					list.Add(field);
				}

				return list;

			}
		}


		#endregion
	}

	/// <summary>
	/// Enveloppe de Table de Bdd
	/// </summary>
	class DbTable : Node
	{
		private DataTable dt;
		public DbTable(DataTable dt)
		{
			this.dt = dt;
		}

		#region INode Membres



		public override string Name
		{
			get { return "tab_" + dt.TableName; }
		}

		public override ICollection<INode> ChildNodes
		{
			get
			{
				var list = new List<INode>();
				foreach(DataRow row in dt.Rows)
				{
					list.Add(new DbRow(row));
				}
				return list;

			}
		}



		#endregion
	}

	/// <summary>
	/// Enveloppe de DataSet
	/// </summary>
	class DbDataSet : Node
	{
		private DataSet ds;
		//	private string name;

		public DbDataSet(DataSet ds)
		{
			this.ds = ds;
		}

		#region INode Membres



		public override string Name
		{
			get { return "tables"; }
		}


		public override ICollection<INode> ChildNodes
		{
			get
			{
				var list = new List<INode>();
				foreach(DataTable table in ds.Tables)
				{
					list.Add(new DbTable(table));
				}
				return list;
			}
		}



		#endregion
	}
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\JsonParser.cs">
    <content><![CDATA[using System;
using pdb.util.Generic.Attributs.Json;
using System.Text.RegularExpressions;
using System.Globalization;
using pdb.util.Generic.Parse;
using pdb.util.Generic.Parse.Json;

namespace pdb.util.Generic.Parse
{
   public class JsonParser : Parser
    {
       public JsonParser()
           : base()
       {
           this.manageListsWithArbo = true; 
       }

       //public void sDoubleFormatProvider(IFormatProvider provider)
       //{
       //    JsonWrapper.DoubleFormatProvider = provider; 
       //}

       public JsonParser(ILogger logger)
           : base(logger)
       {
           manageListsWithArbo = true; 
       }
       public override void setDefaultAttributes()
       {
           base.setDefaultAttributes();

           base.setDefaultAttributes();
           addExclusion(typeof(JsonIgnore));
           addExclusion(typeof(JsonInputIgnore));

           addAttributeName(typeof(JsonName));
           addAttributeName(typeof(JsonInputName));
       }


       /// <summary>
       /// Remplit l'objet value depuis le json correspondant
       /// </summary>
       /// <param name="o"></param>
       /// <param name="xml"></param>
       public void Fill(Object o, string json)
       {
           try
           {
               json = Regex.Replace(json,
                      @"\\u(?<Value>[a-zA-Z0-9]{4})",
                m =>
                {
                    return ((char)int.Parse(m.Groups["Value"].Value, NumberStyles.HexNumber)).ToString();
                });

           }
           catch
           {
           }



           JsonBuilder builder = new JsonBuilder(json);
           JsonWrapper wrapper = builder.build(); 

           Fill_(o, wrapper); 
       }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\Node.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Text;
using pdb.util.Generic;

namespace pdb.util.Generic.Parse
{
	/// <summary>
	/// Implémentation partielle de INode
	/// </summary>
	public abstract class Node : INode
	{
		/// <summary>
		/// Type du champ
		/// </summary>
		protected Type type = typeof(string);
		public Type Type { set { type = value; } get { return type; } }

		/// <summary>
		/// Nom du champ
		/// </summary>
		public abstract string Name { get; }

		/// <summary>
		/// Récupération du contenu du noeud en fonction du type
		/// </summary>
		protected virtual object parse()
		{
            return null; // throw new NotImplementedException("only for leafs");
		}

		public object Content { get { return parse(); } }
        public virtual ICollection<INode> ChildNodes
		{
			get { return new List<INode>(); }
		}
		/// <summary>
		/// représentation Xml de la donnée pour logs
		/// </summary>
		public virtual string OuterXml
		{
			get
			{
				StringBuilder sb = new StringBuilder();
				sb.Append("<");
				sb.Append(Name);
				sb.Append(">");
				foreach(Node node in ChildNodes)
					sb.Append(node.OuterXml);
				sb.Append("</");
				sb.Append(Name);
				sb.Append(">");

				return sb.ToString();
			}
		}

     


		/// <summary>
		/// Conversion de la chaîne en booléen
		/// </summary>
		/// <param name="node"></param>
		/// <returns></returns>
		protected static Boolean toBool(string content)
		{
			if(content ==null)
				throw new ArgumentNullException(); 

			switch(content.ToUpper().Trim())
			{
				case "O":
				case "Y":
				case "TRUE":
				case "1":
					return true;
				case "N":
				case "FALSE":
				case "0":
				case "-1":
					return false;
				default:
					throw new ArgumentException("impossible de convertir '" + content + "' en booléen");
			}

		}

        protected static bool? getBool(string content)
        {
            if (string.IsNullOrEmpty(content))
                return null; 
            switch(content.ToLower().Trim())
            {
                case "na" : case "n/a" : return null;
                default: return toBool(content); 
            }
        }

		public override string ToString()
		{
			return OuterXml;
		}

	}

	
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\Parser.cs">
    <content><![CDATA[using System;
using System.Reflection;
using System.Text;
using pdb.util.Generic;
using pdb.util.Generic.Attributs;
using pdb.util.Generic;
using pdb.util;

namespace pdb.util.Generic.Parse
{
    /// <summary>
    /// Exception parser
    /// </summary>
    public class ParserException : ApplicationException
    {
        public ParserException(string msg, Exception inner) : base(msg, inner) { }
    }

    /// <summary>
    /// Exception parser Overflow
    /// </summary>
    public class ParseOverflowException : ApplicationException
    {
        public readonly string value;
        public readonly string nodeName;
        public readonly object max;


        public ParseOverflowException(string value, string nodeName, Object max)
            : base()
        {
            this.nodeName = nodeName;
            this.value = value;
            this.max = max; 

        }
    }

    /// <summary>
    /// Exception parser Forma
    /// </summary>
    public class ParseFormatException : ApplicationException
    {
        public readonly string value;
        public readonly string nodeName;

        public ParseFormatException(string value, string nodeName)
            : base()
        {
            this.nodeName = nodeName;
            this.value = value;

        }
    }




    /// <summary>
    /// Construit une Value à partir d'une source de donnée
    /// </summary>
    public abstract class Parser : ParserBase
    {

        public override void setDefaultAttributes()
        {
            base.setDefaultAttributes();
            addExclusion(typeof(InputIgnore));
            addAttributeName(typeof(InputNameAttribute));
        }


        public Parser(ILogger logger)
            : base(logger)
        {

        }

        public Parser()
            : base()
        {

        }


        /// <summary>
        /// Remplissage de l'objet avec les données du noeud correspondant
        /// </summary>
        /// <param name="o"></param>
        /// <param name="node"></param>
        protected void Fill_(Object o, INode node)
        {
            Dictionary<object> unknowNodes = new Dictionary<object>();
            Type oType = o.GetType();

            #region traitement particulier OutPutFormatFirstPropertyAsValueAttribute
            object[] attCoquille = oType.GetCustomAttributes(typeof(OutPutFormatFirstPropertyAsValueAttribute), true);
            if (attCoquille.GetLength(0) == 1)
            {
                OutPutFormatFirstPropertyAsValueAttribute att = attCoquille[0] as OutPutFormatFirstPropertyAsValueAttribute;
                if (att.FirstPropertyAsValue)
                {
                    PropertyInfo prop0 = oType.GetProperties()[0];
                    node.Type = prop0.PropertyType;
                    object value = node.Content;
                    prop0.SetValue(o, value, null);
                    return;
                }
            }
            #endregion

            TypeInfo oTypeInfo = new TypeInfo(oType);

            if (oTypeInfo.IsPrimary)
            {
                throw new ArgumentException("l'objet " + o + " est primaire");
            }

            if (oTypeInfo.IsList)
            {
                //remplissage de la collection 
                TypeInfo subInfo = new TypeInfo(oTypeInfo.SubType);
                object subObj = null;
                foreach (INode subNode in node.ChildNodes)
                {
                    subNode.Type = subInfo.Type;
                    if (subInfo.IsPrimary)
                        subObj = subNode.Content;
                    else
                    {
                        subObj = Activator.CreateInstance(subInfo.Type);
                        Fill_(subObj, subNode);
                    }

                    //ajout du sous-objet à la liste 
                    oTypeInfo.Add(o, subObj);


                }
                return;
            }

            //Cas général : on parse un objet 

            //table de correspondance nom du noeud -> information de type + éventuellement instance de liste générique
            Dictionary<PropInfo> dict = new Dictionary<PropInfo>();

            // Scan des propriétés de l'objet et remplissable des tables de correspondance
            foreach (PropertyInfo prop in oType.GetProperties())
            {
                string name = prop.Name;
                try
                {
                    // Changement du nom de la propriété si précisé dans les attributs
                    name = getName(prop);
                    PropInfo propInfo = new PropInfo(prop);
                    dict.Add(name, propInfo);

                    // Si la propiété est une liste (de sous-objets) on instancie une liste vide
                    if (propInfo.IsList)
                    {
                        prop.SetValue(o, propInfo.getListInstance(), null);
                    }
                }
                catch (Exception ex)
                {
                    string err = "impossible d'ajouter la propriété " + name + " à l'objet " + o.GetType().FullName + " " + node.OuterXml;
                    logger.Error(err, ex);
                    throw new ParserException(err, ex);
                }
            }

            // parcours du noeud
            foreach (INode childNode in node.ChildNodes)
            {
                try
                {
                    if (childNode.Name != null && dict.ContainsKey(childNode.Name) || o is IExtend)
                    {
                        if (!dict.ContainsKey(childNode.Name))
                        {
                            (o as IExtend).addExtend(childNode);
                        }
                        else
                    {
                        PropInfo childInfo = dict[childNode.Name];
                        childNode.Type = childInfo.Type;
                        //String strValue = subXml.InnerText;
                        if (childInfo.IsPrimary)
                        {
                            // valeur simple (int, double?, datetime?, string)

                            object value = childNode.Content; // parse(xmlInfo.Type, subXml);
                            childInfo.Property.SetValue(o, value, null);

                        }
                        else if (childInfo.IsList)
                        {
                            if (fillLists)
                            {
                                TypeInfo subInfo = new TypeInfo(childInfo.SubType);
                                object subObj = null;
                                if (!manageListsWithArbo)
                                {
                                    // Dans le xml reçu les objets de liste sont en vrac. 
                                    // on récupère malheureusement les éléments putôt que les listes
                                    // cas DC : les limites ne sont pas contenues dans une balise limites
                                    //creation d'un objet contenu dans la liste

                                    childNode.Type = subInfo.Type;
                                    if (subInfo.IsPrimary)
                                        subObj = childNode.Content; //  parse(subInfo.Type, subXml);
                                    else
                                    {
                                        subObj = Activator.CreateInstance(subInfo.Type);
                                        Fill_(subObj, childNode);
                                    }

                                    //ajout du sous-objet à la liste
                                    childInfo.Add(subObj);

                                }
                                else
                                {
                                    // cas standard <Deals><Deal>...</Deal><Deal>...</Deal></Deals>
                                    Fill_(childInfo.getListInstance(), childNode);
                                }
                            }

                        }
                        else
                        {
                            // objet complexe de type Value==> appel récursif
                            object subObj = Activator.CreateInstance(childInfo.Type);
                            Fill_(subObj, childNode);
                            childInfo.Property.SetValue(o, subObj, null);
                        }
                    }
                    }
                    else
                    {
                        string name = childNode.Name ?? "";
                        // noeud ignoré
                        if (!unknowNodes.ContainsKey(name))
                            unknowNodes.Add(name, childNode.ToString());
                    }

                }
                catch (ParseOverflowException ex)
                {
                    throw ex;
                }
                catch (Exception ex)
                {

                    string outerXml = childNode.OuterXml;
                    string err = "impossible de parser le noeud:" + childNode.Name + " " + outerXml;
                    logger.Error(err, ex);
                    throw new ParserException(err, ex);
                }
            }

            if (unknowNodes.Count > 0)
            {
                StringBuilder sbUnknow = new StringBuilder();
                sbUnknow.Append(o.GetType().Name);
                sbUnknow.Append(":");
                sbUnknow.Append("noeuds ignorés:");
                foreach (string unkownNode in unknowNodes.Keys)
                {
                    sbUnknow.Append(unkownNode);
                    sbUnknow.Append("|");
                }
                logger.log(sbUnknow.ToString());

            }



        }



        /// <summary>
        /// Remplissage d'une collection (liste ou tableau)
        /// </summary>
        /// <param name="o"></param>
        /// <param name="xml"></param>
        //private static void FillCollection(ICollection o, XmlNode xml)
        //{
        //    try
        //    {
        //        Type type = o.GetType();
        //        Type nestedType;

        //        if (o is Array)
        //        {
        //            nestedType = type.GetElementType();
        //        }
        //        else
        //        {
        //            nestedType = type.GetGenericArguments()[0];
        //        }

        //        ArrayList aux = new ArrayList();
        //        foreach (XmlNode xmlSub in xml.ChildNodes)
        //        {
        //            object subObj = null;
        //            if (isPrimary(nestedType))
        //            {
        //                subObj = parse(nestedType, xmlSub.InnerText);
        //            }
        //            else
        //            {
        //                subObj = Activator.CreateInstance(nestedType);
        //                Fill_(subObj, xmlSub);
        //            }
        //            aux.Add(subObj);
        //        }

        //        if (o is Array)
        //        {
        //            aux.CopyTo(o as Array);
        //        }
        //        else
        //        {
        //            foreach (object sub in aux)
        //            {
        //                MethodInfo mi = type.GetMethod("Add");
        //                mi.Invoke(o, new Object[] { sub });
        //            }
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        logDossier.Error(String.Format("impossible de parser la collection {0}", xml.OuterXml), e);
        //        Console.WriteLine("impossible de parser la collection {0} {1}", xml.OuterXml, e.ToString());
        //    }
        //}
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\ParserBase.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Reflection;
using pdb.util.Generic.Attributs;

namespace pdb.util.Generic.Parse
{
    /// <summary>
    /// Boite à outils des parseurs et sérialiseurs : principalement gestion des noeuds ignorés ou dont le nom change.
    /// </summary>
    public class ParserBase
    {
        protected ILogger logger; 
        /// <summary>
        /// gère les listes de sous éléments regroupés dans une balise intermédiaire (true) ou à non (false) dans le xml
        /// </summary>
        protected bool manageListsWithArbo = false;
        /// <summary>
        /// remplit également les listes de sous-objets
        /// </summary>
        protected bool fillLists = true;

        /// <summary>
        /// Liste des attributs permettant d'ignorer un champ
        /// </summary>
        private List<Type> Exclusions = new List<Type>();

        /// <summary>
        /// Liste des attributs permettant d'ignorer un champ lors de l'update
        /// </summary>
        private List<Type> UpdateExclusions = new List<Type>();

        /// <summary>
        /// Nécessité d'avoir un des attributs pour prendre en compte un champ
        /// </summary>
        private List<Type> Recommandations = new List<Type>();


        /// <summary>
        /// Liste des attributs pris en compte pour le changement de nom d'un champ
        /// </summary>
        private List<Type> AttributesNames = new List<Type>();

        /// <summary>
        /// Liste des attributs pris en compte pour la conversion d'une enumération en entier
        /// </summary>
        private List<Type> EnumAsInts = new List<Type>();

        /// <summary>
        /// Liste des attributs pris en compte pour la conversion d'une DateTime en string
        /// </summary>
        private List<Type> DateTimeAsStrings = new List<Type>();

        private List<Type> IntAsString = new List<Type>();

        private List<Type> customs = new List<Type>(); 

        /// <summary>
        /// Initialisation des attributs pris en compte
        /// </summary>
        virtual public void setDefaultAttributes()
        {
            clearAttributes();
            addExclusion(typeof(Ignore));
            addAttributeName(typeof(NameAttribute));
            addEnumAsInt(typeof(EnumAsIntAttribute));
            addDateTimeAsString(typeof(DateTimeAsString));
            addIntAsString(typeof(IntAsString));
        }

        private void checkLogger()
        {
            if (this.logger == null)
                logger = pdb.util.Logger.getLogger("Parser"); 
        }

        public ParserBase(ILogger logger)
        {
            this.logger = logger;

            if (this.logger == null)
                this.logger = pdb.util.Logger.getLogger("Parser"); 
            setDefaultAttributes();
        }

        public ParserBase()
            : this(null)
        {
        }


        public void clearAttributes()
        {
            clearUpdateExclusions(); 
            clearExclusions();
            clearAttributeNames();
            clearDateTimeAsString();
            clearEnumAsInt();
            clearRecommandations();
            clearIntAsString();
        }


        public ILogger Logger { set { logger = value; } }
        public bool ManageListsWithArbo { get { return manageListsWithArbo; } set { manageListsWithArbo = value; } }
        public bool FillLists { set { fillLists = value; } }

        /// <summary>
        /// Ajout d'un type d'attribut pris en compte pour ignorer un champ
        /// </summary>
        /// <param name="type"></param>
        public void addExclusion(Type type)
        {
            if (!Exclusions.Contains(type))
                Exclusions.Add(type);
        }

        /// <summary>
        /// Ajout d'un type d'attribut pris en compte pour ignorer un champ lors de la mise à jour
        /// </summary>
        /// <param name="type"></param>
        public void addUpdateExclusion(Type type)
        {
            if (!UpdateExclusions.Contains(type))
                UpdateExclusions.Add(type);
        }

        /// <summary>
        /// Suppression de tous les types d'attributs permettant d'ignorer un champ
        /// </summary>
        public void clearExclusions()
        {
            Exclusions.Clear();
        }

        public void clearUpdateExclusions()
        {
            UpdateExclusions.Clear(); 
        }

        /// <summary>
        /// Ajout d'un type d'attribut pris en compte pour renommer un champ
        /// </summary>
        /// <param name="type"></param>
        public void addAttributeName(Type type)
        {
            if (!AttributesNames.Contains(type))
            {
                if (type.GetInterface(typeof(IAttributeName).Name) != null)
                    AttributesNames.Add(type);
                else
                    throw new ArgumentException("on doit ajouter un attribut de type IAttributeName");
            }
        }


        public void addEnumAsInt(Type type)
        {
            if (!EnumAsInts.Contains(type))
                EnumAsInts.Add(type);
        }

        public void clearEnumAsInt()
        {
            EnumAsInts.Clear();
        }

        public void clearIntAsString()
        {
            IntAsString.Clear();
        }

        public void addDateTimeAsString(Type type)
        {
            if (!DateTimeAsStrings.Contains(type))
                DateTimeAsStrings.Add(type);
        }
        public void addIntAsString(Type type)
        {
            if (!IntAsString.Contains(type))
                IntAsString.Add(type);
        }

        public void clearDateTimeAsString()
        {
            DateTimeAsStrings.Clear();
        }

        /// <summary>
        /// Suppression de tous les types d'attributs permettant de renommer un champ
        /// </summary>
        public void clearAttributeNames()
        {
            AttributesNames.Clear();
        }


        /// <summary>
        /// Ajout d'un attribut permettant d'inclure des champs
        /// </summary>
        /// <param name="type"></param>
        public void addRecommandation(Type type)
        {
            if (!Recommandations.Contains(type))
                Recommandations.Add(type);
        }

        public void clearRecommandations()
        {
            Recommandations.Clear();
        }


        /// <summary>
        /// Récupération du nom modifié
        /// </summary>
        /// <param name="mem">Membre considéré</param>
        /// <remarks>On parcourt tous les types déclarés. le dernier (le plus spécifique) l'emporte</remarks>
        /// <returns></returns>
        public string getName(MemberInfo mem)
        {
            string name = mem.Name;
            foreach (Type type in AttributesNames)
            {
                string aux = AttributeHelper.CustomName(mem, type);
                if (aux != mem.Name)
                    name = aux;
            }
            return name;
        }

        //public string getName(PropInfo prop)
        //{
        //    string name = prop.Name;
        //    string aux = getName(prop.Property);
        //    if (aux != name)
        //        return name;
        //    return getName(prop.Type);
        //}



        /// <summary>
        /// Existe-t-il un attribut de nom ? 
        /// </summary>
        /// <param name="mem"></param>
        /// <returns></returns>
        public bool HasAttributeName(MemberInfo mem)
        {
            foreach (Type type in AttributesNames)
            {
                if (AttributeHelper.HasAttribute(mem, type))
                    return true;
            }
            return false;
        }

        public bool Consider(MemberInfo mem)
        {
            return Consider(mem, false); 
        }

        /// <summary>
        /// Prise en compte d'un champ
        /// </summary>
        /// <param name="prop"></param>
        /// <returns>true:on gère, false, on ignore le champ</returns>
        public bool Consider(MemberInfo prop, bool update)
        {
            bool _consider = true;

            // Dès la premiere exclusion rencontrée on ne prend pas en compte
            foreach (Type exclu in Exclusions)
            {
                if (AttributeHelper.HasAttribute(prop, exclu)) //if(prop.HasAttribute(exclu))				
                    return false;
            }

            if (update)
            {
                foreach (Type exclu in UpdateExclusions)
                {
                    if (AttributeHelper.HasAttribute(prop, exclu)) //if(prop.HasAttribute(exclu))				
                        return false;
                }
            }

            // si un ou plusieurs attributs recommandés, on ne prend pas en compte par défaut
            if (Recommandations.Count > 0)
            {
                _consider = false;
                foreach (Type oblig in Recommandations)
                {
                    // Dès la premiere recommendation rencontrée on permet la prise en compte du champ
                    if (AttributeHelper.HasAttribute(prop, oblig))
                    //if(prop.HasAttribute(oblig))
                    {
                        return true;
                    }
                }
            }
            return _consider;
        }

        public bool ConsiderIntAsString(MemberInfo mem)
        {
            foreach (Type transform in IntAsString)
            {
                if (AttributeHelper.HasAttribute(mem, transform))
                    return true;
            }
            return false;
        }


        public bool ConsiderAsInt(MemberInfo mi)
        {

            foreach (Type enumAsInt in EnumAsInts)
            {
                if (AttributeHelper.HasAttribute(mi, enumAsInt)) //if(prop.HasAttribute(exclu))				
                    return true;
            }
            return false;

        }

        public bool ConsiderAsString(MemberInfo mi)
        {
            foreach (Type DateTimeAsString in DateTimeAsStrings)
            {
                if (AttributeHelper.HasAttribute(mi, DateTimeAsString)) //if(prop.HasAttribute(exclu))				
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Dictionnaire dont les clés string ne sont pas sensibles à la casse
        /// </summary>
        /// <typeparam name="T"></typeparam>
        protected class Dictionary<T>
        {
            private Dictionary<string, T> dict = new Dictionary<string, T>();
            public void Add(string key, T info)
            {
                dict.Add(getKey(key), info);
            }

            public bool ContainsKey(string key)
            {
                return dict.ContainsKey(getKey(key));
            }
            public T this[string key]
            {
                get
                {
                    return dict[getKey(key)];
                }
            }
            private static string getKey(string key)
            {
                return key.Trim().ToLower();
            }
            public int Count
            {
                get { return dict.Count; }
            }
            public Dictionary<string, T>.KeyCollection Keys
            {
                get
                {
                    return dict.Keys;
                }
            }
        }

    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\XmlParser.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.util.Generic.Attributs.Xml;
using System.Globalization;
using pdb.util;
using pdb.util.Generic.Parse;

namespace pdb.util.Generic.Parse
{
	/// <summary>
	/// Helper permettant de construire des collections d'objets à partir d'une collection de noeuds Xml
	/// </summary>
	/// <typeparam name="T"></typeparam>
	public class XmlParserGen<T> where T : new()
	{
		private ILogger logger;
		XmlParser parser;

        public XmlParserGen(ILogger logger)
		{
			this.logger = logger;
			parser = new XmlParser(logger);
		}

		/// <summary>
		/// Renvoi d'une collection avec interruption en cas d'erreur
		/// </summary>
		/// <param name="xml"></param>
		/// <returns></returns>
		public List<T> getCollection(XmlNodeList xml)
		{
			return getCollection(xml, false);
		}

		/// <summary>
		/// Création d'un collection
		/// </summary>
		/// <param name="xml"></param>
		/// <param name="continueAfterError">si true, on continue (adapté aux traitements Batch)</param>
		/// <returns></returns>
		public List<T> getCollection(XmlNodeList xml, bool continueAfterError)
		{
			List<T> list = new List<T>();
			for(int i = 0; i < xml.Count; i++)
			{
				XmlNode subXml = xml[i];
				T item = new T();
				try
				{
					parser.Fill(item, subXml);
				}
				catch(Exception e)
				{
					logger.Error("impossible de parser le noeud n°{0} {1}", i, subXml.InnerXml, e);
					if(continueAfterError)
					{
						continue;
					}
					throw;

				}
				list.Add(item);
			}
			return list;
		}

	}

	/// <summary>
	/// Parseur Xml pour constitution des objets à l'aide de leur représentation xml 
	/// </summary>
	public class XmlParser : Parser
	{
		public XmlParser() : base() { }
		public XmlParser(ILogger logger) : base(logger) { }

		/// <summary>
		/// Ajout des attributs par défaut
		/// </summary>
		public override void setDefaultAttributes()
		{
			base.setDefaultAttributes();
			addExclusion(typeof(XmlIgnore));
			addExclusion(typeof(XmlInputIgnore));

			addAttributeName(typeof(XmlNameAttribute));
			addAttributeName(typeof(XmlInputNameAttribute));

            XmlWrapper.DateFormatProvider = new CultureInfo("fr-FR");

		}

		/// <summary>
		/// Remplit l'objet value depuis le noeud xml correspondant
		/// </summary>
		/// <param name="o"></param>
		/// <param name="xml"></param>
		public void Fill(Object o, XmlNode xml)
		{
			Fill_(o, new XmlWrapper(xml, logger));
		}

		/// <summary>
		/// Helper réaliser le parsing d'un champ Date
		/// </summary>
		/// <param name="xml"></param>
		/// <returns></returns>
		public DateTime? toDateNullable(XmlNode xml)
		{
			var wrapper = new XmlWrapper(xml, null);
			return wrapper.toDateNullable();
		}

	}

}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\XmlSerializer.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Linq;
using pdb.util.Generic.Attributs;
using pdb.util.Generic.Attributs.Xml;
using pdb.util.Generic.Parse;

namespace pdb.util.Generic.Parse
{
    /// <summary>
    /// Sérialise un objet au format Xml
    /// </summary>
    public class XmlSerializer : ParserBase
    {

        /// <summary>
        /// affichage des types primaires
        /// </summary>
        private bool withType;
        public bool WithInfoType { get { return withType; } set { withType = value; } }

        private bool clearEmpy;
        public bool ClearEmpy { get { return clearEmpy; } set { clearEmpy = value; } }

        private bool includeDeclaration = true;
        public bool IncludeDeclaration { get { return includeDeclaration; } set { includeDeclaration = value; } }

        private string dtFormat;
        public string DateFormat { get { return dtFormat; } set { dtFormat = value; } }

        private string oldDateFormat;
        public string OldDatFormat { get { return oldDateFormat; } set { oldDateFormat = value; } }

        private bool dtFormatIso;
        public bool DateFormatIso { get { return dtFormatIso; } set { dtFormatIso = value; } }

        private NumberFormatInfo nfi;



        public override void setDefaultAttributes()
        {
            base.setDefaultAttributes();
            addExclusion(typeof(OutputIgnore));
            addExclusion(typeof(XmlIgnore));
            addExclusion(typeof(XmlOutputIgnore));

            addAttributeName(typeof(OutputNameAttribute));
            addAttributeName(typeof(XmlNameAttribute));
            addAttributeName(typeof(XmlOutputNameAttribute));
        }


        /// <summary>
        /// Par défaut on ne prend pas en compte l'attribut OutPutXmlIgnore
        /// </summary>
        public XmlSerializer() : base() { }

        public NumberFormatInfo NumberFormatInfo { get { return nfi; } set { nfi = value; } }



        /// <summary>
        /// Renvoie le document correspondant à l'objet
        /// </summary>
        /// <param name="value">objet à sérialiser</param>
        /// <param name="withType">affichage des types primaires</param>
        /// <returns>document Xml de l'objet</returns>
        /// 
        public XmlDocument Serialize(object value)
        {
            XmlDocument doc = new XmlDocument() { PreserveWhitespace = false };
            if (includeDeclaration)
            {
                var declaration = doc.CreateXmlDeclaration("1.0", Encoding.UTF8.BodyName, null);
                doc.AppendChild(declaration);
            }

            string name = getName(value.GetType());
            var root = doc.CreateElement(name);
            doc.AppendChild(root);
            Serialize(doc, root, value, false);
            return doc;
        }

        /// <summary>
        /// Renvoi le contenu Xml de l'objet correctement formaté
        /// </summary>
        /// <param name="value">objet à sérialiser</param>
        /// <param name="withType">affichage des types primaires</param>
        /// <returns>contenu Xml</returns>
        /// <remarks>le Xml obtenu nativement est insatisfaisant car trop verbeux et peu lisible: 
        /// les balises vides sont rendues avec un saut de ligne</remarks>
        public string SaveXml(object value)
        {

            var doc = Serialize(value);
            return FormatXml(doc);

        }

        public static string FormatXml(XmlDocument doc)
        {
            //doc.CreateXmlDeclaration("1.0", Encoding.UTF8.ToString(), null); 
            doc.PreserveWhitespace = false;
            MemoryStream ms = new MemoryStream();

            doc.Save(ms); ms.Position = 0;
            string content;

            using (StreamReader sr = new StreamReader(ms))
            {
                content = sr.ReadToEnd();
            }

            content = Regex.Replace(content, @"<([^\/]*)>\r\n\W*</(.*)>", delegate(Match m)
            {
                string un = m.Groups[1].Value;
                string deux = m.Groups[2].Value;
                return "<" + un + "></" + deux + "/>";
            });
            content = Regex.Replace(content, @"<(.*)></.*>", "<$1 />");

            return content;
        }

        public void Serialize(XmlDocument doc, XmlNode parent, object value)
        {
            Serialize(doc, parent, value, false);
        }

        /// <summary>
        /// Sérialisation progressive d'un objet
        /// </summary>
        /// <param name="doc">document Xml de l'objet</param>
        /// <param name="parent">Noeud courant</param>
        /// <param name="withType">affichage des types primaires</param>
        /// <param name="value">objet à sérialiser</param>
        public XmlNode Serialize(XmlDocument doc, XmlNode parent, object value, bool createParent)
        {


            if (value == null)
            {
                return null;
            }
            System.Type type = value.GetType();
            TypeInfo typeInfo = new TypeInfo(type);

            #region traitement particulier OutPutFormatFirstPropertyAsValueAttribute
            object[] attCoquille = type.GetCustomAttributes(typeof(OutPutFormatFirstPropertyAsValueAttribute), true);
            if (attCoquille.GetLength(0) == 1)
            {
                OutPutFormatFirstPropertyAsValueAttribute att = attCoquille[0] as OutPutFormatFirstPropertyAsValueAttribute;
                if (att.FirstPropertyAsValue)
                {
                    PropertyInfo prop0 = type.GetProperties()[0];
                    PropInfo p = new PropInfo(prop0);

                    writeProp(doc, p, parent as XmlElement, prop0.GetValue(value, null));

                    return parent;
                }
            }
            #endregion

            XmlNode _parent = parent;

            if (typeInfo.IsList)
            {
                if (!fillLists)
                    return _parent;
                Type subType = typeInfo.SubType;

                ICollection coll = value as ICollection;
                if (createParent)
                {
                    XmlElement root = doc.CreateElement(subType.Name + "s");
                    parent.AppendChild(root);
                    _parent = root;
                }
                foreach (object subValue in coll)
                {
                    if (createParent || !manageListsWithArbo)
                        Serialize(doc, _parent, subValue, true);
                    else
                    {

                        XmlElement xitem = doc.CreateElement(subType.Name);
                        _parent.AppendChild(xitem);
                        Serialize(doc, xitem, subValue, false);


                    }
                }
                return _parent;
            }

            if (createParent)
            {
                XmlElement root = doc.CreateElement(value.GetType().Name);
                parent.AppendChild(root);
                _parent = root;

            }

            foreach (PropertyInfo prop in type.GetProperties())
            {
                // champ non pris en compte
                if (!Consider(prop))
                    continue;

                object subvalue = prop.GetValue(value, null);
                if (subvalue == null || DateTime.MinValue.Equals(subvalue))
                {
                    if (clearEmpy)
                    {
                        object[] attForce = prop.GetCustomAttributes(typeof(AlwaysWriteAttribute), true);
                        if (attForce.GetLength(0) == 1)
                        {
                        }
                        else
                            continue;
                    }
                }

                PropInfo subInfo = new PropInfo(prop);

                if (subInfo.IsList && !fillLists)
                    continue;

                // Création du noeud correspondant à la property


                // si la property est primaire (string, double?, dateTime...), on écrit directement le noeud
                if (subInfo.IsPrimary)
                {
                    XmlElement subXml = doc.CreateElement(getName(subInfo.Property));
                    _parent.AppendChild(subXml);
                    //Affichage éventuel des infos de type
                    if (withType)
                    {
                        XmlAttribute attType = doc.CreateAttribute("type");
                        Type subType = subInfo.Type;
                        string typeName = subType.Name;
                        if (subType.BaseType == typeof(Enum))
                            typeName = "Enum";
                        if (subType.IsGenericType && subType.GetGenericTypeDefinition() == typeof(Nullable<>))
                            typeName = Nullable.GetUnderlyingType(subType).Name;


                        attType.Value = typeName;
                        subXml.Attributes.Append(attType);
                    }


                    var str = "";
                    if (subvalue != null)
                    {

                        if (subvalue is DateTime || subvalue is DateTime?)
                        {
                            if (subvalue.Equals(DateTime.MinValue))
                                str = "";
                            else if (string.IsNullOrEmpty(dtFormat))
                            {
                                //Utilisé pour O2D
                                XElement xel = new XElement(subInfo.Property.Name, subvalue);
                                str = xel.Value;
                            }
                            else
                            {
                                //Utilisé par DC
                                var dt = (DateTime)subvalue;
                                str = dt.ToString(dtFormat, CultureInfo.InvariantCulture);
                            }
                        }

                        //Astuce pour obtenir les dates au format ISO 8601
                        // On n'affiche pas les DateMin


                        else
                        {

                            var subType = subInfo.Type;


                            if (subType == typeof(double) || subType == typeof(double?))
                            {
                                if (nfi == null)
                                    str = subvalue.ToString();
                                else
                                    str = ((double)subvalue).ToString(nfi);
                            }
                            //if (type == typeof(DateTime) || type == typeof(DateTime?))
                            //    return toDate();
                            else if (subType == typeof(bool) || subType == typeof(bool?))
                                str = (bool)subvalue ? "O" : "N";

                            else
                                str = subvalue.ToString();

                        }
                    }

                    subXml.InnerText = str;

                }
                //Si la property est une liste d'objets
                else if (subInfo.IsList)
                {
                    if (fillLists)
                    {
                        IList list = subvalue as IList;

                        XmlElement subXml = null;
                        if (manageListsWithArbo)
                        {
                            if (!clearEmpy)
                            {
                                subXml = doc.CreateElement(getName(subInfo.Property));
                                _parent.AppendChild(subXml);

                            }
                        }
                        foreach (object oListValue in list)
                        {
                            // appel récursif sur chaque élément de la liste
                            string namevalue = getName(oListValue.GetType());
                            if (manageListsWithArbo)
                            {
                                if (subXml == null)
                                {
                                    subXml = doc.CreateElement(getName(subInfo.Property));
                                    _parent.AppendChild(subXml);
                                }

                                var _namevalue = getName(subInfo.Property);
                                if (_namevalue != subInfo.Property.Name)
                                    namevalue = _namevalue;
                                var xmloListValue = doc.CreateElement(namevalue);

                                subXml.AppendChild(xmloListValue);

                                Serialize(doc, xmloListValue, oListValue, false);
                            }
                            else
                            {
                                subXml = doc.CreateElement(getName(subInfo.Property));
                                _parent.AppendChild(subXml);
                                Serialize(doc, subXml, oListValue, false);
                            }
                        }
                    }

                }
                //property est un autre objet Value : appel récursif
                else
                {
                    if (subvalue == null)
                        continue;
                    if (!subvalue.GetType().Namespace.StartsWith("System.Runtime.Serialization"))
                    {
                        XmlElement subXml = doc.CreateElement(getName(subInfo.Property));
                        _parent.AppendChild(subXml);
                        Serialize(doc, subXml, subvalue, false);
                    }
                }

            }

            if (value is IExtend)
            {
                var extend = value as IExtend;
                foreach (INode subNode in extend.getExtendedNodes())
                {
                    writeExtend(doc, _parent, subNode);
                }

            }
            return _parent;
        }

        private void writeExtend(XmlDocument doc, XmlNode parent, INode value)
        {
            var list = value.ChildNodes;
            XmlElement subXml = null;
            if (list.Count == 0)
            {
                var content = value.Content;
                if (clearEmpy)
                {
                    if (content == null || content is DBNull || string.IsNullOrEmpty(content.ToString()))
                        return;
                }

                subXml = doc.CreateElement(value.Name);
                parent.AppendChild(subXml);
                string strContent = content.FromString();


                if (!string.IsNullOrEmpty(oldDateFormat))
                {
                    if (!string.IsNullOrEmpty(dtFormat))
                    {
                        DateTime dt;
                        if (DateTime.TryParseExact(strContent, oldDateFormat, null, DateTimeStyles.None, out dt))
                            strContent = dt.ToString(dtFormat, CultureInfo.InvariantCulture);
                    }
                }

                subXml.InnerText = strContent;

                return;
            }


            subXml = doc.CreateElement(value.Name);
            parent.AppendChild(subXml);
            foreach (INode sub in list)
            {
                writeExtend(doc, subXml, sub);
            }

        }

        private void writeProp(XmlDocument doc, PropInfo subInfo, XmlElement subXml, object subvalue)
        {
            //Affichage éventuel des infos de type
            if (withType)
            {
                XmlAttribute attType = doc.CreateAttribute("type");
                Type subType = subInfo.Type;
                string typeName = subType.Name;
                if (subType.BaseType == typeof(Enum))
                    typeName = "Enum";
                if (subType.IsGenericType && subType.GetGenericTypeDefinition() == typeof(Nullable<>))
                    typeName = Nullable.GetUnderlyingType(subType).Name;


                attType.Value = typeName;
                subXml.Attributes.Append(attType);
            }
            //Astuce pour obtenir les dates au format ISO 8601
            // On n'affiche pas les DateMin
            if (subvalue != null && subvalue.Equals(DateTime.MinValue))
                subvalue = null;

            if (!string.IsNullOrEmpty(dtFormat)
                && subvalue != null
                && (subvalue is DateTime || subvalue is DateTime?))
            {
                var dt = (DateTime)subvalue;
                subXml.InnerText = dt.ToString(dtFormat, CultureInfo.InvariantCulture);
            }
            else
            {
                XElement xel = new XElement(subInfo.Property.Name, subvalue);
                subXml.InnerText = xel.Value;
            }

        }


        private void writeProp(XmlWriter writer, PropInfo subInfo, object subvalue)
        {
            //Affichage éventuel des infos de type
            if (withType)
            {
                Type subType = subInfo.Type;
                string typeName = subType.Name;
                if (subType.BaseType == typeof(Enum))
                    typeName = "Enum";
                if (subType.IsGenericType && subType.GetGenericTypeDefinition() == typeof(Nullable<>))
                    typeName = Nullable.GetUnderlyingType(subType).Name;

                writer.WriteAttributeString("type", typeName);
               

            }
            //Astuce pour obtenir les dates au format ISO 8601
            // On n'affiche pas les DateMin
            if (subvalue != null && subvalue.Equals(DateTime.MinValue))
                subvalue = null;

            if (!string.IsNullOrEmpty(dtFormat)
                && subvalue != null
                && (subvalue is DateTime || subvalue is DateTime?))
            {
                var dt = (DateTime)subvalue;
                writer.WriteStartElement(getName(subInfo.Property));
                writer.WriteString(dt.ToString(dtFormat, CultureInfo.InvariantCulture));
                writer.WriteEndElement(); 
               
            }
            else
            {
                XElement xel = new XElement(subInfo.Property.Name, subvalue);
                writer.WriteStartElement(getName(subInfo.Property));
                writer.WriteString(xel.Value);
                writer.WriteEndElement(); 
            }

        }



        public void Serialize(XmlWriter writer, object value, bool createParent)
        {


            if (value == null)
            {
                return ;
            }
            System.Type type = value.GetType();
            TypeInfo typeInfo = new TypeInfo(type);

            #region traitement particulier OutPutFormatFirstPropertyAsValueAttribute
            object[] attCoquille = type.GetCustomAttributes(typeof(OutPutFormatFirstPropertyAsValueAttribute), true);
            if (attCoquille.GetLength(0) == 1)
            {
                OutPutFormatFirstPropertyAsValueAttribute att = attCoquille[0] as OutPutFormatFirstPropertyAsValueAttribute;
                if (att.FirstPropertyAsValue)
                {
                    PropertyInfo prop0 = type.GetProperties()[0];
                    PropInfo p = new PropInfo(prop0);

                    writeProp(writer,p,prop0.GetValue(value, null); //        doc, p, parent as XmlElement, prop0.GetValue(value, null));

                    return;
                }
            }
            #endregion

          //  XmlNode _parent = parent;

            if (typeInfo.IsList)
            {
                if (!fillLists)
                    return;
                Type subType = typeInfo.SubType;

                ICollection coll = value as ICollection;
                if (createParent)
                {
                    writer.WriteStartElement(subType.Name + "s");                    
                }
                foreach (object subValue in coll)
                {
                    if (createParent || !manageListsWithArbo)
                        Serialize(writer, subValue, true);
                    else
                    {
                        writer.WriteStartElement(subType.Name);                      
                        Serialize(writer, subValue, false);
                        writer.WriteEndElement();
                    }
                }
                if (createParent)
                    writer.WriteEndElement(); 
            }

            if (createParent)
            {
                  writer.WriteStartElement(value.GetType().Name);
            }

            foreach (PropertyInfo prop in type.GetProperties())
            {
                // champ non pris en compte
                if (!Consider(prop))
                    continue;

                object subvalue = prop.GetValue(value, null);
                if (subvalue == null || DateTime.MinValue.Equals(subvalue))
                {
                    if (clearEmpy)
                    {
                        object[] attForce = prop.GetCustomAttributes(typeof(AlwaysWriteAttribute), true);
                        if (attForce.GetLength(0) == 1)
                        {
                        }
                        else
                            continue;
                    }
                }

                PropInfo subInfo = new PropInfo(prop);

                if (subInfo.IsList && !fillLists)
                    continue;

                // Création du noeud correspondant à la property


                // si la property est primaire (string, double?, dateTime...), on écrit directement le noeud
                if (subInfo.IsPrimary)
                {

                    writer.WriteStartElement (getName(subInfo.Property));
                
                    //Affichage éventuel des infos de type
                    if (withType)
                    {
                       
                        Type subType = subInfo.Type;
                        string typeName = subType.Name;
                        if (subType.BaseType == typeof(Enum))
                            typeName = "Enum";
                        if (subType.IsGenericType && subType.GetGenericTypeDefinition() == typeof(Nullable<>))
                            typeName = Nullable.GetUnderlyingType(subType).Name;

                        writer.WriteAttributeString("type", typeName); 
                    }


                    var str = "";
                    if (subvalue != null)
                    {

                        if (subvalue is DateTime || subvalue is DateTime?)
                        {
                            if (subvalue.Equals(DateTime.MinValue))
                                str = "";
                            else if (string.IsNullOrEmpty(dtFormat))
                            {
                                //Utilisé pour O2D
                                XElement xel = new XElement(subInfo.Property.Name, subvalue);
                                str = xel.Value;
                            }
                            else
                            {
                                //Utilisé par DC
                                var dt = (DateTime)subvalue;
                                str = dt.ToString(dtFormat, CultureInfo.InvariantCulture);
                            }
                        }

                        //Astuce pour obtenir les dates au format ISO 8601
                        // On n'affiche pas les DateMin


                        else
                        {

                            var subType = subInfo.Type;


                            if (subType == typeof(double) || subType == typeof(double?))
                            {
                                if (nfi == null)
                                    str = subvalue.ToString();
                                else
                                    str = ((double)subvalue).ToString(nfi);
                            }
                            //if (type == typeof(DateTime) || type == typeof(DateTime?))
                            //    return toDate();
                            else if (subType == typeof(bool) || subType == typeof(bool?))
                                str = (bool)subvalue ? "O" : "N";

                            else
                                str = subvalue.ToString();

                        }
                    }

                    writer.WriteString(str); 
                    writer.WriteEndElement(); 

                }
                //Si la property est une liste d'objets
                else if (subInfo.IsList)
                {
                    if (fillLists)
                    {
                        IList list = subvalue as IList;

                        XmlElement subXml = null;
                        if (manageListsWithArbo)
                        {
                            if (!clearEmpy)
                            {
                                subXml = doc.CreateElement(getName(subInfo.Property));
                                _parent.AppendChild(subXml);

                            }
                        }
                        foreach (object oListValue in list)
                        {
                            // appel récursif sur chaque élément de la liste
                            string namevalue = getName(oListValue.GetType());
                            if (manageListsWithArbo)
                            {
                                if (subXml == null)
                                {
                                    subXml = doc.CreateElement(getName(subInfo.Property));
                                    _parent.AppendChild(subXml);
                                }

                                var _namevalue = getName(subInfo.Property);
                                if (_namevalue != subInfo.Property.Name)
                                    namevalue = _namevalue;
                                var xmloListValue = doc.CreateElement(namevalue);

                                subXml.AppendChild(xmloListValue);

                                Serialize(doc, xmloListValue, oListValue, false);
                            }
                            else
                            {
                                subXml = doc.CreateElement(getName(subInfo.Property));
                                _parent.AppendChild(subXml);
                                Serialize(doc, subXml, oListValue, false);
                            }
                        }
                    }

                }
                //property est un autre objet Value : appel récursif
                else
                {
                    if (subvalue == null)
                        continue;
                    if (!subvalue.GetType().Namespace.StartsWith("System.Runtime.Serialization"))
                    {
                        XmlElement subXml = doc.CreateElement(getName(subInfo.Property));
                        _parent.AppendChild(subXml);
                        Serialize(doc, subXml, subvalue, false);
                    }
                }

            }

            if (value is IExtend)
            {
                var extend = value as IExtend;
                foreach (INode subNode in extend.getExtendedNodes())
                {
                    writeExtend(doc, _parent, subNode);
                }

            }
            return _parent;
        }


    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\XmlWrapper.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using System.Xml;
using pdb.util.Generic;
using pdb.util.Generic.Parse;

namespace pdb.util.Generic.Parse
{
	/// <summary>
	/// Enveloppe d'un noeud Xml pour se conformer à l'interface INode
	/// </summary>
	class XmlWrapper : Node
	{
		private static NumberFormatInfo nfiFr = new NumberFormatInfo();
		private static NumberFormatInfo nfiEn = new NumberFormatInfo();
        private static IFormatProvider dateFormatProvider;
        public static IFormatProvider DateFormatProvider { set { dateFormatProvider = value; } }

		private XmlNode node;
		private ILogger logger;

		static XmlWrapper()
		{
			nfiFr.NumberDecimalSeparator = ".";
			nfiEn.NumberDecimalSeparator = ",";
		}

		public XmlWrapper(XmlNode xml, ILogger logger)
		{
			this.node = xml;
			this.logger = logger;

            if (this.logger == null)
                logger = Logger.getLogger("XmlParser"); 
		}

		

		#region Node Membres
		public override ICollection<INode> ChildNodes
		{
			get
			{
				List<INode> list = new List<INode>(node.ChildNodes.Count);
				foreach(XmlNode subNode in node.ChildNodes)
				{
					if(subNode is XmlElement)
						list.Add(new XmlWrapper(subNode, logger));
				}

				return list;

			}
		}

		public override string OuterXml
		{
			get
			{
				if(node is XmlElement)
					return (node as XmlElement).OuterXml;
				else
					return base.OuterXml; 
			}
		}






		public override string Name
		{
			get { return node.Name; }
		}

		#endregion



		/// <summary>
		/// Convertit une chaine en dateTime nullable 
		/// </summary>
		/// <param name="node"></param>
		/// <remarks>Utilisée pour tte_dfin</remarks>
		/// <returns></returns>
		public DateTime? toDateNullable()
		{
			try
			{
				if(String.IsNullOrEmpty(node.InnerText.Trim())) return null;
				return toDate();
			}

			catch(Exception e)
			{
				string err = "";

				if(node == null)
					err = "impossible de récupérer la date d'un noeud null";
				//	logger.Error("impossible de récupérer la date d'un noeud null", e);
				else
					err = "impossible de parser " + node.Name + " " + node.InnerText + " de type date";
				//	logger.Error("impossible de parser " + node.Name + " " + node.InnerText + " de type date", e);
				logger.Error(err, e);
				throw new ParserException(err, e);
			}
		}

		//private static String ReplaceSpecialChars(String content)
		//{
		//    return content.Replace("&lt;", "<").Replace("&amp;", "&").Replace("&gt;", ">").Replace("&apos;", "'");
		//}






		/// <summary>
		/// récupération de la valeur du noeud
		/// </summary>
		/// <param name="type"></param>
		/// <param name="strValue"></param>
		/// <returns></returns>
		protected override object parse()
		{

			try
			{
				if(String.IsNullOrEmpty(node.InnerText.Trim()))
					return null;

				if(type == typeof(String))
					return node.InnerText;
				if(type == typeof(int) || type == typeof(int?))
					return toInt();
				if(type == typeof(Int64) || type == typeof(Int64?))
					return toLong();
				if(type == typeof(double) || type == typeof(double?))
					return toDouble();
				if(type == typeof(DateTime) || type == typeof(DateTime?))
					return toDate();
                if (type == typeof(Boolean) || type == typeof(Boolean?))
                    return getBool(node.InnerText); 
				if(type.BaseType == typeof(Enum))
					return Enum.Parse(type, node.InnerText);

				throw new ApplicationException(String.Format(" noeud {0} de contenu '{1}' est associé à un type non géré ({2})", node.Name, node.InnerText, type.Name));

			}
			catch(Exception e)
			{
				if(node == null)
					logger.Error("impossible de parser un noeud null de type " + type.FullName, e);
				else
					logger.Error("impossible de parser le noeud '" + node.Name + "' de contenu '" + node.InnerText + "' de type:" + type.FullName, e);
				throw;
			}
		}

		#region conversion
		/// <summary>
		/// convertit la chaine en entier
		/// </summary>
		/// <param name="strValue"></param>
		/// <returns></returns>
		private int? toInt()
		{
			string strValue = node.InnerText.Replace(" ", "");
			try
			{
				return Convert.ToInt32(strValue);
			}
			catch
			{
				try
				{
					logger.log("impossible de convertir en entier le champ xml '{0}' de valeur '{1}', tentative d'arrondir", node.Name, strValue);
					// si la chaine est un double, on récupère l'arrondi
					double? val = toDouble();
					if(val == null) return null;
					double arrondi = Math.Round((double)val, 0, MidpointRounding.AwayFromZero);
					return (int)arrondi;
				}
				catch
				{
					logger.log("impossible de convertir en entier le champ xml '{0}' de valeur '{1}'", node.Name, strValue);
				}
			}
			// on vide les champs non conformes
			return null;
		}

		/// <summary>
		/// convertit la chaine en entier
		/// </summary>
		/// <param name="strValue"></param>
		/// <returns></returns>
		private long? toLong()
		{
			string strValue = node.InnerText.Replace(" ", "");
			try
			{
				return Convert.ToInt64(strValue);
			}
			catch
			{
				try
				{
					logger.log("impossible de convertir en entier le champ xml '{0}' de valeur '{1}', tentative d'arrondir", node.Name, strValue);
					// si la chaine est un double, on récupère l'arrondi
					double? val = toDouble();
					if(val == null) return null;
					double arrondi = Math.Round((double)val, 0, MidpointRounding.AwayFromZero);
					return (long)arrondi;
				}
				catch
				{
					logger.log("impossible de convertir en long le champ xml '{0}' de valeur '{1}'", node.Name, strValue);
				}
			}
			// on vide les champs non conformes
			return null;
		}


		/// <summary>
		/// Convertit la chaîne en double
		/// </summary>
		/// <param name="strValue"></param>
		/// <remarks>prise en compte du séparateur point et virgule</remarks>
		/// <returns></returns>
		private double? toDouble()
		{
			string strValue = node.InnerText.Replace(" ", "");
			try
			{
				// si la chaine contient une virgule, on utilise le format anglais
				if(strValue.Contains(nfiEn.NumberDecimalSeparator))
					return Convert.ToDouble(strValue, nfiEn);
				return Convert.ToDouble(strValue, nfiFr);

			}
			catch
			{
				logger.log("impossible de convertir en nombre le champ xml '{0}' de valeur '{1}'", node.Name, strValue);
			}
			// on vide les champs non conformes
			return null;
		}

		/// <summary>
		/// Conversion de la chaîne en date
		/// </summary>
		/// <param name="node"></param>
		/// <returns></returns>
		private DateTime toDate()
		{
            string str = node.InnerText.Trim();
            if (dateFormatProvider == null)
                return Convert.ToDateTime(str);
            return Convert.ToDateTime(str, dateFormatProvider); 
		//	return Convert.ToDateTime(node.InnerText.Trim());
			//return DateTime.ParseExact(strValue, "dd-MM-yyyy hh:mm:ss", null, System.Globalization.DateTimeStyles.AssumeLocal);
		}


		/// <summary>
		/// Conversion de la chaîne en booléen
		/// </summary>
		/// <param name="node"></param>
		/// <returns></returns>
		private Boolean toBool()
		{
			return Node.toBool(node.InnerText); 
		}


		#endregion

	}
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\Json\JsonBuilder.cs">
    <content><![CDATA[using System;
using System.Text;

namespace pdb.util.Generic.Parse.Json
{
    /// <summary>
    /// Types de noeud Json
    /// </summary>
    enum typeNoeud
    {
        principal,
        tableau,
        objet,
        property
    }
    

    /// <summary>
    /// Constructeur de l'arborescence Json : lecteur du flux json
    /// </summary>
    class JsonBuilder 
    {
        private char[] json;
        /// <summary>
        /// état du lecteur
        /// </summary>
        private JsonState state;
        /// <summary>
        /// Noeud courant
        /// </summary>
       // private JsonWrapper current;

        private StringBuilder sb = new StringBuilder();
        public StringBuilder Sb { get { return sb; } }
        public void clearSb() { sb = new StringBuilder(); }

        public JsonBuilder(string content)
        {
            json = content.ToCharArray();
        }


        /// <summary>
        /// On est en train de parser un tableau de valeurs primitives ( [1,2,3] ['tata','toto']
        /// </summary>
        private bool[] _createPrimitivTab = new bool[10]; 

        /// <summary>
        /// Construction du noeud principal
        /// </summary>
        /// <returns></returns>
        public JsonWrapper build()
        {
            state = JsonState.create(this);
            var wrapper = state.Wrapper; 

            try
            {

                for (int i = 0; i < json.Length; i++)
                {
                    char c = json[i];
                    state.Consume(c);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex); 
            }
            return state.getFirstChildWrapper(); 
        }

     

        # region controleur

        public JsonState State { get { return state; } set { state = value; } }

       

        #endregion


    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\Json\JsonParseException.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.util.Generic.Parse.Json
{
    class JsonParseException : ApplicationException
    {
        public JsonParseException(JsonState from, string txt)
            : base(from + " " + txt)
        { }

        public JsonParseException(JsonState from, char c)
            : this(from, "caractère '" + c + "'")
        { }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\Json\JsonState.cs">
    <content><![CDATA[using System;
using System.Text;

namespace pdb.util.Generic.Parse.Json
{

    /// <summary>
    /// Etat du parcours du flux json
    /// </summary>
    abstract class JsonState
    {

        protected const char QUOTE = '\'';
        protected const char DOUBLE_COTE = '"';
        protected const char DEUX_POINTS = ':';
        protected const char VIRGULE = ',';
        protected const char ECHAP = '\\';
        public const char ACCOLADE_OUVRANTE = '{';
        protected const char ACCOLADE_FERMANTE = '}';
        protected const char CROCHET_OUVRANT = '[';
        protected const char CROCHET_FERMANT = ']';

        protected JsonBuilder builder;
        protected JsonWrapper wrapper;
        protected JsonState parent;
        protected Char c;

        public typeNoeud TypeNoeud { get { return typeNoeud; } }
        protected typeNoeud typeNoeud; 

        #region constructeurs

        protected JsonState(JsonBuilder builder, Char c)
        {
            this.builder = builder; 
            this.c = c; 
        }

        public override string ToString()
        {
            return level + " " +typeNoeud + " "+ display(); 
        }

        protected abstract string display();

        public JsonWrapper getFirstChildWrapper()
        {
            foreach (var sub in wrapper.ChildNodes)
                return sub as JsonWrapper;
            throw new ApplicationException(); 
        }

        public JsonWrapper Wrapper
        {
            get
            {
                return wrapper; 
            }
        }

        public static JsonState create(JsonBuilder builder)
        {
            //JsonState.builder = builder;
            JsonWrapper wrapper = new JsonWrapper(typeNoeud.principal);
            JsonState state = new JsonStateIni(builder);
           
          //  state.builder = builder; 
            state.wrapper = wrapper;
            return state; 
        }

        protected static void buildBrother(JsonState org, JsonState fin)
        {
            fin.wrapper = org.wrapper; 
            fin.parent = org.parent;
            fin.level = org.level;
            fin.typeNoeud = org.typeNoeud;
            fin._createTableau = org._createTableau;
           
           // fin.builder = org.builder;
            fin.builder.State = fin; 
        }

        protected static void buildChild(JsonState org, JsonState fin, typeNoeud type)
        {          
            var childWrapper = new JsonWrapper(type, org.wrapper);
            fin.parent = org;
            fin.wrapper = childWrapper;
            fin.level = org.level + 1;
            fin.typeNoeud = type;
            fin._createTableau = org._createTableau; 
           // builder.State = fin; 
           
           // fin.builder = org.builder;
            fin.builder.State = fin; 
        }

        protected virtual void getParent()
        {
            builder.State = builder.State.parent;
        }

        protected virtual void getParent(char cor)
        {
            var state = builder.State;
            if (state.TypeNoeud == typeNoeud.property && cor == VIRGULE)
                builder.State = builder.State.parent;
            else
            {
                var parent = builder.State.parent;

                while (true)
                {
                    if (parent == null)
                        return;
                    if (parent.c == cor)
                        break;
                    parent = parent.parent; 
                }
                builder.State = parent;
            }
        }

        protected virtual void close(typeNoeud ancestor)
        {
            var state = builder.State;
            while (true)
            {
                if (state == null)
                    return;
                if (state.typeNoeud== ancestor)
                    break;
                state = state.parent;
            }
            builder.State = state.parent; 
        }

      
        #endregion

        protected int level; 
        

        #region indicateurs

        protected bool _endProperty;
        protected bool _endObject;
        protected bool _endTableau;

      //  protected bool _createObject;
        protected bool _createProperty;
        protected bool _createTableau;
        protected bool _createPrimitiveTab;
        
        #endregion
        /// <summary>
        /// Consommation d'un caractère du flux
        /// </summary>
        /// <param name="c"></param>
        public void Consume(char c)
        {
            consume(c);
        }
        /// <summary>
        /// Consommation d'un caractère du flux
        /// </summary>
        protected abstract void consume(char c);

        /// <summary>
        /// caractère à prendre en compte ou pas
        /// </summary>
        /// <param name="c"></param>
        /// <returns></returns>
        protected bool ignoreSpaces(char c)
        {
            bool ret = false;
            if (Char.IsControl(c))
                ret = true;
            else if (Char.IsSeparator(c))
                ret = true;
            else ret = false;
            _ignore = ret;
            return ret;
        }

        public string StackTrace
        {
            get
            {
                string st = ToString();
                if (parent != null)
                    return st + "\r\n" + parent.StackTrace;
                return st; 
            }
        }

        public virtual bool Ignore { get { return false; } }

        protected bool _ignore;

        public bool EndProperty { get { return !Ignore && _endProperty; } }
        public bool EndObject { get { return !Ignore && _endObject; } }
        public bool EndTableau { get { return !Ignore && _endTableau; } }
        //public bool CreateObject { get { return !Ignore && _createObject; } }

        public bool CreateTableau { get { return !Ignore && _createTableau; } }
        public bool CreateProperty { get { return !Ignore && _createProperty; } }
        public bool CreatePrimitiveTab { get { return !Ignore && _createPrimitiveTab; } }

        protected StringBuilder Sb { get { return builder.Sb; } }
        protected void clearSb() { builder.clearSb();}
        //public void init(JsonBuilder builder, StringBuilder sb)
        //{
        //    this.builder = builder;
        //    this.sb = sb; 
        //}


    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\Json\JsonStateDeuxPoints.cs">
    <content><![CDATA[
using System.Text;
namespace pdb.util.Generic.Parse.Json
{
    /// <summary>
    /// Etat du lecteur quand on est entre la lecture du nom et la lecture de la valeur
    /// </summary>
    class JsonStateDeuxPoints : JsonState
    {
        public JsonStateDeuxPoints(JsonBuilder builder, char c)
            : base(builder,c)
        {
        }

        protected override void consume(char c)
        {
            wrapper.setName(Sb.ToString());
            builder.clearSb(); 

            var state = new JsonStateValueIni(builder,c);
            buildBrother(this, state); 
        }

        protected override string display()
        {
            return "2 points"; 
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\Json\JsonStateFinal.cs">
    <content><![CDATA[
namespace pdb.util.Generic.Parse.Json
{
    /// <summary>
    /// Finalisation du noeud en cours, indications de fin de noeud
    /// </summary>
    /// <param name="wrapper"></param>
    /// <param name="c"></param>
    class JsonStateFinal : JsonState
    {
      
        /// <summary>
        /// Finalisation du noeud en cours, indications de fin de noeud
        /// </summary>
        /// <param name="wrapper"></param>
        /// <param name="c"></param>
        public JsonStateFinal(JsonBuilder builder, char c)
            : base(builder, c)
        {
         //   _consume(c); 
        }

        protected override void consume(char c)
        {
            _consume(c); 
        }

        private void _consume(char c)
        {
          
           // bool goUp = false;
            char cor = default(char); 
            Json.typeNoeud _type = Json.typeNoeud.principal;  
            switch (c)
            {
                case CROCHET_FERMANT: _endTableau = true; cor = CROCHET_OUVRANT; _type = Json.typeNoeud.tableau;  break;
                case ACCOLADE_FERMANTE: _endObject = true; cor = ACCOLADE_OUVRANTE; _type = Json.typeNoeud.objet;  break;
                case VIRGULE: _endProperty = true; cor = VIRGULE; _type = Json.typeNoeud.property;  break;
            }



            if (cor != default(char))
            {               
                    base.close(_type); 
            }
               
        }

        protected override string display()
        {
            return "final";
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\Json\JsonStateIni.cs">
    <content><![CDATA[
using System.Text;
using System;
namespace pdb.util.Generic.Parse.Json
{
    /// <summary>
    /// Démarrage de la lecture
    /// </summary>
    class JsonStateIni : JsonState
    {
        public JsonStateIni(JsonBuilder builder)
            : this(builder,default(char))
        {
          
        }

        public JsonStateIni(JsonBuilder builder, char c)
            : base(builder, c)
        {
            builder.clearSb(); 
        }
        public override bool Ignore
        {
            get
            {
                return _ignore; 
            }
        }

        protected override void consume(char c)
        {
            if (ignoreSpaces(c))
                return;

            if (c == VIRGULE)
                return; 
               

            if (c == CROCHET_FERMANT || c == ACCOLADE_FERMANTE)
            {
                getParent();
                return;               
            }


            if (c == CROCHET_OUVRANT)
            {
                var obj = new JsonStateIni(builder,c);
                buildChild(this, obj, typeNoeud.objet);
                return;  
            }

            if (c == ACCOLADE_OUVRANTE)
            {
                var obj = new JsonStateIni(builder,c);
                buildChild(this, obj, typeNoeud.objet);
                return; 
             
            }

            if (_createTableau)
                _createPrimitiveTab = true; 

            //initialisation de la quote ou double quote éventuelle servant à écrire le nom
            char? sep = null;
            if (c == QUOTE || c == DOUBLE_COTE)
                sep = c;
            else
                Sb.Append(c);

            var state = new JsonStateName(builder,c, sep);
            buildChild(this, state, typeNoeud.property); 
           
        }

        protected override string display()
        {
            return "ini"; 
        }

        

      
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\Json\JsonStateName.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.util.Generic.Parse.Json
{
    /// <summary>
    /// Lecteur en phase de lecture du nom
    /// </summary>
    class JsonStateName : JsonState
    {
        private char? _sep;
        public JsonStateName(JsonBuilder builder, char c, char? sep)
            : base(builder,c)
        {
            this._sep = sep;
            _createProperty = true; 
        }

     

        protected override void consume(char c)
        {
            _createProperty = false;
            
            if (c == _sep)
            {
                setPhaseDeuxPoints();
                return;
            }
            if (_sep != QUOTE && _sep != DOUBLE_COTE && c == DEUX_POINTS)
            {
                setPhaseDeuxPoints();
                return;
            }
            Sb.Append(c); 
        }

        private void setPhaseDeuxPoints()
        {
            var state = new JsonStateDeuxPoints(builder,c);
            buildBrother(this, state); 
        }

        protected override string display()
        {
            return "name"; 
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\Json\JsonStateValue.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.util.Generic.Parse.Json
{
    /// <summary>
    /// Phase de lecture de la valeur
    /// </summary>
    class JsonStateValue : JsonState
    {
        private char? _sep;
        private bool precIsBackSlash; 

        public JsonStateValue(JsonBuilder builder, char c, char? sep)
            : base(builder,c)
        {
            this._sep = sep;
        }



        protected override void consume(char c)
        {
            // si quote ou ] ou } ou , ==> on envoie pour finalisation
            bool end = false;
            if (_sep != null)
            {
                if (precIsBackSlash)
                {
                    // soit \' \" ou \n ou cib\\bdels
                    if (c == _sep)
                    {
                    }
                    else if (c == ECHAP)
                    {
                    }
                    //else if (c == 'n')
                    //{
                    //    sb.Append(ECHAP);
                    //    sb.Append(ECHAP);
                    //    sb.Append(c);
                    //    return; 
                    //}
                    else
                    {
                        Sb.Append(ECHAP);
                    }
                   
                }
                else  if (c == _sep)
                    end = true;
            }
            else
            {
                if (c == CROCHET_FERMANT || c == ACCOLADE_FERMANTE || c == VIRGULE)
                    end = true;
            }


            if (end)
            {
                // si la valeur est |null| sans quote ou double quote, on a une valeur nulle
                string strValue = Sb.ToString();
                if (_sep == null && strValue.Equals("null"))
                    clearSb(); 

                var content = Sb.ToString();
                content = content.Replace("<br/>", @"\n").Replace("<br />", @"\n").Replace("<BR />", @"\n");
                wrapper.ValueAsString = content;
                clearSb(); 

                var state = new JsonStateFinal(builder,c);
                buildBrother(this, state);
                state.Consume(c);
                return;
            }
            if (c == ECHAP && _sep != null)
            {
                precIsBackSlash = true;
            }
            else
            {
                precIsBackSlash = false; 
                Sb.Append(c);
            }
        }

        protected override string display()
        {
            return "value";
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\Json\JsonStateValueIni.cs">
    <content><![CDATA[
namespace pdb.util.Generic.Parse.Json
{
    /// <summary>
    /// Initialisation du caractère spécial (' "" ) pour la lecture de la valeur
    /// </summary>
    class JsonStateValueIni : JsonState
    {
        /// <summary>
        /// Initialisation du caractère spécial (' "" ) pour la lecture de la valeur
        /// </summary>
        /// <param name="wrapper"></param>
        public JsonStateValueIni(JsonBuilder builder, char c)
            : base(builder, c)
        {
        }

        public override bool Ignore
        {
            get
            {
                return _ignore;
            }
        }


        protected override void consume(char c)
        {
            if (ignoreSpaces(c))
                return;

            if (c == VIRGULE)
                return;

            if (c == CROCHET_OUVRANT)
            {
                if (!_createTableau)
                {
                    _createTableau = true;
                    this.c = CROCHET_OUVRANT;
                    this.typeNoeud = Json.typeNoeud.tableau;
                    return;
                }
                else
                {
                    _createTableau = true;
                    var state = new JsonStateValueIni(builder,c);
                    buildChild(this, state, Json.typeNoeud.tableau);
                    return;

                }



            }

            if (c == ACCOLADE_OUVRANTE)
            {
                _createTableau = false;
                var state = new JsonStateIni(builder,c);
                buildChild(this, state, typeNoeud.objet);
                return;
            }

            if (c == CROCHET_FERMANT)
            {
                var fin = new JsonStateFinal(builder,c);
                buildBrother(this, fin);
                fin.Consume(c);
                return;

            }





            if (_createTableau)
            {
                _createPrimitiveTab = true;
            }


            char? sep = null;
            if (c == QUOTE || c == DOUBLE_COTE)
                sep = c;
            else
            {
                if (!_endTableau)
                    Sb.Append(c);
            }

            if (!_createPrimitiveTab)
            {
                var obj = new JsonStateValue(builder,c, sep);
                buildBrother(this, obj);
                return;
            }
            else
            {
                var child = new JsonStateValue(builder,c, sep);
                buildChild(this, child, Json.typeNoeud.property);
                return;
            }

            //if (!_endTableau)
            //    wrapper.setPhaseValue(sep, _createPrimitiveTab, _endTableau);
            //else
            //    wrapper.setPhaseFinal(c, _createPrimitiveTab); 


        }

        protected override string display()
        {
            return "value ini";
        }

    }
}
]]></content>
  </file>
  <file path="\pdb.util\Generic\Parse\Json\JsonWrapper.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using pdb.util.Generic;
using pdb.util.Generic.Parse;

namespace pdb.util.Generic.Parse.Json
{
    /// <summary>
    /// Arborescence suivant un format Json
    /// </summary>
    class JsonWrapper : Node
    {
        private static CultureInfo culturefr = new CultureInfo("fr-Fr");
        private static IFormatProvider enFormat = new CultureInfo("en-US");

        //public static IFormatProvider DoubleFormatProvider { set

        /// <summary>
        /// Noeud parent
        /// </summary>
        private JsonWrapper parent;

        /// <summary>
        /// Sous-noeuds
        /// </summary>
        private List<JsonWrapper> childs = new List<JsonWrapper>();

        /// <summary>
        /// type de noeud
        /// </summary>
        private typeNoeud typeNoeud;

        public JsonWrapper(typeNoeud typeNoeud)
        {
            this.typeNoeud = typeNoeud;
        }

        public JsonWrapper(typeNoeud typeNoeud, JsonWrapper parent)
            : this(typeNoeud)
        {
            this.parent = parent;
            parent.childs.Add(this);
        }

        // public typeNoeud TypeNoeud { get { return typeNoeud; } }


        public JsonWrapper Parent { get { return parent; } }

        ///// <summary>
        ///// construction du nom
        ///// </summary>
        //public void NameAppend(char c)
        //{
        //    sbName.Append(c);
        //}
        ///// <summary>
        ///// Construction de la valeur
        ///// </summary>
        //public void ValueAppend(char c)
        //{
        //    sbValue.Append(c);
        //}

        //public void resetValue()
        //{
        //    sbValue = new StringBuilder(); 
        //}



        private string name;

        public override string Name
        {
            get { return name; }

        }

        public void setName(string name) { this.name = name; }

        public override string OuterXml
        {
            get
            {
                StringBuilder sb = new StringBuilder();
                sb.Append("<");
                sb.Append(Name);
                sb.Append(">");
                string value = valueAsString;
                if (!string.IsNullOrEmpty(value))
                    sb.Append(value);
                else
                {
                    foreach (INode node in childs)
                    {
                        sb.Append(node.OuterXml);
                    }
                }

                sb.Append("</");
                sb.Append(Name);
                sb.Append(">");

                return sb.ToString();

            }
        }

        private string valueAsString;
        public string ValueAsString
        {
            get
            {
                return valueAsString;
            }
            set
            {
                valueAsString = value;
            }
        }

        public override ICollection<INode> ChildNodes
        {
            get
            {
                var list = new List<INode>();
                foreach (var _node in childs)
                    list.Add(_node);
                return list;
            }
        }


        protected override object parse()
        {
            string strValue = valueAsString;
            if (String.IsNullOrEmpty(strValue))
                return null;

            if (type == typeof(String))
                return strValue;
            try
            {
                if (type == typeof(int) || type == typeof(int?))
                {
                    try { return Convert.ToInt32(strValue); }
                    catch (OverflowException)
                    {
                        throw new ParseOverflowException(strValue, name, int.MaxValue);
                    }
                }
                if (type == typeof(Int64) || type == typeof(Int64?))
                    try { return Convert.ToInt64(strValue); }
                    catch (OverflowException)
                    {
                        throw new ParseOverflowException(strValue, name, long.MaxValue);
                    }

                if (type == typeof(double) || type == typeof(double?))
                    try { return Convert.ToDouble(strValue, enFormat); }
                    catch (OverflowException)
                    {
                        throw new ParseOverflowException(strValue, name, double.MaxValue);
                    }

                if (type == typeof(float) || type == typeof(float?))

                    try { return Convert.ToSingle(strValue, enFormat); }
                    catch (OverflowException)
                    {
                        throw new ParseOverflowException(strValue, name, float.MaxValue);
                    }
                if (type == typeof(DateTime) || type == typeof(DateTime?))
                    return Convert.ToDateTime(strValue, culturefr);
                if (type == typeof(Boolean) || type == typeof(Boolean?))
                    return getBool(strValue);
                if (type.IsEnum)
                {
                    try
                    {
                        return Enum.Parse(type, strValue);
                    }
                    catch
                    {
                        return Convert.ToInt32(strValue);
                    }
                }
            }
            catch (FormatException)
            {
                throw new ParseFormatException(strValue, name); 
            }

            throw new ApplicationException(String.Format(" noeud {0} de contenu '{1}' est associé à un type non géré ({2})", Name, strValue, type.Name));
        }

        public void ClearChildNodes()
        {
            childs.Clear();
        }




    }
}
]]></content>
  </file>
  <file path="\pieceDb.iT\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using iTunesLib;
using pdb.it.persistance;
using pdb.obj;
using pdb.ordo;
using pdb.util;

namespace pdb.it
{
    public class TrackInfoItunes : ITrackInfoItunes
    {
        private static Logger log = Logger.getLogger("Track");
        private static Loader loader;
        public static Loader Loader { set { loader = value; } }
        protected IITFileOrCDTrack track;
        protected IITFileOrCDTrack tracktrack;

        private TrackPlayListManager listManager = new TrackPlayListManager();
        private string className = "";
        // private int index;

        private static BackGroundTaskMgr bg = BackGroundTaskMgr.getMgr("Track", 12);
        private static BackGroundTaskMgr bgg = BackGroundTaskMgr.getMgr("Group", 12);
        private static BackGroundTaskMgr bgGroupPrior = BackGroundTaskMgr.getMgr("PriorG", 11);
        private static BackGroundTaskMgr bgGroup2nd = BackGroundTaskMgr.getMgr("SeconG", 13);
        //private static BackGroundTaskMgr bgGroupDelta = BackGroundTaskMgr.getMgr("DeltaG", 11);
        private static BackGroundTaskMgr bgFirstClass = BackGroundTaskMgr.getMgr("FirstClass", 10);
        private static BackGroundTaskMgr bgSeconClass = BackGroundTaskMgr.getMgr("SeconClass", 10);
        private static BackGroundTaskMgr bgClass = BackGroundTaskMgr.getMgr("Classement", 0);

        // private TrackPersistantId persistentId;
        private bool loaded;

        // private ITrackNative local;
        // public void registerDependency(ITrackNative local) { this.local = local; }
        public void releaseDependency() { }

        //public TrackPersistantId PersistantId { set { persistentId = value; } }



        public class TrackClassNameEventArgs : EventArgs
        {
            public TrackClassNameEventArgs(string value) { this.Value = value; }
            readonly public string Value;
        }

        public event EventHandler<TrackClassNameEventArgs> classNameChanged;

        private void OnClassNameChange(string value) { if (classNameChanged != null) classNameChanged(this, new TrackClassNameEventArgs(value)); }

#if VERIF
        public void verif()
        {
            var toto = loader.getTrack(this);
        }

#endif

        private int playCount = -1;
        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{

        //    this.track = track;
        //    this.playedDate = track.PlayedDate;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.comment = track.Comment;
        //    this.grouping = track.Grouping;

        //    Fill();


        //}

        private void Fill()
        {
            var track = this.track;
            if (track == null)
                track = this.tracktrack;
            if (track == null)
                return;

            this.id = track.TrackDatabaseID;

            this.artist = track.Artist;
            this.album = track.Album;
            this.name = track.Name;
            this.trackNumber = track.TrackNumber;
            this.rating = track.Rating;
            this.year = track.Year;
            // this.comment = track.Comment;
            this.enabled = track.Enabled;
            this._isPodCast = track.Podcast;
            // this.playedDate = track.PlayedDate;
            this.location = track.Location;
            //this.grouping = track.Grouping;
            this.playCount = track.PlayedCount;




        }


        //public TrackInfoItunes(XmlNode xTrack)
        //{
        //    build(xTrack);
        //}

        public TrackInfoItunes()
        {
        }

        public void makeRead()
        {
            var track = this.track;
            if (track == null)
                track = tracktrack;
            if (track == null)
                return;
            track.PlayedCount = 1;

        }

        public static int getID(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": return Convert.ToInt32(value);


                }
            }
            return -1;
        }

        public virtual void build(IITFileOrCDTrack track)
        {

            this.tracktrack = track;
            this.track = track;
            this.playedDate = track.PlayedDate;
            this.duration = TimeSpan.FromSeconds(track.Duration);
            this.comment = track.Comment;
            this.grouping = track.Grouping;

            Fill();
        }

        public virtual void build(XmlNode xTrack)
        {
            enabled = true;
            string key = "";
            bool nextIgnore = false;
            rating = 0;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        _isPodCast = true; nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        enabled = false; nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": id = Convert.ToInt32(value);
                        break;
                    case "Name": name = value; break;
                    case "Artist": artist = value; break;
                    case "Album": album = value; break;
                    case "Total Time": duration = TimeSpan.FromMilliseconds(Convert.ToDouble(value)); break;
                    case "Track Number": trackNumber = Convert.ToInt32(value); break;
                    case "Comments": if (!loaded) comment = value; break;
                    case "Play Date UTC": playedDate = Convert.ToDateTime(value); break;
                    case "Rating": rating = Convert.ToInt32(value); break;
                    case "Location": Uri uri = new Uri(value);
                        location = uri.LocalPath.Replace(@"\\localhost\", "");
                        break;
                    case "Year": year = Convert.ToInt32(value); break;
                    case "Grouping": if (!loaded) grouping = value; break;
                    case "Kind": if (value.Equals("Flux audio sur Internet"))
                            strange = true; break;
                    case "Track Type": if (!"File".Equals(value)) strange = true; break;
                    case "Play Count": playCount = Convert.ToInt32(value); break;

                    case "Volume Adjustment": if (!loaded)
                            volume = Convert.ToInt32(value);

                        break;
                }
                //if (Name.Contains("Les cartes de la mémoire"))
                //{
                //    int toto = 0;
                //}
            }
            loaded = true;
        }

        public virtual void export(XmlWriter w)
        {

        }



        private int id;
        //public int TrackId { get { return track.trackID; } }
        public int ID { get { return id; } }

        protected IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (tracktrack == null)
                {
                    var _t = loader.getTrackTrack(this);
                    if (_t != null)
                    {
                        tracktrack = _t.Track;
                        // persistentId = _t.Id;
                    }
                }
                return tracktrack;
            }
        }

        protected IITFileOrCDTrack Track
        {
            get
            {
                if (track == null)
                {
                    var t = loader.getTrack(this);
                    if (t != null)
                    {
                        track = t;
                    }

                }

                if (track == null)
                    return tracktrack;
                return track;

            }
        }



        #region ITrackNative Membres
        private string artist = "";
        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                if (value == null || value.Equals(artist)) return;

                bgClass.add(new Bgtask(() =>
                {
                    Track.Artist = value;
                    artist = value;
                }, this, "change artist from '{0}' to'{1}' {2}", artist, value, this
                ));


            }
        }


        private string album = "";
        public string Album
        {
            get
            {
                return album;
            }
            set
            {
                if (value == null || value.Equals(album)) return;
                bgClass.add(new Bgtask(() =>
                {
                    // log.log("change album from '{0}' to'{1}' {2}", album, value, this);
                    Track.Album = value;
                    album = value;
                }, this,
                "change album from '{0}' to'{1}' {2}", album, value, this
                ));

            }
        }
        private string name = "";
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value == null || value.Equals(name)) return;

                var bgtaskName = new BgTaskName(this, string.Format("change name from '{0}' to '{1}' {2}", name, value, this), value);
                bgClass.add(bgtaskName);

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }
        private int trackNumber;
        public int TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                if (trackNumber != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //    log.log("change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this);
                        Track.TrackNumber = value;
                        trackNumber = value;
                    }, this,
                    "change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this));
                }
            }
        }
        private int rating = 0;
        public int Rating
        {
            get
            {
                return rating;
            }
            set
            {
                if (rating != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //     log.log("change rating from '{0}' to'{1}' {2}", rating, value, this);
                        Track.Rating = value;
                        rating = value;
                    }, this,
                     "change rating from '{0}' to'{1}' {2}", rating, value, this));
                }
            }
        }
        private int year;
        public int Year
        {
            get
            {
                return year;
            }
            set
            {
                if (year != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.Year = value;
                        year = value;
                    }, this,
                    "change year from '{0}' to'{1}' {2}", year, value, this));

                }
            }
        }
        private string comment = "";
        private bool firstClass;
        public bool FirstClass { get { return firstClass; } set { firstClass = value; } }
        // public void makeFirstClass() { firstClass = true; }
        public string Comment
        {
            get
            {
                return comment;
            }
            set
            {
                firstClass = false;
                if (comment != value)
                {
                    try
                    {
                        var tab0 = comment.Split(' ');
                        var tab1 = value.Split(' ');

                        var count0 = tab0.GetLength(0);
                        var count1 = tab1.GetLength(0);

                        if (count0 != count1)
                            firstClass = true;

                        else if (comment.Length > 3)
                        {
                            string org = tab0[count0 - 1];
                            string fin = tab1[count1 - 1];

                            firstClass = !org.Equals(fin);
                        }
                    }

                    catch
                    {
                        firstClass = true;
                    }

                    var sb = new StringBuilder();
                    sb.Append(ClassName);
                    sb.Append(".");
                    sb.Append((Rating / 20).ToString());

                    var task = new BgTaskComment(this, string.Format("{0} change comment from '{1}' to '{2}' {3}", sb.ToString(), comment, value, this), value);

                    if (firstClass)
                        bgFirstClass.add(task);
                    else
                        bg.add(task);
                    // comment = value;
                }
            }
        }
        private bool enabled;
        public bool Enabled
        {
            get
            {
                return enabled;
            }
            set
            {
                if (enabled != value)
                {
                    bgClass.add(new BgTaskCheck(this, "uncheck " + this));

                    //bg.add(new Bgtask(() =>
                    //{
                    //    // log.log("change enbled from '{0}' to'{1}' {2}", enabled, value, this);
                    //    Track.Enabled = value;
                    //    enabled = value;
                    //}, this,
                    //"change enabled from '{0}' to'{1}' {2}", enabled, value, this));
                }
            }
        }
        private bool _isPodCast;
        public bool isPodcast
        {
            get { return _isPodCast; }
        }
        private DateTime playedDate;
        public DateTime PlayedDate
        {
            get
            {
                if (playCount > 0)
                    return playedDate;
                return DateTime.MinValue;
            }
        }
        protected string location;
        public string Location
        {
            get { return location; }
        }

        private TimeSpan duration;
        public TimeSpan Duration
        {
            get { return duration; }
            set { throw new NotImplementedException();  }
        }


        private string artWork;
        public string ArtWork
        {
            get
            {
                return artWork;
            }
            set
            {
                if (value != artWork)
                {
                    log.log("change ArtWork from {0}  {1}  {2}", artWork, value, this);
                    IITArtworkCollection artworks = Track.Artwork;
                    string path = Track.Location + Path.DirectorySeparatorChar + artWork;
                    if (artworks == null || artworks.Count == 0)
                    {
                        Track.AddArtworkFromFile(path);
                    }
                    else
                    {
                        artworks[0].SetArtworkFromFile(path);
                    }
                    artWork = value;

                }

            }
        }

        private string grouping = "";
        public string Grouping
        {
            get
            {
                return grouping;
            }


        }

        public void setGrouping(string value, bool prior)
        {
            if (grouping != value)
            {
                bool _delta = false;
                // bool _deltaRank = false; 
                string rankAlbum = "";
                string equivAlbum = "";
                if (value != null)
                {
                    string[] org = grouping.Split(' ');
                    string[] _new = value.Split(' ');

                    int count = org.GetLength(0);
                    if (_new.GetLength(0) != count || count < 3)
                        _delta = true;
                    else
                    {
                        rankAlbum = _new[1];
                        equivAlbum = _new[2];
                        if (!org[1].Equals(_new[1]))
                        {
                            _delta = true;
                        }
                    }
                }

                var sb = new StringBuilder();
                sb.Append(rankAlbum);
                sb.Append(" ");
                sb.Append(equivAlbum);
                sb.Append(" ");
                sb.Append(album);
                //sb.Append(ClassName);
                //sb.Append(".");
                //sb.Append((Rating / 20).ToString());

                var task = new BgTaskGrouping(this, string.Format("{0} change grouping from '{1}' to'{2}' {3}", sb.ToString(), grouping, value, this), value);

                if (firstClass)
                {
                    bgSeconClass.add(task);
                    return;
                }

                //if (prior)
                //{
                //    bgGroupPrior.add(task);
                //    return;
                //}



                if (_delta)
                {
                    if (prior)
                        bgGroupPrior.add(task);
                    else
                        bgGroup2nd.add(task);
                    return;
                }

                bgg.add(task);

                //if (_delta)
                //    bgGroupDelta.add(task);
                //else
                //{
                //    bgg.add(task);
                //}
                //  grouping = value;
            }
        }



        private int volume;
        public int Volume
        {
            get { return volume; }
            set
            {
                if (volume != value)
                {
                    int _value = loader.VolumeMin;
                    if (value > _value)
                        _value = value;
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.VolumeAdjustment = _value;
                        volume = _value;
                    }, this,
                    "change volume from '{0}' to '{1}' {2}", volume, _value, this));

                }
            }

        }

        #endregion

        private bool strange = false;
        public bool Strange { get { return strange; } }
        public override string ToString()
        {
            return location;
        }



        public List<CPlayList> PLayLists
        {
            get { return listManager.PLayLists; }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return listManager.ClassPlayLists; }
        }

        public void AddPlayList(CPlayList a_playList)
        {
            listManager.AddPlayList(a_playList);
            // className = listManager.ClassName;
        }

        public void removePlayList(CPlayList list)
        {
            listManager.removePlayList(list);
            // className = listManager.ClassName;
        }


        public string ClassName
        {
            get
            {
                className = listManager.ClassName;
                return className;
            }
            set
            {
                className = listManager.ClassName;
                if (className != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        loader.setClassPlayList(this, className, value);
                        className = value;
                    }, this,
                   "change className from '{0}' to'{1}' {2}", className, value, this));


                    //log.log("change Class Name from '{0}' to'{1}' {2}", className, value, this);
                    //className = value;
                    //OnClassNameChange(value);
                }
            }
        }
        public override bool Equals(object obj)
        {
            if (string.IsNullOrEmpty( Location))
                return false;
            if (obj is IFile)
            {
                IFile other = obj as IFile;
                return Location.Equals(other.Location);
            }
            return false;
        }
        public override int GetHashCode()
        {
            if (Location.isNullorEmpty()) return -1;
            return Location.GetHashCode();
        }

        public void Delete()
        {
            if (tracktrack != null)
                tracktrack.Delete();
            else
                bgClass.add(new BgTaskDeleteTrackTrack(this, "delete Track " + this));
        }

        private class Bgtask : pdb.ordo.BgTask
        {
            TrackInfoItunes info;
            public Bgtask(execDel impl, TrackInfoItunes info, string format, params object[] args)
                : base(impl, format, args)
            { this.info = info; }

            public override void exec()
            {
                base.exec();
                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }
            }



        }
        private class BgTaskDeleteTrackTrack : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskDeleteTrackTrack(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
                foreach (PlayList pl in info.PLayLists)
                {
                    var tInList = pl.getPieceInList(info) as TrackInList;
                    //loader.removeTrackInList(pl.getPath(), tInList,pl._pl); 
                }

            }

            public override void exec()
            {
                try
                {
                    var _track = info.TrackTrack;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Delete();
                    loader.removeTrack(info);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.tracktrack != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComment : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComment(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Comment = value;
                    info.comment = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }


        private class BgTaskName : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskName(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Name = value;
                    info.name = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        public void invalidationTrack()
        {

            loader.invalidationTrack(this);
            track = null;
            //  persistentId = null; 
        }


        private class BgTaskGrouping : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskGrouping(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        //  Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Grouping = value;
                    info.grouping = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //   Thread.Sleep(1000 * Try); 
                }

            }
        }



        private class BgTaskCheck : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;

            public BgTaskCheck(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Enabled = false;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }

            }
        }




        private TrackInfoItunes parent;

        public virtual ITrackInfoItunes LinkedTo
        {
            get
            {
                return parent;
            }
            set
            {
                parent = value as TrackInfoItunes;
            }
        }


        public int PieceId
        {
            get { return -1; }
        }


        public int PieceParentId
        {
            get { return -1; }
            set { }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion

    }
}



]]></content>
  </file>
</db>
