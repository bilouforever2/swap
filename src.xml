<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\pdb.player\ViewModel\BibViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Windows.Input;
using System.Windows.Threading;
using pdb.db.piece.type;
using pdb.gen;
using pdb.gen.conf;
using pdb.obj;
using pdb.player.ViewModel.Commande;

namespace pdb.player.ViewModel
{
    class BibViewModel : IListWriter, IAbortTask
    {
      //  private CPlayList _root;
        private List<PlayListViewModel> windows = new List<PlayListViewModel>();
        private PlayListViewModel currentPlaying;

        public event EventHandler changelistPlaying;
     //   private static BibViewModel _instance;
       private PlayListViewModel root; 

        public BibViewModel(CPlayList _root)
            
        {
            this.root = new PlayListViewModel(_root); 
            //if (_instance != null)
            //    throw new ApplicationException();
         //   this._root = _root;

            currentPlaying = root;
//            _instance = this;

        }

        public BibViewModel(PlayListViewModel root)
    {
        this.root = root; 
    }

        //public BibViewModel(PlayListViewModel root) :base(
        //{
        //}
        public PlayListViewModel Root { get { return root; } }
        private PlayListViewModel _listes; 
        public PlayListViewModel Listes
        {
            get
            {
                if (_listes == null)
                {
                    foreach (PlayListViewModel sub in root)
                    {
                        if (sub.Name == "listes")
                        {
                            _listes = sub;
                            break; 
                        }
                    }
                }
                return _listes; 
            }
        }

       // public static BibViewModel Instance { get { return _instance; } }

        private ICommand cmdImport;
        public ICommand Import
        {
            get
            {
                if (cmdImport == null)
                    cmdImport = new ImportCmd(App.Instance, PlayerViewModel.Player);
                return cmdImport; 
            }
        }

        private ICommand cmdCreateList;
        public ICommand CreateList
        {
            get
            {
                if (cmdCreateList == null)
                {
                    cmdCreateList = new CreateListCmd(App.Instance); 
                }
                return cmdCreateList; 
            }
        }

        public PlayListViewModel CurrentPlaying
        {
            get
            {
                return currentPlaying;
            }
            set
            {
                if (value != currentPlaying)
                {
                    currentPlaying = value;
                    if (changelistPlaying != null)
                        changelistPlaying(this, EventArgs.Empty);
                }
            }
        }



        public PlayListViewModel Musique { get { return root.get("musique", true); } }
        //private ObservableCollectionTS<PlayListViewModel> _ihmPl; 
        //public ObservableCollectionTS<PlayListViewModel> PlayLists
        //{
        //    get
        //    {
        //        if (_ihmPl == null)
        //            _ihmPl = new ObservableCollectionTS<PlayListViewModel>(new List<PlayListViewModel>{this});
        //        return _ihmPl; 
        //       // return new ObservableCollectionTS<PlayListViewModel>(new List<PlayListViewModel> { _playlists });
        //    }
        //}

        //public PlayListViewModel PlayLists
        //{
        //    get
        //    {
        //        return this;
        //    }
        //}

        public List<PlayListViewModel> PlayLists_
        {
            get
            {
                return new List<PlayListViewModel>(root);
            }
        }

        private delegate void writePlayListDel(string folder, string name, ICollection<IFile> list, bool withOrder, IBgTask task);

        public void writePlayList(string folder, string name, ICollection<IFile> list, bool withOrder, IBgTask task)
        {
            if (aborted || task.Abort)
                return;
            //if (!Dispatcher.CurrentDispatcher.CheckAccess())
            //{
            //    Dispatcher.CurrentDispatcher.Invoke(new writePlayListDel(writePlayList), new object[] { folder, name, withOrder, task });
            //    return; 
            //}

            var conf = CConf.ConfGen;

            if (!conf.GenE)
            {
                if (name.StartsWith("e"))
                    return;
            }
            if (!conf.GenLarge)
            {
                if (name.EndsWith("+"))
                    return;
            }

            // misc.log(">< writePlaylist {0}", task);
            string[] folders = new string[] { folder };
            if (folder.Contains(@"\"))
            {
                folders = folder.Split('\\');
            }

            PlayListViewModel current = root;
            foreach (string f in folders)
            {
                if (aborted)
                    return;
                current = current.getOrCreatePlayList(f);
            }


            //   PlayListComposite plFolder = loader.getOrCreateFolder(folder);
            if (aborted)
                return;
            var playlist = current.getOrCreatePlayList(name);// loader.getOrCreatePlayList(current, name, false);

            // CPlayList playlist = loader.getList(plFolder, name);//  getList(folder, name);
            // return loader.mergeList(playlist, list, withOrder,this);
            //  var truncateList = truncate(playlist, list);
            if (aborted)
                return;
            playlist.mergeList(list, this);


        }




        public string Type
        {
            get { return "player"; }
        }

        private bool aborted;
        public bool Aborted
        {
            get { return aborted; }
            set { aborted = value; }
        }


        #region classement
        private delegate void setClassementDel(TrackListViewModel track, string _class, Classement newCl);
        public void setClassement(TrackListViewModel track, string newValue)
        {
            if (track == null)
                return;
            

            var piece = track.Track.Piece;
            var _class = piece.ClassName;

            var newCl = Classement.create(newValue);
            if (newCl.ClassList == _class)
                return;

            if (!Dispatcher.CurrentDispatcher.CheckAccess())
            {
                Dispatcher.CurrentDispatcher.Invoke(new setClassementDel(setClass), new object[] { track, _class, newCl });
                return;
            }
            else
                setClass(track, _class, newCl);




        }

        private void setClass(TrackListViewModel track, string _class, Classement newCl)
        {
            var org = getClass(_class, false);
            var t = PlayListViewModel.findTrack(org, track.Master.PieceId); 
            org.RemoveTrack(t, true);
            var newpl = getClass(newCl.ClassList, true);

            newpl.AddTrack(track.Master, true);
        }

        public PlayListViewModel getClass(string className, bool create)
        {
            char[] tab = className.ToCharArray();
            int count = tab.GetLength(0);
            int index = 0;
            PlayListViewModel current = root.get("classement", create);
            while (true)
            {
                if (current == null)
                    return null;
                if (index >= count)
                    break;
                var c = tab[index];
                if (c == '.')
                    break;
                current = current.get(c.ToString(), create);
                index++;
            }

            return current;
        }

        public PlayListViewModel getClass(int className)
        {
            return getClass(className.ToString(), false);
        }
        #endregion

        #region localisation
        #endregion

    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\TrackListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Windows;
using pdb.obj;
using pdb.util;
using pdb.gen;
using pdb.db.obj;

namespace pdb.player.ViewModel
{

    public class TrackListViewModel : BibViewModelBase, ITrackNativeDates
    {




        #region répercut
        //  private static BgDict<int, List<TrackListViewModel>> dictT = new BgDict<int, List<TrackListViewModel>>();
        #endregion
        private TrackList track;
        private PieceViewModel piece;
        private static TrackListViewModel currentPlaying;
        private static TrackListViewModel currentSelected;
        public TrackList Track { get { return track; } }
        public CPiece Piece { get { return piece.Piece; } }
        public Piece PieceGen { get { return track.Piece; } }
        public Piece Master { get { return PieceGen.Master; } }

        public void remove()
        {
            //var list = dictT[PieceId];
            //if (list == null)
            //    return;
            //list.Remove(this);
        }

        public void refresh()
        {
            piece.eraseCommentGrouping();
            OnPropertyChanged("ExportStatus");
            OnPropertyChanged("TV");
            OnPropertyChanged("Comment");
            OnPropertyChanged("Grouping");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("ClassementVirtuel");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("");
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                base.IsSelected = value;
                if (value)
                    CurrentSelected = this;
            }
        }

        private int index;
        public int Index
        {
            get { return index; }
            set
            {
                if (value != index)
                {
                    index = value;
                    OnPropertyChanged("Index");
                }
            }
        }

        public static event EventHandler CurrentSelectedChanged;
        public static TrackListViewModel CurrentSelected
        {
            get
            {
                return currentSelected;
            }
            set
            {
                if (value != currentSelected)
                {
                    currentSelected = value;
                    if (CurrentSelectedChanged != null)
                        CurrentSelectedChanged("Track", EventArgs.Empty);
                }
            }
        }

        public static event EventHandler CurrentHumanSelectedChanged;
        private static TrackListViewModel humanSelected;
        public static TrackListViewModel HumanSelected
        {
            get { return humanSelected; }
            //set
            //{
            //    if (value != humanSelected)
            //    {
            //        humanSelected = value;
            //        if (CurrentHumanSelectedChanged != null)
            //            CurrentHumanSelectedChanged("Human", EventArgs.Empty);
            //    }
            //}
        }

        public static void setHumanSelected(PlayListViewModel pl, TrackListViewModel track)
        {
            if (track != humanSelected)
            {
                humanSelected = track;
                  if (CurrentHumanSelectedChanged != null)
                      CurrentHumanSelectedChanged(pl, EventArgs.Empty);
            }
        }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
                //if (value != track.Enabled)
                //{
                //    track.Piece.Enabled = value;
                //    OnPropertyChanged("Enabled");
                //}
            }
        }
        //  private exportState exportState;
        //public int ExportState
        //{
        //    get
        //    {
        //        return (int)exportState;
        //    }
        //}

        public static EventHandler ExportStatusChange;
        private static void OnExportStatusChange(TrackListViewModel tv)
        {
            if (ExportStatusChange != null)
                ExportStatusChange(tv, EventArgs.Empty);
        }

        public static event EventHandler ClassementChange;
        private static void OnClassementChange(TrackListViewModel tv)
        {
            if (ClassementChange != null)
                ClassementChange(tv, EventArgs.Empty);
        }

        public TrackListViewModel TV { get { return this; } }

        public exportState ExportStatus
        {
            get
            {
                return PieceGen.ExportStatus; // exportState;
            }
            set
            {
                if (PieceGen.ExportStatus != value)
                {
                    PieceGen.ExportStatus = value;
                    OnPropertyChanged("ExportStatus");
                    OnPropertyChanged("TV");
                    refresh();
                    OnExportStatusChange(this);
                    //refresh();
                    OnPropertyChanged("Background");

                }
            }
        }






        public TrackListViewModel(TrackList track, PlayListViewModel playlist)
            : base(track, playlist)
        {
            this.track = track;
            this.piece = PieceViewModel.getPiece(track); // new PieceViewModel(track); // track.Piece.Track as CPiece; 
            piece.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(piece_PropertyChanged);
            int id = track.PieceId;
            //if (!dictT.ContainsKey(id))
            //{
            //    var list = new List<TrackListViewModel>();
            //    dictT.Add(id, list);
            //}

            //dictT[id].Add(this);

        }

        void piece_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            OnPropertyChanged(e.PropertyName);
        }

        public String StrPlaying
        {
            get
            {
                if (playing) return "<))";
                return "";
            }
        }
        public string MedianneStatus
        {
            get
            {
                var p = PieceGen;
                if (p.Medianne)
                    return ">>";
                if (p.MedianneLight)
                    return ">";
                if (p.Border)
                    return "-";
                if (p.BorderMin)
                    return "-";
                if (p.BorderEffect)
                    return "--";
              
                return "";
            }
        }

        private bool playing;
        public bool Playing
        {
            get { return playing; }
            set
            {
                if (value != playing)
                {
                    playing = value;
                    if (playing)
                    {
                        CurrentPlaying = this;
                    }
                    OnPropertyChanged("Playing");
                    OnPropertyChanged("StrPlaying");
                }
            }
        }

        public static TrackListViewModel CurrentPlaying
        {
            get
            {
                return currentPlaying;
            }
            set
            {
                if (value != currentPlaying)
                {
                    if (currentPlaying != null)
                        currentPlaying.Playing = false;
                    currentPlaying = value;
                }
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
                //if (value != track.Rating)
                //{
                //    track.Rating = value;
                //    onPropertyChanged("Rating");
                //}
            }
        }

        //  private pdb.db.obj.CPiece CPiece { get { return track.Piece.Track as pdb.db.obj.CPiece; } }


        //public static readonly DependencyProperty ClassementProperty =
        //DependencyProperty.Register("Classement", typeof(String),
        // typeof(PieceViewModel), new UIPropertyMetadata(null));
        public String Classement
        {
            get
            {
                return piece.Piece.StrClassement;
            }
            set
            {
                App.gen.Albums.signalClassChange(track); 
                // piece.StrClassement = value;
                if (value != piece.Piece.StrClassement)
                {
                    try
                    {
                    
                        App.bib.setClassement(this, value);

                        // piece.Piece.StrClassement = value;

                    }
                    catch
                    {
                    }
                    piece.Classement = value;
                    OnClassementChange(this);
                    // onPropertyChanged("Classement");


                }
                App.go();
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
                //if (value != piece.Year)
                //{
                //    track.Year = value;
                //    onPropertyChanged("Year");
                //}
            }
        }


        //public static readonly DependencyProperty CommentProperty =
        //DependencyProperty.Register("Comment", typeof(string),
        //typeof(PieceViewModel), new UIPropertyMetadata(null)); 
        public string Comment
        {
            get
            {
                return piece.Comment;
            }
            set
            {
                //piece.Comment = value; 
                if (value != piece.Comment)
                {
                    //  track.Comment = value;
                    piece.Comment = value;
                    OnPropertyChanged("Comment");

                }
            }
        }

        public string Grouping
        {
            get { return piece.Grouping; }
            set
            {
                //  piece.Grouping = value;
                if (value != piece.Grouping)
                {
                    piece.Grouping = value;
                    // track.setGrouping(value, true);
                    OnPropertyChanged("Grouping");
                }
            }
        }




        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }


        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set
            {
                piece.Duration = value;
                //if (!Exists)
                //    return; 
                //if (value != Duration)
                //{
                //    var deltaMs = Math.Abs(value.TotalMilliseconds - Duration.TotalMilliseconds);
                //    if (deltaMs >= 1)
                //    {
                //        track.Duration = value;
                //        if (deltaMs >= 1000)
                //            onPropertyChanged("Duration");
                //    }
                //}
            }
        }

        public string Location
        {
            get { return piece.Location; }
        }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
                //if (value != track.Artist)
                //{
                //    track.Artist = value;
                //    onPropertyChanged("Artist");
                //}
            }
        }

        public string Album
        {
            get
            {
                if (track.Virtual)
                    return track.Album;
                return piece.Album;
            }
            set
            {
                if (!track.Virtual)
                    piece.Album = value;
                //if (value != track.Album)
                //{
                //    track.Album = value;
                //    onPropertyChanged("Album");
                //}
            }
        }

        public string Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
                //if (value != track.Name)
                //{
                //    track.Piece.Name = value;
                //    onPropertyChanged("Name");
                //}
            }
        }

        public int TrackNumber
        {
            get
            {
                return piece.TrackNumber;
            }
            set
            {
                piece.TrackNumber = value;
                //if (value != track.TrackNumber)
                //{
                //    track.TrackNumber = value;
                //    onPropertyChanged("TrackNumber");
                //}
            }
        }


        public void setClassement(string className, int rating)
        {
            piece.Piece.setClassement(className, rating);
            PieceGen.invalidateCache();

        }

        public string ClassName
        {
            get
            {
                return piece.Piece.ClassName;
            }
            set
            {
                piece.Piece.ClassName = value;
            }
        }


        public DateTime PlayedDate
        {
            get { return piece.Piece.PlayedDate; }
        }

        public string ArtWork
        {
            get
            {
                return piece.Piece.ArtWork;
            }
            set
            {
                piece.Piece.ArtWork = value;
            }
        }

        public void setGrouping(string value, bool prior)
        {
            piece.Piece.setGrouping(value, prior);
            piece.Grouping = value;
            // onPropertyChanged("Grouping");
        }

        public string ClassementVirtuel { get { return PieceGen.ClassementVirtuel; } }

        public decimal CoeffVirtuel { get { return PieceGen.CoeffVirtuel; } }

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.Piece.ClassPlayLists; }
        }

        public List<DateTime> Dates
        {
            get { return new List<DateTime>(piece.Piece.Dates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.Piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return track.Piece.ClassEvol; }
        }

        public long Size { get { return Piece.Size; } }

        public bool Exists { get { return Piece.Exists; } }

        //public void onPropertyChanged(string propertyName)
        //{
        //    var list = dictT[PieceId];
        //    if (list == null)
        //    {
        //        OnPropertyChanged(propertyName);
        //    }
        //    else
        //    {
        //        foreach (TrackListViewModel t in dictT[PieceId])
        //            t.OnPropertyChanged(propertyName);
        //    }
        //}




        public int PieceId
        {
            get { return track.PieceId; }
        }


        public int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }

        public void setParent(TrackListViewModel parent)
        {
            piece.Piece.Parent = parent.Piece;
            track.Piece.Parent = parent.track.Piece;
        }

        public void fusion(TrackListViewModel toDelete)
        {
            App.Db.List.fusion(piece.Piece, toDelete.Piece);

        }





        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfAlbumSortW.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.ConfAlbumSortW"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="ConfAlbumSortW" Height="194" Width="978" Loaded="Window_Loaded">
    <Grid Height="116" Width="861">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="182*" />
            <ColumnDefinition Width="201*" />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="7*" />
        </Grid.RowDefinitions>
        <Grid Grid.ColumnSpan="2" Margin="0,0,-172,0">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />

            </Grid.ColumnDefinitions>
            <CheckBox Grid.Row="0" Grid.Column="0" Name="cb_enabled" ToolTip="utilisé" Margin="5" Padding="4" />
            <ComboBox Grid.Row="0" Grid.Column="1" Name="cbxSort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox  Grid.Row="0" Grid.Column="2" Name="tb_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="3" Name="cb_quasi" ToolTip="quasi" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="4" Name="cb_lissage" ToolTip="lissage" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="5" Name="cb_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="6" Name="cb_reSort" ToolTip="reSort" Margin="5" Padding="4" />
            <TextBox  Grid.Row="0" Grid.Column="7" Name="tb_safe" Width="30" ToolTip="safe" Margin="5" KeyUp="tb_safe_KeyDown" />
            <TextBox  Grid.Row="0" Grid.Column="8" Name="tb_coeff" Width="30" ToolTip="coeff des morceaux virtuels" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="9" Name="cb_removeFirst" ToolTip="mise à zero des premiers" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="10" Name="cb_deleteFirst" ToolTip="suppression des premiers" Margin="5" Padding="4" />
            <ComboBox ToolTip="removelast" Grid.Row="0" Grid.Column="11" Name="cbx1_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>unselected</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="0" Grid.Column="12" Name="cb_cumul" ToolTip="cumul" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="13" Name="cb_noAdd" ToolTip="pas d'ajout" Margin="5" Padding="4" />
            <TextBox  Grid.Row="0" Grid.Column="14" Name="tb_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="15" Name="cb_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="16" Name="cb_virtOnlyDisabled" ToolTip="virtuel: seulement les décochés" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="17" Name="cb_forceCoeffVirt" ToolTip="virtuel: coeff forcé" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="18" Name="cb_virtAlignSelected" ToolTip="virtuel: aligné sur le coché" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="19" Name="cb_virtAlignPrec" ToolTip="virtuel: aligné sur le précédent" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="20" Name="cb_coeffVirtAdjust" ToolTip="coeffvirt ajusté sur coeff selected" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="21" Name="cb_coeffVirtAuto" ToolTip="coeffvirt automatique" Margin="5" Padding="4" />
            <TextBox  Grid.Row="0" Grid.Column="22" Name="tb_zero" Width="120" ToolTip="zéro" Margin="5" />

            <CheckBox Grid.Row="1" Grid.Column="0"  Name="cb2_enabled" ToolTip="utilisé" Margin="5" Padding="4" />
            <ComboBox Grid.Row="1" Grid.Column="1" Name="cbx2Sort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none2"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict2">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light2" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy2" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox Grid.Row="1" Grid.Column="2"  Name="tb2_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox Grid.Row="1" Grid.Column="3" Name="cb2_quasi" ToolTip="quasi" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="4" Name="cb2_lissage" ToolTip="lissage" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="5" Name="cb2_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="6" Name="cb2_reSort" ToolTip="reSort" Margin="5" Padding="4" />
            <TextBox  Grid.Row="1" Grid.Column="7" Name="tb2_safe" Width="30" ToolTip="safe" Margin="5" />
            <TextBox  Grid.Row="1" Grid.Column="8" Name="tb2_coeff" Width="30" ToolTip="coeff des morceaux virtuels" Margin="5" />
            <CheckBox  Grid.Row="1" Grid.Column="9" Name="cb2_removeFirst" ToolTip="removeFirst" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="10" Name="cb2_deleteFirst" ToolTip="deleteFirst" Margin="5" Padding="4" />
            <ComboBox ToolTip="removelast" Grid.Row="1" Grid.Column="11" Name="cbx2_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>unselected</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="1" Grid.Column="12" Name="cb2_cumul" ToolTip="cumul" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="13" Name="cb2_noAdd" ToolTip="pas d'ajout" Margin="5" Padding="4" />
            <TextBox  Grid.Row="1" Grid.Column="14" Name="tb2_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox  Grid.Row="1" Grid.Column="15" Name="cb2_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="16" Name="cb2_virtOnlyDisabled" ToolTip="virtuel: seulement les décochés" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="17" Name="cb2_forceCoeffVirt" ToolTip="virtuel: coeff forcé" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="18" Name="cb2_virtAlignSelected" ToolTip="virtuel: aligné sur le coché" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="19" Name="cb2_virtAlignPrec" ToolTip="virtuel: aligné sur le précédent" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="20" Name="cb2_coeffVirtAdjust" ToolTip="coeffvirt ajusté sur coeff selected" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="21" Name="cb2_coeffVirtAuto" ToolTip="coeffvirt automatique" Margin="5" Padding="4" />
            <TextBox  Grid.Row="1" Grid.Column="22" Name="tb2_zero" Width="120" ToolTip="zéro" Margin="5" />
        </Grid>
        
        <StackPanel Grid.Row="2"  Orientation="Horizontal"  HorizontalAlignment="Right" Margin="0,5" Grid.Column="1" Width="243">
            <TextBox Grid.Row="2" Name="tb_stackSize" Width="30"  VerticalAlignment="Center" Text="10" ToolTip="taille de la pile d'exclusion" Margin="5" Padding="4"/>
            <TextBox Grid.Row="2" Name="tb_coeffEnabled" Width="60"  VerticalAlignment="Center" Text="1" ToolTip="Coeff des morceaux cochés"  KeyUp="tb_safe_KeyDown" Margin="5" Padding="4"/>
            <Button Grid.Row="2" Name="bt_cancel" Height="25" HorizontalAlignment="Right" Content="Cancel" Click="bt_cancel_Click"   Margin="5" Padding="4"/>
            <Button Grid.Row="2" Name="bt_ok" Height="25" HorizontalAlignment="Right" Content="Ok" Click="bt_ok_Click"   Margin="5" Padding="4"/>
        </StackPanel>
    </Grid>

</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfAlbumSortW.xaml.cs">
    <content><![CDATA[using System;
using System.Windows;
using pdb.gen.Tuning;
using pdb.gen;
using pdb.db.piece.type;

namespace pdb.player.Vue
{
    /// <summary>
    /// Interaction logic for ConfAlbumSortW.xaml
    /// </summary>
    public partial class ConfAlbumSortW : Window
    {
        private ConfAlbumSort conf;
        public ConfAlbumSortW()
        {
            InitializeComponent();
            this.Loaded += new RoutedEventHandler(ConfAlbumSortW_Loaded);
        }

        void ConfAlbumSortW_Loaded(object sender, RoutedEventArgs e)
        {
            bt_ok.IsDefault = true; 
            display();
        }

        public ConfAlbumSortW(ConfAlbumSort conf)
            : this()
        {
            this.conf = conf;
        }

        void display()
        {
            tb_coeffEnabled.Text = conf.coeffEnabled.ToString();
            tb_stackSize.Text = conf.stackSize.ToString(); 
            var list = conf.Composants;
            var item1 = list[0];
            cb_enabled.IsChecked = item1.enabled;
            cbxSort.SelectedIndex = (int)item1.type;
            tb_medianne.Text = item1.medianne.ToString();
            cb_quasi.IsChecked = item1.quasi;
            cb_lissage.IsChecked = item1.lissage;
            cb_removeEpsilon.IsChecked = item1.removeEpsilon;
            cb_reSort.IsChecked = item1.reSort;
            cb_removeFirst.IsChecked = item1.removeFirst;
            cb_deleteFirst.IsChecked = item1.deleteFirst;
            cbx1_removeLast.SelectedIndex = (int)item1.removeLast;
            cb_cumul.IsChecked = item1.cumul;
            cb_noAdd.IsChecked = item1.noAdd;
            tb_safe.Text = item1.safe.ToString();
            tb_coeff.Text = item1.coeffVirt.ToString();
            tb_exp.Text = item1.expEnabled.ToString();
            tb_zero.Text = Piece.getClassementEquiv(item1.zero);
            cb_removeEnabled.IsChecked = item1.removeEnabled;
            cb_virtOnlyDisabled.IsChecked = item1.virtOnlyDisabled;
            cb_forceCoeffVirt.IsChecked = item1.forceCoeffVirt;
            cb_virtAlignPrec.IsChecked = item1.virtAlignPrec;
            cb_virtAlignSelected.IsChecked = item1.virtAlignSelected;
            cb_coeffVirtAdjust.IsChecked = item1.coeffVirtAdjust;
            cb_coeffVirtAuto.IsChecked = item1.coeffVirtAuto;



            if (list.Count > 1)
            {
                item1 = list[1];
                cb2_enabled.IsChecked = item1.enabled;
                cbx2Sort.SelectedIndex = (int)item1.type;
                tb2_medianne.Text = item1.medianne.ToString();
                cb2_quasi.IsChecked = item1.quasi;
                cb2_lissage.IsChecked = item1.lissage;
                cb2_removeEpsilon.IsChecked = item1.removeEpsilon;
                cb2_reSort.IsChecked = item1.reSort;
                cb2_removeFirst.IsChecked = item1.removeFirst;
                cb2_deleteFirst.IsChecked = item1.deleteFirst;
                cbx2_removeLast.SelectedIndex = (int)item1.removeLast;
                cb2_cumul.IsChecked = item1.cumul;
                cb2_noAdd.IsChecked = item1.noAdd;
                tb2_safe.Text = item1.safe.ToString();
                tb2_coeff.Text = item1.coeffVirt.ToString();
                tb2_exp.Text = item1.expEnabled.ToString();
                tb2_zero.Text = Piece.getClassementEquiv(item1.zero);
                cb2_removeEnabled.IsChecked = item1.removeEnabled;
                cb2_virtOnlyDisabled.IsChecked = item1.virtOnlyDisabled;
                cb2_forceCoeffVirt.IsChecked = item1.forceCoeffVirt;
                cb2_virtAlignPrec.IsChecked = item1.virtAlignPrec;
                cb2_virtAlignSelected.IsChecked = item1.virtAlignSelected;
                cb2_coeffVirtAdjust.IsChecked = item1.coeffVirtAdjust;
                cb2_coeffVirtAuto.IsChecked = item1.coeffVirtAuto;
            }
        }
        void record()
        {
            conf.coeffEnabled = Convert.ToDecimal(tb_coeffEnabled.Text);
            conf.stackSize = Convert.ToInt32(tb_stackSize.Text); 
            var list = conf.Composants;
            var item1 = list[0];
            item1.enabled = cb_enabled.IsChecked.Value;
            item1.type = (util.medianneMode)cbxSort.SelectedIndex;
            item1.medianne = Convert.ToDecimal(tb_medianne.Text);
            item1.quasi = cb_quasi.IsChecked.Value;
            item1.lissage = cb_lissage.IsChecked.Value;
            item1.removeEpsilon = cb_removeEpsilon.IsChecked.Value;
            item1.reSort = cb_reSort.IsChecked.Value;
            item1.removeFirst = cb_removeFirst.IsChecked.Value;
            item1.deleteFirst = cb_deleteFirst.IsChecked.Value;
            item1.removeLast = (util.removeLast)cbx1_removeLast.SelectedIndex;
            item1.cumul = cb_cumul.IsChecked.Value;
            item1.noAdd = cb_noAdd.IsChecked.Value;
            item1.safe = Convert.ToInt32(tb_safe.Text);
            item1.coeffVirt = Convert.ToDecimal(tb_coeff.Text);
            item1.expEnabled = Convert.ToDecimal(tb_exp.Text);
            var cl = Classement.create(tb_zero.Text);
            item1.zero = cl.RapportClassement;
            item1.removeEnabled = cb_removeEnabled.IsChecked.Value;
            item1.virtOnlyDisabled = cb_virtOnlyDisabled.IsChecked.Value;
            item1.forceCoeffVirt = cb_forceCoeffVirt.IsChecked.Value;
            item1.virtAlignPrec = cb_virtAlignPrec.IsChecked.Value;
            item1.virtAlignSelected = cb_virtAlignSelected.IsChecked.Value;
            item1.coeffVirtAuto = cb_coeffVirtAuto.IsChecked.Value;
            item1.coeffVirtAdjust = cb_coeffVirtAdjust.IsChecked.Value;

            if (list.Count > 1)
            {
                if (cbx2Sort.SelectedIndex == 0)
                {
                    list.RemoveAt(1);
                    return;
                }
            }
            else
            {
                if (cbx2Sort.SelectedIndex > 0)
                {
                    item1 = new util.ConfMedianne();
                    list.Add(item1);
                }
            }

            if (list.Count > 1)
            {
                item1 = list[1];

                item1.enabled = cb2_enabled.IsChecked.Value;
                item1.type = (util.medianneMode)cbx2Sort.SelectedIndex;
                item1.medianne = Convert.ToDecimal(tb2_medianne.Text);
                item1.quasi = cb2_quasi.IsChecked.Value;
                item1.lissage = cb2_lissage.IsChecked.Value;
                item1.removeEpsilon = cb2_removeEpsilon.IsChecked.Value;
                item1.reSort = cb2_reSort.IsChecked.Value;
                item1.removeFirst = cb2_removeFirst.IsChecked.Value;
                item1.deleteFirst = cb2_deleteFirst.IsChecked.Value;
                item1.removeLast = (util.removeLast)cbx2_removeLast.SelectedIndex;
                item1.cumul = cb2_cumul.IsChecked.Value;
                item1.noAdd = cb2_noAdd.IsChecked.Value;
                item1.safe = Convert.ToInt32(tb2_safe.Text);
                item1.coeffVirt = Convert.ToDecimal(tb2_coeff.Text);
                item1.expEnabled = Convert.ToDecimal(tb2_exp.Text);
                item1.zero = Convert.ToDecimal(tb2_zero.Text);

                cl = Classement.create(tb2_zero.Text);
                item1.zero = cl.RapportClassement;
                item1.removeEnabled = cb2_removeEnabled.IsChecked.Value;
                item1.virtOnlyDisabled = cb2_virtOnlyDisabled.IsChecked.Value;
                item1.forceCoeffVirt = cb2_forceCoeffVirt.IsChecked.Value;
                item1.virtAlignPrec = cb2_virtAlignPrec.IsChecked.Value;
                item1.virtAlignSelected = cb2_virtAlignSelected.IsChecked.Value;
                item1.coeffVirtAuto = cb2_coeffVirtAuto.IsChecked.Value;
                item1.coeffVirtAdjust = cb2_coeffVirtAdjust.IsChecked.Value;
            }
        }

        private void bt_cancel_Click(object sender, RoutedEventArgs e)
        {
            Close();
        }

        private void bt_ok_Click(object sender, RoutedEventArgs e)
        {
            record();
            Close();
            conf.Calcul();
            App.go();
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {

        }

        private void tb_safe_KeyDown(object sender, System.Windows.Input.KeyEventArgs e)
        {
            onchange(); 
        }

        private void tb_safe_TextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
        {
            onchange(); 
        }

        private void onchange()
        {
            if (true != cb_coeffVirtAdjust.IsChecked)
                return;
            try
            {
                var safe = Convert.ToInt32(tb_safe.Text);
                var coeffEnabled = Convert.ToDecimal(tb_coeffEnabled.Text);
                var coeffVirt = Math.Pow((double)coeffEnabled, 1.0 / (safe + 1.0));
                tb_coeff.Text = coeffVirt.ToString();
            }
            catch
            {
            }

        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\HashList.cs">
    <content><![CDATA[using System.Collections.Generic;

namespace pdb.util
{
    /// <summary>
    /// Cumule HashTable et liste
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class HashList<T> : IEnumerable<T>
    {
        private Dictionary<T, IndexItem> dict = new Dictionary<T, IndexItem>();
        private List<T> list = new List<T>();

        public void Add(T item)
        {
            int index = list.Count;
            IndexItem iitem = new IndexItem(index, item);
            dict.Add(item, iitem);
            list.Add(item);
        }

        public HashList()
        {
        }

        public HashList(int count)
        {
            list = new List<T>(count);
            dict = new Dictionary<T, IndexItem>(count);
        }

        public HashList(IEnumerable<T> source)
        {
            foreach (T item in source)
            {
                Add(item);
            }
        }

        public bool Contains(T item)
        {
            return dict.ContainsKey(item);
        }

        public bool Remove(T item)
        {
            if (!dict.ContainsKey(item))
                return false;
            var index = dict[item].index;
            dict.Remove(item);
            list.RemoveAt(index);
            return true;
        }

        public int IndexOf(T item)
        {
            if (dict.ContainsKey(item))
                return dict[item].index;
            return -1;
        }

        private class IndexItem
        {
            public readonly int index;
            public readonly T value;
            public IndexItem(int index, T value)
            {
                this.index = index;
                this.value = value;
            }
        }

        public IEnumerator<T> GetEnumerator()
        {
            return list.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public void Sort(IComparer<T> comparer)
        {
            var aux = list;
            aux.Sort(comparer);
            list = new List<T>();
            dict = new Dictionary<T, IndexItem>();

            foreach (T item in aux)
            {
                Add(item);
            }

        }
        public List<T> List { get { return new List<T>(list); } }
        public int Count { get { return list.Count; } }
        public T this[int index]
        {
            get
            {
                return list[index];
            }
            set
            {
                IndexItem iitem = new IndexItem(index, value);
                if (dict.ContainsKey(value))
                    dict[value] = iitem;
                else
                    dict.Add(value, iitem); 
                list[index] = value; 
            }
        }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\pdb.gen.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.gen</RootNamespace>
    <AssemblyName>pdb.gen</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="albums\Album.cs" />
    <Compile Include="albums\AlbumComparer.cs" />
    <Compile Include="albums\AlbumMedianne.cs" />
    <Compile Include="albums\Albums.cs" />
    <Compile Include="albums\StackAlbum.cs" />
    <Compile Include="albums\VirtualAlbumPiece.cs" />
    <Compile Include="CalcEquiv.cs" />
    <Compile Include="Consolid.cs" />
    <Compile Include="CLegacyListWriter.cs" />
    <Compile Include="CRank.cs" />
    <Compile Include="IListWriter.cs" />
    <Compile Include="ListPiece.cs" />
    <Compile Include="CPieceComparer.cs" />
    <Compile Include="ListSelection.cs" />
    <Compile Include="ListWriterMgr.cs" />
    <Compile Include="Math.cs" />
    <Compile Include="pertinence\TrackBuilder.cs" />
    <Compile Include="Piece.cs" />
    <Compile Include="CalcDate.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="stat\ClassStruct.cs" />
    <Compile Include="stat\Condenseur.cs" />
    <Compile Include="stat\DynamicStatBuilder.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="stat\MedianneValue.cs" />
    <Compile Include="stat\NewClassement.cs" />
    <Compile Include="stat\StatBuilder.cs" />
    <Compile Include="stat\StatConteneur.cs" />
    <Compile Include="TrackList.cs" />
    <Compile Include="Tuning\CConf.cs" />
    <Compile Include="Tuning\CConfQL.cs" />
    <Compile Include="Tuning\CConfSort.cs" />
    <Compile Include="Tuning\ConfAlbumSort.cs" />
    <Compile Include="Tuning\ConfGen.cs" />
    <Compile Include="Tuning\CTuning.cs" />
    <Compile Include="Tuning\Export.cs" />
    <Compile Include="Tuning\GroupingDisplay.cs" />
    <Compile Include="Tuning\Import.cs" />
    <Compile Include="Virtuel\VirtualPiece.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823D1D-851C-456B-AC4C-B0BEEC173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\PieceDb.Consolid\Piece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;

namespace pdb.gen
{
    public enum infoMedianne : short
    {
        none = 0,
        med = 1,
        medLight = 2,
        border = 4,
        borderEff = 8,
        borderMin = 16
    }
    /// <summary>
    /// Ajout de données utiles Ranq
    /// </summary>
    public class Piece : ITrackMetaData, IFile, ITrackNativeDates
    {
        private ITrackNativeDates track;
        public bool Virtual { get { return PieceId < 0; } }
        // private String className = "";
        private static CultureInfo en = new CultureInfo("en-US");
        //  private static List<displayCategory> minCategories;

        protected static Consolid gen;
        public static Consolid Gen { set { gen = value; } }

        static Piece()
        {
            //   minCategories = new List<displayCategory> { displayCategory.rankTime, displayCategory.timeValue, displayCategory.dates, displayCategory.pertinentDates };
        }

        public ITrackNativeDates Track { get { return track; } }

        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank
        {
            get
            {
                if (parent == null)
                    return m_rank;
                return parent.m_rank;
            }
        }

        private infoMedianne _infoMedianne;
        public void eraseInfoMedianne() { _infoMedianne = infoMedianne.none; }
        public infoMedianne InfoMedianne { get { return _infoMedianne; } }
        public bool Medianne
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.med);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Medianne)
                    return;
                _infoMedianne |= infoMedianne.med;
            }
        }
        public bool MedianneLight
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.medLight);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (MedianneLight)
                    return;
                _infoMedianne |= infoMedianne.medLight;
            }
        }

        public bool Border
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.border);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Border)
                    return;
                _infoMedianne |= infoMedianne.border;
            }
        }

        public bool BorderEffect
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderEff);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderEffect)
                    return;
                _infoMedianne |= infoMedianne.borderEff;
            }
        }

        public bool BorderMin
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderMin);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderMin)
                    return;
                _infoMedianne |= infoMedianne.borderMin;
            }
        }


        public void initRank()
        {
            _rapportClassement = -1;
            _infoMedianne = infoMedianne.none;

            // _lnClassement = int.MinValue; 
            Rank.init();
        }

        public int QRank
        {
            get { return Rank.Quality; }
            set { Rank.Quality = value; }
        }

        public int LRank
        {
            get { return Rank.Lenght; }
            set { Rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return Rank.Twice; }
            set { Rank.Twice = value; }
        }

        public int RankAllAlbum
        {
            get { return m_rank.RankAllAlbum; }
            set { m_rank.RankAllAlbum = value; }
        }

        public int RankAlbum { get { if (album == null) return 0; return album.Rank.Sort; } }

        //  public TuningData TuningData { get { return m_rank.Rest; } set { m_rank.Rest = value; } }
        #endregion



        public bool FirstClass { get { return track.FirstClass; } set { track.FirstClass = value; } }
        private Album album;

        internal Album PieceAlbum { get { return album; } set { album = value; } }
        private static int _sID = 0;
        private int _dID;
        internal Piece(ITrackNativeDates track)
        {
            _sID++;
            _dID = _sID;
            this.track = track; initRank();

#if VOL
            int volumeMin = CConf.VolumeMin;
            if (Volume < volumeMin)
                Volume = volumeMin;
#endif
        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList()
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        public String ClassName { get { return track.ClassName; } set { track.ClassName = value; } }

        public void setClassement(string className, int rating)
        {
            if (className == null)
                return;
            track.setClassement(className, rating);
            invalidateCache();

        }

        public void invalidateCache()
        {
            _classNameAndRating = null;
            _classementValueDecimal = -1;
            _rapportClassement = -1;

            if (parent != null)
                parent.invalidateCache(); 

        }

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in track.PLayLists)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        #region CPieceComparer compatibilité
        public List<CPlayList> ClassPlayLists
        {
            get { return track.ClassPlayLists; }
        }
        /// <summary>
        /// ClassList principale
        /// </summary>
        public CPlayList ClassPlayList
        {
            get
            {
                List<CPlayList> classLists = track.ClassPlayLists;
                if (classLists.Count > 0)
                    return classLists[0];
                return null;
            }
        }


        public int RatingCmp
        {
            get
            {
                int rating = track.Rating;
                if (rating < 0)
                    return 0;
                return rating;
            }
        }
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return ClassName.isInteger();
            }
        }

        private string _classNameAndRating;
        public String ClassNameAndRating
        {
            get
            {
                if (_classNameAndRating == null)
                {
                    if (!isClassListNumeric)
                        _classNameAndRating = "";
                    _classNameAndRating = ClassName + ((track.Rating / 20).ToString());
                }
                return _classNameAndRating;
            }
        }

        private decimal _classementValueDecimal = -1;
        public decimal ClassementValueDecimal
        {
            get
            {
                if (_classementValueDecimal < 0)
                {
                    if (!isClassListNumeric) return 0;
                    string classNameAndRating = ClassNameAndRating.Insert(1, ",");
                    _classementValueDecimal = Convert.ToDecimal(classNameAndRating);
                }
                return _classementValueDecimal;
            }
        }
        //private double _classementValue = -1; 
        //public double ClassementValue
        //{
        //    get
        //    {
        //        if (_classementValue == -1)
        //        {
        //            if (!isClassListNumeric)
        //                _classementValue = 0;
        //            else
        //            {
        //                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
        //                _classementValue= Convert.ToDouble(classNameAndRating);
        //            }
        //        }

        //        return _classementValue; 
        //    }
        //}

        private decimal _rapportClassement = -1;
        public decimal RapportClassement
        {
            get
            {
                if (parent != null)
                    return parent.RapportClassement;
                if (_rapportClassement != -1)
                    return _rapportClassement;

                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                _rapportClassement = resultat;
                // _classementVirtuel = resultat; 
                return _rapportClassement;
            }
        }


        //private decimal _lnClassement = -1;
        //public decimal LnClassement
        //{
        //    get
        //    {
        //        if (_lnClassement == int.MinValue)
        //        {
        //            var rapport = RapportClassement;
        //            if (rapport <= 0m)
        //                _lnClassement = 0m;
        //            else
        //                _lnClassement = Math.Log10(rapport) + 10;
        //        }
        //        return _lnClassement; 
        //    }
        //}
        static int NB_DEC = 4;
        public static string getReadableCl(string str)
        {
            int count = str.Length;
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {
                        if (i >= NB_DEC)
                        {
                            i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();
        }

        public static string getClassementEquiv(decimal valRapport)
        {
            if (valRapport < 0)
                return "";
            if (valRapport == 0m)
                return "0";
            decimal v = 0;
            decimal r = valRapport;
            StringBuilder sb = new StringBuilder();
            int _ok = Int16.MaxValue;

            for (int i = 0; i < 13; i++)
            {
                v = 6 * r;
                int a = (int)(v + 0.0001m);
                if (a > 0 && i < _ok)
                {
                    _ok = i;
                }
                r = v - a;
                if (r < 0)
                    r = 0;
                sb.Append(a);


                if (i >= _ok + 4)
                    break;
            }
            var str = sb.ToString();
            str = str.Insert(str.Length - 1, ".");
            return getReadableCl(str);
        }




        public decimal RapportClassementDecimal
        {
            get
            {
                if (parent != null)
                    return parent.RapportClassementDecimal;
                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1m;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                return resultat;
            }
        }

        public int classPrecision()
        {
            string classNameAndRating = ClassNameAndRating;
            int precision = 0;
            char[] tab = classNameAndRating.ToCharArray();
            int count = tab.GetLength(0);

            int iIndexDepart = -1;
            int iIndexFin = -1;
            for (int i = 0; i < count; i++)
            {
                Char c = tab[i];
                if (iIndexDepart < 0)
                {
                    if (c != '0')
                        iIndexDepart = i;
                }

                if (c != '0')
                    iIndexFin = i;
            }

            precision = iIndexFin - iIndexDepart + 1;

            return precision;
        }
        #endregion

        #region compatibilité CList
        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        public bool checkIdentity(ITrackIdentity other)
        {
            //return track.Location == other.Location; 
            String location = track.Location;
            return (location.Equals((other.Location)) || CUtil.DefinedEquals(track.Artist, track.Album, track.Name, track.TrackNumber, other.Artist, other.Album, other.Name, other.TrackNumber));
        }
        #endregion

        #region ITrackNative Membres

        public string Artist
        {
            get
            {
                return track.Artist;
            }
            set
            {
                if (track.Artist != value)
                {
                    try
                    {
                        //                 misc.log("change artist from '{0}' to'{1}'", track.Artist, value);
                        track.Artist = value;
                    }
                    catch { misc.log("unable to change artist {0}  {1}", track.Artist, value); }
                }
            }
        }

        public virtual string Album
        {
            get
            {
                return track.Album;
            }
            set
            {
                if (track.Album != value)
                {
                    try
                    {
                        //                   misc.log("change Album from '{0}' to'{1}'", track.Album, value);
                        track.Album = value;
                    }
                    catch { misc.log("unable to change album {0}  {1}", track.Album, value); }
                }
            }
        }

        public string Name
        {
            get
            {
                return track.Name;
            }
            set
            {
                if (track.Name != value)
                {
                    try
                    {
                        //                 misc.log("change Name from '{0}' to'{1}'", track.Name, value);
                        track.Name = value;
                    }
                    catch { misc.log("unable to change name {0}  {1}", track.Name, value); }
                }
            }
        }

        public virtual int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (track.TrackNumber != value)
                {
                    try
                    {
                        //              misc.log("change TrackNumber from '{0}' to'{1}'", track.TrackNumber, value);
                        track.TrackNumber = value;
                    }
                    catch { misc.log("unable to change TrackNumber {0}  {1}", track.TrackNumber, value); }
                }
            }
        }

        public int Rating
        {
            get
            {
                return track.Rating;
            }
            set
            {
                if (track.Rating != value)
                {
                    try
                    {
                        //                misc.log("change Rating from '{0}' to'{1}'", track.Rating, value);
                        track.Rating = value;
                    }
                    catch { misc.log("unable to change Rating {0}  {1}", track.Rating, value); }
                }
            }
        }

        public int Year
        {
            get
            {
                return track.Year;
            }
            set
            {
                if (track.Year != value)
                {
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Year = value;
                    }
                    catch { misc.log("unable to change Year {0}  {1}", track.Year, value); }
                }
            }
        }

#if VOL
        public int Volume
        {
            get
            {
                int volumeMin = CConf.VolumeMin;
                int trackVolume = track.Volume;
                if (trackVolume < volumeMin)
                {
                    Volume = volumeMin;
                }
                return trackVolume;
            }
            set
            {
                if (track.Volume != value)
                {
                    int volumeMin = CConf.VolumeMin;
                    int _value = Math.Max(value, volumeMin);
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Volume = _value;
                    }
                    catch { misc.log("unable to change Volume {0}  {1}", track.Volume, _value); }
                }
            }
        }
#endif

        public string Comment
        {
            get
            {
                //if (string.IsNullOrEmpty(track.Comment))
                //    gen.writeComment(this);
                return track.Comment;
            }
            set
            {
                //if (track.Comment != value)
                //{
                try
                {
                    //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
                    track.Comment = value;
                }
                catch { misc.log("unable to change Comment {0}  {1}", track.Comment, value); }
                //}
            }
        }

        public virtual string Grouping
        {
            get
            {
                if (string.IsNullOrEmpty(track.Grouping))
                {
                    gen.writeGrouping(this);
                }
                return track.Grouping;
            }
            //set
            //{
            //    //if (track.Grouping != value)
            //    //{
            //        try
            //        {
            //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
            //            track.Grouping = value;
            //        }
            //        catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
            //    //}
            //}

        }





        public virtual void setGrouping(string value, bool prior)
        {
            try
            {
                //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
                track.setGrouping(value, prior);
            }
            catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        }

        public bool Enabled
        {
            get
            {
                return track.Enabled;
            }
            set
            {
                if (track.Enabled != value)
                {
                    try
                    {
                        //      misc.log("change Enabled from '{0}' to'{1}'", track.Enabled, value);
                        track.Enabled = value;
                    }
                    catch { misc.log("unable to change Enabled {0}  {1}", track.Enabled, value); }
                }
            }
        }

        public bool isPodcast
        {
            get { return track.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return track.PlayedDate; }
        }

        public string Location
        {
            get { return track.Location; }
        }

        public TimeSpan Duration
        {
            get { return track.Duration; }
            set { track.Duration = value; }
        }

        #endregion

        public List<DateTime> Dates
        {
            get { return track.Dates; }
        }
        public string ArtWork
        {
            get { return track.ArtWork; }
            set { track.ArtWork = value; }
        }

        public List<DateTime> DatesClassement { get { return track.DatesClassement; } }

        public String ClassEvol { get { return track.ClassEvol; } }


        public void writeCommentGrouping()
        {
            var mode = CConf.ConfGen.WriteComment;
            writeComment(mode);
            var modeg = CConf.ConfGen.WriteGrouping;
            writeGrouping(modeg);

        }

        //public List<CPlayList> PLayLists
        //{
        //    get { return track.PLayLists; }
        //}

        /// <summary>
        /// Calculer le commentaire
        /// </summary>
        public void writeComment(writeGrouping mode)
        {
            if (parent != null)
                return;
            if (mode == Tuning.writeGrouping.none)
                return;


            if (mode == Tuning.writeGrouping.mix)
            {
                StringBuilder sbEnd = new StringBuilder();

                sbEnd.Append(ClassName);
                sbEnd.Append(".");
                sbEnd.Append((RatingCmp / 20).ToString());
                sbEnd.Append(ClassEvol);
                string strEnd = sbEnd.ToString();
                string found = "";

                string[] tab = Comment.Split(' ');
                int count = tab.GetLength(0);
                if (count > 0)
                {
                    found = tab[count - 1];
                    if (found.Equals(strEnd))
                        return;
                }
                writeComment(Tuning.writeGrouping.all);
            }

            StringBuilder sb = new StringBuilder();
            //string l_pref = "";
            //string l_str = "";

            string l_strList = ClassName;
            //if (ClassPlayList != null)
            //    l_strList = ClassName;

            ////if (m_classement.Imported)
            ////{
            //if (l_strList != ClassName)
            //{
            //    sb.Append("m (");
            //    sb.Append(ClassName);
            //    sb.Append(") "); 
            //  //  l_pref = "m (" + ClassName + ") ";
            //}
            ////}
            int l_rank = Rank.Twice;

            if (l_rank > 0)
            {
                CTuning.format(sb, l_rank);
                sb.Append(" ");
                //    if (l_rank < 1000)
                //    {
                //        if (CTuning.Total > 1000)
                //        {
                //            l_str += "0";
                //        }
                //        if (l_rank < 100)
                //        {
                //            l_str += "0";
                //            if (l_rank < 10)
                //            {
                //                l_str += "0";
                //            }
                //        }
                //    }


                var r = CTuning.Rapport(Rank.Quality);






                var quality = CConf.Select.Quality;
                //if (quality.Mode != listMode.substract || quality.Exp != 1 || quality.Offset != 0 || CConf.Select.TimePriority != 0)
                //{
                double tx0 = Convert.ToInt32(1000 * r);
                sb.Append(tx0.ToString());
                sb.Append(" ");
                //}

                //  double l_tx = Convert.ToInt32(1000 * CTuning.Calc(m_rank, CConf.Select)); //   RapportNorm(m_rank.Quality, CConf.Sort.Quality));
                var l_tx = CConf.ConfGen.Vie.TotalDays() / CTuning.Calc(m_rank, CConf.Select);
                //  double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
                //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
                //getTx(m_rank.Lenght)
                //     l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();


                sb.Append(l_tx.FormatCustom(3, 4)); //   ToString("G2", en));
                //if (l_tx < 100 || l_tx >= 1000)
                //    sb.Append(l_tx.ToString("G2", en));
                //else
                //    sb.Append(Convert.ToInt64(l_tx).ToString("D", en)); 



                sb.Append(" ");
                var rest = r;

                for (int i = 0; i < 4; i++)
                {
                    var ee = rest * 6.0m;
                    int e = (int)System.Math.Floor(ee);
                    rest = ee - e;
                    sb.Append(e);
                }



                sb.Append(" ");


                //sb.Append(l_tx2.ToString());
                //sb.Append(" ");
                //sb.Append((100 * m_rank.SortValue).ToString("0"));
                //sb.Append(" ");

                //sb.Append(Dates.Count.ToString()); sb.Append(" ");

                //sb.Append(DatesClassement.Count.ToString()); sb.Append(" ");

                //sb.Append(ListSelection.buildListReadOrClassementModified(this).Count.ToString()); sb.Append(" ");

                //   sb.Append((100 * m_rank.TimeRest).ToString("0")); sb.Append(" ");



                sb.Append(l_strList);
                sb.Append(".");
                sb.Append((RatingCmp / 20).ToString());

            }

            sb.Append(ClassEvol);



            Comment = sb.ToString();
            //Comment = l_pref + l_str + ClassEvol;
        }

        public override string ToString()
        {
            return track.ToString();
        }

        public override bool Equals(object obj)
        {
            Piece p = obj as Piece;
            if (p == null)
                return false;
            return PieceId.Equals(p.PieceId);


        }

        private decimal _classementVirtuel;

        public string ClassementVirtuel { get { return Piece.getClassementEquiv(_classementVirtuel); } }
        public decimal VirtualClassement { get { return _classementVirtuel; } }
        public void setClassementVirtuel(decimal virt)
        {
            _classementVirtuel = virt;
        }

        public decimal CoeffVirtuel
        {
            get
            {
                if (_classementVirtuel == 0)
                    return 0;
                return _rapportClassement / _classementVirtuel;
            }
        }

        public override int GetHashCode()
        {
            return PieceId.GetHashCode();
        }

        private bool haveToUpdateGrouping = false;
        public void MarkAsUpdateGrouping() { haveToUpdateGrouping = true; }

        public void writeGrouping(writeGrouping writeGrouping)
        {
            var cat = CConf.ConfGen.DisplayCategories;
            //if (!CConf.ConfGen.WithOrder)
            //    cat = minCategories; 
            if (writeGrouping == Tuning.writeGrouping.none)
                return;

            //if (m_rank.Twice <= 0)
            //    return;
            if (haveToUpdateGrouping)
            {
                setGrouping(getGroup(cat), true);
            }

            else if (writeGrouping == Tuning.writeGrouping.mix)
            {
                bool haveToUpdate = false;
                string org = Grouping;
                if (org != null)
                {
                    string[] data = org.Split(' ');

                    try
                    {
                        foreach (datesMode mode in Enum.GetValues(typeof(datesMode))) //  CConf.ConfGen.Modes) //  Enum.GetValues(typeof(datesMode)))
                        {
                            DisplayGrouping found = cat.Find(c => (int)c.category == (int)mode);
                            //displayCategory found = cat.Find(c => (int)c == (int)mode);
                            if (found != null)
                            {
                                int indexOfTime = cat.IndexOf(found);

                                string timeValue = data[indexOfTime];
                                string newValue = getTimeValue(mode, found.mode);
                                if (!newValue.Equals(timeValue))
                                {
                                    haveToUpdate = true;
                                    break;
                                }
                            }
                        }
                    }
                    catch
                    {
                        haveToUpdate = true;
                    }
                }
                else
                {
                    haveToUpdate = true;
                }
                if (haveToUpdate)
                    setGrouping(getGroup(cat), true);
            }
            else
                setGrouping(getGroup(cat), false);
        }



        private string getTimeValue(datesMode modeDates, timeMode modeTime)
        {
            switch (modeTime)
            {
                case timeMode.simple: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates)).FormatCustomTs(2);
                case timeMode.complex: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustomTs(2);
                case timeMode.last:
                case timeMode.equiv:
                case timeMode.equivNorm:
                    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    if (modeTime == timeMode.equivNorm)
                        return ts.FormatCustomTs(3, 2, 4);
                    return ts.FormatCustomTs(2);

                case timeMode.delta:
                case timeMode.deltaNorm:

                    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
                    var delta = tsf - ts0;
                    delta = delta * 100;
                    //if (modeTime == timeMode.deltaNorm)
                    //    return delta.FormatCustom(3, 2, 4);
                    return "(" + delta.FormatCustomTs(2) + ")";
                default:
                    throw new NotImplementedException();

            }

            //if (modeTime == timeMode.complex)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustom(2);
            //else if (modeTime == Tuning.timeMode.simple)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates)).FormatCustom(2);
            ////   return m_rank.TimeRest.FormatCustom(2); //.ToString("G2", en); 
            //else if (modeTime == timeMode.equiv || modeTime == timeMode.equivNorm)
            //{
            //    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);

            //    if (modeTime == timeMode.equivNorm || modeTime == timeMode.deltaNorm)
            //        return ts.FormatCustom(3, 2, 4);
            //    return ts.FormatCustom(2);
            //}
            //else
            //{
            //    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
            //    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
            //    var delta = tsf - ts0;

            //    if (modeTime == timeMode.equivNorm)
            //        return delta.FormatCustom(3, 2, 4);
            //    return delta.FormatCustom(2);
            //}
        }



        private string getGroup(List<DisplayGrouping> categories)
        {
            StringBuilder sb = new StringBuilder();

            bool begin = false;

            displayCategory last = displayCategory.none;
            foreach (var category in categories)
            {
                try
                {
                    if (begin //&& (int)category.category <= (int)displayCategory.pipe
                        && last != displayCategory.croc1 && last != displayCategory.par1
                        && category.category != displayCategory.croc2 && category.category != displayCategory.par2)
                        sb.Append(" ");
                    begin = true;

                    switch (category.category)
                    {
                        case displayCategory.rankSort:
                            CTuning.format(sb, Rank.Sort); break;
                        case displayCategory.rankDelta:
                            CTuning.format(sb, Rank.RankDelta); break;
                        case displayCategory.rankTime:
                            CTuning.format(sb, Rank.RankRest); break;
                        case displayCategory.rankAllAlbum:
                            CTuning.format(sb, RankAllAlbum); break;
                        case displayCategory.rankAlbum:
                            if (album != null)
                                sb.Append(album.Rank.Sort); break;
                        case displayCategory.rankAlbumReverse:
                            if (album != null)
                            {
                                int rank = album.Rank.Sort;
                                rank = 1 + gen.Albums.Count - rank;
                                sb.Append(rank); 
                            }
                            break; 
                        case displayCategory.rankEquiv:
                            if (album != null)
                                sb.Append(album.Equiv);
                            break;
                        case displayCategory.rankEquivLight:
                            if (album != null)
                                sb.Append(album.EquivLight);
                            break;
                        case displayCategory.rankEquivLight0:
                            if (album != null)
                                sb.Append(album.EquivLight0);
                            break;
                        case displayCategory.albumMoy:
                            if (album != null)
                            {
                                sb.Append(album.Moyenne);
                            }
                            break;
                        case displayCategory.lenght:
                            sb.Append(Convert.ToInt32(100 * CTuning.Rapport(Rank.Lenght))); break; //   CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length))); break;
                        case displayCategory.sortValue:
                            sb.Append((1000 * Rank.SortValue).ToString("####", en)); break;
                        case displayCategory.tplay:
                            sb.Append(getTimeValue(datesMode.play, category.mode)); break;
                        case displayCategory.tclass:
                            sb.Append(getTimeValue(datesMode.@class, category.mode)); break;
                        case displayCategory.tclassMin:
                            sb.Append(getTimeValue(datesMode.classMin, category.mode)); break;
                        case displayCategory.tmix:
                            sb.Append(getTimeValue(datesMode.mix, category.mode)); break;
                        case displayCategory.tmixMin:
                            sb.Append(getTimeValue(datesMode.mixMin, category.mode)); break;
                        case displayCategory.timeCoeff:
                            sb.Append((100 * Rank.TimeCoeff).ToString("G3", en)); break;
                        case displayCategory.dplay:
                            sb.Append(ListSelection.getPlayDates(this).Count.ToString()); break;
                        case displayCategory.dclass:
                            sb.Append(ListSelection.getDatesClassement(this).Count.ToString());
                            break;
                        case displayCategory.dclassMin:
                            sb.Append(ListSelection.getClassDatesMin(this).Count.ToString()); break;
                        case displayCategory.dmix:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, false).Count.ToString());
                            break;
                        case displayCategory.dmixMin:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, true).Count.ToString());
                            break;
                        case displayCategory.pipe:
                            sb.Append("|");
                            break;
                        case displayCategory.par1: sb.Append("("); break;
                        case displayCategory.par2: sb.Append(")"); break;
                        case displayCategory.croc1: sb.Append("["); break;
                        case displayCategory.croc2: sb.Append("]"); break;

                        default:
                            break;
                    }


                    last = category.category;
                }

                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }
            }
            return sb.ToString();
        }

        public virtual int PieceId
        {
            get
            {
                return track.PieceId;
            }
        }


        private Piece parent;
        public Piece Parent
        {
            get { return parent; }
            set
            {
                if (value == null)
                {
                    if (parent != null)
                    {
                        parent.removeChild(this);
                        this.PieceParentId = -1;
                    }
                }
                else
                {
                    parent = value;
                    this.PieceParentId = value.PieceId;
                    parent.addChild(this);
                }
            }
        }
        public Piece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        private List<Piece> childs = new List<Piece>();
        public List<Piece> Childs { get { return childs; } }
        private void addChild(Piece child)
        {
            if (child != null && parent != null)
                throw new ApplicationException(string.Format("on ne doit pas affecter un enfant à un non-maitre. enfant:{0} parent {1}", child, parent));

            if (!childs.Contains(child))
                childs.Add(child);
        }

        private void removeChild(Piece child)
        {
            childs.Remove(child);
        }

        public virtual int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion

        private exportState exportState;
        public exportState ExportStatus
        {
            get
            {
                return exportState; // exportState;
            }
            set
            {
                exportState = value;
            }
        }




        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public void buildVirtualAlbums(List<Piece> list)
        {

            foreach (var path in track.RelativesPath)
            {

                var tab = path.Split('\\');
                var sb = new StringBuilder();

                sb.Append(@"\");
                var count = tab.GetLength(0);
                for (int i = 0; i < count; i++)
                {
                    var _s = tab[i];
                    if (string.IsNullOrEmpty(_s))
                        continue;

                    var virt = createVirtualAlbum(sb.ToString());
                    list.Add(virt);
                    if (i > 0)
                        sb.Append(@"\");
                    sb.Append(_s);




                }
            }
        }

        private Piece createVirtualAlbum(string path)
        {
            var virt = new VirtualAlbumPiece(track, Master, path);
            return virt;
        }
    }

    public enum exportState
    {
        none = 0,
        miss = 1,
        present = 2,
        copy = 3,
        delete = 4
    }


}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.util;
using System;
using System.Globalization;
using pdb.gen.Tuning;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    public class Album
    {

        private string name;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }
        private int stackIndex;
        public int StackIndex { get { return stackIndex; } set { stackIndex = value; } }
        private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }



        private List<Piece> list = new List<Piece>();
        private static int _sID = 0;
        private int _dID;


        public Album(string name)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        private string equiv = "";
        public string Equiv { get { return equiv; } }

        private string equivLight = "";
        public string EquivLight { get { return equivLight; } }

        private string equivLight0 = "";
        public string EquivLight0 { get { return equivLight0; } }

        private string moyenne = "";
        public string Moyenne { get { return moyenne; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            if (list.Contains(piece))
                return false;
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);
            piece.PieceAlbum = this;
            return true;
        }

        public List<Piece> Tracks
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceClassementDisplayComparer());
                return l;
            }
        }


        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        private bool atLeastOneEnabled;
        public bool AtLeastOneEnabled { get { return atLeastOneEnabled; } }

        public void makeSort(decimal coeffEnabled, ConfMedianne mode, ConfMedianne mode0) //IList<double> reference, IList<Piece> pieces)
        {
            try
            {
                //if (name == "The College Dropout")
                //{
                //}
                decimal offset = conf.AlbumMoyOffset;
                int count = list.Count;
                list.Sort(new PieceSortComparer());
                var listSortedValues = new List<decimal>();
                for (int i = 0; i < count; i++)
                {
                    listSortedValues.Add(list[i].Rank.SortValue);
                    if (!classed && list[i].isClassListNumeric)
                        classed = true;
                }

                m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                decimal moy = 0m;
                #region calcul brut
                #region init
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;
                    //if (coeffEnabled != 1m && p.Enabled)
                    //{
                    //    rapportClassement /= coeffEnabled;
                    //}
                    p.setClassementVirtuel(list[i].RapportClassement);

                    list[i].eraseInfoMedianne();

                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                list.Sort(new PieceClassementComparer());
                listSortedValues = new List<decimal>();
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].VirtualClassement);

                #endregion

                if (count > 0)
                    moy /= count;
                classMoy = moy;



                var med = CalcMedianne.getMedianne(listSortedValues, medianne);
                classementValue = med.d;
                if (classementValue > 0m)
                    list[med.index].Medianne = true;

                var _med = AlbumMedianne.getMedianneLight(new List<Piece>(list),coeffEnabled, mode0, false);
                equivLight0 = Piece.getClassementEquiv(_med.d);

                #endregion
                #region calcul virtuel
                #region init (prise en compte coeff des enabled)
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;
                    if (coeffEnabled != 1m && p.Enabled)
                    {
                        rapportClassement /= coeffEnabled;
                    }
                    p.setClassementVirtuel(rapportClassement);
                }
                list.Sort(new PieceClassementComparer());
                #endregion

                med = AlbumMedianne.getMedianneLight(new List<Piece>(list), coeffEnabled, mode, true);
                classementValueLight = med.d;

                #endregion

                equiv = Piece.getClassementEquiv(classementValue); // (10000 * m_rank.SortValue).ToString("00000.0", cu); 
                equivLight = Piece.getClassementEquiv(classementValueLight);

                moyenne = Piece.getClassementEquiv(classMoy);
            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }



        }



        public decimal getTrackSortValue(int index)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }

        public void makeSelection()
        {
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private void initRank()
        {
            m_rank.init();
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return name.Equals(o.name);
        }
        public override int GetHashCode()
        {
            return name.GetHashCode(); 
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumComparer.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.IO;
using System;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.util;

namespace pdb.gen.albums
{
    //public enum albumSortMode
    //{
    //    /// <summary>
    //    /// tri sur moyenne quand aucun des albums n'a défini sa médianne
    //    /// </summary>
    //    strict,
    //    /// <summary>
    //    /// tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur moyenne
    //    /// </summary>
    //    mix,
    //    /// <summary>
    //    /// Tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur medianne light
    //    /// </summary>
    //    mixLight,
    //    /// <summary>
    //    /// Tri sur medianne light quand les deux albums ont défini leur médianne, sinon tri sur moyenne
    //    /// </summary>
    //    mixLight2,
    //    /// <summary>
    //    /// Calcul médianne quasi strict, qq miettes pour éviter le zero
    //    /// </summary>
    //    medQuasi,
    //    /// <summary>
    //    /// Calcul Médianne moins strict
    //    /// </summary>
    //    medLight,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise un morceau au plus pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à deux morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe2,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à trois morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe3,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 4 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe4,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 5 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe5,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 6 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe6,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 10 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe10,
    //    /// <summary>
    //    /// tri uniquement sur la moyenne
    //    /// </summary>
    //    light

    //}
    class AlbumClassComparer : IComparer<Album>
    {
        private ConfAlbumSort mode;
        public AlbumClassComparer(ConfAlbumSort mode)
        {
            this.mode = mode;
        }
        private void calc(ref decimal xx, ref decimal yy, Album x, Album y, ConfMedianne cmpt)
        {
            switch (cmpt.type)
            {
                case medianneMode.none:
                    break;
                case medianneMode.strict: xx = x.ClassementValue; yy = y.ClassementValue;
                    break;
                case medianneMode.light: xx = x.ClassementValueLight; yy = y.ClassementValueLight;
                    break;
                case medianneMode.moy: xx = x.ClassementMoy; yy = y.ClassementMoy;
                    break;
                default:
                    break;
            }
        }

        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;


            int cmp = 0;

         
            
            
            decimal xx =0;
            decimal yy=0;

            var composants = mode.ComposantsUtiles; 
            if (composants.Count > 1)
            {
                if (x.ClassementValue == 0m || y.ClassementValue == 0m)
                {
                    var cmpt2 = composants[1];
                    calc(ref xx, ref yy, x, y, cmpt2);
                    cmp = xx.CompareTo(yy);
                    if (cmp != 0)
                        return cmp; 
                }

            }

            var cmpt = composants[0];
            calc(ref xx, ref yy, x, y, cmpt);

            cmp = xx.CompareTo(yy);
            if (cmp != 0)
                return cmp; 

            //if (mode == albumSortMode.light)
            //{
            //    cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            //    if (cmp != 0)
            //        return cmp;
            //}
            //else if (mode == albumSortMode.mix)
            //{
            //    if (x.ClassementValue == 0m || y.ClassementValue == 0m)
            //    {
            //        cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //}

            //else if (mode == albumSortMode.mixLight)
            //{
            //    if (x.ClassementValue == 0m || y.ClassementValue == 0m)
            //    {
            //        cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //}

            //else if (mode == albumSortMode.mixLight2)
            //{
            //    if (x.ClassementValue == 0m || y.ClassementValue == 0m)
            //    {
            //        cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //    else
            //    {
            //        cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //}

            //else if (mode == albumSortMode.medLight
            //    || mode == albumSortMode.medQuasi
            //    || mode == albumSortMode.medLightSafe
            //    || mode == albumSortMode.medLightSafe2
            //    || mode == albumSortMode.medLightSafe3
            //    || mode == albumSortMode.medLightSafe4
            //    || mode == albumSortMode.medLightSafe5
            //    || mode == albumSortMode.medLightSafe6
            //    || mode == albumSortMode.medLightSafe10
            //    )
            //{
            //    cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            //    if (cmp != 0)
            //        return cmp;
            //}



            cmp = x.ClassementValue.CompareTo(y.ClassementValue);
            if (cmp != 0)
                return cmp;

            cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            if (cmp != 0)
                return cmp;

            cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            if (cmp != 0)
                return cmp;

            int i = 0;
            var t1 = -2m;
            var t2 = -2m;
            while (true)
            {
                t1 = x.getTrackSortValue(i);
                t2 = y.getTrackSortValue(i);

                cmp = t1.CompareTo(t2);
                if (cmp != 0)
                    return cmp;



                if (t1 == 0)
                    break;

                i++;

            }
            cmp = x.DurationValue.CompareTo(y.DurationValue);
            if (cmp != 0)
                return cmp;
            return -x.Name.CompareTo(y.Name);

        }
    }

    class AlbumClassComparerStack : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            int cmp = x.StackIndex.CompareTo(y.StackIndex);
            if (cmp != 0)
                return -cmp;
            return x.Rank.Sort.CompareTo(y.Rank.Sort);
        }
    }

    class AlbumClassComparer2 : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            return x.Rank2.CompareTo(y.Rank2); 
        }
    }


    class AlbumSortComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            int cmp = x.Rank.SortValue.CompareTo(y.Rank.SortValue);
            if (cmp != 0)
                return cmp;

            if (x.Rank.SortValue == 0)
            {

            }

            var xx = x.getFirstTrackSortValue();
            var yy = y.getFirstTrackSortValue();

            return xx.CompareTo(yy);

        }
    }

    class AlbumRestComparer : IComparer<Album>
    {
        static AlbumSortComparer subCmp = new AlbumSortComparer();
        const decimal EPSILON = 0.00001m;
        public int Compare(Album x, Album y)
        {
            var xx = x.Rank.TimeRest;
            var yy = y.Rank.TimeRest;
            int cmp = 0;
            if (Math.Abs(xx - yy) >= EPSILON)
                cmp = xx.CompareTo(yy);
            if (cmp == 0)
                return subCmp.Compare(x, y);
            return cmp;
        }
    }

    class PieceInVirtualAlbumComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return x.Location.CompareTo(y.Location);
        }
    }

    class PieceInAlbumComparer : IComparer<Piece>
    {
        private bool debile(int trackNumber)
        {
            return trackNumber <= 0 || trackNumber > 10000;
        }

        private bool debile(Piece piece)
        {
            return debile(piece.TrackNumber);
        }
        public int Compare(Piece x, Piece y)
        {
            if (debile(x))
            {
                if (debile(y))
                {
                    var f1 = Path.GetFileName(x.Location);
                    var f2 = Path.GetFileName(y.Location);
                    return f1.CompareTo(f2);
                }
                return -1;
            }
            if (debile(y))
                return 1;
            var cmp = x.TrackNumber.CompareTo(y.TrackNumber);
            if (cmp != 0)
                return cmp;
            return x.Location.CompareTo(y.Location);
        }
    }

    class AllPieceComparer : IComparer<Piece>
    {
        PieceInAlbumComparer pieceComp = new PieceInAlbumComparer();
        IComparer<Album> albumcomp = new AlbumClassComparer2();

        public int Compare(Piece x, Piece y)
        {
            int cmp = albumcomp.Compare(x.PieceAlbum, y.PieceAlbum);
            if (cmp != 0)
                return cmp;
            return -pieceComp.Compare(x, y);
        }
    }

    class AllPieceComparer2 : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return -x.RankAllAlbum.CompareTo(y.RankAllAlbum);
        }
    }

    class AlbumNameComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            return x.Name.CompareTo(y.Name);
        }
    }


}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumMedianne.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.Collections;

namespace pdb.gen.albums
{
    class AlbumMedianne
    {
        const decimal PRECISION = 0.0000001m;
        private static int index;
        public static int Index { get { return index; } }


        public static DecimalIndex getMedianne(IEnumerable list, decimal coeffMedianne)
        {
            var _list = new List<decimal>();
            foreach (object o in list)
            {
                _list.Add(Convert.ToDecimal(o));
            }
            return getMedianne(_list, coeffMedianne);
        }

        public static DecimalIndex getMedianne(List<decimal> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }

        public static DecimalIndex getMedianneLight(List<decimal> list, List<Piece> pieces, ConfMedianne mode, bool signal)
        {
            DecimalIndex ret0 = new DecimalIndex();
            DecimalIndex ret = ret0;
            try
            {


                var _zero = mode.zero;
                var medianne = getMedianne_(list, mode.medianne);
                ret0.d = medianne;
                ret0.index = index;

                if (list.Count == 1)
                    return ret0;

                if (mode.safe == 0)
                {
                    return calcmedianneVirt(list, mode, 0, 0);
                }

                int indexV = 0;
                int nbAdd = 0;

                int count = list.Count;

                if (mode.safe > 0)
                {

                    int i0 = count - 1;
                    int _nbNoAdd = 0;

                    for (int i = 0; i < count; i++)
                    {
                        if (list[i] <= _zero)
                        {
                            i0 = i;
                            _nbNoAdd = count - i0;
                            break;
                        }
                    }
                    if (i0 == 0)
                        return ret0;

                    //for (int i00 = 1; i00 <= i0; i00++)
                    //{
                    //    decimal coeff = (decimal)i00 / (decimal)i0;
                    List<decimal> _list = new List<decimal>(list);
                    //for (int i = i00; i < count; i++)
                    //    _list[i] = 0m;
                    //liste partielle originale
                    //  List<decimal> _list0 = new List<decimal>(_list);
                    int _count = System.Math.Min(count, i0 + mode.safe);
                    decimal[] virt = new decimal[_count];
                    _nbNoAdd = System.Math.Min(mode.safe, _nbNoAdd);
                    if (mode.noAdd)
                    {

                        decimal _coeff = 1m;
                        for (int j = _nbNoAdd - 1; j >= 0; j--)
                        {
                            if (j < count)
                            {
                                _coeff /= mode.coeffVirt;
                                _list[j] = _list[j] * _coeff;
                            }
                        }
                    }
                    else if (mode.lissage || mode.removeEpsilon || mode.cumul)
                    {
                        for (int i = 0; i < i0; i++)
                        {
                            decimal _coeff = 1m;
                            decimal _base = _list[i];
                            for (int j = i + 1; j < _count; j++)
                            {
                                _coeff /= mode.coeffVirt;
                                virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                            }
                        }
                    }
                    else
                    {
                        decimal courant = _list[0];
                        for (int i = 1; i < _count; i++)
                        {
                            if (_list[i] <= _zero)
                            {
                                courant /= mode.coeffVirt;
                                virt[i] = courant;
                            }
                            else
                                courant = _list[i];
                        }
                    }

                    decimal value = int.MaxValue;
                    int ii = 0;
                    if (mode.noAdd)
                    {
                        //for (ii = 1; ii < count && ii < _count; ii++)
                        //{
                        //    var calc = virt[ii];
                        //    if (calc > 0m)
                        //        list[ii] = calc;
                        //}
                    }
                    else
                    {
                        for (ii = 1; ii < count && ii < _count; ii++)
                        {
                            value = _list[ii];
                            var calc = virt[ii];
                            if (value < calc)
                            {
                                if (mode.lissage || value <= _zero)
                                {
                                    if (value <= _zero)
                                        nbAdd++;
                                    value = calc;
                                    _list[ii] = value;
                                }

                            }
                            else
                                indexV = ii;
                        }
                        if (mode.removeEpsilon)
                        {
                            // j'ai 5 virtuel alors que j'ai deux safe
                            ///xx---
                            int nb = 0;
                            for (int i = indexV + 1; i < _count; i++)
                            {
                                nb++;
                                if (nb <= mode.safe)
                                    continue;
                                _list[i] = 0m;
                            }

                        }
                        if (mode.removeFirst)
                        {
                            for (int i = 0; i < nbAdd; i++)
                            {
                                _list[i] = 0m;
                            }
                        }
                    }

                    for (int i = 0; i < _list.Count && i < pieces.Count; i++)
                        pieces[i].setClassementVirtuel(_list[i]);

                    if (mode.deleteFirst)
                    {
                        for (int i = 0; i < nbAdd; i++)
                        {
                            _list.RemoveAt(0);
                        }
                    }

                    if (mode.reSort || mode.removeFirst || mode.noAdd)
                    {
                        _list.Sort();
                        _list.Reverse();
                        pieces.Sort(new PieceCmp());
                    }



                    if (mode.noAdd)
                        nbAdd = _nbNoAdd;

                    ret = calcmedianneVirt(_list, mode, nbAdd, System.Math.Min(i0, mode.safe));
                    if (mode.expEnabled != 0)
                    {
                        int _nb = pieces.Count<Piece>(p => !p.Enabled);
                        decimal _c = (decimal)_nb / (decimal)count;
                        _c = Math.Pow(_c, mode.expEnabled);
                        ret.d *= _c;
                    }


                }
                else
                    ret = calcmedianneVirt(list, mode, 0, 0);

                //if (ret < ret0)
                //    ret = ret0; 



            }
            finally
            {
                if (signal)
                {
                    try
                    {
                        pieces[ret.index].MedianneLight = true;
                        pieces[ret.indexBorder].Border = true;
                        pieces[ret.indexBorderEffect].BorderEffect = true;
                        pieces[ret.indexBorderMin].BorderMin = true;

                    }
                    catch { }
                }
            }

            return ret;
        }

        public static DecimalIndex getMedianneLight(List<Piece> pieces, decimal coeffEnabled, ConfMedianne mode, bool signal)
        {

            DecimalIndex ret0 = new DecimalIndex();
            DecimalIndex ret = ret0;
            try
            {
                var _zero = mode.zero;
                var medianne = getMedianne_(pieces, mode.medianne);
                ret0.d = medianne;
                ret0.index = index;
                ret = ret0;
                if (pieces.Count == 1)
                    return ret0;

                if (mode.safe == 0)
                {
                    return calcmedianneVirt(pieces, mode, 0, 0);
                }

                int indexV = 0;
                int nbAdd = 0;

                int count = pieces.Count;
                List<Piece> _pieces = pieces;
                //if (mode.virtOnlyDisabled)
                //{
                //    _pieces = pieces.FindAll(p => !p.Enabled && p.VirtualClassement > 0m);
                //    _pieces.Sort(new PieceCmp());
                //}


                if (mode.safe > 0)
                {
                    int i0 = count - 1;
                    int _nbNoAdd = 0;
                    //if (mode.virtOnlyDisabled)
                    //{
                    //    _nbNoAdd = pieces.Count<Piece>(p => p.Enabled);
                    //}
                    //else
                    //{

                    for (int i = 0; i < count; i++)
                    {
                        var pp = pieces[i];
                        if (pp.VirtualClassement == 0m)
                        {
                            i0 = i;
                            _nbNoAdd = count - i0;
                            break;
                        }
                    }

                    if (mode.virtOnlyDisabled)
                        _nbNoAdd = pieces.Count<Piece>(p => p.Enabled);  // || p.VirtualClassement == 0m);
                    if (i0 == 0)
                        return ret0;
                    //}

                    //for (int i00 = 1; i00 <= i0; i00++)
                    //{
                    //    decimal coeff = (decimal)i00 / (decimal)i0;
                    List<decimal> _list = new List<decimal>();
                    for (int i = 0; i < _pieces.Count; i++)
                        _list.Add(_pieces[i].VirtualClassement);
                    //for (int i = i00; i < count; i++)
                    //    _list[i] = 0m;
                    //liste partielle originale
                    //  List<decimal> _list0 = new List<decimal>(_list);
                    int _count = System.Math.Min(count, i0 + mode.safe);
                    decimal[] virt = new decimal[_count];
                    _nbNoAdd = System.Math.Min(mode.safe, _nbNoAdd);
                    if (mode.noAdd)
                    {
                        var _coeffVirt = mode.coeffVirt;
                        if (count < mode.safe && mode.coeffVirtAuto)
                        {
                            _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
                        }
                        decimal _coeff = 1m;
                        decimal prec = 0m;
                        if (mode.virtAlignPrec)
                        {
                            if (_nbNoAdd < _list.Count)
                                prec = _list[_nbNoAdd];
                        }

                        for (int j = _nbNoAdd - 1; j >= 0; j--)
                        {
                            if (j < _pieces.Count)
                            {

                                if (!mode.virtOnlyDisabled || !_pieces[j].Enabled)
                                {
                                    _coeff /= _coeffVirt;
                                    var cand = _list[j] * _coeff;
                                    if (mode.virtAlignPrec)
                                    {
                                        if (cand < prec)
                                            cand = prec;
                                    }

                                    if (mode.virtAlignSelected && mode.virtOnlyDisabled)
                                    {
                                        // quel serait le score s'il était coché
                                        var vu = _list[j] / coeffEnabled;
                                        // en plus une petite marge
                                        //  vu *= mode.coeffVirt; 
                                        if (cand < vu)
                                            cand = vu;
                                    }
                                    _list[j] = cand;
                                }
                                else if (mode.forceCoeffVirt)
                                    _coeff /= _coeffVirt;
                                prec = _list[j];
                            }
                        }

                    }
                    else if (mode.lissage || mode.removeEpsilon || mode.cumul)
                    {
                        for (int i = 0; i < i0; i++)
                        {
                            decimal _coeff = 1m;
                            decimal _base = _list[i];
                            for (int j = i + 1; j < _count; j++)
                            {
                                _coeff /= mode.coeffVirt;
                                virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                            }
                        }
                    }
                    else
                    {
                        decimal courant = _list[0];
                        for (int i = 1; i < _count; i++)
                        {
                            if (_list[i] <= _zero)
                            {
                                courant /= mode.coeffVirt;
                                virt[i] = courant;
                            }
                            else
                                courant = _list[i];
                        }
                    }

                    decimal value = int.MaxValue;
                    int ii = 0;
                    if (mode.noAdd)
                    {
                        //for (ii = 1; ii < count && ii < _count; ii++)
                        //{
                        //    var calc = virt[ii];
                        //    if (calc > 0m)
                        //        list[ii] = calc;
                        //}
                    }
                    else
                    {
                        for (ii = 1; ii < count && ii < _count; ii++)
                        {
                            value = _list[ii];
                            var calc = virt[ii];
                            if (value < calc)
                            {
                                if (mode.lissage || value <= _zero)
                                {
                                    if (value <= _zero)
                                        nbAdd++;
                                    value = calc;
                                    _list[ii] = value;
                                }

                            }
                            else
                                indexV = ii;
                        }
                        if (mode.removeEpsilon)
                        {
                            // j'ai 5 virtuel alors que j'ai deux safe
                            ///xx---
                            int nb = 0;
                            for (int i = indexV + 1; i < _count; i++)
                            {
                                nb++;
                                if (nb <= mode.safe)
                                    continue;
                                _list[i] = 0m;
                            }

                        }
                        if (mode.removeFirst)
                        {
                            for (int i = 0; i < nbAdd; i++)
                            {
                                _list[i] = 0m;
                            }
                        }
                    }

                    for (int i = 0; i < _list.Count && i < _pieces.Count; i++)
                        _pieces[i].setClassementVirtuel(_list[i]);

                    if (mode.deleteFirst)
                    {
                        for (int i = 0; i < nbAdd; i++)
                        {
                            pieces.RemoveAt(0);
                        }
                    }

                    if (mode.reSort || mode.removeFirst || mode.noAdd)
                    {
                        //_list.Sort();
                        //_list.Reverse();
                        pieces.Sort(new PieceCmp());
                    }



                    if (mode.noAdd)
                        nbAdd = _nbNoAdd;

                    ret = calcmedianneVirt(pieces, mode, nbAdd, System.Math.Min(i0, mode.safe));
                    if (mode.expEnabled != 0)
                    {
                        int _nb = pieces.Count<Piece>(p => !p.Enabled);
                        decimal _c = (decimal)_nb / (decimal)count;
                        _c = Math.Pow(_c, mode.expEnabled);
                        ret.d *= _c;
                    }


                }
                else
                    ret = calcmedianneVirt(pieces, mode, 0, 0);

                //if (ret < ret0)
                //    ret = ret0; 

            }
            finally
            {

                if (signal)
                {
                    try
                    {
                        pieces[ret.index].MedianneLight = true;
                        pieces[ret.indexBorder].Border = true;
                        pieces[ret.indexBorderEffect].BorderEffect = true;
                        pieces[ret.indexBorderMin].BorderMin = true;

                    }
                    catch { }
                }
            }

            return ret;
        }




        private class PieceCmp : IComparer<Piece>
        {
            private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
            public int Compare(Piece x, Piece y)
            {
                int cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }




        private static DecimalIndex calcmedianneVirt(IList<decimal> list, ConfMedianne conf, int nbAdd, int nbDel)
        {
            var _list = new List<decimal>(list);
            int count = _list.Count;

            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            int _nbSupp = 0;
            bool beginBorder = false;
            for (int i = 0; i < count; i++)
            {

                if (i > 0)
                {

                    _list.RemoveAt(count - i);

                }

                var aux = getMedianne_(_list, conf.medianne);
                if (aux == 0m)
                    continue;
                if (!beginBorder)
                {
                    beginBorder = true;
                    ret.indexBorder = count - i - 1;
                }
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
                {
                    coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
                }
                if (conf.quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                    ret.indexBorderEffect = count - i - 1;
                }

                if (_list[count - i - 1] > conf.zero)
                {

                    if (conf.removeLast == removeLast.non)
                        break;
                    _nbSupp++;
                    if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
                        break;
                }


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }



        private static DecimalIndex calcmedianneVirt(IList<Piece> list, ConfMedianne conf, int nbAdd, int nbDel)
        {
            var _list = new List<Piece>(list);
            var classes = _list.FindAll(p => p.VirtualClassement > conf.zero); 
            int count = _list.Count;

            int nbEnabled = classes.Count<Piece>(p => p.Enabled);
            int nbDisabled = classes.Count<Piece>(p => !p.Enabled);
            int nbdispo = System.Math.Min(nbEnabled, nbDisabled); 


            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            int _nbSupp = 0;
            //int _nbSuppDisabled = 0;
            //int _nbSuppEnabled = 0;
            bool beginBorder = false;
            for (int i = 0; i < count; i++)
            {

                if (i > 0)
                {
                    //var d = _list[count - i];
                    //if (d.Enabled)
                    //    nbEnabled--;
                    //else
                    //    nbDisabled--;
                   
                    _list.RemoveAt(count - i);

                }

                var aux = getMedianne_(_list, conf.medianne);
                if (aux == 0m)
                    continue;
                if (!beginBorder)
                {
                    beginBorder = true;
                    ret.indexBorder = count - i - 1;
                }
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
                {
                    coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
                }
                if (conf.quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                    ret.indexBorderEffect = count - i - 1;
                }

                ret.indexBorderMin = count - i - 1;
                var p = _list[count - i - 1];

                if (p.VirtualClassement > conf.zero)
                {
                    // je regarde si le morceau est désactivé
                    // si c'est coché, je ne regarde pas quand je considèere qu'on peut supprimmer les morceaux activé
                    if (p.Enabled)
                        nbEnabled--;
                    else
                        nbDisabled--;
                    nbdispo--; 

                    if (!p.Enabled || !conf.removeEnabled || conf.removeLast == removeLast.unselected)
                    {
                        //bool priseEncompte = true || nbEnabled <= 0 || !conf.removeEnabled || conf.removeLast == removeLast.unselected;
                        //if (priseEncompte)
                        //{
                        if ((conf.removeLast == removeLast.non || conf.removeLast == removeLast.unselected )&& nbEnabled < 0)
                            break;
                       
                        if (conf.removeLast == removeLast.unselected) //&& (nbEnabled <= 0 ||  nbDisabled <=0))
                        {
                            if (nbdispo < 0)
                                break; 
                        }
                          
                        _nbSupp++;
                        if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
                            break;
                        // }


                    }
                }


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }

        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1];
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var pente = (val1 - val0);
            var dx = medianne - index;
            var dy = pente * dx;
            return val0 + dy;

        }

        private static decimal getMedianne_(IList<Piece> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0].VirtualClassement;
            if (coeffMedianne == 0)
                return list[0].VirtualClassement;
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1].VirtualClassement;
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index].VirtualClassement;
            var val1 = list[i1].VirtualClassement;
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var pente = (val1 - val0);
            var dx = medianne - index;
            var dy = pente * dx;
            return val0 + dy;

        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using pdb.util;
using System.Collections.Generic;
using System;
using pdb.obj;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    public class Albums
    {
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
        }
        private BgDictString<Album> dict = new BgDictString<Album>();
        private Consolid consolid;
        private StackAlbum stack = StackAlbum.Instance; 
        private void check_(Piece piece)
        {
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                var album = dict[__album];
                if (album == null)
                {
                    album = new Album(__album);
                    album.Virtual = piece.Virtual;
                    dict.Add(__album, album);
                }
                album.add(piece);

            }


        }

        public int Count { get { return dict.Count; } }

        private string getKey(string _album)
        {
            string str = "-";
            if (!string.IsNullOrEmpty(_album))
            {
                str = _album.Trim();
            }
            return str; 
        }

        public void sortVirtual()
        {
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }
        }

        public void check(Piece piece)
        {
            check_(piece);
            foreach (Piece child in piece.Childs)
                check_(child);
        }

        public Album getAlbum(TrackList piece)
        {
            return piece.Piece.PieceAlbum;
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                return dict[__album];
            }
            return null;
        }

        public void makeSort()
        {
          
            var confSort = consolid.SortAlbumMode;
            stack.Capacity = confSort.stackSize; 
            ///check to find first light
            ConfMedianne confMedianne = null; 
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp; 
            }

            var conf0 = new ConfMedianne(confMedianne) { safe = 0 }; 

        

           
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSort(confSort.coeffEnabled, confMedianne,conf0); //listRef, reference); 
            }

            list.Sort(new AlbumClassComparer(consolid.SortAlbumMode));
            list.Reverse();
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            // prise en compte de la stack
            stack.build(); 
            var listStack = stack.Albums;
            foreach (Album s in listStack)
            {
                string key = getKey(s.Name);
                var alb = dict[key];
                stack.merge(s, alb);  
            }
            list.Sort(new AlbumClassComparerStack());
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank2 = i + 1; 
            }
        }

        public List<Album> makeSelection()
        {
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSelection();
            }
            list.Sort(new AlbumRestComparer());
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }
            return list;
        }


        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }

        public void signalClassChange(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return;
            stack.Add(album); 
        }



    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\StackAlbum.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.util;

namespace pdb.gen.albums
{
    class StackAlbum
    {
        private StackAlbum() { }
        public static StackAlbum Instance = new StackAlbum();
        private HashList<Album> list = new HashList<Album>();
        private int capacity;
        public int Capacity
        {
            set
            {
                if (capacity != value)
                {
                    capacity = value;
                }
            }
        }

        public void build()
        {
            int i = list.Count - 1;
            int nb = capacity;
            for (; i >= 0 && nb > 0; i--)
            {
                nb--;
                list[i].StackIndex = i + 1;
            }
            for (; i >= 0; i--)
            {
                list[i].StackIndex = 0;
            }
        }

        public void Add(Album album)
        {
            if (list.Contains(album))
                list.Remove(album);
            list.Add(album);
        }

        public List<Album> Albums { get { return new List<Album>(list); } }
        public void merge(Album mine, Album their)
        {

            int index = list.IndexOf(mine);
            their.StackIndex = mine.StackIndex;
            list[index] = their;

        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\ConfAlbumSort.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.Xml;
using pdb.util;

namespace pdb.gen.Tuning
{

    /// <summary>
    /// Configuration sort Albums
    /// </summary>
    public class ConfAlbumSort : TuningBase
    {
      
        private List<ConfMedianne> composants = new List<ConfMedianne>();
        private List<ConfMedianne> composantsUtiles = new List<ConfMedianne>();
        public List<ConfMedianne> Composants { get { return composants; } }
        public List<ConfMedianne> ComposantsUtiles { get { return composantsUtiles; } }
        public decimal coeffEnabled = 1m;
        public int stackSize = 0; 
        public void Calcul()
        {
            composantsUtiles = new List<ConfMedianne>();
            foreach (var cmp in composants)
            {
                if (cmp.enabled)
                    composantsUtiles.Add(cmp);
            }
            if (composantsUtiles.Count == 0)
                composantsUtiles.Add(composants[0]);
        }
        public ConfAlbumSort()
        {
        }

        public ConfAlbumSort(XmlElement node)
            : base(node)
        {

            composants.Clear();
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    var cmp = new ConfMedianne(node, sub as XmlElement);
                    composants.Add(cmp);
                }
            }

            builddec("coeffEnabled", v => coeffEnabled = v);
            buildi("stackSize", v => stackSize = v); 
            Calcul();

        }
        public bool Enabled
        {
            get
            {
                foreach (var cmp in composants)
                {
                    if (cmp.enabled)
                        return true;
                }
                return false;
            }
        }
    }


}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\GroupingDisplay.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.util;

namespace pdb.gen.Tuning
{

    public class DisplayGrouping
    {
        public displayCategory category;
        public readonly timeMode mode;
        public DisplayGrouping(displayCategory category, timeMode mode)
        {
            this.category = category;
            this.mode = mode;
        }

        public override string ToString()
        {
            return string.Format("{0} {1}", category, mode);
        }
    }
    public enum timeMode
    {
        simple = 0,
        complex = 1,
        last = 2,
        equiv = 4,
        equivNorm = 5,
        delta = 8,
        deltaNorm = 9
    }

    public enum displayCategory
    {
        none = 0,
        tplay = datesMode.play,
        tclass = datesMode.@class,
        tclassMin = datesMode.classMin,
        tmix = datesMode.mix,
        tmixMin = datesMode.mixMin,
        timeValue = 9,
        rankSort = 10,
        rankTime = 11,
        rankDelta = 12,
        rankAlbum = 13,
        rankEquiv =14,
        rankEquivLight = 15,
        rankEquivLight0 = 16,
        rankAllAlbum =17,
        albumMoy = 18,
        rankAlbumReverse =19,
        lenght = 20,
        sortValue = 21,
        timeCoeff = 30,
        dplay = 41,
        dclass = 42,
        dclassMin = 43,
        dmix = 44,
        dmixMin = 50,
        pipe = 100,
        par1 = 101,
        par2 = 102,
        croc1 = 103,
        croc2 =104
      
    }
    class GroupingDisplay
    {
        private List<DisplayGrouping> categories = new List<DisplayGrouping>();
        private timeMode timeMode = timeMode.simple;

        public List<DisplayGrouping> Categories { get { return categories; } }
        public timeMode TimeMode { get { return timeMode; } }

        public GroupingDisplay(XmlElement parent)
        {
            if (parent == null)
                return;
            var _timeMode = parent.Attributes["timeMode"];
            if (_timeMode != null)
            {
                timeMode = (timeMode)Enum.Parse(typeof(timeMode), _timeMode.Value, true);
            }
            foreach (XmlNode node in parent.ChildNodes)
            {
                if (node is XmlElement)
                {
                    try
                    {
                        var tmCat = timeMode;
                        _timeMode = node.Attributes["timeMode"];
                        if (_timeMode != null)
                        {
                            tmCat = (timeMode)Enum.Parse(typeof(timeMode), _timeMode.Value, true);
                        }

                        var cat = (displayCategory)Enum.Parse(typeof(displayCategory), node.Name, true);
                        categories.Add(new DisplayGrouping(cat, tmCat));
                    }
                    catch
                    {
                        misc.log("impossible de parser " + node.Name);
                        throw;
                    }
                }
            }
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            foreach (var cat in categories)
            {
                sb.Append(cat.ToString());
                sb.Append(" ");
            }
            return sb.ToString();
        }

    }
}
]]></content>
  </file>
</db>
