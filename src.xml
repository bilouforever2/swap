<db path="C:\Bernard\db1\PieceDb3Ref">
   <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;
using pdb.db.piece.type;

namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log;
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;
       

        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }

        public App()
            : base()
        {
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private void CheckException(string from, object sender, object ex)
        {
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {
                //double r = 0.02;
                //var ln = Math.Log10(r);
                //var rr = Math.Pow(10, ln);
                //var rrr = Math.Exp(ln * Math.Log(10)); 


                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init("pdb.player");
                log = Logger.getLogger("Program");

                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");


                var xmlConf = CConf.loadConf();
                export = CConf.Export;
                import = CConf.Import;
              
                gen = new Consolid();
                gen.SortAlbumMode = CConf.ConfGen.AlbumSort; 
                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);
                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni();
                Db.loadData();

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                thLoop = new Thread(loop);
                thLoop.Start();
                MemUtil.Start();
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        public static void go()
        {
            lock (_lock)
            {
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        private static void goInit()
        {
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;
            gen.MakeConsolid(Db.List.getList());

            if (CConf.ResetOneCl)
            {
                Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;
                Classement min = Classement.create("00001.0"); decimal mind = min.ClassementValueDecimal;
                var _albums = gen.Albums;
                foreach (var album in _albums.List)
                {
                    if (album.Name == "Mémos vocaux" || album.Name == "Pictures at an Exhibition")
                    {
                    }
                    var l = album.Tracks;
                    decimal pluspetitNonNull = 0m;
                    foreach (Piece t in l)
                    {
                        decimal clValue = t.ClassementValueDecimal;
                        if (clValue >= mind)
                        {
                            pluspetitNonNull = clValue;
                        }

                    }
                    foreach (Piece t in l)
                    {
                        if (t.Parent == null)
                        {
                            decimal clValue = t.ClassementValueDecimal;
                            if (t.isClassListNumeric && clValue > zer0d)
                            {
                                if (clValue < mind || clValue > pluspetitNonNull)
                                {
                                    var dPiece = Db.getPiece(t.PieceId);
                                    t.Enabled = true;
                                    t.setClassement("0", 0);
                                    dPiece.eraseClassement2();
                                }
                            }
                        }
                    }
                }
                gen.MakeConsolid(Db.List.getList());
            }


            gen.buildMusique();
            gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


            gen.timeRanking();
            gen.eraseGrouping();
            // gen.writeComment();
            gen.createRot(CConf.ListBase, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            gen.CommentGo = true;
            gen.GroupinGO = true;
          //  PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual;
            PlayerViewModel.Instance.ConfAlbumSort = gen.SortAlbumMode; 
        }

        private static void _go()
        {
            try
            {
                gen.CommentGo = false;
                gen.GroupinGO = false;
                bib.Aborted = true;
                Db.saveAsync();
                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;
                if (__end || __go) return;

              //  gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
                //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 
                gen.MakeConsolid(Db.List.getList()); //   bib.Musique.Tracks);
                if (__end || __go) return;

                gen.timeRanking();
                if (__end || __go) return;



                if (__end || __go) return;
                ChronoData.DateAuto = true;

                //if (refresh != null)
                //    refresh(PHASE1, EventArgs.Empty);

                if (__end || __go) return;
                bib.Aborted = false;
                ListWriterMgr.Async = false;
                //listWriter = new ListWriter(root);
                try
                {
                    CConf.loadConf();
                }
                catch (Exception ex)
                {
                    log.log(ex.ToString());
                }
               // gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                gen.createRot(CConf.ListBase, App.bib);
                //if (refresh != null)
                //    refresh(PHASE1, EventArgs.Empty);

            
                //log.log("visibles"); 
                //foreach (TrackListViewModel visible in Player.VisibleItems)
                //{
                //    if (__end || __go) return;
                //    visible.PieceGen.writeCommentGrouping();
                //    visible.refresh(); 
                //}
                //if (refresh != null)
                //    refresh(PHASE2, EventArgs.Empty);

                //if (__end || __go) return;
                //gen.writeComment();
                //if (__end || __go) return;
                //gen.writeGrouping();
                if (refresh != null)
                    refresh(PHASE2, EventArgs.Empty);

                if (__end || __go) return;

                gen.CommentGo = true;
                gen.GroupinGO = true;


                gen.CommentGo = true;
                gen.GroupinGO = true;
                //if (refresh != null)
                //    refresh(PHASE2, EventArgs.Empty);
                // _refresh = true;
                gen.builStats();
                //bib = new BibViewModel(Db.Root); 
                //gen.createRot(CConf.ListBase, bib);
                //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                gen.CommentGo = true;
                gen.GroupinGO = true;




            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                if (refresh != null)
                    refresh(PHASE2, EventArgs.Empty);
                ExportCmd.CalculExport();
            }


        }

        public static event EventHandler refresh;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            App.bib.Aborted = true;
            Db.WriteDB1();
            Db.WriteDB2();
            App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.Track);
            if (l == null)
                return null;
            foreach (ITrackMetaData p in l)
            {

                TrackListViewModel trackList = PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                    return null;
                case MessageBoxResult.No:
                    return false;
                case MessageBoxResult.None:
                    return null;
                case MessageBoxResult.OK:
                    return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export;
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog();
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir;
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\pdb.player.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{4166FA60-B33F-4496-9352-EDD8F3214021}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.player</RootNamespace>
    <AssemblyName>pdb.player</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <TargetFrameworkProfile>
    </TargetFrameworkProfile>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;NONI</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>pdb.player.App</StartupObject>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Interop.AXVLC, Version=1.0.0.0, Culture=neutral, processorArchitecture=x86">
      <SpecificVersion>False</SpecificVersion>
      <EmbedInteropTypes>False</EmbedInteropTypes>
      <HintPath>bin\Interop.AXVLC.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Xaml">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
    </Compile>
    <Compile Include="model\Equalization.cs" />
    <Compile Include="ViewModel\AllTracksViewModel.cs" />
    <Compile Include="ViewModel\BibViewModel.cs" />
    <Compile Include="ViewModel\BibViewModelBase.cs" />
    <Compile Include="ViewModel\Commande\CommandeBase.cs" />
    <Compile Include="ViewModel\Commande\CreateListCmd.cs" />
    <Compile Include="ViewModel\Commande\DeleteCmd.cs" />
    <Compile Include="ViewModel\Commande\ImportCmd.cs" />
    <Compile Include="ViewModel\Commande\InfoCmd.cs" />
    <Compile Include="ViewModel\Commande\Link\LinkRegister.cs" />
    <Compile Include="ViewModel\Commande\Link\RecordFather.cs" />
    <Compile Include="ViewModel\Commande\Play.cs" />
    <Compile Include="ViewModel\Commande\PlayList\AddToList.cs" />
    <Compile Include="ViewModel\Commande\PlayList\CheckCmd.cs" />
    <Compile Include="ViewModel\Commande\PlayList\ExportCmd.cs" />
    <Compile Include="ViewModel\Commande\PlayList\ExportCompress.cs" />
    <Compile Include="ViewModel\Commande\PlayList\PlayListCommande.cs" />
    <Compile Include="ViewModel\Commande\RecordClassement.cs" />
    <Compile Include="ViewModel\DetailAlbumViewModel.cs" />
    <Compile Include="ViewModel\DetailClassementViewModel.cs" />
    <Compile Include="ViewModel\gen\ListWriter.cs" />
    <Compile Include="ViewModel\InfoViewModel.cs" />
    <Compile Include="ViewModel\Interfaces.cs" />
    <Compile Include="ViewModel\PieceViewModel.cs" />
    <Compile Include="ViewModel\PlayerViewModel.cs" />
    <Compile Include="ViewModel\StatItemViewModel.cs" />
    <Compile Include="ViewModel\TrackListViewModel.cs" />
    <Compile Include="ViewModel\PlayListViewModel.cs" />
    <Compile Include="ViewModel\ViewModelBase.cs" />
    <Compile Include="Vue\Adorn\AdornedControl.cs" />
    <Compile Include="Vue\Adorn\AdornerPlacement.cs" />
    <Compile Include="Vue\Adorn\FrameworkElementAdorner.cs" />
    <Compile Include="Vue\AlbumCtl.xaml.cs">
      <DependentUpon>AlbumCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\BarAdorner.cs" />
    <Compile Include="Vue\BibCtl.xaml.cs">
      <DependentUpon>BibCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\BrowsePlayList.xaml.cs">
      <DependentUpon>BrowsePlayList.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ClassementCtl.xaml.cs">
      <DependentUpon>ClassementCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfAlbumSortW.xaml.cs">
      <DependentUpon>ConfAlbumSortW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfExport.xaml.cs">
      <DependentUpon>ConfExport.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfImport.xaml.cs">
      <DependentUpon>ConfImport.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\DataGridPlayList.xaml.cs">
      <DependentUpon>DataGridPlayList.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\FolderBrowserDialog.xaml.cs">
      <DependentUpon>FolderBrowserDialog.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\FolderBrowserDialogW.xaml.cs">
      <DependentUpon>FolderBrowserDialogW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\getNb.xaml.cs">
      <DependentUpon>getNb.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Info.xaml.cs">
      <DependentUpon>Info.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\PlayerControler.xaml.cs">
      <DependentUpon>PlayerControler.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StatCtl.xaml.cs">
      <DependentUpon>StatCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StateBar.xaml.cs">
      <DependentUpon>StateBar.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StringDialog.xaml.cs">
      <DependentUpon>StringDialog.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Util\BaseConverter.cs" />
    <Compile Include="Vue\Util\StringFormatConverter.cs" />
    <Compile Include="Vue\Util\Utils.cs" />
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Player.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Player.xaml.cs">
      <DependentUpon>Player.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Page Include="Vue\AlbumCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\BibCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\BrowsePlayList.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ClassementCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfAlbumSortW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfExport.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfImport.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\DataGridPlayList.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\FolderBrowserDialog.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\FolderBrowserDialogW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\getNb.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Vue\Info.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\PlayerControler.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StatCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StateBar.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StringDialog.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <None Include="app.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <AppDesigner Include="Properties\" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\engine\pdb.player.engine.build\pdb.player.engine.build.csproj">
      <Project>{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}</Project>
      <Name>pdb.player.engine.build</Name>
    </ProjectReference>
    <ProjectReference Include="..\engine\pdb.player.engine\pdb.player.engine.csproj">
      <Project>{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}</Project>
      <Name>pdb.player.engine</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823d1d-851c-456b-ac4c-b0beec173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{c2b34ca9-3bb2-464f-8691-5f5b7cb2b997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.Consolid\pdb.gen.csproj">
      <Project>{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}</Project>
      <Name>pdb.gen</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.Db\pdb.db.csproj">
      <Project>{43D27B47-E615-451D-AD25-67C5B8447C4A}</Project>
      <Name>pdb.db</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <Resource Include="Vue\images\Toolbar-MP3-Forward-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Pause-icon.png" />
    <Resource Include="Vue\images\Toolbar-MP3-Play-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Rewind-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Stop-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\pdb.player\ViewModel\PlayerViewModel.cs">
    <content><![CDATA[using pdb.player.model;
using pdb.player.ViewModel.Commande;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading;
using System.Windows.Data;
using System.Windows.Input;
using pdb.player.engine;
using pdb.player.engine.build;
using pdb.util;
using System.Collections;
using pdb.gen.conf;
using pdb.gen.albums;
using pdb.gen.Tuning;

namespace pdb.player.ViewModel
{


    enum positionstate
    {
        free,
        cannotPrevious,
        cannotForward
    }

    class HiddenPlayList : ItrackProvider
    {
        private ICollectionView viewOrg; 
        private PlayListViewModel pl;
        private static List<TrackListViewModel> hiddenSelected = new List<TrackListViewModel>();

        public HiddenPlayList(PlayListViewModel pl, ICollectionView viewOrg)
        {
            this.viewOrg = viewOrg; 
            this.pl = pl;
        }
        public ICollectionView PresentationTracks
        {
            get { return viewOrg; }
        }

        public void Focus(int index)
        {

        }

        public PlayListViewModel PlayList
        {
            get { return pl; }
        }


        public void doFilter(string filter)
        {
            PlayerViewModel.doFilter(PresentationTracks, filter);
        }


        public List<TrackListViewModel> SelectedTracks
        {
            get { return hiddenSelected; }
        }
    }

 

    class PlayerViewModel : ViewModelBase
    {
        private static PlayerViewModel _instance;
        private static volatile object _lock = new object();
        private ConfAlbumSort confAlbumSort;
        public ConfAlbumSort ConfAlbumSort { get { return confAlbumSort; } set { confAlbumSort = value; } }
        public static PlayerViewModel Instance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_lock)
                    {
                        if (_instance == null)
                            _instance = new PlayerViewModel(); 
                    }
                }
                return _instance; 
            }
        }
        private IPlayerEngine player = PlayerBuilder.create("vlcplugin");

        private TrackListViewModel currentTrack;
        private PlayListViewModel currentPl;
        public event EventHandler currentTrackChange;
        public event EventHandler resumeChange;
        private playerstate state;
        private positionstate _positionstate;
        private bool onlyEnabled = true;
       // private bool sortByAlbum = true;
        private bool withVirtualAlbum = CConf.ConfGen.AlbumVirtual; 
        ItrackProvider _real;
        private Logger log;
        public static IPlayerEngine Player { get { return Instance.player; } }

       
        public bool OnlyEnabled
        {
            get
            {
                return onlyEnabled;
            }
            set
            {
                if (value != onlyEnabled)
                {
                    onlyEnabled = value;
                    OnPropertyChanged("OnlyEnabled");
                }
            }
        }

        public bool SortByAlbum
        {
            get
            {
                return confAlbumSort.Enabled;
            }
        }
        //private albumSortMode sortAlbumMode;
        //public albumSortMode SortAlbumMode
        //{
        //    get { return sortAlbumMode; }
        //    set
        //    {
        //        if (value != sortAlbumMode)
        //        {
        //            sortAlbumMode = value;
        //            OnPropertyChanged("SortAlbumMode");
        //            App.go();
        //        }
        //    }
        //}

        public bool WithVirtualAlbum
        {
            get { return withVirtualAlbum; }
            set
            {
                if (value != withVirtualAlbum)
                {
                    withVirtualAlbum = value;
                    OnPropertyChanged("WithVirtualAlbum");
                    App.go();
                }
            }
        }



        private PlayerViewModel()
        {
            this.log = Logger.getLogger("PlayerViewModel");
            player.mediaEndReached += player_mediaEndReached;
            player.Volume = volume;
            TrackListViewModel.CurrentHumanSelectedChanged += TrackListViewModel_CurrentHumanSelectedChanged;


            new Thread(refreshLoop).Start();
            this.currentPl = PlayListViewModel.SelectedPlayList;
        }

        void TrackListViewModel_CurrentHumanSelectedChanged(object sender, EventArgs e)
        {
            makeResume(); 
        }

        void player_mediaEndReached(object sender, EventArgs e)
        {
            var track = this.CurrentTrack;
            if (track != null)
                track.Piece.recordJustReadTrack();
            next();
            App.go();
        }

        #region commande
        private ICommand cmdPlayPause;
        private ICommand cmdForward;
        private ICommand cmdStop;
        private ICommand cmdBackWard;
        private readonly static TimeSpan LIMIT_BACK = TimeSpan.FromSeconds(5.1);

        public ICommand Play
        {
            get
            {
                if (cmdPlayPause == null)
                    cmdPlayPause = new PlayPause();
                return cmdPlayPause;
            }
        }

        public ICommand Forward
        {
            get
            {
                if (cmdForward == null)
                    cmdForward = new ForWard();
                return cmdForward;
            }
        }

        public ICommand BackWard
        {
            get
            {
                if (cmdBackWard == null)
                    cmdBackWard = new BackWard();
                return cmdBackWard;
            }
        }

        public bool canForward()
        {
            return canPlay() && _positionstate != positionstate.cannotForward;
        }
        public bool canBackWard()
        {
            if (!canPlay())
                return false;
            if (PlayJustStarted)
                return _positionstate != positionstate.cannotPrevious;
            return true;

        }

        public void backWard()
        {
            if (PlayJustStarted)
                movetoPrevious();
            else
                goStartTrack();
        }


        public void forward()
        {
            movetoNext();
        }

        public bool isHidden { get { return provider is HiddenPlayList; } }

        public void pause()
        {
            State = playerstate.pause;
            player.pause();
        }

        private bool PlayJustStarted { get { return ElapsedTime < LIMIT_BACK; } }

        #endregion

        #region navigation
        public bool canPlay()
        {
            //if (currentPl == null)
            //    return false;
            var tracks = PresentationTracks;
            if (tracks == null)
                return false;
            if (tracks.IsEmpty)
                return false;
            return true;
        }



        private void movetoNext()
        {
            move(true);
        }

        private void goStartTrack()
        {
            Position = 0;
        }

        private void move(bool _toNext)
        {
            bool playing = state == playerstate.play;
            TrackListViewModel item = null;



            var tracks = PresentationTracks;

            Func<bool> _move;
            if (_toNext)
                _move = tracks.MoveCurrentToNext;
            else
                _move = tracks.MoveCurrentToPrevious;
            try
            {


                if (currentTrack != null)
                    tracks.MoveCurrentTo(currentTrack);
                if (!_move())
                {
                    return;
                }

                while (true)
                {
                    item = tracks.CurrentItem as TrackListViewModel;
                    if (item != null && item.Exists && (!onlyEnabled || item.Enabled))
                        break;
                    if (!_move())
                    {
                        item = null;
                        return;
                    }

                }



            }
            finally
            {
                if (item == null)
                    _positionstate = _toNext ? positionstate.cannotForward : positionstate.cannotPrevious;
                CurrentTrack = item;
                tracks.MoveCurrentTo(currentTrack);
                if (item != null)
                {
                    focus(tracks.CurrentPosition);
                    if (playing)
                    {
                        player.play(item.Location, true);
                    }
                }

            }
        }


        private void movetoPrevious()
        {
            move(false);
            //bool playing = state == playerstate.play;
            //TrackListViewModel item = null;

            //var tracks = PresentationTracks;
            //try
            //{


            //    if (currentTrack != null)
            //        tracks.MoveCurrentTo(currentTrack);
            //    if (!tracks.MoveCurrentToPrevious())
            //    {
            //        _positionstate = positionstate.cannotPrevious;
            //        state = playerstate.stop;
            //        return;
            //    }

            //    while (true)
            //    {
            //        item = tracks.CurrentItem as TrackListViewModel;
            //        if (item.Enabled)
            //            break;
            //        if (!tracks.MoveCurrentToPrevious())
            //        {
            //            _positionstate = positionstate.cannotPrevious;
            //            state = playerstate.stop;
            //            return;
            //        }

            //    }



            //}
            //finally
            //{
            //    CurrentTrack = item;
            //    tracks.MoveCurrentTo(currentTrack);
            //    if (item != null)
            //    {
            //        focus(tracks.CurrentPosition);
            //        if (playing)
            //        {
            //            player.play(item.Location, true);

            //        }
            //    }

            //}
        }


        public void play(bool forceDisabled, bool reload)
        {

            TrackListViewModel item = currentTrack;
            var tracks = PresentationTracks;
            try
            {
                if (!canPlay())
                    return;

                while (true)
                {
                    if (item == null)
                    {
                        _positionstate = positionstate.cannotPrevious;

                        if (!tracks.MoveCurrentToFirst())
                        {
                            //_positionstate = positionstate.cannotPrevious; 
                            return;
                        }

                        while (true)
                        {
                            item = tracks.CurrentItem as TrackListViewModel;
                            if (item != null && item.Exists && (!onlyEnabled || item.Enabled))
                                break;
                            if (!tracks.MoveCurrentToNext())
                            {
                                _positionstate = positionstate.cannotForward;
                                return;
                            }
                            _positionstate = positionstate.free;
                        }

                        if (item == null)
                            return;


                    }
                    tracks.MoveCurrentTo(item);
                    if (tracks.CurrentPosition >= 0)
                        break;
                    item = null;
                }

                CurrentTrack = item;

                focus(tracks.CurrentPosition);

                State = playerstate.play;
                //item.Playing = true;
                player.play(currentTrack.Location, reload);
            }
            finally
            {
                if (!canPlay() || currentTrack == null)
                    stop();
            }
        }



        public void stop()
        {

            if (isHidden)
            {
                provider = _real;
                tracks = provider.PresentationTracks;
            }

            State = playerstate.stop;
            player.stop();

        }

        private void next()
        {
            movetoNext();
        }



        #endregion

        private ItrackProvider provider;
        //internal ItrackProvider Provider
        //{
        //    set
        //    {

        //        //if (state != playerstate.stop)
        //        //{
        //        //    if (provider != null)
        //        //    {
        //        //        if (provider is HiddenPlayList)
        //        //        {
        //        //        }
        //        //        else
        //        //        {
        //        //            provider = new HiddenPlayList(provider.PresentationTracks);
        //        //        }
        //        //    }
        //        //    else
        //        //        provider = value;
        //        //}
        //        provider = value;
        //    }
        //}
        public ICollectionView PresentationTracks
        {
            get
            {
                if (provider == null)
                    return null;
                return provider.PresentationTracks;
            }
        }
        private void focus(int index)
        {
            if (provider == null)
                return;
            provider.Focus(index);
        }






        public playerstate State
        {
            get
            {
                return state;
            }
            set
            {
                if (value != state)
                {
                    state = value;
                    OnPropertyChanged("State");
                    OnPropertyChanged("SrcPlayPause");
                }
            }
        }



        private bool bEnd;
        private void refreshLoop()
        {
            while (!bEnd)
            {
                Thread.Sleep(1000);
                refresh();
            }
        }

        private void refresh()
        {
            try
            {

                //  this.IndexList = infos.IndexList;
                var _position = player.Position;
                if (_position != position) { position = _position; OnPropertyChanged("Position"); }

                this.ElapsedTime = player.Elapsed;
                this.Length = player.Duration;

                this.RemainingTime = Length - ElapsedTime;
                if (CurrentTrack == null)
                {
                    CurrentName = "";
                    CurrentAuthorAlbum = "";
                }
                else
                {
                    CurrentName = currentTrack.Name;
                    CurrentAuthorAlbum = String.Format("{0} - {1}", currentTrack.Artist, currentTrack.Album);
                    if (currentTrack.Exists)
                        currentTrack.Duration = length;
                }

            }
            catch { }

        }


        public TrackListViewModel CurrentTrack
        {
            get { return currentTrack; }
            set
            {
                if (value != null)
                    value.Playing = true;
                if (value != currentTrack)
                {
                    if (currentTrack != null)
                        currentTrack.Playing = false;
                    currentTrack = value;
                    if (currentTrack == null)
                        stop();
                    if (currentTrackChange != null)
                        currentTrackChange(Instance, EventArgs.Empty);
                }
            }
        }



        public static void reset(ItrackProvider provider, TrackListViewModel track)
        {
            Instance.provider = provider;
            Instance._positionstate = positionstate.free;
            Instance.CurrentTrack = track;
            Instance.currentPl = provider.PlayList;
            Instance.provider = provider;
            Instance.tracks = provider.PresentationTracks;
            Instance.play(true, true);
            Instance.makeResume();
        }


        public PlayListViewModel PlayList
        {
            get
            {
                return currentPl;
            }
        }
        ICollectionView tracks = null;
        public void set(ItrackProvider provider)
        {
            try
            {
                if (provider == null)
                {
                    log.log("provider null");
                    this.provider = null;
                    this.currentPl = null;
                    return;
                }
                else if (this.provider == null)
                {
                    log.log("init provider " + provider);
                    this.provider = provider;
                    this.currentPl = provider.PlayList;
                    this.tracks = provider.PresentationTracks;
                }

                else
                {


                    if (provider.PlayList == currentPl || state == playerstate.stop)
                    {
                        if (isHidden)
                        {
                            log.log("retour au réel");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                            tracks.MoveCurrentTo(TrackListViewModel.CurrentPlaying);
                            provider.Focus(tracks.CurrentPosition);
                        }
                        else
                        {
                            log.log("détection standart");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                        }
                    }

                    else
                    {
                        if (isHidden)
                        {
                            log.log("toujours virtuel");
                        }
                        else
                        {


                            log.log("passage en virtuel");
                            this.provider = new HiddenPlayList(currentPl, tracks);
                            this._real = provider;
                            // this.currentPl = provider.PlayList;
                            //this.tracks = provider.PresentationTracks; 
                        }
                    }
                }

                _positionstate = positionstate.free;
                if (currentPl == null)
                {
                    CurrentTrack = null;
                    stop();
                    return;
                }

            }
            finally
            {
                OnPropertyChanged("State");
                OnPropertyChanged("SrcPlayPause");
                makeResume();
            }
        }
      //  private class filterTask
      //  {
      //      public filterTask()
      //      {
      //      }
      //      public string filter;
      //      //public string waitingFilter; 
      //      //private bool cancel; 
      //      //private Thread th;
      //      public Predicate<object> Filter;
      //      //public ICollectionView coll;
      //      //private bool busy;

      //      public void go()
      //      {
             
      //          if (!string.IsNullOrEmpty(filter))
      //              filter = filter.Trim().ToLower().removeAccent();

      //          var tab = filter.Split(' ');
      //          // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 
      //          lock (this)
      //              busy = true;
      //          coll.Filter = item =>
      //          {
      //              TrackListViewModel vitem = item as TrackListViewModel;
      //              if (vitem == null) return false;

      //              //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
      //              //    return vitem.Classement.StartsWith(filter);
      //              bool ok = true;
      //              var name = vitem.Name.Trim().ToLower().removeAccent();
      //              var artist = vitem.Artist.Trim().ToLower().removeAccent();
      //              var album = vitem.Album.Trim().ToLower().removeAccent();
      //              var classement = vitem.Classement;
      //              foreach (string str in tab)
      //              {
      //                  if (!ok)
      //                      return false;
      //                  if (string.IsNullOrEmpty(str))
      //                      continue;
      //                  var str_ = str.Trim();
      //                  if (str_ == string.Empty)
      //                      continue;

      //                  ok = name.Contains(str_)
      //                      || artist.Contains(str_)
      //                      || album.Contains(str_)
      //                      || classement.StartsWith(str_);

      //              }

      //              return ok;

      //          };

      //          lock (this)
      //              busy = true;

      //      }
      //      private void getItems()
      //      {
      //          try
      //          {
      //              if (!string.IsNullOrEmpty(filter))
      //                  filter = filter.Trim().ToLower().removeAccent();
      //              if (cancel)
      //                  return;
      //              var tab = filter.Split(' ');
      //              if (cancel)
      //                  return;
      //              Filter = item =>
      //              {
      //                  TrackListViewModel vitem = item as TrackListViewModel;
      //                  if (vitem == null) return false;

      //                  //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
      //                  //    return vitem.Classement.StartsWith(filter);
      //                  bool ok = true;
      //                  var name = vitem.Name.Trim().ToLower().removeAccent();
      //                  var artist = vitem.Artist.Trim().ToLower().removeAccent();
      //                  var album = vitem.Album.Trim().ToLower().removeAccent();
      //                  var classement = vitem.Classement;
      //                  foreach (string str in tab)
      //                  {
      //                      if (!ok)
      //                          return false;
      //                      if (string.IsNullOrEmpty(str))
      //                          continue;
      //                      var str_ = str.Trim();
      //                      if (str_ == string.Empty)
      //                          continue;

      //                      ok = name.Contains(str_)
      //                          || artist.Contains(str_)
      //                          || album.Contains(str_)
      //                          || classement.StartsWith(str_);

      //                  }

      //                  return ok;

      //              };
      //          }
      //          catch (Exception ex)
      //          {
      //              App.log.log(ex.ToString()); 
      //          }
      //      }
      //  }
      ////  private static filterTask filtertask = new filterTask(); 
        public static void doFilter(ICollectionView coll, string filter)
        {
           
            if (!string.IsNullOrEmpty(filter))
                filter = filter.Trim().ToLower().removeAccent();

            var tab = filter.Split(' ');
            // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 
          
            coll.Filter = item =>
            {
                TrackListViewModel vitem = item as TrackListViewModel;
                if (vitem == null) return false;

                //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
                //    return vitem.Classement.StartsWith(filter);
                bool ok = true;
                var name = vitem.Name.Trim().ToLower().removeAccent();
                var artist = vitem.Artist.Trim().ToLower().removeAccent();
                var album = vitem.Album.Trim().ToLower().removeAccent();
                var classement = vitem.Classement;
                foreach (string str in tab)
                {
                    if (!ok)
                        return false;
                    if (string.IsNullOrEmpty(str))
                        continue;
                    var str_ = str.Trim();
                    if (str_ == string.Empty)
                        continue;

                    ok = name.Contains(str_)
                        || artist.Contains(str_)
                        || album.Contains(str_)
                        || classement.StartsWith(str_);

                }

                return ok;

            };
        }




        //public void set(ItrackProvider provider)
        //{
        //    try
        //    {
        //        if (provider == null)
        //        {
        //            this.provider = null;
        //            this.currentPl = null;
        //            return;
        //        }
        //        else if (this.provider == null)
        //        {
        //            this.provider = provider;
        //            this.currentPl = provider.PlayList;
        //            this.tracks = provider.PresentationTracks;
        //        }

        //        else
        //        {
        //            if (provider.PlayList == currentPl || state == playerstate.stop)
        //            {
        //                this.provider = provider;
        //                this.currentPl = provider.PlayList;
        //                this.tracks = provider.PresentationTracks;
        //            }

        //            else
        //            {
        //                if (_real == null || _real.PlayList != provider.PlayList)
        //                {
        //                    this.provider = new HiddenPlayList(currentPl, tracks);
        //                    this._real = provider;
        //                }
        //                else
        //                {
        //                    this.provider = _real;
        //                }
        //            }
        //        }

        //        _positionstate = positionstate.free;
        //        if (currentPl == null)
        //        {
        //            CurrentTrack = null;
        //            stop();
        //            return;
        //        }

        //    }
        //    finally
        //    {
        //        OnPropertyChanged("State");
        //        OnPropertyChanged("SrcPlayPause");
        //    }
        //}


        public void doFilter(String filter)
        {
            var provider = DisplayProvider;

            if (provider == null)
                return;
            provider.doFilter(filter);
            makeResume();
        }

        private ItrackProvider DisplayProvider
        {
            get
            {
                if (provider == null)
                    return null;
                if (isHidden && _real != null)
                {
                    return _real;
                }
                return provider;
            }
        }

        private string resume;

        public void makeResume()
        {
            string newResume = resume;
            try
            {

                IEnumerable items = null;
                var provider = DisplayProvider;
                if (provider == null)
                    return;
                var tracks = provider.PresentationTracks;
                int nbOrg = -1;
                items = tracks;
                if (items == null)
                    return;

                var selected = provider.SelectedTracks;
                if (selected.Count > 1)
                {
                    items = selected;
                    nbOrg = 0;
                    foreach (TrackListViewModel t in tracks)
                        nbOrg++;
                }
                int nb = 0, nbSelected = 0, nbAbsent = 0;
                TimeSpan duration = new TimeSpan(), durationSelected = new TimeSpan(), durationAbsent = new TimeSpan();

                foreach (TrackListViewModel track in items)
                {
                    nb++;
                    duration += track.Duration;
                    if (track.Enabled)
                    {
                        nbSelected++;
                        durationSelected += track.Duration;
                    }
                    if (!track.Exists)
                    {
                        nbAbsent++;
                        durationAbsent += track.Duration;
                    }
                }

                ITextWriter sb = new pdb.util.StringBuilder();
                sb.Append(nb);
                sb.Append(" ");
                sb.Append("elt");
                if (nb > 1)
                    sb.Append("s");
                if (nbOrg >= 0)
                {
                    sb.Append(" sur ");
                    sb.Append(nbOrg);
                    sb.Append(",");
                }
                sb.Append(" ");
                humanDuration(sb, duration);
                sb.Append(" ( ");
                sb.Append(nbSelected);
                sb.Append(" ");
                sb.Append("elt");
                if (nbSelected > 1)
                    sb.Append("s");
                sb.Append(" ");
                humanDuration(sb, durationSelected);

                sb.Append(" )");

                if (nbAbsent > 0)
                {
                    sb.Append(" absents:");
                    sb.Append(nbAbsent);
                    sb.Append(" ");
                    sb.Append("elt");
                    if (nb > 1)
                        sb.Append("s");
                    sb.Append(" ");
                    humanDuration(sb, durationAbsent);
                }
                sb.Append("\t");

                var currentTrack = TrackListViewModel.HumanSelected;
                if (currentTrack != null)
                {
                    humanSize(sb, currentTrack.Size);
                    sb.Append(" ");
                    sb.Append(currentTrack.Location);
                }

                newResume = sb.ToString();
            }
            catch (Exception e0)
            {
                App.log.log(e0.ToString()); 
            }
            finally
            {
                if (newResume != resume)
                {
                    resume = newResume;
                    if (resumeChange != null)
                    {
                        try
                        {
                            resumeChange(this, EventArgs.Empty);
                        }
                        catch (Exception ex)
                        {
                            App.log.log(ex.ToString()); 
                        }
                    }
                }
            }
        }

        public string Resume
        {
            get
            {
                //if (resume == null)
                //    makeResume();
                return resume;
            }
        }

        private void humanSize(ITextWriter sb, long size)
        {
            sb.Append( size.HumanReadableSize(-1)); 
        }

        private void humanDuration(ITextWriter sb, TimeSpan duration)
        {
            TimeSpan courant = duration;
            TimeSpan reste = new TimeSpan();
            TimeSpan ts = new TimeSpan();
            double days = duration.TotalDays;
            int idays = (int)days;

            double hours = duration.TotalHours;
            int ihours = (int)hours;


            if (days >= 1)
            {
                ts = new TimeSpan(idays, 0, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(idays);
                sb.Append(" j");
                //if (idays > 1)
                //    sb.Append("s");

                hours = reste.TotalHours;
                ihours = (int)hours;

                if (ihours == 0)
                    return;
                sb.Append(" ");
                sb.Append(ihours);
                sb.Append(" h");
                //if (ihours > 1)
                //    sb.Append("s");
                return;
            }

            double mins = duration.TotalMinutes;
            int imins = (int)mins;

            if (hours > 1)
            {
                ts = new TimeSpan(ihours, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(ihours);
                sb.Append(" h");
                //if (ihours > 1)
                //    sb.Append("s");

                mins = reste.TotalMinutes;
                imins = (int)mins;

                if (imins == 0)
                    return;
                sb.Append(" ");
                sb.Append(imins);
                sb.Append(" m");
                //if (imins > 1)
                //    sb.Append("s");
                return;

            }

            ts = new TimeSpan(0, imins, 0);
            reste = courant.Subtract(ts);
            sb.Append(imins);
            sb.Append(" m");
            //if (imins > 1)
            //    sb.Append("s");

            double secs = reste.TotalSeconds;
            int isec = (int)secs;


            if (isec == 0)
                return;
            sb.Append(" ");
            sb.Append(isec);
            sb.Append(" s");
            //if (imins > 1)
            //    sb.Append("s");
            return;



        }

        # region infos

        private bool transitionState = false;
        public bool TransitionState { set { transitionState = value; OnPropertyChanged("SrcPlayPause"); } }

        public String SrcPlayPause
        {
            get
            {
                if (isHidden)
                    return @"images\Toolbar-MP3-Stop-icon.png";
                if (state != playerstate.play)
                    return @"images\Toolbar-MP3-Play-icon.png";
                return @"images\Toolbar-MP3-Pause-icon.png";
            }
        }


        //private int indexList = -1;
        //public int IndexList
        //{
        //    get { return indexList; }
        //    set
        //    {
        //        if (value != indexList)
        //        {
        //            indexList = value;
        //            this.OnPropertyChanged("IndexList");
        //        }
        //    }
        //}

        private double position = 0;
        public double Position
        {
            get
            {

                return position;
            }
            set
            {
                if (value != position)
                {
                    position = value;
                    player.Position = value;
                    this.OnPropertyChanged("Position");
                }
            }
        }

        private String currentName;
        public String CurrentName
        {
            get { return currentName; }
            set
            {
                if (value != currentName)
                {
                    currentName = value;
                    this.OnPropertyChanged("CurrentName");
                }
            }
        }

        private double volume = 0.5;
        public double Volume
        {
            get { return volume; }
            set
            {
                if (value != volume)
                {
                    volume = value;
                    player.Volume = value;
                    OnPropertyChanged("Volume");
                }
            }
        }


        private String currentAuthorAlbum;
        public String CurrentAuthorAlbum
        {
            get { return currentAuthorAlbum; }
            set
            {
                if (value != currentAuthorAlbum)
                {
                    currentAuthorAlbum = value;
                    this.OnPropertyChanged("CurrentAuthorAlbum");
                }
            }
        }

        private TimeSpan sinceBeginReadTrack;
        public TimeSpan ElapsedTime
        {
            get { return sinceBeginReadTrack; }
            set
            {
                if (value != sinceBeginReadTrack)
                {
                    sinceBeginReadTrack = value;
                    this.OnPropertyChanged("ElapsedTime");
                }
            }
        }

        private TimeSpan remainingTime;
        public TimeSpan RemainingTime
        {
            get { return remainingTime; }
            set
            {
                if (value != remainingTime)
                {
                    remainingTime = value;
                    this.OnPropertyChanged("RemainingTime");
                }
            }
        }

        private TimeSpan length;
        public TimeSpan Length
        {
            get { return length; }
            set
            {
                if (value != length && value > TimeSpan.FromMilliseconds(100))
                {
                    length = value;
                    this.OnPropertyChanged("Length");
                }
            }
        }
        #endregion
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfAlbumSortW.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.ConfAlbumSortW"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="ConfAlbumSortW" Height="205" Width="403">
    <Grid Height="113" Width="383">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="182*" />
            <ColumnDefinition Width="201*" />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="7*" />
        </Grid.RowDefinitions>
        <Grid Grid.ColumnSpan="2">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
            </Grid.ColumnDefinitions>
            <CheckBox Grid.Row="0" Grid.Column="0" Name="cb_enabled" ToolTip="utilisé" Margin="5" Padding="4" />
            <ComboBox Grid.Row="0" Grid.Column="1" Name="cbxSort" Height="25" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox  Grid.Row="0" Grid.Column="2" Name="tb_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="3" Name="cb_quasi" ToolTip="quasi" Margin="5" Padding="4" />
            <TextBox  Grid.Row="0" Grid.Column="4" Name="tb_safe" Width="30" ToolTip="safe" Margin="5" />
            <TextBox  Grid.Row="0" Grid.Column="5" Name="tb_coeff" Width="30" ToolTip="coeff des morceaux virtuels" Margin="5" />

            <CheckBox Grid.Row="1" Grid.Column="0"  Name="cb2_enabled" ToolTip="utilisé" Margin="5" Padding="4" />
            <ComboBox Grid.Row="1" Grid.Column="1" Name="cbx2Sort" Height="25" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none2"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict2">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light2" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy2" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox Grid.Row="1" Grid.Column="2"  Name="tb2_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox Grid.Row="1" Grid.Column="3" Name="cb2_quasi" ToolTip="quasi" Margin="5" Padding="4" />
            <TextBox Grid.Row="1" Grid.Column="4" Name="tb2_safe" Width="30" ToolTip="safe" Margin="5" />
            <TextBox Grid.Row="1" Grid.Column="5" Name="tb2_coeff" Width="30" ToolTip="coeff des morceaux virtuels" Margin="5" />

        </Grid>
        <StackPanel Orientation="Horizontal" Margin="5"  HorizontalAlignment="Stretch" VerticalAlignment="Stretch" Grid.ColumnSpan="2">
            
        </StackPanel>
        <StackPanel Grid.Row="2"  Orientation="Horizontal" Margin="5,5,-1,-36"  HorizontalAlignment="Stretch" VerticalAlignment="Stretch" Grid.ColumnSpan="2">
            
        </StackPanel>
        <StackPanel Grid.Row="2"  Orientation="Horizontal"  HorizontalAlignment="Right" Margin="0,5,5,5" Grid.Column="1">
            <Button Grid.Row="2" Name="bt_cancel" HorizontalAlignment="Right" Content="Cancel" Click="bt_cancel_Click"   Margin="5" />
            <Button Grid.Row="2" Name="bt_ok" HorizontalAlignment="Right" Content="Ok" Click="bt_ok_Click"   Margin="5" />
        </StackPanel>
    </Grid>

</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfAlbumSortW.xaml.cs">
    <content><![CDATA[using System;
using System.Windows;
using pdb.gen.Tuning;

namespace pdb.player.Vue
{
    /// <summary>
    /// Interaction logic for ConfAlbumSortW.xaml
    /// </summary>
    public partial class ConfAlbumSortW : Window
    {
        private ConfAlbumSort conf;
        public ConfAlbumSortW()
        {
            InitializeComponent();
            this.Loaded += new RoutedEventHandler(ConfAlbumSortW_Loaded);
        }

        void ConfAlbumSortW_Loaded(object sender, RoutedEventArgs e)
        {
            display(); 
        }

        public ConfAlbumSortW(ConfAlbumSort conf)
            : this()
        {
            this.conf = conf;
        }

        void display()
        {
            var list = conf.Composants;
            var item1 = list[0];
            cb_enabled.IsChecked = item1.enabled;
            cbxSort.SelectedIndex = (int)item1.type;
            tb_medianne.Text = item1.medianne.ToString();
            cb_quasi.IsChecked = item1.quasi;
            tb_safe.Text = item1.safe.ToString();
            tb_coeff.Text = item1.coeffVirt.ToString();

            if (list.Count > 1)
            {
                item1 = list[1];
                cb2_enabled.IsChecked = item1.enabled;
                cbx2Sort.SelectedIndex = (int)item1.type;
                tb2_medianne.Text = item1.medianne.ToString();
                cb2_quasi.IsChecked = item1.quasi;
                tb2_safe.Text = item1.safe.ToString();
                tb2_coeff.Text = item1.coeffVirt.ToString();
            }
        }
        void record()
        {
            var list = conf.Composants;
            var item1 = list[0];
            item1.enabled = cb_enabled.IsChecked.Value;
            item1.type = (util.medianneMode)cbxSort.SelectedIndex;
            item1.medianne = Convert.ToDecimal(tb_medianne.Text);
            item1.quasi = cb_quasi.IsChecked.Value;
            item1.safe = Convert.ToInt32(tb_safe.Text);
            item1.coeffVirt = Convert.ToDecimal(tb_coeff.Text);

            if (list.Count > 1)
            {
                if (cbx2Sort.SelectedIndex == 0)
                {
                    list.RemoveAt(1);
                    return;
                }
            }
            else
            {
                if (cbx2Sort.SelectedIndex > 0)
                {
                    item1 = new util.ConfMedianne();
                    list.Add(item1); 
                }
            }

            if (list.Count > 1)
            {
                item1 = list[0];

                item1.enabled = cb2_enabled.IsChecked.Value;
                item1.type = (util.medianneMode)cbx2Sort.SelectedIndex;
                item1.medianne = Convert.ToDecimal(tb2_medianne.Text);
                item1.quasi = cb2_quasi.IsChecked.Value;
                item1.safe = Convert.ToInt32(tb2_safe.Text);
                item1.coeffVirt = Convert.ToDecimal(tb2_coeff.Text);
            }
        }

        private void bt_cancel_Click(object sender, RoutedEventArgs e)
        {
            Close(); 
        }

        private void bt_ok_Click(object sender, RoutedEventArgs e)
        {
            record();
            Close();
            conf.Calcul(); 
            App.go(); 
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\PlayerControler.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.PlayerControler"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
              xmlns:local="clr-namespace:pdb.player"
              xmlns:util="clr-namespace:pdb.player.Vue.Util"
             mc:Ignorable="d" 
             d:DesignHeight="167" d:DesignWidth="777">
    <UserControl.Resources>
        <util:StringFormatConverter x:Key="StringFormater" />
        <util:TimeFormatConverter x:Key="TimeSpan" />
        <util:IntFormatConverter x:Key="Int" />
        <Style x:Key="EmptyButtonStyle" TargetType="{x:Type Button}">
            <Setter Property="Background" Value="#00000000"/>
            <Setter Property="BorderBrush" Value="#00000000"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Foreground" Value="{DynamicResource {x:Static SystemColors.ControlTextBrushKey}}"/>
            <Setter Property="HorizontalContentAlignment" Value="Center"/>
            <Setter Property="VerticalContentAlignment" Value="Center"/>
            <Setter Property="Padding" Value="0"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="{x:Type Button}">
                        <ContentPresenter 
                        HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" 
                        Margin="{TemplateBinding Margin}" 
                        RecognizesAccessKey="True" 
                        SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" 
                        VerticalAlignment="{TemplateBinding VerticalContentAlignment}"
                           
                            />
                        
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </UserControl.Resources>
    <Grid Margin="0" >
        <Grid.Background>
            <LinearGradientBrush StartPoint="0,0" EndPoint="0,1">
                <GradientStop Color="#fff" Offset="0" />
                <GradientStop Color="#dfdfdf" Offset="1" />
               
            </LinearGradientBrush>

        </Grid.Background>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Name="defNav" Width="Auto" />
            <ColumnDefinition Name="defInfo" Width="*" />
            <ColumnDefinition Name="defFilter" Width="Auto" />
        </Grid.ColumnDefinitions>
        <Grid Margin="10" Grid.Column="0" >
            <StackPanel Orientation="Horizontal" VerticalAlignment="Bottom">

                <Button Name="b_rewind" Height="40" Width="40" Command="{Binding BackWard}" Style="{DynamicResource EmptyButtonStyle}">
                    <Image Source="images\Toolbar-MP3-Rewind-icon.png"  Height="30" Width="30"></Image>
                </Button>
                <Button Name="b_play" Height="40" Width="40"  Command="{Binding Play,UpdateSourceTrigger=PropertyChanged}"  Style="{DynamicResource EmptyButtonStyle}">
                    <!--<Image Name="I_Play" Source="images\Toolbar-MP3-Play-icon.png"   Height="30" Width="30"></Image>-->
                    <Image Name="I_Play" Source="{Binding SrcPlayPause, UpdateSourceTrigger=PropertyChanged}"   Height="30" Width="30"></Image>
                </Button>
                <Button Name="b_forward" Height="40" Width="40" Command="{Binding Forward}"  Style="{DynamicResource EmptyButtonStyle}">
                    <Image Source="images\Toolbar-MP3-Forward-icon.png"    Height="30" Width="30" ></Image>
                </Button>
                <Grid Margin="10">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition />
                        <ColumnDefinition />
                        <ColumnDefinition />
                    </Grid.ColumnDefinitions>
                    <TextBlock Text="&lt;)" Grid.Column="0"  VerticalAlignment="Center" Margin="0,0,5,0"/>
                    <Slider Grid.Column="1"  Margin="5,0,0,0" Name="SliderVolume" Width="150" VerticalAlignment="Center" HorizontalAlignment="Stretch"  Minimum="0" Maximum="1" Value="{Binding Path=Volume, UpdateSourceTrigger=PropertyChanged, Mode=TwoWay}" IsMoveToPointEnabled="True" />
                    <TextBlock Text="&lt;)))" Grid.Column="2"  VerticalAlignment="Center"  Margin="5,0,00,0"/>
                </Grid>
            </StackPanel>
        </Grid>
       
        <Grid Grid.Column="1">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Name="defName" MaxHeight="50" Height="Auto" />
                    <RowDefinition Name="defPosition" Height="Auto" />
                </Grid.RowDefinitions>

                <StackPanel Grid.Row="0" Orientation="Vertical" HorizontalAlignment="Center" VerticalAlignment="Bottom" Margin="0,15,0,0">
                    <Label Name="l_TrackName"  HorizontalAlignment="Center" Content="{Binding Path=CurrentName,  UpdateSourceTrigger=PropertyChanged}"  FontWeight="Bold" Padding="0" Margin="0"></Label>
                    <Label Grid.Row="1" Name="l_trackAuthorAlbum" HorizontalAlignment="Center" Content="{Binding Path=CurrentAuthorAlbum,  UpdateSourceTrigger=PropertyChanged}"  Padding="0" Margin="0"/>
                </StackPanel>
                <Grid Grid.Row="2"  HorizontalAlignment="Stretch" Margin="5">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" />
                        <ColumnDefinition Width="*" />
                        <ColumnDefinition Width="Auto" />
                    </Grid.ColumnDefinitions>
                    <StackPanel Grid.Column="0" Orientation="Horizontal">
                        <CheckBox Name="cbEnabled" VerticalAlignment="Center" DockPanel.Dock="Left" ToolTip="Jouer seulement les morceaux cochés" IsChecked="{Binding OnlyEnabled,UpdateSourceTrigger=PropertyChanged}" />
                        <Button Name="btSort" Content="  "  Height="15" ToolTip="Configuration du tri par album" Click="btSort_Click" />
                        <!--<ComboBox Name="cbxSort" Height="20" SelectedIndex="{Binding SortAlbumMode, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource sortAlbum} }"  >
                                  <ComboBox.ToolTip>
                                    <TextBlock  xml:space="preserve">
strict          = tri sur moyenne quand aucun des albums n'a défini sa médianne
mix             = tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur moyenne
mixLight        = tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur medianne light
mixLight2       = tri sur medianne light quand les deux albums ont défini leur médianne, sinon tri sur moyenne
medQuasi        = calcul médianne quasi strict, qq miettes pour éviter le zero
medLight        = calcul Médianne moins strict
medLightSafe   = calcul medLight, on virtualise un morceau au plus pour avoir une estimation basse
medLightSafe2   = calcul medLight, on virtualise jusqu'à deux morceaux pour avoir une estimation basse                                        
medLightSafe3   = calcul medLight, on virtualise jusqu'à trois morceaux pour avoir une estimation basse   ...                                     
light           = tri uniquement sur la moyenne
                                    </TextBlock>
                                  </ComboBox.ToolTip>
                            <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict">strict</ComboBoxItem>
                            <ComboBoxItem ToolTip="tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur moyenne" Name="mix" >mix</ComboBoxItem>
                            <ComboBoxItem ToolTip="tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur medianne light" Name="mixLight" >mixLight</ComboBoxItem>
                            <ComboBoxItem ToolTip="tri sur medianne light quand les deux albums ont défini leur médianne, sinon tri sur moyenne" Name="mixLight2" >mixLight2</ComboBoxItem>
                            <ComboBoxItem ToolTip="Calcul médianne quasi strict, qq miettes pour éviter le zero" Name="medQuasi" >medQuasi</ComboBoxItem>                            
                            <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="medLight" >medLight</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise un morceau au plus pour avoir une estimation basse" Name="medLightSafe" >medLightSafe</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à deux morceaux pour avoir une estimation basse" Name="medLightSafe2" >medLightSafe2</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à trois morceaux pour avoir une estimation basse" Name="medLightSafe3" >medLightSafe3</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à 4 morceaux pour avoir une estimation basse" Name="medLightSafe4" >medLightSafe4</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à 5 morceaux pour avoir une estimation basse" Name="medLightSafe5" >medLightSafe5</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à 6 morceaux pour avoir une estimation basse" Name="medLightSafe6" >medLightSafe6</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à 10 morceaux pour avoir une estimation basse" Name="medLightSafe10" >medLightSafe10</ComboBoxItem>
                            <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="light" >light</ComboBoxItem>
                        </ComboBox>-->
                        <CheckBox Name="cbAlbumVirtual" VerticalAlignment="Center" DockPanel.Dock="Left" ToolTip="albums virtuels" IsChecked="{Binding WithVirtualAlbum,UpdateSourceTrigger=PropertyChanged}" Visibility="{Binding WithVirtualAlbum, Converter={StaticResource boolVis}, Mode=OneTime}"/>
                        <Label Name="Duration" DockPanel.Dock="Left" VerticalAlignment="Bottom" Content="{Binding Path=ElapsedTime, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource TimeSpan}}"  />

                    </StackPanel>
                    <Slider Grid.Column="1"  Margin="5,0,0,0" Name="PBar"  VerticalAlignment="Bottom" HorizontalAlignment="Stretch"  Minimum="0" Maximum="1" Value="{Binding Path=Position, UpdateSourceTrigger=PropertyChanged, Mode=TwoWay}" IsMoveToPointEnabled="True" />
                    <StackPanel Grid.Column="2" Orientation="Horizontal">
                        <Label Name="RemainingTime"   VerticalAlignment="Bottom" Content="{Binding Path=RemainingTime, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource TimeSpan}}"  />
                        <Label Content="/" />
                        <Label Name="Length"  VerticalAlignment="Bottom" Content="{Binding Path=Length, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource TimeSpan}}"/>
                    </StackPanel>
                </Grid>
            </Grid>

        </Grid>
        <DockPanel Grid.Column="2" HorizontalAlignment="Stretch" VerticalAlignment="Top" Margin="0,15,0,0">
            <GroupBox Header="Filtre" HorizontalAlignment="Right" DockPanel.Dock="Right">
                <StackPanel Orientation="Horizontal" >
                    <TextBox x:Name="txtFilter" MinWidth="150"  KeyUp="txtFilter_KeyUp" />
                </StackPanel>
            </GroupBox>
        </DockPanel>


    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\PlayerControler.xaml.cs">
    <content><![CDATA[using pdb.player.model;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace pdb.player.Vue
{
    /// <summary>
    /// Logique d'interaction pour PlayerControler.xaml
    /// </summary>
    public partial class PlayerControler : UserControl
    {

        public PlayerControler()
        {
            InitializeComponent();
            this.Loaded += PlayerControler_Loaded;
        }

        void PlayerControler_Loaded(object sender, RoutedEventArgs e)
        {
            DataContext = PlayerViewModel.Instance;
           
        }

        private void txtFilter_KeyUp(object sender, KeyEventArgs e)
        {
            String filter = txtFilter.Text;
            doFilter(filter);
        }

        private void doFilter(String filter)
        {
            PlayerViewModel.Instance.doFilter(filter);
        }

        private void btSort_Click(object sender, RoutedEventArgs e)
        {
            var conf = PlayerViewModel.Instance.ConfAlbumSort;
            var dialog = new ConfAlbumSortW(conf);
            dialog.ShowDialog(); 
        }

       
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\Util\StringFormatConverter.cs">
    <content><![CDATA[using System;
using System.Windows.Data;
using pdb.util;
using pdb.player.ViewModel;
using System.Windows.Media;
using pdb.gen;
using pdb.gen.albums;

namespace pdb.player.Vue.Util
{
    [ValueConversion(typeof(object), typeof(string))]
    public class StringFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            string format = parameter as string;
            if (!string.IsNullOrEmpty(format))
            {
                return string.Format(culture, format, value);
            }
            else
            {
                return value.ToString();
            }
        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(TimeSpan), typeof(string))]
    public class TimeFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is TimeSpan)
            {
                TimeSpan ts = (TimeSpan)value;
                return String.Format("{0}:{1}{2}", ts.Minutes, ts.Seconds >= 10 ? "" : "0", ts.Seconds);
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }

    [ValueConversion(typeof(string), typeof(string))]
    public class ClFormatConverter : BaseConverter, IValueConverter
    {
        static int NB_DEC = 4; 
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return "";
            var str = value.ToString();
            int count = str.Length;
            return Piece.getReadableCl(str); 
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            bool second = false;
            //if (str.StartsWith("0"))
                second = true; 
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {

                        if (i > NB_DEC || (i >= NB_DEC && second))
                        {
                            if (!second)
                            {
                                second = true;
                                i = 1;
                            }
                            else
                                i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();


        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            if (value == null) return "";
            return value.ToString().Replace(" ", "");
        }
    }


    [ValueConversion(typeof(int), typeof(string))]
    public class IntFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is int)
            {
                int ivalue = (int)value;
                if (ivalue <= 0) return "";
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            int result;
            if (int.TryParse(value.ToString(), out result))
            {
                return result;
            }
            return null;
        }
    }
    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class BgColorFormatConverter : BaseConverter, IValueConverter
    {
        public SolidColorBrush getColor(TrackListViewModel tv)
        {
            exportState es = tv.ExportStatus;
            if (!tv.Exists)
                es = exportState.miss;
            switch (es)
            {
                case exportState.none: return Brushes.White;
                case exportState.miss: return Brushes.LightGray;
                case exportState.present: return Brushes.White;
                case exportState.copy: return Brushes.LightGreen;
                case exportState.delete: return Brushes.DarkGray;
                default:
                    break;
            }   
            return Brushes.White; 
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                return getColor(tv); 
          
            }
            catch
            {
               
            }
            return Brushes.White; 
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(bool), typeof(System.Windows.Visibility))]
    public class BoolToVis : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is bool)
            {
                return (bool)value ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed; 
            }
            return null; 

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            if (System.Windows.Visibility.Visible.Equals(value)) return true;
            if (System.Windows.Visibility.Collapsed.Equals(value)) return false;
            return null; 

        }
    }
    [ValueConversion(typeof(medianneMode), typeof(int))]
    public class SortModeConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value is medianneMode)
            {
                return (int)value; 
            }
            return null;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value is int)
            {
                return (medianneMode)(int)(value); 
            }
            return null; 
        }
    }





}
]]></content>
  </file>
  <file path="\pdb.util\Medianne.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;

namespace pdb.util
{
    public enum medianneMode
    {
        none = 0,
        strict = 1,
        light = 2,
        moy = 3

    }
    public class ConfMedianne : TuningBase
    {
        public medianneMode type;
        public decimal medianne = 0.5m;
        public bool quasi;
        public int safe;
        public decimal coeffVirt = 10m;
        public bool enabled;
        public ConfMedianne()
        {
        }

        public ConfMedianne(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var strType = "";
            builds("type", v => strType = v);
            type = (medianneMode)Enum.Parse(typeof(medianneMode), strType, true); 
            builddec("medianne", v=>medianne = v);
            builddec("coeffVirt", v => coeffVirt = v);
            buildb("quasi", v => quasi = v);
            buildi("safe", v => safe = v);
            buildb("enabled", v => enabled = v);
        }
    }
    public class CalcMedianne
    {
        const decimal PRECISION = 0.0000001m;
        private static int index;
        public static int Index { get { return index; } }


        public static DecimalIndex getMedianne(IEnumerable list, decimal coeffMedianne)
        {
            var _list = new List<decimal>();
            foreach (object o in list)
            {
                _list.Add(Convert.ToDecimal(o));
            }
            return getMedianne(_list, coeffMedianne);
        }

        public static DecimalIndex getMedianne(IList<decimal> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }

        public static DecimalIndex getMedianneLight(IList<decimal> list, ConfMedianne mode)
        {
            return getMedianneLight(list, mode.medianne, mode.quasi, mode.safe, mode.coeffVirt); 
        }

        public static DecimalIndex getMedianneLight(IList<decimal> list, decimal coeffMedianne, bool quasi, int nbVirt, decimal coeffVirt)
        {
            DecimalIndex ret = new DecimalIndex();
            var medianne = getMedianne_(list, coeffMedianne);
            ret.d = medianne;
            ret.index = index;
            if (list.Count == 1)
                return ret;

            int nbAdd = 0; 

            int count = list.Count;

            if (nbVirt > 0)
            {

                int i0 = count - 1;

                for (int i = 0; i < count; i++)
                {
                    if (list[i] == 0m)
                    {
                        i0 = i;
                        break;
                    }
                }
                if (i0 == 0)
                    return ret;

                //for (int i00 = 1; i00 <= i0; i00++)
                //{
                //    decimal coeff = (decimal)i00 / (decimal)i0;
                    List<decimal> _list = new List<decimal>(list);
                    //for (int i = i00; i < count; i++)
                    //    _list[i] = 0m;
                    //liste partielle originale
                  //  List<decimal> _list0 = new List<decimal>(_list);
                    int _count = Math.Min(count, i0 + nbVirt);
                    decimal[] virt = new decimal[_count];
                    for (int i = 0; i < i0; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = _list[i];
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= coeffVirt;
                            virt[j] += _base * _coeff;
                        }
                    }
                 
                    decimal value = int.MaxValue;
                    int ii = 0;
                    for (ii = 1; ii < count && ii < _count; ii++)
                    {
                        value = _list[ii];
                        var calc = virt[ii];
                        if (value ==0m && value < calc)
                        {
                            nbAdd++; 
                            value = calc;
                            _list[ii] = value;

                        }                        
                    }
                  
                    _list.Sort();
                    _list.Reverse();

                    //for (int i = 0; i < nbAdd; i++)
                    //    _list.RemoveAt(0); 


                    var retAux = calcmedianneVirt(_list, coeffMedianne, quasi);
                    //retAux.d *= coeff;
                    if (retAux > ret)
                    {
                        ret = retAux;
                      //  ret.index += nbAdd; 
                    }
                //}


            }
            else
                ret = calcmedianneVirt(list, coeffMedianne, quasi);

            //  ret = getRapport(ret);

         
            return ret;
        }


        public static DecimalIndex getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi, int nbVirt)
        {
            DecimalIndex ret = new DecimalIndex();
            var medianne = getMedianne_(list, coeffMedianne);
            ret.d = medianne;
            ret.index = index;
            if (list.Count == 1)
                return ret;

            int count = list.Count;


            // decimal ret = medianne; //int.MinValue;

            if (nbVirt > 0)
            {

                int i0 = count - 1;

                for (int i = 0; i < count; i++)
                {
                    if (list[i] == 0m)
                    {
                        i0 = i;
                        break;
                    }
                }
                if (i0 == 0)
                    return ret;

                for (int i00 = 1; i00 <= i0; i00++)
                {
                    decimal coeff = (decimal)i00 / (decimal)i0;
                    List<decimal> _list = new List<decimal>(list);
                    for (int i = i00; i < count; i++)
                        _list[i] = 0m;
                    int _count = Math.Min(count, i00 + nbVirt);
                    decimal[] virt = new decimal[_count];
                    for (int i = 0; i < i00; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = _list[i];
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= 10m;
                            virt[j] += _base * _coeff;
                        }
                    }
                    // decimal prec = -1m;  
                    int _nbVirt = 0;
                    decimal value = int.MaxValue;
                    int ii = 0;
                    for (ii = 1; ii < count && ii < _count; ii++)
                    {
                        //   prec = value;
                        value = _list[ii];
                        var calc = virt[ii];
                        if (value < calc)
                        {
                            if (_nbVirt >= nbVirt)
                                break;
                            _nbVirt++;
                            value = calc;  //Math.Min(prec, calc);
                            _list[ii] = value;

                        }
                        else
                            _nbVirt = 0;
                    }
                    for (int i = ii; i < count && i < _count; i++)
                    {
                        _list[i] = 0m;
                    }
                    //_list.Sort();
                    //_list.Reverse(); 



                    var retAux = calcmedianneVirt(_list, coeffMedianne, quasi);
                    retAux.d *= coeff;
                    if (retAux > ret)
                        ret = retAux;
                }


            }
            else
                ret = calcmedianneVirt(list, coeffMedianne, quasi);

            //  ret = getRapport(ret);

            //if (ret < medianne)
            //    ret = medianne;
            return ret;
        }

        private static decimal getLn(decimal rapport)
        {
            if (rapport <= 0)
                return 0m;
            return Convert.ToDecimal(10 + Math.Log10((double)rapport));
        }
        private static decimal getRapport(decimal ln)
        {
            return Convert.ToDecimal(Math.Pow(10, (double)ln - 10));
        }

        private static DecimalIndex calcmedianneVirt(IList<decimal> _list, decimal coeffMedianne, bool quasi)
        {

            int count = _list.Count;
            
            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                {
                   
                    _list.RemoveAt(count - i);
                }

                var aux = getMedianne_(_list, coeffMedianne);
                if (aux == 0m)
                    continue;
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
               decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                }

                if (_list[count - i - 1] > 0m)
                    break;
              

            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }


        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1];
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var pente = (val1 - val0);
            var dx = medianne - index;
            var dy = pente * dx;
            return val0 + dy;

        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}
]]></content>
  </file>
  <file path="\pdb.util\TuningBase.cs">
    <content><![CDATA[using System;
using System.Xml;

namespace pdb.util
{

    public class TuningBase
    {
        public delegate void sets(string value);
        public delegate void setd(double value);
        public delegate void setdec(decimal value);
        public delegate void seti(int value);
        public delegate void setb(bool value);

        protected XmlElement parent;
        protected XmlElement child;

        public TuningBase() : this(null,null)
        {
        }

        public TuningBase(XmlElement node) : this(null, node) { }

        public TuningBase(XmlElement parent, XmlElement child)
        {
            this.parent = parent;
            this.child = child; 
        }

     

        protected void buildd(string name, setd setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
            elt = child[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
        }

        protected void builddec(string name, setdec setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(Convert.ToDecimal(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(Convert.ToDecimal(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setd(Convert.ToDecimal(elt.InnerText));
            elt = child[name];
            if (elt != null)
                setd(Convert.ToDecimal(elt.InnerText));
        }
      
        protected void buildi( string name, seti seti)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
            elt = child[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
        }
      
        protected void builds(string name, sets sets)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                sets(att.InnerText);
            att = child.Attributes[name];
            if (att != null)
                sets(att.InnerText);

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                sets(elt.InnerText);
            elt = child[name];
            if (elt != null)
                sets(elt.InnerText);
        }
       
        protected void buildb(string name, setb setb)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setb("true" == att.InnerText);
            att = child.Attributes[name];
            if (att != null)
                setb("true" == att.InnerText);

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setb("true" == elt.InnerText);
            elt = child[name];
            if (elt != null)
                setb("true" == elt.InnerText);
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;
using pdb.gen.Virtuel;
using pdb.gen.Tuning;

namespace pdb.gen
{
    /// <summary>
    /// G�re l'application propri�taire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des donn�es consolid�es morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        private List<Piece> allClassedInAlbumEnabled = new List<Piece>();
        /// <summary>
        /// Liste des donn�es morceux dupliqu�s 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        private Albums albums; // = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private volatile object _lock = new object();
        private bool _consolidEnCours;


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private CPlayList root = new CPlayList("root", null, creator);
        public CPlayList Root { get { return root; } }
        private CPlayList musique;
        private CPlayList classement;
        private CPlayList listes;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new CPlayList("musique", root, creator);
            classement = new CPlayList("classement", root, creator);
            listes = new CPlayList("listes", root, creator);
        }

        private void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating;
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        public void buildClassTree()
        {
            buildClassTree(classement);
        }


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }
        private bool _fisrtConsolid;
        public Albums Albums { get { return albums; } }
        public void MakeConsolid(IEnumerable<ITrackNativeDates> dbList)
        {
            try
            {
                waitForConsolid();
                listPiece = new List<Piece>();
                listPieceInAlbum = new List<Piece>();
                var auxlistPieceInAlbum = new List<Piece>();
                albums = new Albums(this);
                VirtualPiece.init();
                m_listTrackClassed = new List<Piece>();
                allClassed = new List<Piece>();
                allClassedInAlbumEnabled = new List<Piece>();
              //  htIds = new BgDict<int, Piece>();
                foreach (ITrackNativeDates track in dbList)
                {

                    if (!track.isPodcast)
                    {
                        Piece piece = null;
                        int pieceId = track.PieceId;
                        if (htIds.ContainsKey(pieceId))
                        {
                            piece = htIds[pieceId];
                            piece.initRank(); 
                        }
                        else
                        {
                            piece = new Piece(track);
                            htIds.Add(pieceId, piece);
                        }
                       
                        auxlistPieceInAlbum.Add(piece);
                       
                    }
                }
                // link
                foreach (Piece piece in auxlistPieceInAlbum)
                {
                    int parentId = piece.PieceParentId;
                    if (parentId > 0)
                    {
                        piece.Parent = htIds[parentId];
                    }
                }

                // liste FORT + albums

                foreach (Piece piece in auxlistPieceInAlbum)
                {
                    if (piece.Parent == null)
                    {
                        listPiece.Add(piece);
                        listPieceInAlbum.Add(piece);
                        foreach (Piece child in piece.Childs)
                            listPieceInAlbum.Add(child);
                        if (_albumVirtual)
                            piece.buildVirtualAlbums(listPieceInAlbum);
                        albums.check(piece);
                    }
                }

                foreach (Piece piece in listPieceInAlbum)
                {
                    if (!string.IsNullOrEmpty(piece.ClassName))
                    {
                        allClassed.Add(piece);
                        if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                            allClassedInAlbumEnabled.Add(piece);
                    }
                }

                albums.sortVirtual();
                Ranking();
            }
            finally
            {
                lock (_lock)
                {
                    _fisrtConsolid = true;
                    _consolidEnCours = false;
                }
            }

        }

        public void buildMusique()
        {
            foreach (Piece piece in listPieceInAlbum)
            {
                musique.addObj(piece);
            }

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.Tracks;
                tracks.Sort(new PieceTrackNumberComparer());
                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }

        }

        public void buildLists(CPlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(CPlayList mine, CPlayList ext)
        {
            foreach (PlComponent c in ext)
            {
                if (c is CPlayList)
                {
                    var subExt = c as CPlayList;
                    var sub = new CPlayList(subExt.Name, mine);
                    sub.ID = subExt.ID;
                    // mine.add(sub);
                    buildList(sub, subExt);
                }
                else
                {
                    var t = c as IFile;
                    var piece = htIds[t.PieceId];
                    mine.add(new TrackList(piece));
                }
            }
        }

        internal Album getAlbum(TrackList track)
        {
            return albums.getAlbum(track);
        }

        public List<Piece> getTracksAlbum(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.Tracks;
        }

        public List<Piece> getTracksAlbumByNumber(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackByNumber;
        }

        //public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        //{
        //    var album = getAlbum(track);
        //    if (album == null)
        //        return;
        //    foreach (var p in album.Tracks)
        //    {
        //        container.Add(p);
        //    }
        //}

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPieceInAlbum);
                list.Sort(new AllPieceComparer2());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking()
        {
            QRanking();
            LRanking();
            QLRanking();

            misc.log("setTuningDateValues");
            var list = new List<Piece>(listPiece);
            foreach (Piece piece in list)
            {
                piece.FirstClass = false;
                CRank rank = piece.Rank;
                var sortValue = CTuning.Calc(rank, CConf.Sort);
                rank.SortValue = sortValue;

                ListSelection.setTuningDateValues(piece);
            }

            misc.log("PieceRestComparer->RankRest ");
            list.Sort(new PieceRestComparer());

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            list.Sort(new PieceDeltaComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankDelta = i + 1;
            }

            misc.log("PieceSortComparer->Sort ");
            list.Sort(new PieceSortComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            misc.log("AlbumsSort ");
            var all = new List<Piece>(listPieceInAlbum);

            albums.makeSort();
            misc.log("AllPieceComparer->RankAllAlbum ");
            all.Sort(new AllPieceComparer());
            for (int i = 0; i < all.Count; i++)
            {
                all[i].RankAllAlbum = i + 1;
            }

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackNativeDates> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackNativeDates track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux not�s
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.ClassementValueDecimal);
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                misc.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                misc.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        misc.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating);
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                misc.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    misc.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    misc.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    misc.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    misc.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                misc.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                misc.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    misc.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                misc.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            misc.log("Qranking");



            CPieceComparerByGoodness l_pieceComparer = new CPieceComparerByGoodness();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }


            //on ordonne les morceaux top-down => sont privil�gi�s les plus en vue
            listPiece.Sort(l_pieceComparer);

            //compactage de la liste en tenant compte des mieux not�s
            m_list = new CListPiece(listPiece);

            misc.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.ClassName != "")
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            misc.log("Qranking:track classed :" + m_listTrackClassed.Count);
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }

            Console.WriteLine("Qranking:total class�s : " + m_listTrackClassed.Count);

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                    break;
            }
            return Convert.ToInt32(qRank);
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur longueur
        /// </summary>
        /// <remarks></remarks>
        private void LRanking()
        {
            misc.log("LRanking");
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByLenght());
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.LRank = l_iIndex + 1;
            }
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur qualit� +longueur en cas d'�galit�
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            misc.log("QLRanking");
            m_listQL = new List<Piece>(m_listTrackClassed);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByQualityAndLength());
            int count = l_aux.Count;
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.QLRank = l_iIndex + 1;
            }

            l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.Rank.TwiceInv = l_iIndex + 1;
            }

            if (CConf.Condensation)
            {
                var l = new List<Piece>(this.listPiece);
                l.Sort(new CPieceComparerByQualityAndLength2());
                new Condenseur(m_listQL).gener2();

            }

        }

        public void builStats()
        {
            try
            {
                bool generDistrib = step % 10 == 0;
                new StatBuilder(m_listQL).gener3(generDistrib);
                var stat = new StatBuilder(m_listQL) { Loupe = 1 };
                stat.gener4("stats4.txt");
                stat = new StatBuilder(m_listQL) { Loupe = 2 };
                stat.gener4("stats4.txt");
                stat = new StatBuilder(m_listQL) { Loupe = 3 };
                stat.gener4("stats4.txt");
                var unselected = m_listQL.FindAll(t => !t.Enabled);
                new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
                stat = new StatBuilder(unselected) { Loupe = 1 };
                stat.gener4("courant4.txt");
                stat = new StatBuilder(unselected) { Loupe = 2 };
                stat.gener4("courant4.txt");
                stat = new StatBuilder(unselected) { Loupe = 3 };
                stat.gener4("courant4.txt");

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }


        public DynamicStat generStat(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            return new DynamicStatBuilder(list).gener(className);
        }



        public void timeRanking()
        {
            misc.log("timeRanking");
            foreach (var piece in allClassed)
                ListSelection.setTuningDateValues(piece);


        }

        /// <summary>
        /// redirection des index metier de la table m�tier vers la table locale
        /// Copie des valeurs pertinentes(classlist)
        /// </summary>
        /// <remarks></remarks>
        public void eraseGrouping()
        {
            thCommentGo = false;
            thGroupingGo = false;
            misc.log("eraseGrouping");
            foreach (Piece piece in listPieceInAlbum)
            {
                piece.setGrouping("", false);
                piece.Comment = "";
            }
        }
        public void writeGrouping()
        {
            misc.log("writeGrouping");
            var list = new List<Piece>(listPieceInAlbum);
            // list.Sort(new CPieceComparerByQualityAndLength());
            list.Sort(new AllPieceComparer2());

            var writeGrouping = CConf.ConfGen.WriteGrouping;
            foreach (Piece piece in list)
            {
                try
                {
                    piece.writeGrouping(writeGrouping);
                }
                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }

            }
        }


        private bool thGroupingGo;
        private bool thCommentGo;

        public bool GroupinGO
        {
            set
            {
                thGroupingGo = value;
                if (value)
                {
                }
            }
        }
        public bool CommentGo
        {
            set
            {
                thCommentGo = value;
                if (value)
                {
                }
            }
        }



        private void writeGroupingAsync()
        {
            var writeGrouping = CConf.ConfGen.WriteGrouping;
            foreach (Piece piece in listPieceInAlbum)
            {
                try
                {
                    if (!thGroupingGo)
                        return;
                    piece.writeGrouping(writeGrouping);
                }
                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }

            }
        }

        private void writeCommentAsync()
        {
            var writeComment = CConf.ConfGen.WriteComment;
            foreach (Piece piece in listPiece)
            {
                try
                {
                    if (!thCommentGo)
                        return;
                    piece.writeComment(writeComment);
                }
                catch (Exception ex)
                {
                    misc.log("writeComment::" + ex.ToString());
                }
            }
        }

        public void writeGrouping(Piece piece)
        {
            var writeGrouping = CConf.ConfGen.WriteGrouping;
            piece.writeGrouping(writeGrouping);

        }
       // private bool _sortByAlbum = true;
        public bool SortByAlbum { get { return _albumSortMode.Enabled; } }

        private ConfAlbumSort _albumSortMode; 
        public ConfAlbumSort SortAlbumMode { set { _albumSortMode = value; } get { return _albumSortMode; } }
        
        private bool _albumVirtual = CConf.ConfGen.AlbumVirtual;
        public bool AlbumVirtual { get { return _albumVirtual; } set { _albumVirtual = value; } }

        public void writeComment()
        {
            misc.log("writeComment");
            var list = new List<Piece>(listPiece);
            list.Sort(new CPieceComparerByQualityAndLength());

            var writeComment = CConf.ConfGen.WriteComment;
            foreach (Piece piece in list)
            {
                try
                {
                    piece.writeComment(writeComment);
                }
                catch (Exception ex)
                {
                    misc.log("writeComment::" + ex.ToString());
                }
            }




        }

        public void writeComment(Piece piece)
        {
            var writeComment = CConf.ConfGen.WriteComment;
            try
            {
                piece.writeComment(writeComment);
            }
            catch (Exception ex)
            {
                misc.log("writeComment::" + ex.ToString());
            }
        }



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public void createRot(string a_baseName, params IListWriter[] writers)
        {
            var conf = CConf.ConfGen;

            misc.log("Clegacy:createRot {0}", a_baseName);
            List<Piece> l_list = new List<Piece>();
            List<Piece> source = null;
            if (SortByAlbum)
                source = allClassedInAlbumEnabled;
            else
                source = m_listTrackClassed;
            foreach (Piece l_piece in source)
            {
                //if (l_piece.belongsTo(a_baseName))
                //{
                l_list.Add(l_piece);
                // }
            }
            m_listWriter = new CLegacyListWriter(l_list, SortByAlbum);

            l_list = new List<Piece>();
            foreach (Piece piece in listPieceInAlbum)
                l_list.Add(piece);

            listWriterAll = new CLegacyListWriter(l_list, SortByAlbum);


            foreach (IListWriter writer in writers)
                m_listWriter.addWriter(writer);

            foreach (IListWriter writer in writers)
                listWriterAll.addWriter(writer);

            //      m_listWriter.reset();
            foreach (var duration in conf.Listes)
            {


                foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                {

                    foreach (Piece piece in allClassed)
                        ListSelection.setTuningDateValues(piece, mode.item);

                    m_listWriter.writeGen(mode, duration, "g", false);
                    m_listWriter.writeGen(mode, duration, "e", true);
                }
            }

            if (conf.GenCheck)
                m_listWriter.writeCheckClassement(0);

            for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
            {
                m_listWriter.writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
            }


            foreach (var duration in conf.Listes)
            {

                foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                {

                    foreach (Piece piece in allClassed)
                        ListSelection.setTuningDateValues(piece, mode.item);

                    m_listWriter.writeGen(albums, mode, duration, "g", false);
                }
            }

            listWriterAll.writeGen(albums, null, null, "all", false);

            return;

            writeRot(1);

            m_listWriter.writeCheckClassement(1);

            m_listWriter.reset();
            writeRotMin(-1);
            writeRotMin(10);
            writeRotMin(1);
        }
        private void writeRotMin(int a_nbHour)
        {
            misc.log("----------------------");
            m_listWriter.writeRotMin(a_nbHour);
        }
        private void writeRot(int a_base)
        {
            m_listWriter.writeRot(a_base);

        }
        #endregion
    }
}



]]></content>
  </file>
  <file path="\PieceDb.Consolid\pdb.gen.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.gen</RootNamespace>
    <AssemblyName>pdb.gen</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="albums\Album.cs" />
    <Compile Include="albums\AlbumComparer.cs" />
    <Compile Include="albums\Albums.cs" />
    <Compile Include="albums\VirtualAlbumPiece.cs" />
    <Compile Include="CalcEquiv.cs" />
    <Compile Include="Consolid.cs" />
    <Compile Include="CLegacyListWriter.cs" />
    <Compile Include="CRank.cs" />
    <Compile Include="IListWriter.cs" />
    <Compile Include="ListPiece.cs" />
    <Compile Include="CPieceComparer.cs" />
    <Compile Include="ListSelection.cs" />
    <Compile Include="ListWriterMgr.cs" />
    <Compile Include="Math.cs" />
    <Compile Include="pertinence\TrackBuilder.cs" />
    <Compile Include="Piece.cs" />
    <Compile Include="CalcDate.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="stat\ClassStruct.cs" />
    <Compile Include="stat\Condenseur.cs" />
    <Compile Include="stat\DynamicStatBuilder.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="stat\MedianneValue.cs" />
    <Compile Include="stat\NewClassement.cs" />
    <Compile Include="stat\StatBuilder.cs" />
    <Compile Include="stat\StatConteneur.cs" />
    <Compile Include="TrackList.cs" />
    <Compile Include="Tuning\CConf.cs" />
    <Compile Include="Tuning\CConfQL.cs" />
    <Compile Include="Tuning\CConfSort.cs" />
    <Compile Include="Tuning\ConfAlbumSort.cs" />
    <Compile Include="Tuning\ConfGen.cs" />
    <Compile Include="Tuning\CTuning.cs" />
    <Compile Include="Tuning\Export.cs" />
    <Compile Include="Tuning\GroupingDisplay.cs" />
    <Compile Include="Tuning\Import.cs" />
    <Compile Include="Virtuel\VirtualPiece.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823D1D-851C-456B-AC4C-B0BEEC173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.util;
using System;
using System.Globalization;
using pdb.gen.Tuning;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    public class Album
    {

        private string name;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
       // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }

        private List<Piece> list = new List<Piece>();
        private static int _sID = 0;
        private int _dID;


        public Album(string name)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        private string equiv = "";
        public string Equiv { get { return equiv; } }

        private string equivLight = "";
        public string EquivLight { get { return equivLight; } }

        private string moyenne = "";
        public string Moyenne { get { return moyenne; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            if (list.Contains(piece))
                return false;
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);
            piece.PieceAlbum = this;
            return true;
        }

        public List<Piece> Tracks
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceClassementValueComparer());
                return l;
            }
        }


        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        private bool atLeastOneEnabled;
        public bool AtLeastOneEnabled { get { return atLeastOneEnabled; } }

        public void makeSort(ConfMedianne mode) //IList<double> reference, IList<Piece> pieces)
        {
            try
            {
                //if (name == "The College Dropout")
                //{
                //}
                decimal offset = conf.AlbumMoyOffset;
                int count = list.Count;
                list.Sort(new PieceSortComparer());
                var listSortedValues = new List<decimal>();
                for (int i = 0; i < count; i++)
                {
                    listSortedValues.Add(list[i].Rank.SortValue);
                    if (!classed && list[i].isClassListNumeric)
                        classed = true;
                }

                m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;



                listSortedValues = new List<decimal>();
                list.Sort(new PieceClassementValueComparer());
                decimal moy = 0m;
                for (int i = 0; i < count; i++)
                {
                    var rapportClassement = list[i].RapportClassement;
                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;

                    listSortedValues.Add(rapportClassement);
                }
                if (count > 0)
                    moy /= count;
                classMoy = moy;


                var med = CalcMedianne.getMedianne(listSortedValues, medianne);
                classementValue = med.d;
                if (classementValue > 0m)
                    list[med.index].Medianne = true;

                med = CalcMedianne.getMedianneLight(listSortedValues, mode);
                classementValueLight = med.d;
                if (classementValueLight > 0m)
                    list[med.index].MedianneLight = true;




                //int iequiv = CalcMedianne.getEquiv(reference, m_rank.SortValue, 0, reference.Count - 1);
                //equiv = pieces[iequiv];
                equiv = Piece.getClassementEquiv(classementValue); // (10000 * m_rank.SortValue).ToString("00000.0", cu); 
                equivLight = Piece.getClassementEquiv(classementValueLight);

                moyenne = Piece.getClassementEquiv(classMoy);
            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }



        }



        public decimal getTrackSortValue(int index)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }

        public void makeSelection()
        {
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private void initRank()
        {
            m_rank.init();
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumComparer.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.IO;
using System;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.util;

namespace pdb.gen.albums
{
    //public enum albumSortMode
    //{
    //    /// <summary>
    //    /// tri sur moyenne quand aucun des albums n'a défini sa médianne
    //    /// </summary>
    //    strict,
    //    /// <summary>
    //    /// tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur moyenne
    //    /// </summary>
    //    mix,
    //    /// <summary>
    //    /// Tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur medianne light
    //    /// </summary>
    //    mixLight,
    //    /// <summary>
    //    /// Tri sur medianne light quand les deux albums ont défini leur médianne, sinon tri sur moyenne
    //    /// </summary>
    //    mixLight2,
    //    /// <summary>
    //    /// Calcul médianne quasi strict, qq miettes pour éviter le zero
    //    /// </summary>
    //    medQuasi,
    //    /// <summary>
    //    /// Calcul Médianne moins strict
    //    /// </summary>
    //    medLight,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise un morceau au plus pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à deux morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe2,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à trois morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe3,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 4 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe4,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 5 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe5,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 6 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe6,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 10 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe10,
    //    /// <summary>
    //    /// tri uniquement sur la moyenne
    //    /// </summary>
    //    light

    //}
    class AlbumClassComparer : IComparer<Album>
    {
        private ConfAlbumSort mode;
        public AlbumClassComparer(ConfAlbumSort mode)
        {
            this.mode = mode;
        }
        private void calc(ref decimal xx, ref decimal yy, Album x, Album y, ConfMedianne cmpt)
        {
            switch (cmpt.type)
            {
                case medianneMode.none:
                    break;
                case medianneMode.strict: xx = x.ClassementValue; yy = y.ClassementValue;
                    break;
                case medianneMode.light: xx = x.ClassementValueLight; yy = y.ClassementValueLight;
                    break;
                case medianneMode.moy: xx = x.ClassementMoy; yy = y.ClassementMoy;
                    break;
                default:
                    break;
            }
        }

        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;


            int cmp = 0;
            decimal xx =0;
            decimal yy=0;
            var composants = mode.ComposantsUtiles; 
            if (composants.Count > 1)
            {
                if (x.ClassementValue == 0m || y.ClassementValue == 0m)
                {
                    var cmpt2 = composants[1];
                    calc(ref xx, ref yy, x, y, cmpt2);
                    cmp = xx.CompareTo(yy);
                    if (cmp != 0)
                        return cmp; 
                }

            }

            var cmpt = composants[0];
            calc(ref xx, ref yy, x, y, cmpt);

            cmp = xx.CompareTo(yy);
            if (cmp != 0)
                return cmp; 

            //if (mode == albumSortMode.light)
            //{
            //    cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            //    if (cmp != 0)
            //        return cmp;
            //}
            //else if (mode == albumSortMode.mix)
            //{
            //    if (x.ClassementValue == 0m || y.ClassementValue == 0m)
            //    {
            //        cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //}

            //else if (mode == albumSortMode.mixLight)
            //{
            //    if (x.ClassementValue == 0m || y.ClassementValue == 0m)
            //    {
            //        cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //}

            //else if (mode == albumSortMode.mixLight2)
            //{
            //    if (x.ClassementValue == 0m || y.ClassementValue == 0m)
            //    {
            //        cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //    else
            //    {
            //        cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //}

            //else if (mode == albumSortMode.medLight
            //    || mode == albumSortMode.medQuasi
            //    || mode == albumSortMode.medLightSafe
            //    || mode == albumSortMode.medLightSafe2
            //    || mode == albumSortMode.medLightSafe3
            //    || mode == albumSortMode.medLightSafe4
            //    || mode == albumSortMode.medLightSafe5
            //    || mode == albumSortMode.medLightSafe6
            //    || mode == albumSortMode.medLightSafe10
            //    )
            //{
            //    cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            //    if (cmp != 0)
            //        return cmp;
            //}



            cmp = x.ClassementValue.CompareTo(y.ClassementValue);
            if (cmp != 0)
                return cmp;

            cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            if (cmp != 0)
                return cmp;

            cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            if (cmp != 0)
                return cmp;

            int i = 0;
            var t1 = -2m;
            var t2 = -2m;
            while (true)
            {
                t1 = x.getTrackSortValue(i);
                t2 = y.getTrackSortValue(i);

                cmp = t1.CompareTo(t2);
                if (cmp != 0)
                    return cmp;



                if (t1 == 0)
                    break;

                i++;

            }
            cmp = x.DurationValue.CompareTo(y.DurationValue);
            if (cmp != 0)
                return cmp;
            return -x.Name.CompareTo(y.Name);

        }
    }

    class AlbumClassComparer2 : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            return x.Rank.Sort.CompareTo(y.Rank.Sort);
        }
    }


    class AlbumSortComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            int cmp = x.Rank.SortValue.CompareTo(y.Rank.SortValue);
            if (cmp != 0)
                return cmp;

            if (x.Rank.SortValue == 0)
            {

            }

            var xx = x.getFirstTrackSortValue();
            var yy = y.getFirstTrackSortValue();

            return xx.CompareTo(yy);

        }
    }

    class AlbumRestComparer : IComparer<Album>
    {
        static AlbumSortComparer subCmp = new AlbumSortComparer();
        const decimal EPSILON = 0.00001m;
        public int Compare(Album x, Album y)
        {
            var xx = x.Rank.TimeRest;
            var yy = y.Rank.TimeRest;
            int cmp = 0;
            if (Math.Abs(xx - yy) >= EPSILON)
                cmp = xx.CompareTo(yy);
            if (cmp == 0)
                return subCmp.Compare(x, y);
            return cmp;
        }
    }

    class PieceInVirtualAlbumComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return x.Location.CompareTo(y.Location);
        }
    }

    class PieceInAlbumComparer : IComparer<Piece>
    {
        private bool debile(int trackNumber)
        {
            return trackNumber <= 0 || trackNumber > 10000;
        }

        private bool debile(Piece piece)
        {
            return debile(piece.TrackNumber);
        }
        public int Compare(Piece x, Piece y)
        {
            if (debile(x))
            {
                if (debile(y))
                {
                    var f1 = Path.GetFileName(x.Location);
                    var f2 = Path.GetFileName(y.Location);
                    return f1.CompareTo(f2);
                }
                return -1;
            }
            if (debile(y))
                return 1;
            var cmp = x.TrackNumber.CompareTo(y.TrackNumber);
            if (cmp != 0)
                return cmp;
            return x.Location.CompareTo(y.Location);
        }
    }

    class AllPieceComparer : IComparer<Piece>
    {
        PieceInAlbumComparer pieceComp = new PieceInAlbumComparer();
        IComparer<Album> albumcomp = new AlbumClassComparer2();

        public int Compare(Piece x, Piece y)
        {
            int cmp = albumcomp.Compare(x.PieceAlbum, y.PieceAlbum);
            if (cmp != 0)
                return cmp;
            return -pieceComp.Compare(x, y);
        }
    }

    class AllPieceComparer2 : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return -x.RankAllAlbum.CompareTo(y.RankAllAlbum);
        }
    }

    class AlbumNameComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            return x.Name.CompareTo(y.Name);
        }
    }


}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using pdb.util;
using System.Collections.Generic;
using System;
using pdb.obj;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    public class Albums
    {
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
        }
        private BgDictString<Album> dict = new BgDictString<Album>();
        private Consolid consolid;
        private void check_(Piece piece)
        {
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                var album = dict[__album];
                if (album == null)
                {
                    album = new Album(__album);
                    album.Virtual = piece.Virtual;
                    dict.Add(__album, album);
                }
                album.add(piece);

            }


        }

        public void sortVirtual()
        {
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }
        }

        public void check(Piece piece)
        {
            check_(piece);
            foreach (Piece child in piece.Childs)
                check_(child);
        }

        public Album getAlbum(TrackList piece)
        {
            return piece.Piece.PieceAlbum;
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                return dict[__album];
            }
            return null;
        }

        public void makeSort()
        {
          
            var confSort = consolid.SortAlbumMode; 
            ///check to find first light
            ConfMedianne confMedianne = null; 
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp; 
            }

        

            var listRef = new List<double>();
            //foreach (Piece piece in reference)
            //    listRef.Add(piece.RapportClassement); // piece.Rank.SortValue); 
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSort(confMedianne); //listRef, reference); 
            }

            list.Sort(new AlbumClassComparer(consolid.SortAlbumMode));
            list.Reverse();
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
        }

        public List<Album> makeSelection()
        {
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSelection();
            }
            list.Sort(new AlbumRestComparer());
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }
            return list;
        }


        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }



    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\CConf.cs">
    <content><![CDATA[using System;
using System.IO;
using System.Xml;
using pdb.gen.Tuning;
using pdb.ordo.conf;
using pdb.util;
using pdb.gen.albums;
namespace pdb.gen.conf
{
    public enum rankingType
    {
        middle = 0,
        up = 1,
        bottom = 2
    }

   
    public class CConf
    {
        private static volatile object _lock = new object(); 
        private const string CONF_FILE = @"..\pdb.conf.xml";
        private static string m_listBase = "classement";
        private static int m_before = 0;
        private static int m_after = 0;
        private static bool m_checkModifStrict = true;
        private static bool scan = false;
        private static string copyTo = "";
        private static bool copyModeFile = false;
        private static CConfSort m_sort = new CConfSort();
        private static int classementOffset = 0;
        private static rankingType _rankingType = rankingType.middle;
       // private static bool deleteFile;
        private static int maxTask = int.MaxValue; 

        private static CConfSort m_select = new CConfSort();
        private static ConfGen confGen = new ConfGen();

        private static bool removeVersions;
        private static bool condensation;
        private static bool resetOneCl; 
       
       // private static int taskDelayError = -1;

        private static bool menage = false;

       
        private static bool ordonnancement; 

      //  private static DataConf dataConf;
        private static ConfOrdo ordoConf = new ConfOrdo(); 
     

        
        private static int volumeMin = -125;
        private static bool abortOpe;

        private static Export export = new Export();
        private static Import import = new Import(); 
       
     



        public static XmlElement loadConf()
        {
            lock (_lock)
            {
                misc.log("load conf");
                if (!File.Exists(CONF_FILE))
                    return null ;
                XmlDocument l_doc = new XmlDocument();
                l_doc.Load(CONF_FILE);
                XmlElement l_xmlRoot = l_doc.DocumentElement;
                XMLTool l_xmlConf = new XMLTool(l_xmlRoot);

                string l_str = l_xmlConf.getNodeValue("listBase");
                if (!string.IsNullOrEmpty(l_str))
                    m_listBase = l_str;

                l_str = l_xmlConf.getNodeValue("before");
                if (!string.IsNullOrEmpty(l_str))
                    m_before = Convert.ToInt32(l_str);

                l_str = l_xmlConf.getNodeValue("after");
                if (!string.IsNullOrEmpty(l_str))
                    m_after = Convert.ToInt32(l_str);

                l_str = l_xmlConf.getNodeValue("checkModifStrict");
                if (!string.IsNullOrEmpty(l_str))
                    m_checkModifStrict = Convert.ToBoolean(l_str);

                l_str = l_xmlConf.getNodeValue("scan");
                if (!string.IsNullOrEmpty(l_str))
                    scan = Convert.ToBoolean(l_str);

                l_str = l_xmlConf.getNodeValue("copyTo");
                if (!string.IsNullOrEmpty(l_str))
                {
                    copyTo = l_str;
                    l_str = l_xmlConf.getAttValue("copyTo", "copyModeFile");
                    if (!string.IsNullOrEmpty(l_str))
                        copyModeFile = Convert.ToBoolean(l_str);
                }

                l_str = l_xmlConf.getNodeValue("classementOffset");
                if (!string.IsNullOrEmpty(l_str))
                    classementOffset = Convert.ToInt32(l_str);
                l_str = l_xmlConf.getNodeValue("rankingType");
                if (!string.IsNullOrEmpty(l_str))
                    _rankingType = (rankingType)Enum.Parse(typeof(rankingType), l_str);

              

                l_str = l_xmlConf.getNodeValue("maxTask");
                if (!string.IsNullOrEmpty(l_str))
                    maxTask = Convert.ToInt32(l_str);

              

               

             

                l_str = l_xmlConf.getNodeValue("volumeMin");
                if (!string.IsNullOrEmpty(l_str))
                    volumeMin = Convert.ToInt32(l_str);

               

               

                removeVersions = l_xmlConf.getBoolValue("removeVersions", false);
                condensation = l_xmlConf.getBoolValue("condensation", false);
                resetOneCl = l_xmlConf.getBoolValue("resetOneCl",false); 
                abortOpe = l_xmlConf.getBoolValue("abortOpe"); 


               
                ordonnancement = l_xmlConf.getBoolValue("ordonnancement");

                menage = l_xmlConf.getBoolValue("menage", false);



                m_sort = new CConfSort(l_xmlConf.NodeLookUp("sort"), 0.5m);
                m_select = new CConfSort(l_xmlConf.NodeLookUp("selection"), 1);

                confGen = new ConfGen(l_xmlConf.NodeLookUp("gen"));
               // Album.Medianne = confGen.Medianne; 
                

             //   dataConf = new DataConf(l_xmlConf.NodeLookUp("data"));

                ordoConf = new ConfOrdo(l_xmlConf.NodeLookUp("ordo"));

                export = new Export(l_xmlConf.NodeLookUp("export"));
                import = new Import(l_xmlConf.NodeLookUp("import"));





                return l_xmlRoot; 
            }

        }


        public static string ListBase
        {
            get { return m_listBase; }
        }

        public static ConfGen ConfGen
        {
            get { return confGen; }
        }

        public static CConfSort Sort
        {
            get { return m_sort; }
        }
        public static CConfSort Select
        {
            get { return m_select; }
        }
        public static int Before
        {
            get { return m_before; }
        }
        public static int After
        {
            get { return m_after; }
        }
        public static bool CheckModifStrict
        {
            get { return m_checkModifStrict; }
        }
        public static int MaxTask { get { return maxTask; } }
        public static rankingType RankingType { get { return _rankingType; } }

        public static bool Scan { get { return scan; } }
        public static string CopyTo { get { return copyTo; } }

        public static bool CopyModeFile { get { return copyModeFile; } }

        public static int ClassementOffset { get { return classementOffset; } }

       // public static bool DeleteFile { get { return deleteFile; } }

       // public static DataConf DataConf { get { return dataConf; } }

        public static bool RemoveVersions { get { return removeVersions; } }
        public static bool Condensation { get { return condensation; } }
        public static bool ResetOneCl { get { return resetOneCl; } }

      

      //  public static int TaskDelayError { get { return taskDelayError; } }

        public static bool Menage { get { return menage; } }

       
        public static bool Ordonnancement { get { return ordonnancement; } }
        public static bool AbortOpe { get { return abortOpe; } }

        //public static int MaxScan { get { return maxScan; } }
        public static int VolumeMin { get { return volumeMin; } }

      
        public static ConfOrdo ConfOrdo { get { return ordoConf; } }

        public static Export Export { get { return export; } }
        public static Import Import { get { return import; } }
        public static string display()
        {   
            StringBuilder sb = new StringBuilder(); 
            sb.Append( String.Format("base:{0} before:{1} after: {2} select:{3} sort:{4}", m_listBase, m_before, m_after, m_select, m_sort));
            sb.AppendLine(confGen.ToString());
            sb.AppendLine(ordoConf.ToString()); 

            return sb.ToString();
        }

    }


    public enum ConfType
    {
        sort,
        selection
    }
}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\ConfAlbumSort.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.Xml;
using pdb.util;

namespace pdb.gen.Tuning
{
   
    /// <summary>
    /// Configuration sort Albums
    /// </summary>
    public class ConfAlbumSort : TuningBase
    {
      //  
        private List<ConfMedianne> composants = new List<ConfMedianne>();
        private List<ConfMedianne> composantsUtiles = new List<ConfMedianne>();
        public List<ConfMedianne> Composants { get { return composants; } }
        public List<ConfMedianne> ComposantsUtiles { get { return composantsUtiles; } }
        public void Calcul()
        {
            composantsUtiles = new List<ConfMedianne>();
            foreach (var cmp in composants)
            {
                if (cmp.enabled)
                    composantsUtiles.Add(cmp); 
            }
            if (composantsUtiles.Count == 0)
                composantsUtiles.Add(composants[0]); 
        }
        public ConfAlbumSort()
        {
        }

        public ConfAlbumSort(XmlElement node)
            : base(node)
        {
          
            composants.Clear(); 
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    var cmp = new ConfMedianne(node, sub as XmlElement);
                    composants.Add(cmp); 
                }
            }

            Calcul(); 

        }
        public bool Enabled
        {
            get
            {
                foreach (var cmp in composants)
                {
                    if (cmp.enabled)
                        return true; 
                }
                return false; 
            }
        }
    }

   
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\ConfGen.cs">
    <content><![CDATA[using System;
using System.Xml;
using pdb.gen.conf;
using pdb.util;
using System.Collections.Generic;
using pdb.gen.albums;

namespace pdb.gen.Tuning
{
    public enum writeGrouping
    {
        none = 0,
        selected = 1,
        mix = 2,
        all = 3,

    }

    public enum datesMode
    {
        play = 1,
        @class = 2,
        classMin = 3,
        mix = 4,
        mixMin = 5

    }

    public class ExtendToNative<T>
    {
        public readonly T item;
        public readonly bool extend;
        public readonly bool extendTimeOrder;
        public readonly bool level;

        public ExtendToNative(T item, bool extend, bool extendTimeOrder, bool level)
        {
            this.item = item;
            this.extend = extend;
            this.extendTimeOrder = extendTimeOrder;
            this.level = level;
        }

        public override string ToString()
        {
            return item.ToString();
        }
    }
    public class ConfGen
    {

        private CConfQL confCourbe = new CConfQL();

        private TimeSpan vie = TimeSpan.FromDays(365);
        datesMode dates;
        private List<ExtendToNative<double>> listes = new List<ExtendToNative<double>>();
        private decimal exp = 1;
        private bool withOrder;
        private bool orderZero;
        private bool orderLarge;
        private bool genE;
        private bool genLarge;
        private bool writeGroupingZero;
        private bool genCheck;
        bool albumOrdo;
        bool onlyEnabled;
        /// <summary>
        /// Simuler la conso du premier élément
        /// </summary>
        private bool anticipation;

        //private double equivDelta = 0.00001;
        //private int equivStep = 100000; 
        private writeGrouping writeGrouping = writeGrouping.selected;
        private writeGrouping writeComment = writeGrouping.all;

        private GroupingDisplay groupingDisplay = new GroupingDisplay(null);

        private DateTime minPlayDate = DateTime.MinValue;
        private DateTime minClassDate = DateTime.MinValue;
        private int offsetPlayDate = 0;
        private int offsetClassDate = 0;
        private int offsetClassMin = 1;
        private int listLimit = int.MaxValue;
        private int listReaderAfter = 0;
        private int listReaderBefore = 0;
      //  private decimal medianne = 0.5m;
        private decimal albumMoyOffset = 0m;

        private List<ExtendToNative<datesMode>> cat = new List<ExtendToNative<datesMode>>();
        private ExtendToNative<int> precisionMin = new ExtendToNative<int>(-1, false, false, false);
        private ExtendToNative<int> precisionMax = new ExtendToNative<int>(-1, false, false, false);

        private ConfAlbumSort albumSortMode = new ConfAlbumSort(); 

     
        private bool albumVirtual = false; 

        public ConfGen()
        {
        }
        public ConfGen(XmlElement a_xml)
        {
            if (a_xml == null)
                return;
            XMLTool l_xml = new XMLTool(a_xml);
            XmlElement xmlQuality = l_xml.NodeLookUp("courbe");
            
            confCourbe = new CConfQL(xmlQuality);

            var str = l_xml.getNodeValue("dates");
            if (!string.IsNullOrEmpty(str))
                dates = (datesMode)Enum.Parse(typeof(datesMode), str, true);
            var xTime = l_xml.NodeLookUp("time");
            if (xTime != null)
            {
                var _xtime = new XMLTool(xTime);
                string l_str = _xtime.getNodeValue("vie").Trim();
                if (!string.IsNullOrEmpty(l_str))
                    vie = TimeSpan.FromDays(Convert.ToDouble(l_str));

                l_str = _xtime.getNodeValue("exp").Trim();
                if (!string.IsNullOrEmpty(l_str))
                    exp = Convert.ToDecimal(l_str);
            }

            var xLists = l_xml.NodeLookUp("lists");
            if (xLists != null)
            {
                foreach (XmlNode xList in xLists.ChildNodes)
                {
                    if (xList is XmlElement)
                    {

                        double iList = Convert.ToDouble(xList.InnerText);
                        bool extend = false;
                        var att = xList.Attributes["nat"];
                        if (att != null && att.Value == "true")
                            extend = true;

                        bool extendtimeOrder = false;
                        att = xList.Attributes["timeOrder"];
                        if (att != null && att.Value == "true")
                            extendtimeOrder = true;

                        bool _level = false;
                        att = xList.Attributes["level"];
                        if (att != null && att.Value == "true")
                            _level = true;

                        ExtendToNative<double> e = new ExtendToNative<double>(iList, extend, extendtimeOrder, _level);
                        listes.Add(e);
                    }
                }
            }

            str = l_xml.getNodeValue("writeGrouping");
            if (!string.IsNullOrEmpty(str))
                writeGrouping = (writeGrouping)Enum.Parse(typeof(writeGrouping), str);

            str = l_xml.getNodeValue("writeComment");
            if (!string.IsNullOrEmpty(str))
                writeComment = (writeGrouping)Enum.Parse(typeof(writeGrouping), str);

            str = l_xml.getNodeValue("equivDelta");
            if (!string.IsNullOrEmpty(str))
                CalcEquiv.coeffDelta = Convert.ToDecimal(str);

            str = l_xml.getNodeValue("equivStep");
            if (!string.IsNullOrEmpty(str))
                CalcEquiv.MAX_STEP = Convert.ToInt32(str);

            var l_display = l_xml.NodeLookUp("display");
            groupingDisplay = new GroupingDisplay(l_display);

            withOrder = l_xml.getBoolValue("withOrder");
            orderLarge = l_xml.getBoolValue("orderLarge");
            orderZero = l_xml.getBoolValue("orderZero");
            genE = l_xml.getBoolValue("genE");
            genLarge = l_xml.getBoolValue("genLarge");
            writeGroupingZero = l_xml.getBoolValue("writeGroupingZero");
            genCheck = l_xml.getBoolValue("genCheck");
            anticipation = l_xml.getBoolValue("anticipation");
            albumOrdo = l_xml.getBoolValue("albumOrdo");
            onlyEnabled = l_xml.getBoolValue("onlyEnabled");
           
            albumVirtual = l_xml.getBoolValue("albumVirtual", albumVirtual);

            str = l_xml.getNodeValue("minPlayDate");
            if (!string.IsNullOrEmpty(str))
                minPlayDate = Convert.ToDateTime(str);

            str = l_xml.getNodeValue("minClassDate");
            if (!string.IsNullOrEmpty(str))
                minClassDate = Convert.ToDateTime(str);

            str = l_xml.getNodeValue("offsetPlayDate");
            if (!string.IsNullOrEmpty(str))
                offsetPlayDate = Convert.ToInt32(str);

            str = l_xml.getNodeValue("offsetClassDate");
            if (!string.IsNullOrEmpty(str))
                offsetClassDate = Convert.ToInt32(str);

            str = l_xml.getNodeValue("offsetClassMin");
            if (!string.IsNullOrEmpty(str))
                offsetClassMin = Convert.ToInt32(str);

            str = l_xml.getNodeValue("listLimit");
            if (!string.IsNullOrEmpty(str))
                listLimit = Convert.ToInt32(str);

            str = l_xml.getNodeValue("listReaderAfter");
            if (!string.IsNullOrEmpty(str))
                listReaderAfter = Convert.ToInt32(str);

            str = l_xml.getNodeValue("listReaderBefore");
            if (!string.IsNullOrEmpty(str))
                listReaderBefore = Convert.ToInt32(str);

            //str = l_xml.getNodeValue("medianne");
            //if (!string.IsNullOrEmpty(str))
            //    medianne = Convert.ToDecimal(str);


            str = l_xml.getNodeValue("albumMoyOffset");
            if (!string.IsNullOrEmpty(str))
                albumMoyOffset = Convert.ToDecimal(str);
            var xalbumSort = l_xml.NodeLookUp("albumSort");

            albumSortMode = new ConfAlbumSort(xalbumSort); 

            //str = l_xml.getNodeValue("albumSortMode");
            //if (!string.IsNullOrEmpty(str))
            //    albumSortMode = (albumSortMode) Enum.Parse(typeof(albumSortMode), str, true); 

            var xDir = l_xml.NodeLookUp("dir");
            if (xDir != null)
            {
                foreach (XmlNode xSub in xDir.ChildNodes)
                {
                    if (xSub is XmlElement)
                    {
                        if (xSub.Name == "precision")
                        {
                            var _precisionMin = Convert.ToInt32(xSub.Attributes["min"].Value);
                            bool _extend = false;

                            var att = xSub.Attributes["nat"];
                            if (att != null && att.Value == "true")
                                _extend = true;

                            bool _extendtimeOrder = false;
                            att = xSub.Attributes["timeOrder"];
                            if (att != null && att.Value == "true")
                                _extendtimeOrder = true;
                            var _precisionMax = Convert.ToInt32(xSub.Attributes["max"].Value);

                            bool _level = false;
                            att = xSub.Attributes["level"];
                            if (att != null && att.Value == "true")
                                _level = true;


                            precisionMin = new ExtendToNative<int>(_precisionMin, _extend, _extendtimeOrder, _level);
                            precisionMax = new ExtendToNative<int>(_precisionMax, _extend, _extendtimeOrder, _level);
                        }
                        else
                        {
                            datesMode item = (datesMode)(Enum.Parse(typeof(datesMode), xSub.Name, true));
                            bool extend = false;
                            var att = xSub.Attributes["nat"];
                            if (att != null && att.Value == "true")
                                extend = true;

                            bool _extendtimeOrder = false;
                            att = xSub.Attributes["timeOrder"];
                            if (att != null && att.Value == "true")
                                _extendtimeOrder = true;

                            bool _level = false;
                            att = xSub.Attributes["level"];
                            if (att != null && att.Value == "true")
                                _level = true;

                            cat.Add(new ExtendToNative<datesMode>(item, extend, _extendtimeOrder, _level));

                        }
                    }

                }
            }

        }

        public CConfQL Courbe { get { return confCourbe; } }

        public decimal Exp { get { return exp; } }
        public TimeSpan Vie { get { return vie; } }
        public datesMode Dates { get { return dates; } }
        public IEnumerable<ExtendToNative<double>> Listes { get { return listes; } }

        public writeGrouping WriteGrouping { get { return writeGrouping; } }
        public writeGrouping WriteComment { get { return writeComment; } }

        //  public GroupingDisplay Display { get { return groupingDisplay; } }
        public timeMode TimeMode { get { return groupingDisplay.TimeMode; } }
        public List<DisplayGrouping> DisplayCategories
        {
            get
            {
                var list = groupingDisplay.Categories;
                var found = list.Find(c => c.category == displayCategory.timeValue);

                int indexCurrentTimeValue = -1; //list.IndexOf(displayCategory.timeValue);
                if (found != null)
                    indexCurrentTimeValue = list.IndexOf(found);
                if (indexCurrentTimeValue >= 0)
                {
                    list[indexCurrentTimeValue].category = (displayCategory)dates;
                }

                return list;
            }
        }
        public bool WithOrder { get { return withOrder; } }
        public bool OrderLarge { get { return orderLarge; } }
        public bool OrderZero { get { return orderZero; } }
        public bool GenE { get { return genE; } }
        public bool GenLarge { get { return genLarge; } }
        public bool GenCheck { get { return genCheck; } }
        public bool Anticipation { get { return anticipation; } }
        public bool WriteGroupingZero { get { return writeGroupingZero; } }
        public bool AlbumOrdo { get { return albumOrdo; } }
        public bool OnlyEnabled { get { return onlyEnabled; } }


        public DateTime MinPlayDate { get { return minPlayDate; } }
        public DateTime MinClassDate { get { return minClassDate; } }

        public int OffsetPlayDate { get { return offsetPlayDate; } }
        public int OffsetClassDate { get { return offsetClassDate; } }
        public int OffsetClassMin { get { return offsetClassMin; } }
        public override string ToString()
        {
            return string.Format(" vie:{0} exp:{1} quality:{2} onlyPlayed:{3} writeGrouping:{4} display:{5}", vie, exp, confCourbe, dates, writeGrouping, groupingDisplay);
        }

        public List<ExtendToNative<datesMode>> Modes { get { return cat; } }
        public ExtendToNative<int> PrecisionMin { get { return precisionMin; } }
        public ExtendToNative<int> PrecisionMax { get { return precisionMax; } }
        public int ListLimit { get { return listLimit; } }
        public int ListReaderAfter { get { return listReaderAfter; } }
        public int ListReaderBefore { get { return listReaderBefore; } }
        //public decimal Medianne { get { return medianne; } }
        public decimal AlbumMoyOffset { get { return albumMoyOffset; } }
        //public albumSortMode AlbumSortMode { get { return albumSortMode; } } //set { albumSortStrict = value; } }
        public ConfAlbumSort AlbumSort { get { return albumSortMode; } }
        public bool AlbumVirtual { get { return albumVirtual; } }
    }
}
]]></content>
  </file>
</db>
