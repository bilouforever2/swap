<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;
using pdb.db.piece.type;

namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log;
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;


        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }

        public App()
            : base()
        {
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private void CheckException(string from, object sender, object ex)
        {
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {
                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init("pdb.player");
                log = Logger.getLogger("Program");

                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");


                var xmlConf = CConf.loadConf();
                export = CConf.Export;
                import = CConf.Import;
                gen = new Consolid();
                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);
                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni();
                Db.loadData();

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                thLoop = new Thread(loop);
                thLoop.Start();
                MemUtil.Start();
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        public static void go()
        {
            lock (_lock)
            {
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        private static void goInit()
        {
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;
            gen.MakeConsolid(Db.List.getList());

            if (CConf.ResetOneCl)
            {
                Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;
                Classement min = Classement.create("00001.0"); decimal mind = min.ClassementValueDecimal;
                var _albums = gen.Albums;
                foreach (var album in _albums.List)
                {
                    if (album.Name == "Mémos vocaux" || album.Name == "Pictures at an Exhibition")
                    {
                    }
                    var l = album.Tracks;
                    decimal pluspetitNonNull = 0m;
                    foreach (Piece t in l)
                    {
                        decimal clValue = t.ClassementValueDecimal;
                        if (clValue >= mind)
                        {
                            pluspetitNonNull = clValue;
                        }

                    }
                    foreach (Piece t in l)
                    {
                        if (t.Parent == null)
                        {
                            decimal clValue = t.ClassementValueDecimal;
                            if (t.isClassListNumeric && clValue > zer0d)
                            {
                                if (clValue < mind || clValue > pluspetitNonNull)
                                {
                                    var dPiece = Db.getPiece(t.PieceId);
                                    t.Enabled = true;
                                    t.setClassement("0", 0);
                                    dPiece.eraseClassement2();
                                }
                            }
                        }
                    }
                }
                gen.MakeConsolid(Db.List.getList());
            }


            gen.buildMusique();
            gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


            gen.timeRanking();
            gen.eraseGrouping();
            // gen.writeComment();
            gen.createRot(CConf.ListBase, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            gen.CommentGo = true;
            gen.GroupinGO = true;
            PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual;
        }

        private static void _go()
        {
            try
            {
                gen.CommentGo = false;
                gen.GroupinGO = false;
                bib.Aborted = true;
                Db.saveAsync();
                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;
                if (__end || __go) return;

                gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
                //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 
                gen.MakeConsolid(Db.List.getList()); //   bib.Musique.Tracks);
                if (__end || __go) return;

                gen.timeRanking();
                if (__end || __go) return;



                if (__end || __go) return;
                ChronoData.DateAuto = true;

                //if (refresh != null)
                //    refresh(PHASE1, EventArgs.Empty);

                if (__end || __go) return;
                bib.Aborted = false;
                ListWriterMgr.Async = false;
                //listWriter = new ListWriter(root);
                try
                {
                    CConf.loadConf();
                }
                catch (Exception ex)
                {
                    log.log(ex.ToString());
                }
                gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                gen.createRot(CConf.ListBase, App.bib);
                //if (refresh != null)
                //    refresh(PHASE1, EventArgs.Empty);

            
                //log.log("visibles"); 
                //foreach (TrackListViewModel visible in Player.VisibleItems)
                //{
                //    if (__end || __go) return;
                //    visible.PieceGen.writeCommentGrouping();
                //    visible.refresh(); 
                //}
                //if (refresh != null)
                //    refresh(PHASE2, EventArgs.Empty);

                //if (__end || __go) return;
                //gen.writeComment();
                //if (__end || __go) return;
                //gen.writeGrouping();
                if (refresh != null)
                    refresh(PHASE2, EventArgs.Empty);

                if (__end || __go) return;

                gen.CommentGo = true;
                gen.GroupinGO = true;


                gen.CommentGo = true;
                gen.GroupinGO = true;
                //if (refresh != null)
                //    refresh(PHASE2, EventArgs.Empty);
                // _refresh = true;
                gen.builStats();
                //bib = new BibViewModel(Db.Root); 
                //gen.createRot(CConf.ListBase, bib);
                //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                gen.CommentGo = true;
                gen.GroupinGO = true;




            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                if (refresh != null)
                    refresh(PHASE2, EventArgs.Empty);
                ExportCmd.CalculExport();
            }


        }

        public static event EventHandler refresh;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            App.bib.Aborted = true;
            Db.WriteDB1();
            Db.WriteDB2();
            App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.Track);
            if (l == null)
                return null;
            foreach (ITrackMetaData p in l)
            {

                TrackListViewModel trackList = PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                    return null;
                case MessageBoxResult.No:
                    return false;
                case MessageBoxResult.None:
                    return null;
                case MessageBoxResult.OK:
                    return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export;
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog();
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir;
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Player.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Player"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:userCtl="clr-namespace:pdb.player.Vue"
       
        Title="Player" >
   

    <Grid Margin="0,0,0,0">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        <userCtl:PlayerControler Grid.Row="0" />
        <Grid Grid.Row="1">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="100"/>
                <ColumnDefinition Width="3"/>
                <ColumnDefinition Width="40*"/>
                <ColumnDefinition Width="3"/>
                <ColumnDefinition Width="12*"/>
                <ColumnDefinition Width="3"/>
                <ColumnDefinition Width="18*"/>
            </Grid.ColumnDefinitions>
            <userCtl:BibCtl x:Name="BibCtle" Grid.Column="0" Background="AliceBlue" />
            <GridSplitter Grid.Column="1" HorizontalAlignment="Stretch" />
            <userCtl:DataGridPlayList x:Name="dg_pl" Grid.Column="2" />
            <GridSplitter Grid.Column="3" HorizontalAlignment="Stretch" />
            <DockPanel Grid.Column="4" HorizontalAlignment="Stretch" >
                <userCtl:AlbumCtl DockPanel.Dock="Right" />
            </DockPanel>
            <GridSplitter Grid.Column="5" HorizontalAlignment="Stretch" />
            <DockPanel Grid.Column="6" HorizontalAlignment="Stretch" >
                <userCtl:ClassementCtl DockPanel.Dock="Right" />
            </DockPanel>

        </Grid>
        <userCtl:StateBar Grid.Row="2" />
    </Grid>
</Window>
]]></content>
  </file>
  <file path="\pdb.player\Player.xaml.cs">
    <content><![CDATA[using System.ComponentModel;
using System.Windows;
using pdb.util;
using System.Collections.Generic;
using pdb.player.ViewModel;

namespace pdb.player
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class Player : Window
    {
      
        private static Logger log;
        private static Player _instance; 
        
       
        public Player()
        {
            InitializeComponent();
            log = App.log;
            this.BibCtle.BibRoot = App.bib; 
            this.Loaded += Player_Loaded;
            this.Closing += new CancelEventHandler(Player_Closing);
            _instance = this; 
        }

        void Player_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            App.shutdown(); 
        }

        void Player_Loaded(object sender, RoutedEventArgs e)
        {
            //new ThreadUtil(() =>
            //App.go(),"go").Start(); 
           
        }

        public static List<TrackListViewModel> VisibleItems { get { return _instance.dg_pl.VisibleItems; } }

        
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\PieceViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.gen;
using pdb.db.obj;
using pdb.util;

namespace pdb.player.ViewModel
{
    class PieceViewModel : ViewModelBase
    {
        private CPiece piece;
        private Piece gen;
        private PieceViewModel(CPiece piece, Piece gen)
        {
            this.piece = piece; //.Piece.Track as CPiece; 
            this.gen = gen;
        }
        private static BgDict<int, PieceViewModel> dict = new BgDict<int, PieceViewModel>();

        public static PieceViewModel getPiece(TrackList track)
        {
            Piece gen = track.Piece;
            CPiece piece = gen.Track as CPiece;
            int id = piece.PieceId;
            PieceViewModel pv = null;
            if (!dict.ContainsKey(id))
            {
                pv = new PieceViewModel(piece, gen);
                dict.Add(id, pv);
                return pv;
            }
            return dict[id];
        }
        public CPiece Piece { get { return piece; } }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                if (value != piece.Enabled)
                {
                    piece.Enabled = value;
                    OnPropertyChanged("Enabled");
                }
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {

                if (value != piece.Rating)
                {
                    piece.Rating = value;
                    OnPropertyChanged("Rating");
                }
            }
        }

        public String Classement
        {
            get
            {
                return piece.StrClassement;
            }
            set
            {
                if (value != piece.StrClassement)
                {
                    piece.StrClassement = value;
                    OnPropertyChanged("Classement");


                }
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                if (value != piece.Year)
                {
                    piece.Year = value;
                    OnPropertyChanged("Year");
                }
            }
        }

        public void eraseCommentGrouping() { _commentGroupingOk = false; }
        private bool _commentGroupingOk;

        public string Comment
        {
            get
            {
                if (!_commentGroupingOk)
                {
                    _commentGroupingOk = true;
                    gen.writeCommentGrouping();

                }
                return gen.Comment;
            }
            set
            {
                if (value != piece.Comment)
                {
                    piece.Comment = value;
                    OnPropertyChanged("Comment");

                }
            }
        }

        public string Grouping
        {
            get
            {
                if (!_commentGroupingOk)
                {
                    _commentGroupingOk = true;
                    gen.writeCommentGrouping();
                }
                return gen.Grouping;
            }
            set
            {
                if (value != piece.Grouping)
                {
                    piece.setGrouping(value, true);
                    OnPropertyChanged("Grouping");
                }
            }
        }




        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }

        public bool Exists { get { return piece.Exists; } }
        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set
            {
                if (!Exists)
                    return;
                if (value != Duration)
                {
                    var deltaMs = Math.Abs(value.TotalMilliseconds - Duration.TotalMilliseconds);
                    if (deltaMs >= 1)
                    {
                        piece.Duration = value;
                        if (deltaMs >= 1000)
                            OnPropertyChanged("Duration");
                    }
                }
            }
        }

        public string Location
        {
            get { return piece.Location; }
        }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                if (value != piece.Artist)
                {
                    piece.Artist = value;
                    OnPropertyChanged("Artist");
                }
            }
        }

        public string Album
        {
            get
            {
                return piece.Album;
            }
            set
            {
                if (value != piece.Album)
                {
                    piece.Album = value;
                    OnPropertyChanged("Album");
                }
            }
        }

        public string Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                if (value != piece.Name)
                {
                    piece.Name = value;
                    OnPropertyChanged("Name");
                }
            }
        }

        public int TrackNumber
        {
            get
            {
                return piece.TrackNumber;
            }
            set
            {
                if (value != piece.TrackNumber)
                {
                    piece.TrackNumber = value;
                    OnPropertyChanged("TrackNumber");
                }
            }
        }


    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\TrackListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Windows;
using pdb.obj;
using pdb.util;
using pdb.gen;
using pdb.db.obj;

namespace pdb.player.ViewModel
{

    public class TrackListViewModel : BibViewModelBase, ITrackNativeDates
    {




        #region répercut
        //  private static BgDict<int, List<TrackListViewModel>> dictT = new BgDict<int, List<TrackListViewModel>>();
        #endregion
        private TrackList track;
        private PieceViewModel piece;
        private static TrackListViewModel currentPlaying;
        private static TrackListViewModel currentSelected;
        public TrackList Track { get { return track; } }
        public CPiece Piece { get { return piece.Piece; } }
        public Piece PieceGen { get { return track.Piece; } }
        public Piece Master { get { return PieceGen.Master; } }

        public void remove()
        {
            //var list = dictT[PieceId];
            //if (list == null)
            //    return;
            //list.Remove(this);
        }

        public void refresh()
        {
            piece.eraseCommentGrouping();
            OnPropertyChanged("ExportStatus");
            OnPropertyChanged("TV");
            OnPropertyChanged("Comment");
            OnPropertyChanged("Grouping");
            OnPropertyChanged("");
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                base.IsSelected = value;
                if (value)
                    CurrentSelected = this;
            }
        }

        private int index;
        public int Index
        {
            get { return index; }
            set
            {
                if (value != index)
                {
                    index = value;
                    OnPropertyChanged("Index");
                }
            }
        }

        public static event EventHandler CurrentSelectedChanged;
        public static TrackListViewModel CurrentSelected
        {
            get
            {
                return currentSelected;
            }
            set
            {
                if (value != currentSelected)
                {
                    currentSelected = value;
                    if (CurrentSelectedChanged != null)
                        CurrentSelectedChanged("Track", EventArgs.Empty);
                }
            }
        }

        public static event EventHandler CurrentHumanSelectedChanged;
        private static TrackListViewModel humanSelected;
        public static TrackListViewModel HumanSelected
        {
            get { return humanSelected; }
            set
            {
                if (value != humanSelected)
                {
                    humanSelected = value;
                    if (CurrentHumanSelectedChanged != null)
                        CurrentHumanSelectedChanged("Human", EventArgs.Empty);
                }
            }
        }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
                //if (value != track.Enabled)
                //{
                //    track.Piece.Enabled = value;
                //    OnPropertyChanged("Enabled");
                //}
            }
        }
        //  private exportState exportState;
        //public int ExportState
        //{
        //    get
        //    {
        //        return (int)exportState;
        //    }
        //}

        public static EventHandler ExportStatusChange;
        private static void OnExportStatusChange(TrackListViewModel tv)
        {
            if (ExportStatusChange != null)
                ExportStatusChange(tv, EventArgs.Empty);
        }

        public TrackListViewModel TV { get { return this; } }

        public exportState ExportStatus
        {
            get
            {
                return PieceGen.ExportStatus; // exportState;
            }
            set
            {
                if (PieceGen.ExportStatus != value)
                {
                    PieceGen.ExportStatus = value;
                    OnPropertyChanged("ExportStatus");
                    OnPropertyChanged("TV");
                    refresh();
                    OnExportStatusChange(this);
                    //refresh();
                    //OnPropertyChanged("Background"); 

                }
            }
        }






        public TrackListViewModel(TrackList track, PlayListViewModel playlist)
            : base(track, playlist)
        {
            this.track = track;
            this.piece = PieceViewModel.getPiece(track); // new PieceViewModel(track); // track.Piece.Track as CPiece; 
            piece.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(piece_PropertyChanged);
            int id = track.PieceId;
            //if (!dictT.ContainsKey(id))
            //{
            //    var list = new List<TrackListViewModel>();
            //    dictT.Add(id, list);
            //}

            //dictT[id].Add(this);

        }

        void piece_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            OnPropertyChanged(e.PropertyName);
        }

        public String StrPlaying
        {
            get
            {
                if (playing) return "<))";
                return "";
            }
        }

        private bool playing;
        public bool Playing
        {
            get { return playing; }
            set
            {
                if (value != playing)
                {
                    playing = value;
                    if (playing)
                    {
                        CurrentPlaying = this;
                    }
                    OnPropertyChanged("Playing");
                    OnPropertyChanged("StrPlaying");
                }
            }
        }

        public static TrackListViewModel CurrentPlaying
        {
            get
            {
                return currentPlaying;
            }
            set
            {
                if (value != currentPlaying)
                {
                    if (currentPlaying != null)
                        currentPlaying.Playing = false;
                    currentPlaying = value;
                }
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
                //if (value != track.Rating)
                //{
                //    track.Rating = value;
                //    onPropertyChanged("Rating");
                //}
            }
        }

        //  private pdb.db.obj.CPiece CPiece { get { return track.Piece.Track as pdb.db.obj.CPiece; } }


        //public static readonly DependencyProperty ClassementProperty =
        //DependencyProperty.Register("Classement", typeof(String),
        // typeof(PieceViewModel), new UIPropertyMetadata(null));
        public String Classement
        {
            get
            {
                return piece.Piece.StrClassement;
            }
            set
            {
                // piece.StrClassement = value;
                if (value != piece.Piece.StrClassement)
                {
                    try
                    {
                        App.bib.setClassement(this, value);

                        // piece.Piece.StrClassement = value;

                    }
                    catch
                    {
                    }
                    piece.Classement = value;
                    // onPropertyChanged("Classement");
                    App.go();

                }
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
                //if (value != piece.Year)
                //{
                //    track.Year = value;
                //    onPropertyChanged("Year");
                //}
            }
        }


        //public static readonly DependencyProperty CommentProperty =
        //DependencyProperty.Register("Comment", typeof(string),
        //typeof(PieceViewModel), new UIPropertyMetadata(null)); 
        public string Comment
        {
            get
            {
                return piece.Comment; 
            }
            set
            {
                //piece.Comment = value; 
                if (value != piece.Comment)
                {
                  //  track.Comment = value;
                    piece.Comment = value; 
                    OnPropertyChanged("Comment");

                }
            }
        }

        public string Grouping
        {
            get { return piece.Grouping; }
            set
            {
                //  piece.Grouping = value;
                if (value != piece.Grouping)
                {
                    piece.Grouping = value; 
                   // track.setGrouping(value, true);
                    OnPropertyChanged("Grouping");
                }
            }
        }




        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }


        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set
            {
                piece.Duration = value;
                //if (!Exists)
                //    return; 
                //if (value != Duration)
                //{
                //    var deltaMs = Math.Abs(value.TotalMilliseconds - Duration.TotalMilliseconds);
                //    if (deltaMs >= 1)
                //    {
                //        track.Duration = value;
                //        if (deltaMs >= 1000)
                //            onPropertyChanged("Duration");
                //    }
                //}
            }
        }

        public string Location
        {
            get { return piece.Location; }
        }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
                //if (value != track.Artist)
                //{
                //    track.Artist = value;
                //    onPropertyChanged("Artist");
                //}
            }
        }

        public string Album
        {
            get
            {
                if (track.Virtual)
                    return track.Album;
                return piece.Album;
            }
            set
            {
                if (!track.Virtual)
                    piece.Album = value;
                //if (value != track.Album)
                //{
                //    track.Album = value;
                //    onPropertyChanged("Album");
                //}
            }
        }

        public string Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
                //if (value != track.Name)
                //{
                //    track.Piece.Name = value;
                //    onPropertyChanged("Name");
                //}
            }
        }

        public int TrackNumber
        {
            get
            {
                return piece.TrackNumber;
            }
            set
            {
                piece.TrackNumber = value;
                //if (value != track.TrackNumber)
                //{
                //    track.TrackNumber = value;
                //    onPropertyChanged("TrackNumber");
                //}
            }
        }


        public void setClassement(string className, int rating)
        {
            piece.Piece.setClassement(className, rating);
        }

        public string ClassName
        {
            get
            {
                return piece.Piece.ClassName;
            }
            set
            {
                piece.Piece.ClassName = value;
            }
        }


        public DateTime PlayedDate
        {
            get { return piece.Piece.PlayedDate; }
        }

        public string ArtWork
        {
            get
            {
                return piece.Piece.ArtWork;
            }
            set
            {
                piece.Piece.ArtWork = value;
            }
        }

        public void setGrouping(string value, bool prior)
        {
            piece.Piece.setGrouping(value, prior);
            piece.Grouping = value;
            // onPropertyChanged("Grouping");
        }

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.Piece.ClassPlayLists; }
        }

        public List<DateTime> Dates
        {
            get { return new List<DateTime>(piece.Piece.Dates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.Piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return track.Piece.ClassEvol; }
        }

        public long Size { get { return Piece.Size; } }

        public bool Exists { get { return Piece.Exists; } }

        //public void onPropertyChanged(string propertyName)
        //{
        //    var list = dictT[PieceId];
        //    if (list == null)
        //    {
        //        OnPropertyChanged(propertyName);
        //    }
        //    else
        //    {
        //        foreach (TrackListViewModel t in dictT[PieceId])
        //            t.OnPropertyChanged(propertyName);
        //    }
        //}




        public int PieceId
        {
            get { return track.PieceId; }
        }


        public int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }

        public void setParent(TrackListViewModel parent)
        {
            piece.Piece.Parent = parent.Piece;
            track.Piece.Parent = parent.track.Piece;
        }

        public void fusion(TrackListViewModel toDelete)
        {
            App.Db.List.fusion(piece.Piece, toDelete.Piece);

        }





        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\DataGridPlayList.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.DataGridPlayList"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="300" d:DesignWidth="300" >
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <DataGrid Grid.Row="0" Name="dg" AutoGenerateColumns="False" IsSynchronizedWithCurrentItem="False" 
                  SelectedItem="{Binding SelectedTrack, Mode=TwoWay}"               
                  >
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="{Binding Export.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding Export}" />
                    <MenuItem Header="{Binding ExportCompress.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding ExportCompress}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />



                </ContextMenu>
            </DataGrid.ContextMenu>
            
          
            <DataGrid.Columns>
                

                <DataGridTextColumn Binding="{Binding Index,Mode=OneWay}"/>
                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}"/>
                <DataGridCheckBoxColumn Header="" Binding="{Binding Enabled}" >
                    <DataGridCheckBoxColumn.ElementStyle>
                        <Style TargetType="CheckBox">
                            <Style.Triggers>
                                
                            </Style.Triggers>
                        </Style>
                    </DataGridCheckBoxColumn.ElementStyle>
                </DataGridCheckBoxColumn>
                <DataGridCheckBoxColumn Header="" Binding="{Binding Exists,Mode=OneWay}" />
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Piste"  Binding="{Binding TrackNumber,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Comment" Binding="{Binding Comment,Mode=OneWay}"/>
                <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                
               
                <DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>







            </DataGrid.Columns>
           
            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseMove" Handler="dg_PreviewMouseMove" />
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <!--<Setter Property="IsEnabled" Value="{Binding Exists}" />-->
                    <Setter Property="FontWeight" Value="Normal" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}" />
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="Foreground" Value="Brown" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exists}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                     
                    </Style.Triggers>-->                    
                </Style>
            </DataGrid.ItemContainerStyle>
            <!--<DataGrid.RowStyle>
                <Style TargetType="{x:Type DataGridRow}">
                    <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                </Style>
            </DataGrid.RowStyle>-->
        </DataGrid>
        <DockPanel Grid.Row="1" >
            <TextBlock DockPanel.Dock="Bottom" Text="{Binding Resume}"></TextBlock>
        </DockPanel>
    </Grid>

</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\DataGridPlayList.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using pdb.gen.Tuning;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.util;
using pdb.player.Vue.Util;
using System.Windows.Threading;
using System.Windows.Media;

namespace pdb.player.Vue
{
    public partial class DataGridPlayList : UserControl, ItrackProvider, IRedraw, IExportTracks
    {
        private static int nb;
        private int ID;
        private Logger log;
        private BgColorFormatConverter colorConvert = new BgColorFormatConverter();

        //  private BgDict<int, DataGridRow> dict = new BgDict<int, DataGridRow>(); 

        public DataGridPlayList()
        {
            ID = nb;
            log = Logger.getLogger("DataGridPlayList" + ID);
            nb++;
            InitializeComponent();
            this.Loaded += DataGridPlayList_Loaded;
            App.refresh += new EventHandler(App_refresh);
            PlayListCommande.Provider = this;
        }

        void App_refresh(object sender, EventArgs e)
        {
            log.log("dg::App_refresh");
            redraw();
        }

        //private void refresh()
        //{
        //    if (ID == 0)
        //    {
        //        init();
        //    }
        //}
        void DataGridPlayList_Loaded(object sender, RoutedEventArgs e)
        {
            init(null);
            PlayListViewModel.selectedPlaylistChange += PlayListViewModel_selectedPlaylistChange;
            PlayListViewModel.addDrow(this);

            //  TrackListViewModel.ExportStatusChange += tv_ExportStatusChanged; 
            ExportCmd.Ihm = this;
        }

        //void dg_RowEditEnding(object sender, DataGridRowEditEndingEventArgs e)
        //{
        //    e.Row.Background = colorConvert.getColor(sender as TrackListViewModel);
        //}


        void PlayListViewModel_selectedPlaylistChange(object sender, EventArgs e)
        {
            if (ID == 0)
            {
                init(sender as PlayListViewModel);
            }
        }

        private void init(PlayListViewModel old)
        {
            if (!Dispatcher.CheckAccess())
            {
                Dispatcher.Invoke(new Action<PlayListViewModel>(init));
                return;
            }
            log.log("dg::init");
            SortDescriptionCollection sort = null;
            ICollectionView view = null;
            if (old != null)
            {
                view = CollectionViewSource.GetDefaultView(dg.ItemsSource);
                if (view != null)
                    sort = view.SortDescriptions;
                if (sort != null)
                    old.Sort = sort;
            }


            var pl = PlayListViewModel.SelectedPlayList;
            var currentPlaying = TrackListViewModel.CurrentPlaying;
            if (pl == null)
                return;
            base.DataContext = null;

            var source = dg.ItemsSource;

            dg.ItemsSource = null;
            var items = pl.AlltracksVm;
            items.refresh();

            base.DataContext = items;
            int i = 0;
            if (pl.isSubList("gen"))
            {
            }
            else
            {
                foreach (TrackListViewModel track in items)
                {
                    i++;
                    track.Index = i;
                }
            }
            sort = pl.Sort;
            List<SortDescription> _sort = null;
            if (sort != null)
                _sort = new List<SortDescription>(sort);
            dg.ItemsSource = items;
            PlayerViewModel.Instance.set(this);
            TrackListViewModel.CurrentPlaying = currentPlaying;

            view = CollectionViewSource.GetDefaultView(dg.ItemsSource);

            if (_sort != null && _sort.Count > 0)
            {
                view.SortDescriptions.Clear();
                foreach (var _s in _sort)
                {
                    view.SortDescriptions.Add(_s);
                    foreach (DataGridColumn _c in dg.Columns)
                    {
                        if (_s.PropertyName == _c.SortMemberPath)
                        {
                            _c.SortDirection = _s.Direction;
                            break;
                        }
                    }
                    break;

                }
            }

            //foreach (TrackListViewModel tv in items)
            //    tv.PropertyChanged += new PropertyChangedEventHandler(tv_PropertyChanged);

            putExportTracks(pl, CollectionViewSource.GetDefaultView(dg.ItemsSource));

        }

        //void tv_PropertyChanged(object sender, PropertyChangedEventArgs e)
        //{
        //    if (e.PropertyName == "ExportStatus")
        //        updateColor(sender as TrackListViewModel); 
        //}

        //void updateColor(TrackListViewModel tv)
        //{
        //    if (tv == null)
        //        return; 
        //      var row = dg.ItemContainerGenerator.ContainerFromItem(tv) as DataGridRow;
        //      if (row != null)
        //          row.Background = colorConvert.getColor(tv); 
        //}

        //void tv_ExportStatusChanged(object sender, EventArgs e)
        //{          
        //        Dispatcher.BeginInvoke(DispatcherPriority.Background, new Action<TrackListViewModel>(updateColor), sender as TrackListViewModel);

        //}
        private void dg_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            try
            {
                var r = sender as DataGridRow;
                var t = r.Item as TrackListViewModel;
                PlayerViewModel.reset(this, t);
            }
            catch
            {
            }
        }

        private void dg_MouseClick(object sender, MouseButtonEventArgs e)
        {
            var r = sender as DataGridRow;
            var t = r.Item as TrackListViewModel;
            var l = new List<TrackListViewModel>();
            foreach (TrackListViewModel track in dg.SelectedItems)
                l.Add(track);
            lock (this)
                selectedTracks = l;
            TrackListViewModel.HumanSelected = t;
            startPoint = e.GetPosition(null);
        }

        private List<TrackListViewModel> selectedTracks = new List<TrackListViewModel>();

        private List<TrackListViewModel> SelectedTracks
        {
            get
            {
                lock (this)
                    return selectedTracks;
            }
        }
        ICollectionView ItrackProvider.PresentationTracks
        {
            get { return CollectionViewSource.GetDefaultView(dg.ItemsSource); }
        }
        void ItrackProvider.Focus(int index)
        {

            // dg.SelectedIndex = index;
            var indexbas = Math.Min(index + 100, dg.Items.Count - 1);
            scrol(indexbas);
            scrol(index);
        }

        List<TrackListViewModel> ISelectedTracks.SelectedTracks
        {
            get
            {
                return SelectedTracks;
            }
        }
        void scrol(int index)
        {
            if (!CheckAccess())
            {
                Dispatcher.Invoke(new Action<int>(this.scrol), index);
            }
            else
                dg.ScrollIntoView(dg.Items[index]);
        }
        public PlayListViewModel PlayList
        {
            get { return PlayListViewModel.SelectedPlayList; }
        }
        public void doFilter(string filter)
        {
            PlayerViewModel.doFilter((this as ItrackProvider).PresentationTracks, filter);
        }
        private bool IsUserVisible(FrameworkElement element, FrameworkElement container)
        {
            if (!element.IsVisible)
                return false;
            Rect bounds = element.TransformToAncestor(container).TransformBounds(new Rect(0.0, 0.0, element.ActualWidth, element.ActualHeight));
            Rect rect = new Rect(0.0, 0.0, container.ActualWidth, container.ActualHeight);
            return rect.Contains(bounds.TopLeft) || rect.Contains(bounds.BottomRight);
        }

        private static T FindVisualParent<T>(UIElement element) where T : UIElement
        {
            var parent = element;
            while (parent != null)
            {
                var correctlyTyped = parent as T;
                if (correctlyTyped != null)
                {
                    return correctlyTyped;
                }

                parent = VisualTreeHelper.GetParent(parent) as UIElement;
            }
            return null;
        }

        public void redraw()
        {
            if (!CheckAccess())
            {
                Dispatcher.BeginInvoke(new Action(this.redraw), DispatcherPriority.DataBind);
                return;
            }
            var pl = PlayListViewModel.SelectedPlayList;
          
            bool isgen = false;
            if (pl != null && pl.isSubList("gen"))
                isgen = true;

            var items = dg.ItemsSource as AllTracksViewModel;

            if (items == null)
            {
                dg.Items.Refresh();
            }
            else
            {
                ICollectionView view = CollectionViewSource.GetDefaultView(dg.ItemsSource);
                SortDescriptionCollection sort = view.SortDescriptions;

                List<SortDescription> _sort = null;
                if (sort != null)
                    _sort = new List<SortDescription>(sort);

                int i = 0;
                foreach (TrackListViewModel track in items)
                {
                    i++;
                    if (!isgen)
                        track.Index = i;
                  //  track.refresh();
                }


                if (_sort != null && _sort.Count > 0 && view.SortDescriptions.Count > 0)
                {
                    view.SortDescriptions.Clear();
                    foreach (var _s in _sort)
                    {
                        view.SortDescriptions.Add(_s);
                    }
                }
                items.refresh(); 
                putExportTracks(pl, view);
            }
            return;


            try
            {
                isgen = false;

                if (isgen)
                {
                    log.log("dg::redraw::init");
                    init(pl);
                }
                else
                {
                    log.log("dg::redraw::Refresh");
                    dg.Items.Refresh();
                }
            }
            catch
            {
                try
                {
                    init(pl);
                }
                catch
                {
                }
            }

        }

        private void MenuItem_Click(object sender, RoutedEventArgs e)
        {
            var items = dg.SelectedItems;
            MessageBox.Show(items.Count.ToString());
        }

        public string folderDialog()
        {
            return App.Instance.folderDialog();
        }


        public System.ComponentModel.ICollectionView PresentationTracks
        {
            get
            {
                return ((ItrackProvider)this).PresentationTracks;
            }
        }






        public bool ModeAlbum
        {
            get { return MessageBox.Show("par albums complets", "export", MessageBoxButton.YesNo) == MessageBoxResult.Yes; }
        }

        public bool Continue
        {
            get { return MessageBox.Show("continuer le marché ?", "export", MessageBoxButton.YesNo) == MessageBoxResult.Yes; }
        }




        public void InfoIHm(string message, string caption)
        {
            App.Instance.InfoIHm(message, caption);
        }

        public bool Confirm(string question, string caption)
        {
            return App.Instance.Confirm(question, caption);
        }

        public bool? TriChoix(string question, string caption)
        {
            return App.Instance.TriChoix(question, caption);
        }

        public Export getConfExport(string question)
        {
            return App.Instance.getConfExport(question);
        }

        public Import getConfImport(string question)
        {
            return App.Instance.getConfImport(question);
        }

        public int getNb(string question)
        {
            return App.Instance.getNb(question);
        }

        public bool changeName(string title, IName data)
        {
            return App.Instance.changeName(title, data);
        }

        public PlayListViewModel selectPlayList(string title)
        {
            return App.Instance.selectPlayList(title);
        }



        //  private List<TrackListViewModel> list = new List<TrackListViewModel>(); 
        public List<TrackListViewModel> ListTrack
        {
            get { return null; }
        }

        private void putExportTracks(PlayListViewModel pl, ICollectionView view)
        {
            var list = new List<TrackListViewModel>();
            foreach (TrackListViewModel track in view)
                list.Add(track);
            pl.ExportTracks = list;
            visibleItems = new List<TrackListViewModel>();

            foreach (var item in view)
            {
                var row = dg.ItemContainerGenerator.ContainerFromItem(item) as DataGridRow;
                if (row != null)
                {
                    visibleItems.Add(item as TrackListViewModel); 
                }
            }


        }
        private List<TrackListViewModel> visibleItems = new List<TrackListViewModel>();
        public List<TrackListViewModel> VisibleItems { get { return new List<TrackListViewModel>(visibleItems); } }

        Point startPoint;
        private void dg_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            startPoint = e.GetPosition(null);
        }

        private void dg_PreviewMouseMove(object sender, MouseEventArgs e)
        {
            var mousePos = e.GetPosition(null);
            var diff = startPoint - mousePos;

            if (Math.Abs(diff.X) > SystemParameters.MinimumHorizontalDragDistance
                || Math.Abs(diff.Y) > SystemParameters.MinimumVerticalDragDistance)
            {
                var treeView = sender as DataGrid;
                var treeViewItem = //(e.OriginalSource as DependencyObject).
                    Util.Util<DataGridRow>.FindAnchestor((DependencyObject)e.OriginalSource);
                //   FindAnchestor<TreeViewItem>((DependencyObject)e.OriginalSource);

                if (treeView == null || treeViewItem == null)
                    return;

                var folderViewModel = treeView.SelectedItem as TrackListViewModel;
                if (folderViewModel == null)
                    return;

                var dragData = new DataObject(folderViewModel);
                DragDrop.DoDragDrop(treeViewItem, dragData, DragDropEffects.Copy);
            }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;
using pdb.gen.Virtuel;

namespace pdb.gen
{
    /// <summary>
    /// G�re l'application propri�taire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des donn�es consolid�es morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        private List<Piece> allClassedInAlbumEnabled = new List<Piece>();
        /// <summary>
        /// Liste des donn�es morceux dupliqu�s 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        private Albums albums; // = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private volatile object _lock = new object();
        private bool _consolidEnCours;


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private CPlayList root = new CPlayList("root", null, creator);
        public CPlayList Root { get { return root; } }
        private CPlayList musique;
        private CPlayList classement;
        private CPlayList listes;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new CPlayList("musique", root, creator);
            classement = new CPlayList("classement", root, creator);
            listes = new CPlayList("listes", root, creator);
        }

        private void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating;
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        public void buildClassTree()
        {
            buildClassTree(classement);
        }


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }
        private bool _fisrtConsolid;
        public Albums Albums { get { return albums; } }
        public void MakeConsolid(IEnumerable<ITrackNativeDates> dbList)
        {
            try
            {
                waitForConsolid();
                listPiece = new List<Piece>();
                listPieceInAlbum = new List<Piece>();
                var auxlistPieceInAlbum = new List<Piece>();
                albums = new Albums(this);
                VirtualPiece.init();
                m_listTrackClassed = new List<Piece>();
                allClassed = new List<Piece>();
                allClassedInAlbumEnabled = new List<Piece>();
              //  htIds = new BgDict<int, Piece>();
                foreach (ITrackNativeDates track in dbList)
                {

                    if (!track.isPodcast)
                    {
                        Piece piece = null;
                        int pieceId = track.PieceId;
                        if (htIds.ContainsKey(pieceId))
                        {
                            piece = htIds[pieceId];
                            piece.initRank(); 
                        }
                        else
                        {
                            piece = new Piece(track);
                            htIds.Add(pieceId, piece);
                        }
                       
                        auxlistPieceInAlbum.Add(piece);
                       
                    }
                }
                // link
                foreach (Piece piece in auxlistPieceInAlbum)
                {
                    int parentId = piece.PieceParentId;
                    if (parentId > 0)
                    {
                        piece.Parent = htIds[parentId];
                    }
                }

                // liste FORT + albums

                foreach (Piece piece in auxlistPieceInAlbum)
                {
                    if (piece.Parent == null)
                    {
                        listPiece.Add(piece);
                        listPieceInAlbum.Add(piece);
                        foreach (Piece child in piece.Childs)
                            listPieceInAlbum.Add(child);
                        if (_albumVirtual)
                            piece.buildVirtualAlbums(listPieceInAlbum);
                        albums.check(piece);
                    }
                }

                foreach (Piece piece in listPieceInAlbum)
                {
                    if (!string.IsNullOrEmpty(piece.ClassName))
                    {
                        allClassed.Add(piece);
                        if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                            allClassedInAlbumEnabled.Add(piece);
                    }
                }

                albums.sortVirtual();
                Ranking();
            }
            finally
            {
                lock (_lock)
                {
                    _fisrtConsolid = true;
                    _consolidEnCours = false;
                }
            }

        }

        public void buildMusique()
        {
            foreach (Piece piece in listPieceInAlbum)
            {
                musique.addObj(piece);
            }

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.Tracks;
                tracks.Sort(new PieceTrackNumberComparer());
                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }

        }

        public void buildLists(CPlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(CPlayList mine, CPlayList ext)
        {
            foreach (PlComponent c in ext)
            {
                if (c is CPlayList)
                {
                    var subExt = c as CPlayList;
                    var sub = new CPlayList(subExt.Name, mine);
                    sub.ID = subExt.ID;
                    // mine.add(sub);
                    buildList(sub, subExt);
                }
                else
                {
                    var t = c as IFile;
                    var piece = htIds[t.PieceId];
                    mine.add(new TrackList(piece));
                }
            }
        }

        internal Album getAlbum(TrackList track)
        {
            return albums.getAlbum(track);
        }

        public List<Piece> getTracksAlbum(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.Tracks;
        }

        public List<Piece> getTracksAlbumByNumber(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackByNumber;
        }

        //public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        //{
        //    var album = getAlbum(track);
        //    if (album == null)
        //        return;
        //    foreach (var p in album.Tracks)
        //    {
        //        container.Add(p);
        //    }
        //}

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPieceInAlbum);
                list.Sort(new AllPieceComparer2());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking()
        {
            QRanking();
            LRanking();
            QLRanking();

            misc.log("setTuningDateValues");
            var list = new List<Piece>(listPiece);
            foreach (Piece piece in list)
            {
                piece.FirstClass = false;
                CRank rank = piece.Rank;
                var sortValue = CTuning.Calc(rank, CConf.Sort);
                rank.SortValue = sortValue;

                ListSelection.setTuningDateValues(piece);
            }

            misc.log("PieceRestComparer->RankRest ");
            list.Sort(new PieceRestComparer());

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            list.Sort(new PieceDeltaComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankDelta = i + 1;
            }

            misc.log("PieceSortComparer->Sort ");
            list.Sort(new PieceSortComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            misc.log("AlbumsSort ");
            var all = new List<Piece>(listPieceInAlbum);

            albums.makeSort();
            misc.log("AllPieceComparer->RankAllAlbum ");
            all.Sort(new AllPieceComparer());
            for (int i = 0; i < all.Count; i++)
            {
                all[i].RankAllAlbum = i + 1;
            }

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackNativeDates> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackNativeDates track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux not�s
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.ClassementValueDecimal);
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                misc.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                misc.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        misc.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating);
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                misc.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    misc.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    misc.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    misc.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    misc.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                misc.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                misc.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    misc.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                misc.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            misc.log("Qranking");



            CPieceComparerByGoodness l_pieceComparer = new CPieceComparerByGoodness();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }


            //on ordonne les morceaux top-down => sont privil�gi�s les plus en vue
            listPiece.Sort(l_pieceComparer);

            //compactage de la liste en tenant compte des mieux not�s
            m_list = new CListPiece(listPiece);

            misc.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.ClassName != "")
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            misc.log("Qranking:track classed :" + m_listTrackClassed.Count);
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }

            Console.WriteLine("Qranking:total class�s : " + m_listTrackClassed.Count);

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                    break;
            }
            return Convert.ToInt32(qRank);
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur longueur
        /// </summary>
        /// <remarks></remarks>
        private void LRanking()
        {
            misc.log("LRanking");
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByLenght());
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.LRank = l_iIndex + 1;
            }
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur qualit� +longueur en cas d'�galit�
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            misc.log("QLRanking");
            m_listQL = new List<Piece>(m_listTrackClassed);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByQualityAndLength());
            int count = l_aux.Count;
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.QLRank = l_iIndex + 1;
            }

            l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.Rank.TwiceInv = l_iIndex + 1;
            }

            if (CConf.Condensation)
            {
                var l = new List<Piece>(this.listPiece);
                l.Sort(new CPieceComparerByQualityAndLength2());
                new Condenseur(m_listQL).gener2();

            }

        }

        public void builStats()
        {
            try
            {
                bool generDistrib = step % 10 == 0;
                new StatBuilder(m_listQL).gener3(generDistrib);
                var stat = new StatBuilder(m_listQL) { Loupe = 1 };
                stat.gener4("stats4.txt");
                stat = new StatBuilder(m_listQL) { Loupe = 2 };
                stat.gener4("stats4.txt");
                stat = new StatBuilder(m_listQL) { Loupe = 3 };
                stat.gener4("stats4.txt");
                var unselected = m_listQL.FindAll(t => !t.Enabled);
                new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
                stat = new StatBuilder(unselected) { Loupe = 1 };
                stat.gener4("courant4.txt");
                stat = new StatBuilder(unselected) { Loupe = 2 };
                stat.gener4("courant4.txt");
                stat = new StatBuilder(unselected) { Loupe = 3 };
                stat.gener4("courant4.txt");

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }


        public DynamicStat generStat(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            return new DynamicStatBuilder(list).gener(className);
        }



        public void timeRanking()
        {
            misc.log("timeRanking");
            foreach (var piece in allClassed)
                ListSelection.setTuningDateValues(piece);


        }

        /// <summary>
        /// redirection des index metier de la table m�tier vers la table locale
        /// Copie des valeurs pertinentes(classlist)
        /// </summary>
        /// <remarks></remarks>
        public void eraseGrouping()
        {
            thCommentGo = false;
            thGroupingGo = false;
            misc.log("eraseGrouping");
            foreach (Piece piece in listPieceInAlbum)
            {
                piece.setGrouping("", false);
                piece.Comment = "";
            }
        }
        public void writeGrouping()
        {
            misc.log("writeGrouping");
            var list = new List<Piece>(listPieceInAlbum);
            // list.Sort(new CPieceComparerByQualityAndLength());
            list.Sort(new AllPieceComparer2());

            var writeGrouping = CConf.ConfGen.WriteGrouping;
            foreach (Piece piece in list)
            {
                try
                {
                    piece.writeGrouping(writeGrouping);
                }
                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }

            }
        }


        private bool thGroupingGo;
        private bool thCommentGo;

        public bool GroupinGO
        {
            set
            {
                thGroupingGo = value;
                if (value)
                {
                }
            }
        }
        public bool CommentGo
        {
            set
            {
                thCommentGo = value;
                if (value)
                {
                }
            }
        }



        private void writeGroupingAsync()
        {
            var writeGrouping = CConf.ConfGen.WriteGrouping;
            foreach (Piece piece in listPieceInAlbum)
            {
                try
                {
                    if (!thGroupingGo)
                        return;
                    piece.writeGrouping(writeGrouping);
                }
                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }

            }
        }

        private void writeCommentAsync()
        {
            var writeComment = CConf.ConfGen.WriteComment;
            foreach (Piece piece in listPiece)
            {
                try
                {
                    if (!thCommentGo)
                        return;
                    piece.writeComment(writeComment);
                }
                catch (Exception ex)
                {
                    misc.log("writeComment::" + ex.ToString());
                }
            }
        }

        public void writeGrouping(Piece piece)
        {
            var writeGrouping = CConf.ConfGen.WriteGrouping;
            piece.writeGrouping(writeGrouping);

        }
        private bool _sortByAlbum = true;
        public bool SortByAlbum { set { _sortByAlbum = value; } }

        private albumSortMode _albumSortMode = CConf.ConfGen.AlbumSortMode;
        public albumSortMode SortAlbumMode { set { _albumSortMode = value; } get { return _albumSortMode; } }
        private bool _albumVirtual = CConf.ConfGen.AlbumVirtual;
        public bool AlbumVirtual { get { return _albumVirtual; } set { _albumVirtual = value; } }

        public void writeComment()
        {
            misc.log("writeComment");
            var list = new List<Piece>(listPiece);
            list.Sort(new CPieceComparerByQualityAndLength());

            var writeComment = CConf.ConfGen.WriteComment;
            foreach (Piece piece in list)
            {
                try
                {
                    piece.writeComment(writeComment);
                }
                catch (Exception ex)
                {
                    misc.log("writeComment::" + ex.ToString());
                }
            }




        }

        public void writeComment(Piece piece)
        {
            var writeComment = CConf.ConfGen.WriteComment;
            try
            {
                piece.writeComment(writeComment);
            }
            catch (Exception ex)
            {
                misc.log("writeComment::" + ex.ToString());
            }
        }



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public void createRot(string a_baseName, params IListWriter[] writers)
        {
            var conf = CConf.ConfGen;

            misc.log("Clegacy:createRot {0}", a_baseName);
            List<Piece> l_list = new List<Piece>();
            List<Piece> source = null;
            if (_sortByAlbum)
                source = allClassedInAlbumEnabled;
            else
                source = m_listTrackClassed;
            foreach (Piece l_piece in source)
            {
                //if (l_piece.belongsTo(a_baseName))
                //{
                l_list.Add(l_piece);
                // }
            }
            m_listWriter = new CLegacyListWriter(l_list, _sortByAlbum);

            l_list = new List<Piece>();
            foreach (Piece piece in listPieceInAlbum)
                l_list.Add(piece);

            listWriterAll = new CLegacyListWriter(l_list, _sortByAlbum);


            foreach (IListWriter writer in writers)
                m_listWriter.addWriter(writer);

            foreach (IListWriter writer in writers)
                listWriterAll.addWriter(writer);

            //      m_listWriter.reset();
            foreach (var duration in conf.Listes)
            {


                foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                {

                    foreach (Piece piece in allClassed)
                        ListSelection.setTuningDateValues(piece, mode.item);

                    m_listWriter.writeGen(mode, duration, "g", false);
                    m_listWriter.writeGen(mode, duration, "e", true);
                }
            }

            if (conf.GenCheck)
                m_listWriter.writeCheckClassement(0);

            for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
            {
                m_listWriter.writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
            }


            foreach (var duration in conf.Listes)
            {

                foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                {

                    foreach (Piece piece in allClassed)
                        ListSelection.setTuningDateValues(piece, mode.item);

                    m_listWriter.writeGen(albums, mode, duration, "g", false);
                }
            }

            listWriterAll.writeGen(albums, null, null, "all", false);

            return;

            writeRot(1);

            m_listWriter.writeCheckClassement(1);

            m_listWriter.reset();
            writeRotMin(-1);
            writeRotMin(10);
            writeRotMin(1);
        }
        private void writeRotMin(int a_nbHour)
        {
            misc.log("----------------------");
            m_listWriter.writeRotMin(a_nbHour);
        }
        private void writeRot(int a_base)
        {
            m_listWriter.writeRot(a_base);

        }
        #endregion
    }
}



]]></content>
  </file>
  <file path="\PieceDb.Consolid\Piece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;

namespace pdb.gen
{

    /// <summary>
    /// Ajout de données utiles Ranq
    /// </summary>
    public class Piece : ITrackMetaData, IFile, ITrackNativeDates
    {
        private ITrackNativeDates track;
        public bool Virtual { get { return PieceId < 0; } }
        // private String className = "";
        private static CultureInfo en = new CultureInfo("en-US");
        //  private static List<displayCategory> minCategories;

        protected static Consolid gen;
        public static Consolid Gen { set { gen = value; } }

        static Piece()
        {
            //   minCategories = new List<displayCategory> { displayCategory.rankTime, displayCategory.timeValue, displayCategory.dates, displayCategory.pertinentDates };
        }

        public ITrackNativeDates Track { get { return track; } }

        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank
        {
            get
            {
                if (parent == null)
                    return m_rank;
                return parent.m_rank;
            }
        }

        public void initRank()
        {
            _rapportClassement = -1;
            Rank.init();
        }

        public int QRank
        {
            get { return Rank.Quality; }
            set { Rank.Quality = value; }
        }

        public int LRank
        {
            get { return Rank.Lenght; }
            set { Rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return Rank.Twice; }
            set { Rank.Twice = value; }
        }

        public int RankAllAlbum
        {
            get { return m_rank.RankAllAlbum; }
            set { m_rank.RankAllAlbum = value; }
        }

        //  public TuningData TuningData { get { return m_rank.Rest; } set { m_rank.Rest = value; } }
        #endregion



        public bool FirstClass { get { return track.FirstClass; } set { track.FirstClass = value; } }
        private Album album;

        internal Album PieceAlbum { get { return album; } set { album = value; } }
        private static int _sID = 0;
        private int _dID;
        internal Piece(ITrackNativeDates track)
        {
            _sID++;
            _dID = _sID;
            this.track = track; initRank();

#if VOL
            int volumeMin = CConf.VolumeMin;
            if (Volume < volumeMin)
                Volume = volumeMin;
#endif
        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList()
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        public String ClassName { get { return track.ClassName; } set { track.ClassName = value; } }

        public void setClassement(string className, int rating)
        {
            if (className == null)
                return;
            track.setClassement(className, rating);
        }

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in track.PLayLists)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        #region CPieceComparer compatibilité
        public List<CPlayList> ClassPlayLists
        {
            get { return track.ClassPlayLists; }
        }
        /// <summary>
        /// ClassList principale
        /// </summary>
        public CPlayList ClassPlayList
        {
            get
            {
                List<CPlayList> classLists = track.ClassPlayLists;
                if (classLists.Count > 0)
                    return classLists[0];
                return null;
            }
        }


        public int RatingCmp
        {
            get
            {
                int rating = track.Rating;
                if (rating < 0)
                    return 0;
                return rating;
            }
        }
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return ClassName.isInteger();
            }
        }

        public String ClassNameAndRating
        {
            get
            {
                if (!isClassListNumeric) return "";
                return ClassName + ((track.Rating / 20).ToString());
            }
        }

        public decimal ClassementValueDecimal
        {
            get
            {
                if (!isClassListNumeric) return 0;
                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
                return Convert.ToDecimal(classNameAndRating);
            }
        }
        //private double _classementValue = -1; 
        //public double ClassementValue
        //{
        //    get
        //    {
        //        if (_classementValue == -1)
        //        {
        //            if (!isClassListNumeric)
        //                _classementValue = 0;
        //            else
        //            {
        //                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
        //                _classementValue= Convert.ToDouble(classNameAndRating);
        //            }
        //        }

        //        return _classementValue; 
        //    }
        //}

        private decimal _rapportClassement = -1;
        public decimal RapportClassement
        {
            get
            {
                if (_rapportClassement != -1)
                    return _rapportClassement;

                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                _rapportClassement = resultat;
                return _rapportClassement;
            }
        }
        static int NB_DEC = 4;
        public static string getReadableCl(string str)
        {
            int count = str.Length;
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {
                        if (i >= NB_DEC)
                        {
                            i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();
        }

        public static string getClassementEquiv(decimal valRapport)
        {
            if (valRapport == 0m)
                return "0";
            decimal v = 0;
            decimal r = valRapport;
            StringBuilder sb = new StringBuilder();
            int _ok = Int16.MaxValue;

            for (int i = 0; i < 13; i++)
            {
                v = 6 * r;
                int a = (int)(v + 0.01m);
                if (a > 0 && i < _ok)
                {
                    _ok = i;
                }
                r = v - a;
                if (r < 0)
                    r = 0;
                sb.Append(a);


                if (i >= _ok + 4)
                    break;
            }
            var str = sb.ToString();
            str = str.Insert(str.Length - 1, ".");
            return getReadableCl(str);
        }




        public decimal RapportClassementDecimal
        {
            get
            {
                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1m;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                return resultat;
            }
        }

        public int classPrecision()
        {
            string classNameAndRating = ClassNameAndRating;
            int precision = 0;
            char[] tab = classNameAndRating.ToCharArray();
            int count = tab.GetLength(0);

            int iIndexDepart = -1;
            int iIndexFin = -1;
            for (int i = 0; i < count; i++)
            {
                Char c = tab[i];
                if (iIndexDepart < 0)
                {
                    if (c != '0')
                        iIndexDepart = i;
                }

                if (c != '0')
                    iIndexFin = i;
            }

            precision = iIndexFin - iIndexDepart + 1;

            return precision;
        }
        #endregion

        #region compatibilité CList
        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        public bool checkIdentity(ITrackIdentity other)
        {
            //return track.Location == other.Location; 
            String location = track.Location;
            return (location.Equals((other.Location)) || CUtil.DefinedEquals(track.Artist, track.Album, track.Name, track.TrackNumber, other.Artist, other.Album, other.Name, other.TrackNumber));
        }
        #endregion

        #region ITrackNative Membres

        public string Artist
        {
            get
            {
                return track.Artist;
            }
            set
            {
                if (track.Artist != value)
                {
                    try
                    {
                        //                 misc.log("change artist from '{0}' to'{1}'", track.Artist, value);
                        track.Artist = value;
                    }
                    catch { misc.log("unable to change artist {0}  {1}", track.Artist, value); }
                }
            }
        }

        public virtual string Album
        {
            get
            {
                return track.Album;
            }
            set
            {
                if (track.Album != value)
                {
                    try
                    {
                        //                   misc.log("change Album from '{0}' to'{1}'", track.Album, value);
                        track.Album = value;
                    }
                    catch { misc.log("unable to change album {0}  {1}", track.Album, value); }
                }
            }
        }

        public string Name
        {
            get
            {
                return track.Name;
            }
            set
            {
                if (track.Name != value)
                {
                    try
                    {
                        //                 misc.log("change Name from '{0}' to'{1}'", track.Name, value);
                        track.Name = value;
                    }
                    catch { misc.log("unable to change name {0}  {1}", track.Name, value); }
                }
            }
        }

        public virtual int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (track.TrackNumber != value)
                {
                    try
                    {
                        //              misc.log("change TrackNumber from '{0}' to'{1}'", track.TrackNumber, value);
                        track.TrackNumber = value;
                    }
                    catch { misc.log("unable to change TrackNumber {0}  {1}", track.TrackNumber, value); }
                }
            }
        }

        public int Rating
        {
            get
            {
                return track.Rating;
            }
            set
            {
                if (track.Rating != value)
                {
                    try
                    {
                        //                misc.log("change Rating from '{0}' to'{1}'", track.Rating, value);
                        track.Rating = value;
                    }
                    catch { misc.log("unable to change Rating {0}  {1}", track.Rating, value); }
                }
            }
        }

        public int Year
        {
            get
            {
                return track.Year;
            }
            set
            {
                if (track.Year != value)
                {
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Year = value;
                    }
                    catch { misc.log("unable to change Year {0}  {1}", track.Year, value); }
                }
            }
        }

#if VOL
        public int Volume
        {
            get
            {
                int volumeMin = CConf.VolumeMin;
                int trackVolume = track.Volume;
                if (trackVolume < volumeMin)
                {
                    Volume = volumeMin;
                }
                return trackVolume;
            }
            set
            {
                if (track.Volume != value)
                {
                    int volumeMin = CConf.VolumeMin;
                    int _value = Math.Max(value, volumeMin);
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Volume = _value;
                    }
                    catch { misc.log("unable to change Volume {0}  {1}", track.Volume, _value); }
                }
            }
        }
#endif

        public string Comment
        {
            get
            {
                //if (string.IsNullOrEmpty(track.Comment))
                //    gen.writeComment(this);
                return track.Comment;
            }
            set
            {
                //if (track.Comment != value)
                //{
                try
                {
                    //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
                    track.Comment = value;
                }
                catch { misc.log("unable to change Comment {0}  {1}", track.Comment, value); }
                //}
            }
        }

        public virtual string Grouping
        {
            get
            {
                if (string.IsNullOrEmpty(track.Grouping))
                {
                    gen.writeGrouping(this);
                }
                return track.Grouping;
            }
            //set
            //{
            //    //if (track.Grouping != value)
            //    //{
            //        try
            //        {
            //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
            //            track.Grouping = value;
            //        }
            //        catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
            //    //}
            //}

        }





        public virtual void setGrouping(string value, bool prior)
        {
            try
            {
                //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
                track.setGrouping(value, prior);
            }
            catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        }

        public bool Enabled
        {
            get
            {
                return track.Enabled;
            }
            set
            {
                if (track.Enabled != value)
                {
                    try
                    {
                        //      misc.log("change Enabled from '{0}' to'{1}'", track.Enabled, value);
                        track.Enabled = value;
                    }
                    catch { misc.log("unable to change Enabled {0}  {1}", track.Enabled, value); }
                }
            }
        }

        public bool isPodcast
        {
            get { return track.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return track.PlayedDate; }
        }

        public string Location
        {
            get { return track.Location; }
        }

        public TimeSpan Duration
        {
            get { return track.Duration; }
            set { track.Duration = value; }
        }

        #endregion

        public List<DateTime> Dates
        {
            get { return track.Dates; }
        }
        public string ArtWork
        {
            get { return track.ArtWork; }
            set { track.ArtWork = value; }
        }

        public List<DateTime> DatesClassement { get { return track.DatesClassement; } }

        public String ClassEvol { get { return track.ClassEvol; } }


        public void writeCommentGrouping()
        {
            var mode = CConf.ConfGen.WriteComment;
            writeComment(mode);
            var modeg = CConf.ConfGen.WriteGrouping;
            writeGrouping(modeg);

        }

        //public List<CPlayList> PLayLists
        //{
        //    get { return track.PLayLists; }
        //}

        /// <summary>
        /// Calculer le commentaire
        /// </summary>
        public void writeComment(writeGrouping mode)
        {
            if (parent != null)
                return;
            if (mode == Tuning.writeGrouping.none)
                return;


            if (mode == Tuning.writeGrouping.mix)
            {
                StringBuilder sbEnd = new StringBuilder();

                sbEnd.Append(ClassName);
                sbEnd.Append(".");
                sbEnd.Append((RatingCmp / 20).ToString());
                sbEnd.Append(ClassEvol);
                string strEnd = sbEnd.ToString();
                string found = "";

                string[] tab = Comment.Split(' ');
                int count = tab.GetLength(0);
                if (count > 0)
                {
                    found = tab[count - 1];
                    if (found.Equals(strEnd))
                        return;
                }
                writeComment(Tuning.writeGrouping.all);
            }

            StringBuilder sb = new StringBuilder();
            //string l_pref = "";
            //string l_str = "";

            string l_strList = ClassName;
            //if (ClassPlayList != null)
            //    l_strList = ClassName;

            ////if (m_classement.Imported)
            ////{
            //if (l_strList != ClassName)
            //{
            //    sb.Append("m (");
            //    sb.Append(ClassName);
            //    sb.Append(") "); 
            //  //  l_pref = "m (" + ClassName + ") ";
            //}
            ////}
            int l_rank = Rank.Twice;

            if (l_rank > 0)
            {
                CTuning.format(sb, l_rank);
                sb.Append(" ");
                //    if (l_rank < 1000)
                //    {
                //        if (CTuning.Total > 1000)
                //        {
                //            l_str += "0";
                //        }
                //        if (l_rank < 100)
                //        {
                //            l_str += "0";
                //            if (l_rank < 10)
                //            {
                //                l_str += "0";
                //            }
                //        }
                //    }


                var r = CTuning.Rapport(Rank.Quality);






                var quality = CConf.Select.Quality;
                //if (quality.Mode != listMode.substract || quality.Exp != 1 || quality.Offset != 0 || CConf.Select.TimePriority != 0)
                //{
                double tx0 = Convert.ToInt32(1000 * r);
                sb.Append(tx0.ToString());
                sb.Append(" ");
                //}

                //  double l_tx = Convert.ToInt32(1000 * CTuning.Calc(m_rank, CConf.Select)); //   RapportNorm(m_rank.Quality, CConf.Sort.Quality));
                var l_tx = CConf.ConfGen.Vie.TotalDays() / CTuning.Calc(m_rank, CConf.Select);
                //  double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
                //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
                //getTx(m_rank.Lenght)
                //     l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();


                sb.Append(l_tx.FormatCustom(3, 4)); //   ToString("G2", en));
                //if (l_tx < 100 || l_tx >= 1000)
                //    sb.Append(l_tx.ToString("G2", en));
                //else
                //    sb.Append(Convert.ToInt64(l_tx).ToString("D", en)); 



                sb.Append(" ");
                var rest = r;

                for (int i = 0; i < 4; i++)
                {
                    var ee = rest * 6.0m;
                    int e = (int)System.Math.Floor(ee);
                    rest = ee - e;
                    sb.Append(e);
                }



                sb.Append(" ");


                //sb.Append(l_tx2.ToString());
                //sb.Append(" ");
                //sb.Append((100 * m_rank.SortValue).ToString("0"));
                //sb.Append(" ");

                //sb.Append(Dates.Count.ToString()); sb.Append(" ");

                //sb.Append(DatesClassement.Count.ToString()); sb.Append(" ");

                //sb.Append(ListSelection.buildListReadOrClassementModified(this).Count.ToString()); sb.Append(" ");

                //   sb.Append((100 * m_rank.TimeRest).ToString("0")); sb.Append(" ");



                sb.Append(l_strList);
                sb.Append(".");
                sb.Append((RatingCmp / 20).ToString());

            }

            sb.Append(ClassEvol);



            Comment = sb.ToString();
            //Comment = l_pref + l_str + ClassEvol;
        }

        public override string ToString()
        {
            return track.ToString();
        }

        public override bool Equals(object obj)
        {
            Piece p = obj as Piece;
            if (p == null)
                return false;
            return PieceId.Equals(p.PieceId);


        }

        public override int GetHashCode()
        {
            return PieceId.GetHashCode();
        }

        private bool haveToUpdateGrouping = false;
        public void MarkAsUpdateGrouping() { haveToUpdateGrouping = true; }

        public void writeGrouping(writeGrouping writeGrouping)
        {
            var cat = CConf.ConfGen.DisplayCategories;
            //if (!CConf.ConfGen.WithOrder)
            //    cat = minCategories; 
            if (writeGrouping == Tuning.writeGrouping.none)
                return;

            //if (m_rank.Twice <= 0)
            //    return;
            if (haveToUpdateGrouping)
            {
                setGrouping(getGroup(cat), true);
            }

            else if (writeGrouping == Tuning.writeGrouping.mix)
            {
                bool haveToUpdate = false;
                string org = Grouping;
                if (org != null)
                {
                    string[] data = org.Split(' ');

                    try
                    {
                        foreach (datesMode mode in Enum.GetValues(typeof(datesMode))) //  CConf.ConfGen.Modes) //  Enum.GetValues(typeof(datesMode)))
                        {
                            DisplayGrouping found = cat.Find(c => (int)c.category == (int)mode);
                            //displayCategory found = cat.Find(c => (int)c == (int)mode);
                            if (found != null)
                            {
                                int indexOfTime = cat.IndexOf(found);

                                string timeValue = data[indexOfTime];
                                string newValue = getTimeValue(mode, found.mode);
                                if (!newValue.Equals(timeValue))
                                {
                                    haveToUpdate = true;
                                    break;
                                }
                            }
                        }
                    }
                    catch
                    {
                        haveToUpdate = true;
                    }
                }
                else
                {
                    haveToUpdate = true;
                }
                if (haveToUpdate)
                    setGrouping(getGroup(cat), true);
            }
            else
                setGrouping(getGroup(cat), false);
        }



        private string getTimeValue(datesMode modeDates, timeMode modeTime)
        {
            switch (modeTime)
            {
                case timeMode.simple: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates)).FormatCustomTs(2);
                case timeMode.complex: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustomTs(2);
                case timeMode.last:
                case timeMode.equiv:
                case timeMode.equivNorm:
                    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    if (modeTime == timeMode.equivNorm)
                        return ts.FormatCustomTs(3, 2, 4);
                    return ts.FormatCustomTs(2);

                case timeMode.delta:
                case timeMode.deltaNorm:

                    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
                    var delta = tsf - ts0;
                    delta = delta * 100;
                    //if (modeTime == timeMode.deltaNorm)
                    //    return delta.FormatCustom(3, 2, 4);
                    return "(" + delta.FormatCustomTs(2) + ")";
                default:
                    throw new NotImplementedException();

            }

            //if (modeTime == timeMode.complex)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustom(2);
            //else if (modeTime == Tuning.timeMode.simple)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates)).FormatCustom(2);
            ////   return m_rank.TimeRest.FormatCustom(2); //.ToString("G2", en); 
            //else if (modeTime == timeMode.equiv || modeTime == timeMode.equivNorm)
            //{
            //    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);

            //    if (modeTime == timeMode.equivNorm || modeTime == timeMode.deltaNorm)
            //        return ts.FormatCustom(3, 2, 4);
            //    return ts.FormatCustom(2);
            //}
            //else
            //{
            //    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
            //    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
            //    var delta = tsf - ts0;

            //    if (modeTime == timeMode.equivNorm)
            //        return delta.FormatCustom(3, 2, 4);
            //    return delta.FormatCustom(2);
            //}
        }



        private string getGroup(List<DisplayGrouping> categories)
        {
            StringBuilder sb = new StringBuilder();

            bool begin = false;

            displayCategory last = displayCategory.none;
            foreach (var category in categories)
            {
                try
                {
                    if (begin //&& (int)category.category <= (int)displayCategory.pipe
                        && last != displayCategory.croc1 && last != displayCategory.par1
                        && category.category != displayCategory.croc2 && category.category != displayCategory.par2)
                        sb.Append(" ");
                    begin = true;

                    switch (category.category)
                    {
                        case displayCategory.rankSort:
                            CTuning.format(sb, Rank.Sort); break;
                        case displayCategory.rankDelta:
                            CTuning.format(sb, Rank.RankDelta); break;
                        case displayCategory.rankTime:
                            CTuning.format(sb, Rank.RankRest); break;
                        case displayCategory.rankAllAlbum:
                            CTuning.format(sb, RankAllAlbum); break;
                        case displayCategory.rankAlbum:
                            if (album != null)
                                sb.Append(album.Rank.Sort); break;
                        case displayCategory.rankEquiv:
                            if (album != null)
                                sb.Append(album.Equiv);
                            break;
                        case displayCategory.rankEquivLight:
                            if (album != null)
                                sb.Append(album.EquivLight);
                            break;
                        case displayCategory.albumMoy:
                            if (album != null)
                            {
                                sb.Append(album.Moyenne);
                            }
                            break;
                        case displayCategory.lenght:
                            sb.Append(Convert.ToInt32(100 * CTuning.Rapport(Rank.Lenght))); break; //   CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length))); break;
                        case displayCategory.sortValue:
                            sb.Append((1000 * Rank.SortValue).ToString("####", en)); break;
                        case displayCategory.tplay:
                            sb.Append(getTimeValue(datesMode.play, category.mode)); break;
                        case displayCategory.tclass:
                            sb.Append(getTimeValue(datesMode.@class, category.mode)); break;
                        case displayCategory.tclassMin:
                            sb.Append(getTimeValue(datesMode.classMin, category.mode)); break;
                        case displayCategory.tmix:
                            sb.Append(getTimeValue(datesMode.mix, category.mode)); break;
                        case displayCategory.tmixMin:
                            sb.Append(getTimeValue(datesMode.mixMin, category.mode)); break;
                        case displayCategory.timeCoeff:
                            sb.Append((100 * Rank.TimeCoeff).ToString("G3", en)); break;
                        case displayCategory.dplay:
                            sb.Append(ListSelection.getPlayDates(this).Count.ToString()); break;
                        case displayCategory.dclass:
                            sb.Append(ListSelection.getDatesClassement(this).Count.ToString());
                            break;
                        case displayCategory.dclassMin:
                            sb.Append(ListSelection.getClassDatesMin(this).Count.ToString()); break;
                        case displayCategory.dmix:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, false).Count.ToString());
                            break;
                        case displayCategory.dmixMin:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, true).Count.ToString());
                            break;
                        case displayCategory.pipe:
                            sb.Append("|");
                            break;
                        case displayCategory.par1: sb.Append("("); break;
                        case displayCategory.par2: sb.Append(")"); break;
                        case displayCategory.croc1: sb.Append("["); break;
                        case displayCategory.croc2: sb.Append("]"); break;

                        default:
                            break;
                    }


                    last = category.category;
                }

                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }
            }
            return sb.ToString();
        }

        public virtual int PieceId
        {
            get
            {
                return track.PieceId;
            }
        }


        private Piece parent;
        public Piece Parent
        {
            get { return parent; }
            set
            {
                if (value == null)
                {
                    if (parent != null)
                    {
                        parent.removeChild(this);
                        this.PieceParentId = -1;
                    }
                }
                else
                {
                    parent = value;
                    this.PieceParentId = value.PieceId;
                    parent.addChild(this);
                }
            }
        }
        public Piece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        private List<Piece> childs = new List<Piece>();
        public List<Piece> Childs { get { return childs; } }
        private void addChild(Piece child)
        {
            if (child != null && parent != null)
                throw new ApplicationException(string.Format("on ne doit pas affecter un enfant à un non-maitre. enfant:{0} parent {1}", child, parent));

            if (!childs.Contains(child))
                childs.Add(child);
        }

        private void removeChild(Piece child)
        {
            childs.Remove(child);
        }

        public virtual int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion

        private exportState exportState;
        public exportState ExportStatus
        {
            get
            {
                return exportState; // exportState;
            }
            set
            {
                exportState = value;
            }
        }


        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public void buildVirtualAlbums(List<Piece> list)
        {

            foreach (var path in track.RelativesPath)
            {

                var tab = path.Split('\\');
                var sb = new StringBuilder();

                sb.Append(@"\");
                var count = tab.GetLength(0);
                for (int i = 0; i < count; i++)
                {
                    var _s = tab[i];
                    if (string.IsNullOrEmpty(_s))
                        continue;

                    var virt = createVirtualAlbum(sb.ToString());
                    list.Add(virt);
                    if (i > 0)
                        sb.Append(@"\");
                    sb.Append(_s);




                }
            }
        }

        private Piece createVirtualAlbum(string path)
        {
            var virt = new VirtualAlbumPiece(track, Master, path);
            return virt;
        }
    }

    public enum exportState
    {
        none = 0,
        miss = 1,
        present = 2,
        copy = 3,
        delete = 4
    }


}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.util;
using System;
using System.Globalization;
using pdb.gen.Tuning;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    public class Album
    {

        private string name;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }

        private List<Piece> list = new List<Piece>();
        private static int _sID = 0;
        private int _dID;


        public Album(string name)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        private string equiv = "";
        public string Equiv { get { return equiv; } }

        private string equivLight = "";
        public string EquivLight { get { return equivLight; } }

        private string moyenne = "";
        public string Moyenne { get { return moyenne; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            if (list.Contains(piece))
                return false;
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);
            piece.PieceAlbum = this;
            return true;
        }

        public List<Piece> Tracks
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceClassementValueComparer());
                return l;
            }
        }


        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        private bool atLeastOneEnabled;
        public bool AtLeastOneEnabled { get { return atLeastOneEnabled; } }

        public void makeSort(bool quasi, int medianneVirt) //IList<double> reference, IList<Piece> pieces)
        {
            //if (name == "The College Dropout")
            //{
            //}
            decimal offset = conf.AlbumMoyOffset;
            int count = list.Count;
            list.Sort(new PieceSortComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < count; i++)
            {
                listSortedValues.Add(list[i].Rank.SortValue);
                if (!classed && list[i].isClassListNumeric)
                    classed = true;
            }

            m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne);

            listSortedValues = new List<decimal>();
            list.Sort(new PieceDurationValueComparer());
            for (int i = 0; i < count; i++)
                listSortedValues.Add(list[i].Duration.TotalMilliseconds());
            durationValue = CalcMedianne.getMedianne(listSortedValues, medianne);



            listSortedValues = new List<decimal>();
            list.Sort(new PieceClassementValueComparer());
            decimal moy = 0m;
            for (int i = 0; i < count; i++)
            {
                var rapportClassement = list[i].RapportClassement;
                moy += rapportClassement;
                if (offset > 0m && rapportClassement > 0.0m)
                    moy += offset;

                listSortedValues.Add(rapportClassement);
            }
            if (count > 0)
                moy /= count;
            classMoy = moy;


            classementValue = CalcMedianne.getMedianne(listSortedValues, medianne);

            classementValueLight = CalcMedianne.getMedianneLight(listSortedValues, medianne, quasi, medianneVirt);




            //int iequiv = CalcMedianne.getEquiv(reference, m_rank.SortValue, 0, reference.Count - 1);
            //equiv = pieces[iequiv];
            equiv = Piece.getClassementEquiv(classementValue); // (10000 * m_rank.SortValue).ToString("00000.0", cu); 
            equivLight = Piece.getClassementEquiv(classementValueLight);

            moyenne = Piece.getClassementEquiv(classMoy);



        }

        public decimal getTrackSortValue(int index)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }

        public void makeSelection()
        {
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest);
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private void initRank()
        {
            m_rank.init();
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CListFile.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.util;
using pdb.obj;

using pdb.db.piece;

namespace pdb.db.obj
{
    /// <summary>
    /// liste des fichiers accédant au même morceau
    /// </summary>
    /// <remarks></remarks>
    public class CListFile : IEnumerable<CFile>, IData
    {


        //  private static CFileComparer c_comparer = new CFileComparer();
        private const string TOKEN_FILES = "files";
        private List<CFile> m_list = new List<CFile>();
        public CListFile(XmlElement a_xml)
        {
            XmlElement l_xml = XMLTool.NodeLookUp(a_xml, TOKEN_FILES);
            if (l_xml == null)
                return;
            var att = l_xml.Attributes["f"];
            if (att != null)
            {
                CFile f = new CFile(att.Value);
                @add(f);
                return; 
            }
            foreach (XmlElement l_xmlFile in l_xml)
            {
                CFile l_file = new CFile(l_xmlFile.InnerText);
                @add(l_file);
            }
        }
        public CListFile()
        {
        }
        public void @add(CFile a_file)
        {
            //if (!a_file.exists()) return; //TODO provisoire
            bool l_bFound = false;
            foreach (CFile l_file in m_list)
            {
                if (a_file.Equals(l_file))
                {
                    l_bFound = true;
                    break;
                }
            }
            if (l_bFound)
                return;
            if (a_file.FileType.typeMusic())
                //if (!a_file.exists()) return; 
                m_list.Add(a_file);
        }
        //   private CFile _pertinent; 
        public CFile getPertinentFile()
        {
            //if (_pertinent != null)
            //    return _pertinent; 
            //  var list = m_list.FindAll(delegate(CFile file) { return file.exists(); }); 
            var list = m_list.FindAll(file => file.exists());


            if (list.Count == 1)
                return list[0];

            try
            {
                list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine("impossible de comparer les fichiers");
                foreach (CFile file in list)
                {
                    Console.Write(file.File + ";");
                }
                Console.WriteLine(e.ToString());
            }

            var _pertinent = list.Count == 0 ? null : list[0];
            return _pertinent;
            //if (m_list.Count == 1)
            //    return m_list[0];


            //foreach (CFile l_file in m_list)
            //{
            //    if (l_file.exists())
            //        return l_file;
            //}
            //return m_list[0];
        }

        private CFile getFirstFile()
        {
            var pertinent = getPertinentFile();
            if (pertinent != null)
                return pertinent;
            //if (_pertinent != null)
            //    return _pertinent; 
            //  var list = m_list.FindAll(delegate(CFile file) { return file.exists(); }); 
            var list = m_list; // m_list.FindAll(file => file.exists());


            if (list.Count == 1)
                return list[0];

            try
            {
                list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine("impossible de comparer les fichiers");
                foreach (CFile file in list)
                {
                    Console.Write(file.File + ";");
                }
                Console.WriteLine(e.ToString());
            }

            var _pertinent = list.Count == 0 ? null : list[0];
            return _pertinent;
            //if (m_list.Count == 1)
            //    return m_list[0];


            //foreach (CFile l_file in m_list)
            //{
            //    if (l_file.exists())
            //        return l_file;
            //}
            //return m_list[0];
        }

        public void getSecondaryFiles(List<CFile> list)
        {
            if (m_list.Count <= 1)
                return;
            var pertinent = getPertinentFile();

            foreach (CFile f in m_list)
            {
                if (f.exists() && f != pertinent)
                    list.Add(f);
            }

        }

        public string File
        {
            get
            {
                CFile l_file = getPertinentFile();
                if (l_file == null)
                {
                    if (m_list.Count > 0) return m_list[0].File;
                    return "";
                }
                return l_file.File;
            }
        }

        public string Path
        {
            get
            {
                CFile l_file = getFirstFile();
                if (l_file == null)
                    return "";
                return l_file.Path;
            }
        }
        public String getUri()
        {
            CFile l_file = getPertinentFile();
            if (l_file == null)
                return "";
            return l_file.getUri();
        }

        public bool Exists { get { return getPertinentFile() != null; } }

        public void merge(CListFile a_list)
        {
            CFile aux = getPertinentFile();
            foreach (CFile l_file in a_list)
            {
                @add(l_file);
            }


            CFile _new = getPertinentFile();

            if (aux == null)
            {
                if (_new != null)
                    onChange();

            }
            else
            {
                if (!aux.Equals(_new))
                    onChange();
            }

        }

        private IDataObserver observer;
        public IDataObserver Observer { set { observer = value; } }
        private void onChange() { if (observer != null) observer.RefChange(); }


        /// <summary>
        /// teste s'il existe un fichier en commun entre deux listes
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        /// <remarks></remarks>
        public bool HasOnePathInCommonWith(CListFile other)
        {
            foreach (CFile l_myFile in m_list)
            {
                foreach (CFile l_outFile in other.m_list)
                {
                    if (l_myFile.Equals(l_outFile))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        public bool HasOnePathInCommonWith(String path)
        {

            foreach (CFile l_myFile in m_list)
            {

                if (l_myFile.Path.Equals(path))
                {
                    return true;
                }

            }
            return false;
        }


        public int Count
        {
            get { return m_list.Count; }
        }

        public System.Collections.Generic.IEnumerator<CFile> GetEnumerator()
        {
            return m_list.GetEnumerator();
        }

        public System.Collections.IEnumerator GetEnumerator1()
        {
            return GetEnumerator();
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator1();
        }

        public bool isPodcast
        {
            get
            {
                foreach (CFile l_file in new List<CFile>( m_list))
                {
                    if (l_file.isPodcast)
                        return true;
                }
                return false;
            }
        }


        #region IData Members


        public void write(ITextWriter a_sw)
        {
            //   m_list.Sort(c_comparer)
            XMLTool.openBalise(a_sw, TOKEN_FILES);
            foreach (CFile l_file in this)
            {
                l_file.write(a_sw);
            }
            XMLTool.closeBalise(a_sw, TOKEN_FILES);
        }


        public void write(XmlWriter w)
        {
            m_list.Sort(new CFileComparerName());
            w.WriteStartElement(TOKEN_FILES);
            if (m_list.Count == 1 && m_list[0] != null)
            {
                w.WriteAttributeString("f", m_list[0].File);
            }
            else
            {

                foreach (CFile l_file in this)
                {
                    l_file.write(w);
                }
            }
            w.WriteEndElement();
        }
        public bool HasChange(CListFile lastFull)
        {
            return m_list.Count != lastFull.m_list.Count;
        }
        public void writeDiff(XmlWriter w, CListFile lastFull)
        {
            if (m_list.Count == lastFull.m_list.Count)
                return;
            m_list.Sort(new CFileComparerName());
            lastFull.m_list.Sort(new CFileComparerName());

            w.WriteStartElement(TOKEN_FILES);
            foreach (CFile l_file in this)
            {
                bool found = false;
                foreach (CFile o in lastFull.m_list)
                {
                    if (o.File.Equals(l_file.File))
                    {
                        found = true;
                        break;
                    }
                }
                if (found)
                    continue;

                l_file.write(w);
            }
            w.WriteEndElement();
        }

        #endregion

        public CFile this[int a_index]
        {
            get
            {
                if (a_index < 0 || a_index >= Count)
                {
                    throw new ApplicationException("bad index:" + a_index + " / " + Count);
                }
                else
                {
                    return m_list[a_index];
                }
            }
        }

        public void Sort()
        {
            try
            {
                m_list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
        }
        //private class CFileComparer : IComparer<CFile>
        //{

        //    public int Compare(CFile x, CFile y)
        //    {
        //        return string.Compare(x.File.Trim().ToUpper(), y.File.Trim().ToUpper());
        //    }
        //}

        private long size = -1;
        public long Size
        {
            get
            {
                if (size < 0)
                {
                    var file = getPertinentFile();
                    if (file == null)
                        size = 0;
                    else
                        size = file.Size;
                }
                return size;
            }

        }

        public string DirAndFileName
        {
            get
            {
                var file = getFirstFile();
                if (file == null)
                    return "";
                return file.DirAndFileName;
            }
        }


    }
}


]]></content>
  </file>
</db>
