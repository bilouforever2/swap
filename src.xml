<db path="C:\Bernard\db1\pdb4">
   <file path="\pdb.player\ViewModel\AllTracksViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Windows.Input;
using System.Windows.Threading;
using pdb.player.ViewModel.Commande.Link;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.Commande;
using pdb.util;
using System.Globalization;

namespace pdb.player.ViewModel
{
    public enum listDisplay
    {
        all,
        onlyDisabled,
        onlyEnabled
    }

    public class AllTracksViewModel : List<TrackListViewModel>, INotifyCollectionChanged, INotifyPropertyChanged
    {
        public event NotifyCollectionChangedEventHandler CollectionChanged;
        public event PropertyChangedEventHandler PropertyChanged;
        //   private List<TrackListViewModel> tracks;
        private Dictionary<int, TrackListViewModel> dict;
        private object _lock = new object();
        private PlayListViewModel parent;
        private DispatcherOperation ope;
      


        private bool? onlyDisabled;
        private bool onlyFathers;
        public AllTracksViewModel(PlayListViewModel parent, bool? onlyDisabled, bool onlyFathers)
        {
            this.parent = parent;
            this.onlyDisabled = onlyDisabled;
            this.onlyFathers = onlyFathers;
            //   this.mode = mode; 
            build();
            PlayerViewModel.Instance.resumeChange += playerResumeChange;
            PlayerViewModel.autoChange += new EventHandler(PlayerViewModel_autoChange);
            //TrackListViewModel.CurrentHumanSelectedChanged += PlayerViewModel_autoChange; 
        }

        void PlayerViewModel_autoChange(object sender, EventArgs e)
        {
            OnPropertyChanged("AutoResume");        
        }


        void playerResumeChange(object sender, EventArgs e)
        {
            OnPropertyChanged("TV"); 
            OnPropertyChanged("Resume");
            OnPropertyChanged("AutoResume");  
        }

        public string Resume
        {
            get
            {
                return PlayerViewModel.Instance.Resume;
            }
            set
            {

            }
        }

        protected void OnCollectionChange(NotifyCollectionChangedEventArgs e)
        {
            // Be nice - use BlockReentrancy like MSDN said

            //var dispatcher = Dispatcher.CurrentDispatcher;
            //if (dispatcher.CheckAccess())
            //{
            //    if (CollectionChanged == null)
            //    {
            //    }
            //    else
            //    {
            //        CollectionChanged(this, e); 
            //    }
            //    return; 
            //}

            //dispatcher.Invoke(DispatcherPriority.DataBind, new Action<NotifyCollectionChangedEventArgs>(OnCollectionChange), e);



            var eventHandler = CollectionChanged;
            if (eventHandler != null)
            {
                Delegate[] delegates = eventHandler.GetInvocationList();
                // Walk thru invocation list
                foreach (NotifyCollectionChangedEventHandler handler in delegates)
                {
                    try
                    {
                        var dispatcherObject = handler.Target as DispatcherObject;
                        // If the subscriber is a DispatcherObject and different thread
                        if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                        // Invoke handler in the target dispatcher's thread
                        {
                            ope =
                               dispatcherObject.Dispatcher.BeginInvoke(DispatcherPriority.DataBind,
                                            handler, this, e);
                            ope.Completed += ope_Completed;


                        }
                        else // Execute handler as is
                            handler(this, e);
                    }
                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }
                }
            }
            else
            {
            }

            // PlayerViewModel.Instance.makeResume();

        }

        void ope_Completed(object sender, EventArgs e)
        {
            App.log.log(string.Format("AllTracksViewModel::OnCollectionChange {0} CollectionChanged completé", sender));
            PlayerViewModel.Instance.makeResume();
        }


        protected virtual void OnPropertyChanged(string propertyName)
        {
            var eventHandler = PropertyChanged;
            if (eventHandler == null)
            {
                //   int toto = 0;
            }
            else
            {
                //var dispatcher = Dispatcher.CurrentDispatcher;
                //if (dispatcher.CheckAccess())
                //    PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
                //else
                //    dispatcher.Invoke(new Action<string>(OnPropertyChanged), propertyName);

                Delegate[] delegates = eventHandler.GetInvocationList();
                // Walk thru invocation list
                foreach (PropertyChangedEventHandler handler in delegates)
                {
                    try
                    {
                        var dispatcherObject = handler.Target as DispatcherObject;
                        // If the subscriber is a DispatcherObject and different thread
                        if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                            // Invoke handler in the target dispatcher's thread
                            dispatcherObject.Dispatcher.BeginInvoke(DispatcherPriority.DataBind,
                                          handler, this, new PropertyChangedEventArgs(propertyName));
                        else // Execute handler as is
                            handler(this, new PropertyChangedEventArgs(propertyName));
                    }
                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }
                }
            }
        }

        public void refresh()
        {
            build();
            foreach (TrackListViewModel track in this)
                track.refresh();

        }

        //public void init()
        //{
        //    refresh();
        //    OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
        //}

        public TrackListViewModel TV { get { return TrackListViewModel.HumanSelected; } }

        public void build()
        {
            lock (_lock)
            {
                var list = new List<TrackListViewModel>();
                var dict = new Dictionary<int, TrackListViewModel>();
                buildAllTraks(list, dict, onlyDisabled, onlyFathers);
                if (this.dict == null)
                {
                    this.dict = new Dictionary<int, TrackListViewModel>();
                    foreach (TrackListViewModel track in list)
                    {
                        Add(track);
                        this.dict.Add(track.PieceId, track);
                        track.PropertyChanged += track_PropertyChanged;
                    }

                    OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
                }
                else
                {

                    foreach (TrackListViewModel newTrack in list)
                    {
                        if (!this.dict.ContainsKey(newTrack.PieceId))
                        {
                            Add(newTrack);
                            this.dict.Add(newTrack.PieceId, newTrack);
                            newTrack.PropertyChanged += track_PropertyChanged;
                            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, newTrack));
                        }
                    }

                    foreach (TrackListViewModel track in new List<TrackListViewModel>(this))
                    {
                        if (!dict.ContainsKey(track.PieceId))
                        {
                            Remove(track);
                            this.dict.Remove(track.PieceId);
                            track.PropertyChanged -= track_PropertyChanged;
                            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, track));
                        }
                    }
                }
            }

            //Clear(); 
            //foreach (TrackListViewModel track in parent.Tracks)
            //    Add(track); 
        }

        void track_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            switch (e.PropertyName)
            {
                case "Duration":
                case "Enabled":
                    PlayerViewModel.Instance.makeResume();
                    break;
            }
        }

        public List<TrackListViewModel> AllTracks
        {
            get
            {
                build();
                return this;
            }
        }

        public List<TrackListViewModel> Tracks
        {
            get
            {
                return parent.Tracks;
            }
        }

        protected void buildAllTraks(List<TrackListViewModel> container, Dictionary<int, TrackListViewModel> dict, bool? onlyDisabled, bool onlyFathers)
        {
            foreach (TrackListViewModel t in parent.Tracks)
            {
                if (!t.Enabled || true !=onlyDisabled)
                {
                    if (onlyDisabled == null && t.Enabled)
                    {
                        if (!t.PieceGen.ClassementProvisoireRecent)
                            continue; 
                    }
                    if (t.PieceParentId < 0 || !onlyFathers)
                    {
                        if (!t.Track.Virtual || PlayerViewModel.Instance.WithVirtualAlbum)
                        {
                            
                            if (!dict.ContainsKey(t.PieceId))
                            {
                                dict.Add(t.PieceId, t);
                                container.Add(t);
                                //  t.Index = container.Count; 
                            }
                        }
                    }
                }

            }

            foreach (PlayListViewModel pl in parent)
            {
                AllTracksViewModel other = pl.AlltracksVm;
                //if (true == onlyDisabled)
                //    other = pl.AlltracksVmd;
                //else
                //    other = pl.AlltracksVm;
                other.buildAllTraks(container, dict, onlyDisabled, onlyFathers);
            }
        }

        #region cmd

        private ICommand _contextCmdCheck;
        public ICommand ContextCmdCheck { get { if (_contextCmdCheck == null) _contextCmdCheck = new CheckCmd(); return _contextCmdCheck; } }

        private ICommand _contextCmdUnCheck;
        public ICommand ContextCmdUnCheck { get { if (_contextCmdUnCheck == null) _contextCmdUnCheck = new UnCheckCmd(); return _contextCmdUnCheck; } }


        private ICommand _contextLinkFather;
        public ICommand LinkFather { get { if (_contextLinkFather == null) _contextLinkFather = new LinkFather(); return _contextLinkFather; } }

        private ICommand _contextLinkChild;
        public ICommand LinkChild { get { if (_contextLinkChild == null) _contextLinkChild = new LinkChild(); return _contextLinkChild; } }

        private ICommand _contextLinkFusion;
        public ICommand LinkFusion { get { if (_contextLinkFusion == null) _contextLinkFusion = new LinkFusion(); return _contextLinkFusion; } }

        private ICommand _contextUnLink;
        public ICommand LinkReset { get { if (_contextUnLink == null) _contextUnLink = new LinkReset(); return _contextUnLink; } }

        private ICommand _contextExport;
        public ICommand Export { get { if (_contextExport == null) _contextExport = new ExportCmd(); return _contextExport; } }

        private ICommand _contextExportCompress;
        public ICommand ExportCompress { get { if (_contextExportCompress == null) _contextExportCompress = new ExportCompress(); return _contextExportCompress; } }

        private ICommand _contextDelete;
        public ICommand DeleteTrack { get { if (_contextDelete == null) _contextDelete = new DeleteCmd(); return _contextDelete; } }

        public TrackListViewModel HumanSelected
        {
            get
            {
                return TrackListViewModel.HumanSelected;
            }
        }

        private ICommand _ContextCmdAddToList;
        public ICommand ContextCmdAddToList { get { if (_ContextCmdAddToList == null) _ContextCmdAddToList = new AddToList(App.Instance); return _ContextCmdAddToList; } }

        private ICommand _ContextCmdDbDeleteClassement;
        public ICommand ContextCmdDbDeleteClassement { get { if (_ContextCmdDbDeleteClassement == null) _ContextCmdDbDeleteClassement = new DbDeleteLastClassement(); return _ContextCmdDbDeleteClassement; } }

        private ICommand _ContextCmdDbDeleteRead;
        public ICommand ContextCmdDbDeleteRead { get { if (_ContextCmdDbDeleteRead == null) _ContextCmdDbDeleteRead = new DbDeleteLastRead(); return _ContextCmdDbDeleteRead; } }


        #endregion

        #region from Ihm
        private TrackListViewModel selectedTrack;
        public TrackListViewModel SelectedTrack
        {
            get
            {
                return selectedTrack;
            }
            set
            {
                selectedTrack = value;
                TrackListViewModel.setHumanSelected(parent, value); //  .HumanSelected = value;
                if (selectedTrack != null)
                    selectedTrack.IsSelected = true;
            }
        }
        #endregion

        private int nbAlbumMoved;

        public int NbAlbumMoved
        {
            get { return nbAlbumMoved; }
        }

        public string AutoResume
        {
            get
            {
               
                try
                {

                    var conf = App.gen.SortAlbumMode.ComposantsUtiles[0].Main;
                    var sb = new StringBuilder();
                    
                    sb.Append(conf.CoeffOld.ToString("0.000", CultureInfo.InvariantCulture)); sb.Append("  ");

                    sb.Append((1000 * conf.dcoeffp).ToString("### ### ##0.##\\.##")); sb.Append("m  ");
                    var percentConv = 0m;
                    if (conf.dconvergence > 0) percentConv = conf.dconvergence0 / conf.dconvergence;
                    sb.Append((percentConv).ToString("### ### ##0.##", CultureInfo.InvariantCulture)); sb.Append("  ");
                   
                    sb.Append(conf.Serial); sb.Append(" ");
                    sb.Append(conf.SerialBox); sb.Append(" ");
                    sb.Append(conf.Alt); sb.Append(" ");
                    sb.Append(conf.AltHisto); sb.Append("  ");
                    sb.Append(conf.Elastique); sb.Append(" ");
                    sb.Append(conf.Elastique2);
                    //var motif = selectedCoeff.none;
                    //var current = TrackListViewModel.HumanSelected;
                    //if (current != null)
                    //    motif = current.SelectedMotif; 
                  //  var stat10 = conf.calcStat(motif,10);
                   // sb.Append(stat10); sb.Append(" - ");
                 //   var stat100 = conf.calcStat(motif,100);
                  //  sb.Append(stat100); 

                    //sb.Append(conf.coeffTMin(10).ToString("0.000", CultureInfo.InvariantCulture)); sb.Append(" "); sb.Append(conf.coeffTMax(10).ToString("0.000", CultureInfo.InvariantCulture)); sb.Append(" - ");
                    //sb.Append(conf.coeffTMin(100).ToString("0.000", CultureInfo.InvariantCulture)); sb.Append(" "); sb.Append(conf.coeffTMax(100).ToString("0.000", CultureInfo.InvariantCulture)); 
                    return sb.ToString(); 
                   
                }
                catch
                {
                    return ""; 
                }
            }
        }
        public string NbAlbumMovedDesc
        {
            get
            {
                if (nbAlbumMoved < 0)
                    return "";
                if (nbAlbumMoved == 0)
                    return "pas d'album en quarantaine";
                return string.Format("{0} albums en quarantaine", nbAlbumMoved); 
            }
        }

        public void setNbAlbumMoved(int nb)
        {
            if (nb != nbAlbumMoved)
            {
                nbAlbumMoved = nb;
                OnPropertyChanged("NbAlbumMoved");
                OnPropertyChanged("NbAlbumMovedDesc");
            }

        }

        private int nbAlbumMovedUnavailable;
        public int NbAlbumMovedUnavailable
        {
            get
            {
                return nbAlbumMovedUnavailable; 
            }

            set
            {
                if (value != nbAlbumMovedUnavailable)
                {
                    nbAlbumMovedUnavailable = value;
                    OnPropertyChanged("NbAlbumMovedUnavailable"); 
                }
            }
        }

    }


}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\PlayerViewModel.cs">
    <content><![CDATA[using pdb.player.model;
using pdb.player.ViewModel.Commande;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading;
using System.Windows.Data;
using System.Windows.Input;
using pdb.player.engine;
using pdb.player.engine.build;
using pdb.util;
using System.Collections;
using pdb.gen.conf;
using pdb.gen.albums;
using pdb.gen.Tuning;
using pdb.gen;
using System.Windows.Threading;

namespace pdb.player.ViewModel
{


    enum positionstate
    {
        free,
        cannotPrevious,
        cannotForward
    }

    class HiddenPlayList : ItrackProvider
    {
        private ICollectionView viewOrg;
        private PlayListViewModel pl;
        private static List<TrackListViewModel> hiddenSelected = new List<TrackListViewModel>();

        public HiddenPlayList(PlayListViewModel pl, ICollectionView viewOrg)
        {
            this.viewOrg = viewOrg;
            this.pl = pl;
        }
        public ICollectionView PresentationTracks
        {
            get { return viewOrg; }
        }

        public void Focus(int index)
        {

        }

        public PlayListViewModel PlayList
        {
            get { return pl; }
        }


        public void doFilter(string filter)
        {
            PlayerViewModel.doFilter(PresentationTracks, filter);
        }


        public List<TrackListViewModel> SelectedTracks
        {
            get { return hiddenSelected; }
        }
    }



    class PlayerViewModel : ViewModelBase
    {
        private static PlayerViewModel _instance;
        private static volatile object _lock = new object();
        private ConfAlbumSort confAlbumSort;
        public ConfAlbumSort ConfAlbumSort { get { return confAlbumSort; } set { confAlbumSort = value; } }
        public static PlayerViewModel Instance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_lock)
                    {
                        if (_instance == null)
                            _instance = new PlayerViewModel();
                    }
                }
                return _instance;
            }
        }

        public ConfFilter ConfFilter { get { return FilterTask.conf; } }
        private IPlayerEngine player = PlayerBuilder.create("vlcplugin");

        private TrackListViewModel currentTrack;
        private PlayListViewModel currentPl;
        public event EventHandler currentTrackChange;
        public event EventHandler resumeChange;
        public static event EventHandler autoChange;
        private playerstate state;
        private positionstate _positionstate;
        private bool onlyEnabled = true;
        // private bool sortByAlbum = true;
        private bool withVirtualAlbum = CConf.ConfGen.AlbumVirtual;
        private bool withArtistVirtual = CConf.ConfGen.ArtistVirtual;
        private bool navAuto = CConf.ConfGen.NavAuto;
        public bool NavAuto
        {
            get { return navAuto; }
            set
            {
                if (value != navAuto)
                {
                    navAuto = value;
                    OnPropertyChanged("NavAuto");
                }
            }
        }

        private bool filterOnlyNext;
        public bool FilterNext
        {
            get { return filterOnlyNext; }
            set
            {
                if (value != filterOnlyNext)
                {
                    filterOnlyNext = value;
                    OnPropertyChanged("FilterNext"); 
                }
            }
        }
        ItrackProvider _real;
        private Logger log;
        public static IPlayerEngine Player { get { return Instance.player; } }


        public bool OnlyEnabled
        {
            get
            {
                return onlyEnabled;
            }
            set
            {
                if (value != onlyEnabled)
                {
                    onlyEnabled = value;
                    OnPropertyChanged("OnlyEnabled");
                }
            }
        }
        private bool createRot = true;
        public bool CreateRot
        {
            get
            {
                return createRot;
            }
            set
            {
                if (value != createRot)
                {
                    createRot = value;
                    OnPropertyChanged("CreateRot");
                }
            }
        }

        public bool SortByAlbum
        {
            get
            {
                return confAlbumSort.Enabled;
            }
        }
        //private albumSortMode sortAlbumMode;
        //public albumSortMode SortAlbumMode
        //{
        //    get { return sortAlbumMode; }
        //    set
        //    {
        //        if (value != sortAlbumMode)
        //        {
        //            sortAlbumMode = value;
        //            OnPropertyChanged("SortAlbumMode");
        //            App.go();
        //        }
        //    }
        //}

        public bool WithVirtualAlbum
        {
            get { return withVirtualAlbum; }
            set
            {
                if (value != withVirtualAlbum)
                {
                    withVirtualAlbum = value;
                    OnPropertyChanged("WithVirtualAlbum");
                    App.go();
                }
            }
        }

        public bool WithVirtualArtist
        {
            get { return withArtistVirtual; }
            set
            {
                if (value != withArtistVirtual)
                {
                    withArtistVirtual = value;
                    OnPropertyChanged("WithVirtualArtist");
                    App.go();
                }
            }
        }



        private PlayerViewModel()
        {
            this.log = Logger.getLogger("PlayerViewModel");
            player.mediaEndReached += player_mediaEndReached;
            player.Volume = volume;
            TrackListViewModel.CurrentHumanSelectedChanged += TrackListViewModel_CurrentHumanSelectedChanged;


            new Thread(refreshLoop).Start();
            this.currentPl = PlayListViewModel.SelectedPlayList;
        }

        void TrackListViewModel_CurrentHumanSelectedChanged(object sender, EventArgs e)
        {
            makeResume();
        }

        void player_mediaEndReached(object sender, EventArgs e)
        {
            var track = this.CurrentTrack;
            if (track != null)
                track.Piece.recordJustReadTrack();
            next();
            App.go();
        }

        #region commande
        private ICommand cmdPlayPause;
        private ICommand cmdForward;
        private ICommand cmdStop;
        private ICommand cmdBackWard;
        private readonly static TimeSpan LIMIT_BACK = TimeSpan.FromSeconds(5.1);

        public ICommand Play
        {
            get
            {
                if (cmdPlayPause == null)
                    cmdPlayPause = new PlayPause();
                return cmdPlayPause;
            }
        }

        public ICommand Forward
        {
            get
            {
                if (cmdForward == null)
                    cmdForward = new ForWard();
                return cmdForward;
            }
        }

        public ICommand BackWard
        {
            get
            {
                if (cmdBackWard == null)
                    cmdBackWard = new BackWard();
                return cmdBackWard;
            }
        }

        public bool canForward()
        {
            return canPlay() && _positionstate != positionstate.cannotForward;
        }
        public bool canBackWard()
        {
            if (!canPlay())
                return false;
            if (PlayJustStarted)
                return _positionstate != positionstate.cannotPrevious;
            return true;

        }

        public void backWard()
        {
            if (PlayJustStarted)
                movetoPrevious();
            else
                goStartTrack();
        }

        public void checkNavIni()
        {
            if (!navAuto)
                return;

            var tracks = PresentationTracks;
            bool foundFirst = false;
            TrackListViewModel f = null;

            foreach (TrackListViewModel t in tracks)
            {
                if (t.Index == 1)
                {
                    foundFirst = true;
                }
                if (foundFirst && t.PieceGen.IsNext)
                {
                    f = t;
                    break;
                }
            }

            if (f == null)
                return;

            tracks.MoveCurrentTo(f);
            focus(tracks.CurrentPosition);

        }

        public void forward()
        {
            if (!navAuto)
                movetoNext(true);
            else
            {
                var t = TrackListViewModel.HumanSelected;
                if (t != null)
                {
                    t.refresh();
                    //  var g = t.Grouping; 
                }

                var pl = PlayListViewModel.SelectedPlayList;
                if (pl == null)
                {
                    movetoNext(true);
                    return;
                }

                string _album = "";
                if (currentTrack != null)
                    _album = currentTrack.Album;
                movetoNext(true); // des fois le morceaux affiché n'est pas celui joué. Dommage...
                if (currentTrack != null && currentTrack.Album == _album)
                {
                    if (state == playerstate.play)
                        play(false, true);
                    return;
                }

                if (currentTrack == null)
                    return;
                var album = App.gen.Albums.getAlbum(CurrentTrack.Track);
                var tracks = album.Tracks;
                //    tracks.Sort(new PieceClassementComparer());
                //  decimal val = int.MaxValue;
                int i = 0;
                TrackListViewModel choose = null;
                if (confAlbumSort.ComposantsUtiles[0].cmpMin > modeMin.non)
                {
                    var next = album.Next;
                    if (next != null)
                        choose = pl.FindTrack(next.PieceId);
                }
                else
                {
                    for (i = 0; i < tracks.Count; i++)
                    {
                        var item = tracks[i];
                        if (item != null && (!onlyEnabled || item.Enabled))
                        {
                            var tl = pl.FindTrack(item.PieceId);
                            if (!tl.Exists)
                                continue;
                            choose = tl;

                            //val = v;
                            // choose = tl;
                            if (item.VirtualClassement == 0m)
                            {
                                break;
                                //if (confAlbumSort.ComposantsUtiles[0].cmpMin != modeMin.toujours)
                                //    choose = tl;
                                //break;
                            }
                            // choose = tl;
                        }
                    }
                }

                if (choose != null)
                {
                    //var p = choose.PieceGen;
                    //if (p != null)
                    //   confAlbumSort.auto(p.AutoCoeff1, p.AutoCoeff2); 
                    reset(provider, choose, state == playerstate.play);
                    var coll = PresentationTracks;
                    coll.MoveCurrentTo(choose);
                    focus(coll.CurrentPosition);

                }
                
            }
        }

        public bool isHidden { get { return provider is HiddenPlayList; } }

        public void pause()
        {
            State = playerstate.pause;
            player.pause();
        }

        private bool PlayJustStarted { get { return ElapsedTime < LIMIT_BACK; } }

        #endregion

        #region navigation
        public bool canPlay()
        {
            //if (currentPl == null)
            //    return false;
            var tracks = PresentationTracks;
            if (tracks == null)
                return false;
            if (tracks.IsEmpty)
                return false;
            return true;
        }



        private void movetoNext(bool autoPlay)
        {
            move(true, autoPlay);
        }

        private void goStartTrack()
        {
            Position = 0;
        }

        private void move(bool _toNext, bool autoPlay)
        {
            bool playing = state == playerstate.play;
            TrackListViewModel item = null;



            var tracks = PresentationTracks;

            Func<bool> _move;
            if (_toNext)
                _move = tracks.MoveCurrentToNext;
            else
                _move = tracks.MoveCurrentToPrevious;
            try
            {


                if (currentTrack != null)
                    tracks.MoveCurrentTo(currentTrack);
                if (!_move())
                {
                    return;
                }

                while (true)
                {
                    item = tracks.CurrentItem as TrackListViewModel;
                    if (item != null && item.Exists && (!onlyEnabled || item.Enabled))
                        break;
                    if (!_move())
                    {
                        item = null;
                        return;
                    }

                }



            }
            finally
            {
                if (item == null)
                    _positionstate = _toNext ? positionstate.cannotForward : positionstate.cannotPrevious;
                CurrentTrack = item;
                tracks.MoveCurrentTo(currentTrack);
                if (item != null)
                {
                    focus(tracks.CurrentPosition);
                    if (playing && autoPlay)
                    {
                        player.play(item.Location, true);
                    }
                    focus(tracks.CurrentPosition);
                }

            }
        }


        private void movetoPrevious()
        {
            move(false, true);
            //bool playing = state == playerstate.play;
            //TrackListViewModel item = null;

            //var tracks = PresentationTracks;
            //try
            //{


            //    if (currentTrack != null)
            //        tracks.MoveCurrentTo(currentTrack);
            //    if (!tracks.MoveCurrentToPrevious())
            //    {
            //        _positionstate = positionstate.cannotPrevious;
            //        state = playerstate.stop;
            //        return;
            //    }

            //    while (true)
            //    {
            //        item = tracks.CurrentItem as TrackListViewModel;
            //        if (item.Enabled)
            //            break;
            //        if (!tracks.MoveCurrentToPrevious())
            //        {
            //            _positionstate = positionstate.cannotPrevious;
            //            state = playerstate.stop;
            //            return;
            //        }

            //    }



            //}
            //finally
            //{
            //    CurrentTrack = item;
            //    tracks.MoveCurrentTo(currentTrack);
            //    if (item != null)
            //    {
            //        focus(tracks.CurrentPosition);
            //        if (playing)
            //        {
            //            player.play(item.Location, true);

            //        }
            //    }

            //}
        }


        public void play(bool forceDisabled, bool reload)
        {

            TrackListViewModel item = currentTrack;
            var tracks = PresentationTracks;
            try
            {
                if (!canPlay())
                    return;

                while (true)
                {
                    if (item == null)
                    {
                        _positionstate = positionstate.cannotPrevious;

                        if (!tracks.MoveCurrentToFirst())
                        {
                            //_positionstate = positionstate.cannotPrevious; 
                            return;
                        }

                        while (true)
                        {
                            item = tracks.CurrentItem as TrackListViewModel;
                            if (item != null && item.Exists && (!onlyEnabled || item.Enabled))
                                break;
                            if (!tracks.MoveCurrentToNext())
                            {
                                _positionstate = positionstate.cannotForward;
                                return;
                            }
                            _positionstate = positionstate.free;
                        }

                        if (item == null)
                            return;


                    }
                    tracks.MoveCurrentTo(item);
                    if (tracks.CurrentPosition >= 0)
                        break;
                    item = null;
                }

                CurrentTrack = item;

                focus(tracks.CurrentPosition);

                State = playerstate.play;
                //item.Playing = true;
                player.play(currentTrack.Location, reload);
                focus(tracks.CurrentPosition);
            }
            finally
            {
                if (!canPlay() || currentTrack == null)
                    stop();
            }
        }



        public void stop()
        {

            if (isHidden)
            {
                provider = _real;
                tracks = provider.PresentationTracks;
            }

            State = playerstate.stop;
            player.stop();

        }

        private void next()
        {
            if (navAuto)
                forward();
            else
                movetoNext(true);
        }



        #endregion

        private ItrackProvider provider;
        //internal ItrackProvider Provider
        //{
        //    set
        //    {

        //        //if (state != playerstate.stop)
        //        //{
        //        //    if (provider != null)
        //        //    {
        //        //        if (provider is HiddenPlayList)
        //        //        {
        //        //        }
        //        //        else
        //        //        {
        //        //            provider = new HiddenPlayList(provider.PresentationTracks);
        //        //        }
        //        //    }
        //        //    else
        //        //        provider = value;
        //        //}
        //        provider = value;
        //    }
        //}
        public ICollectionView PresentationTracks
        {
            get
            {
                if (provider == null)
                    return null;
                return provider.PresentationTracks;
            }
        }
        private void focus(int index)
        {
            if (provider == null)
                return;
            provider.Focus(index);
        }






        public playerstate State
        {
            get
            {
                return state;
            }
            set
            {
                if (value != state)
                {
                    state = value;
                    OnPropertyChanged("State");
                    OnPropertyChanged("SrcPlayPause");
                }
            }
        }



        private bool bEnd;
        private void refreshLoop()
        {
            while (!bEnd)
            {
                Thread.Sleep(1000);
                refresh();
            }
        }

        private void refresh()
        {
            try
            {

                //  this.IndexList = infos.IndexList;
                var _position = player.Position;
                if (_position != position) { position = _position; OnPropertyChanged("Position"); }

                this.ElapsedTime = player.Elapsed;
                this.Length = player.Duration;

                this.RemainingTime = Length - ElapsedTime;
                if (CurrentTrack == null)
                {
                    CurrentName = "";
                    CurrentAuthorAlbum = "";
                }
                else
                {
                    CurrentName = currentTrack.Name;
                    var sb = new System.Text.StringBuilder();
                    sb.Append(currentTrack.Artist);
                    sb.Append(" - ");
                    sb.Append(currentTrack.Album);
                    if (currentTrack.PieceGen != null)
                    {
                        if (currentTrack.PieceGen.Virtual)
                        {
                            sb.Append(" (");
                            sb.Append(currentTrack.PieceGen.Master.Album);
                            sb.Append(")");
                        }
                    }
                    CurrentAuthorAlbum = sb.ToString();
                    if (currentTrack.Exists)
                        currentTrack.Duration = length;

                }

            }
            catch { }

        }


        public TrackListViewModel CurrentTrack
        {
            get { return currentTrack; }
            set
            {
                if (value != null)
                    value.Playing = true;
                if (value != currentTrack)
                {
                    if (currentTrack != null)
                        currentTrack.Playing = false;
                    currentTrack = value;
                    if (currentTrack == null)
                        stop();
                    if (currentTrackChange != null)
                        currentTrackChange(Instance, EventArgs.Empty);
                }
            }
        }

        public static void reset(ItrackProvider provider, TrackListViewModel track)
        {
            reset(provider, track, true);
        }

        public static void makeauto(TrackListViewModel current)
        {
            if (current != null)
            {
                var p = current.PieceGen;
                if (p != null)
                {
                    Instance.confAlbumSort.auto(p);
                    if (autoChange != null)
                        autoChange(current, EventArgs.Empty);
                }
            }
        }

        public static void reset(ItrackProvider provider, TrackListViewModel track, bool autoPlay)
        {
            if (provider != null)
            {
                Instance.provider = provider;
                Instance.currentPl = provider.PlayList;
                Instance.provider = provider;
                Instance.tracks = provider.PresentationTracks;

            }
            Instance._positionstate = positionstate.free;






            Instance.CurrentTrack = track;
            if (autoPlay)
                Instance.play(true, true);
            Instance.makeResume();
            App.go();
        }


        public PlayListViewModel PlayList
        {
            get
            {
                return currentPl;
            }
        }
        ICollectionView tracks = null;
        public void set(ItrackProvider provider)
        {
            try
            {
                if (provider == null)
                {
                    log.log("provider null");
                    this.provider = null;
                    this.currentPl = null;
                    return;
                }
                else if (this.provider == null)
                {
                    log.log("init provider " + provider);
                    this.provider = provider;
                    this.currentPl = provider.PlayList;
                    this.tracks = provider.PresentationTracks;
                }

                else
                {


                    if (provider.PlayList == currentPl || state == playerstate.stop)
                    {
                        if (isHidden)
                        {
                            log.log("retour au réel");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                            tracks.MoveCurrentTo(TrackListViewModel.CurrentPlaying);
                            provider.Focus(tracks.CurrentPosition);
                        }
                        else
                        {
                            log.log("détection standart");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                        }
                    }

                    else
                    {
                        if (isHidden)
                        {
                            log.log("toujours virtuel");
                        }
                        else
                        {


                            log.log("passage en virtuel");
                            this.provider = new HiddenPlayList(currentPl, tracks);
                            this._real = provider;
                            // this.currentPl = provider.PlayList;
                            //this.tracks = provider.PresentationTracks; 
                        }
                    }
                }

                _positionstate = positionstate.free;
                if (currentPl == null)
                {
                    CurrentTrack = null;
                    stop();
                    return;
                }

            }
            finally
            {
                OnPropertyChanged("State");
                OnPropertyChanged("SrcPlayPause");
                makeResume();
            }
        }
        //  private class filterTask
        //  {
        //      public filterTask()
        //      {
        //      }
        //      public string filter;
        //      //public string waitingFilter; 
        //      //private bool cancel; 
        //      //private Thread th;
        //      public Predicate<object> Filter;
        //      //public ICollectionView coll;
        //      //private bool busy;

        //      public void go()
        //      {

        //          if (!string.IsNullOrEmpty(filter))
        //              filter = filter.Trim().ToLower().removeAccent();

        //          var tab = filter.Split(' ');
        //          // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 
        //          lock (this)
        //              busy = true;
        //          coll.Filter = item =>
        //          {
        //              TrackListViewModel vitem = item as TrackListViewModel;
        //              if (vitem == null) return false;

        //              //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
        //              //    return vitem.Classement.StartsWith(filter);
        //              bool ok = true;
        //              var name = vitem.Name.Trim().ToLower().removeAccent();
        //              var artist = vitem.Artist.Trim().ToLower().removeAccent();
        //              var album = vitem.Album.Trim().ToLower().removeAccent();
        //              var classement = vitem.Classement;
        //              foreach (string str in tab)
        //              {
        //                  if (!ok)
        //                      return false;
        //                  if (string.IsNullOrEmpty(str))
        //                      continue;
        //                  var str_ = str.Trim();
        //                  if (str_ == string.Empty)
        //                      continue;

        //                  ok = name.Contains(str_)
        //                      || artist.Contains(str_)
        //                      || album.Contains(str_)
        //                      || classement.StartsWith(str_);

        //              }

        //              return ok;

        //          };

        //          lock (this)
        //              busy = true;

        //      }
        //      private void getItems()
        //      {
        //          try
        //          {
        //              if (!string.IsNullOrEmpty(filter))
        //                  filter = filter.Trim().ToLower().removeAccent();
        //              if (cancel)
        //                  return;
        //              var tab = filter.Split(' ');
        //              if (cancel)
        //                  return;
        //              Filter = item =>
        //              {
        //                  TrackListViewModel vitem = item as TrackListViewModel;
        //                  if (vitem == null) return false;

        //                  //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
        //                  //    return vitem.Classement.StartsWith(filter);
        //                  bool ok = true;
        //                  var name = vitem.Name.Trim().ToLower().removeAccent();
        //                  var artist = vitem.Artist.Trim().ToLower().removeAccent();
        //                  var album = vitem.Album.Trim().ToLower().removeAccent();
        //                  var classement = vitem.Classement;
        //                  foreach (string str in tab)
        //                  {
        //                      if (!ok)
        //                          return false;
        //                      if (string.IsNullOrEmpty(str))
        //                          continue;
        //                      var str_ = str.Trim();
        //                      if (str_ == string.Empty)
        //                          continue;

        //                      ok = name.Contains(str_)
        //                          || artist.Contains(str_)
        //                          || album.Contains(str_)
        //                          || classement.StartsWith(str_);

        //                  }

        //                  return ok;

        //              };
        //          }
        //          catch (Exception ex)
        //          {
        //              App.log.log(ex.ToString()); 
        //          }
        //      }
        //  }
        ////  private static filterTask filtertask = new filterTask(); 
        private static IDisposable work;
        private static FilterTask filterTask = null;

        private static bool cancel;
        public static void doFilter0(ICollectionView coll, string filter)
        {

            ILogger log = App.log;
            log.log("filter=>{0}", filter);
            lock (_lock)
            {
                if (work == null)
                {
                    log.log("filter=>{0} verrou libre", filter);
                    work = coll.DeferRefresh();
                }
                else
                {
                    log.log("filter=>{0} verrou pris, abandon tâche en cours", filter);
                    cancel = true;
                }
            }

            var _cancel = cancel;
            if (_cancel)
                log.log("filter=>{0} verrou pris, attente fin tâche en cours", filter);
            while (cancel)
                Thread.Sleep(30);

            if (_cancel)
                log.log("filter=>{0} verrou pris, fin d'attente fin tâche en cours", filter);

            if (!string.IsNullOrEmpty(filter))
                filter = filter.Trim().ToLower().removeAccent();

            var tab = filter.Split(' ');
            // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 


            _cancel = cancel;
            if (!_cancel)
            {
                lock (_lock)
                    _cancel = cancel;
            }

            if (!_cancel)
            {
                log.log("filter=>{0} lancement filtre", filter);
                coll.Filter = item =>
                {
                    if (cancel)
                        return false;
                    TrackListViewModel vitem = item as TrackListViewModel;
                    if (vitem == null) return false;



                    //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
                    //    return vitem.Classement.StartsWith(filter);
                    bool ok = true;
                    var name = vitem.Name.Trim().ToLower().removeAccent();
                    var artist = vitem.Artist.Trim().ToLower().removeAccent();
                    var album = vitem.Album.Trim().ToLower().removeAccent();
                    var classement = vitem.Classement;
                    foreach (string str in tab)
                    {
                        if (!ok)
                            return false;
                        if (string.IsNullOrEmpty(str))
                            continue;
                        var str_ = str.Trim();
                        if (str_ == string.Empty)
                            continue;

                        ok = name.Contains(str_)
                            || artist.Contains(str_)
                            || album.Contains(str_)
                            || classement.StartsWith(str_);

                    }

                    return ok;

                };

                if (cancel)
                    log.log("filter=>{0} la tâche a été interrompue", filter);
            }
            else
            {
                log.log("filter=>{0} finalement pas de lancement", filter);
            }
            lock (_lock)
            {
                if (!cancel)
                {
                    if (work != null)
                    {
                        log.log("filter=>{0} application du filtre", filter);
                        work.Dispose();
                    }
                    else
                    {
                        log.log("filter=>{0} ben pourquoa le work était null ????", filter);
                    }
                    work = null;

                }
            }

            lock (_lock)
                cancel = false;

            log.log("filter=>{0} fin", filter);
        }




        private class FilterTask
        {
            public static ConfFilter conf = new ConfFilter();
            private ICollectionView coll;
            public readonly string filter0;
            public readonly bool filterNext; 

            private string filter;
            private bool _cancel;
            private bool end;
            private Thread th;
            SimpleChrono log;
            public string step;
            private HashSet<int> l = new HashSet<int>();
            public FilterTask(string filter, bool filterNext, ICollectionView coll, SimpleChrono log)
            {
                this.filter0 = filter;
                this.filter = filter;
                this.filterNext = filterNext; 

                this.coll = coll;
                this.log = log;
                step = "ini";
                th = new Thread(calc);
                th.Start();
            }

            public void cancel()
            {
                lock (_lock)
                    _cancel = true;
            }

            public bool End { get { return end; } }
            public bool Cancel { get { return _cancel; } }

            private void calc()
            {
                step = "calc";
                try
                {
                    if (!string.IsNullOrEmpty(filter))
                        filter = filter.Trim().ToLower().removeAccent();
                    if (string.IsNullOrWhiteSpace(filter) && !filterNext)
                    {
                        apply();
                        return;
                    }

                    var tab = filter.Split(' ');

                    int nb = 0;
                    int nbOk = 0;

                    foreach (TrackListViewModel vitem in coll.SourceCollection)
                    {
                        if (_cancel)
                            return;

                        if (filterNext && !vitem.PieceGen.IsNext)
                            continue;
                        if (!filterNext)
                        {
                            if (vitem.PieceGen.Virtual && !conf.includeVirtual)
                                continue;
                            if (vitem.PieceGen.VirtualByArtist && !conf.includeVirtualArtist)
                                continue;
                        }



                        bool ok = true;

                        if (conf.onlyId)
                        {
                            ok = filter == vitem.PieceId.ToString();
                        }
                        else
                        {

                            var name = vitem.Name.Trim().ToLower().removeAccent();
                            var artist = vitem.Artist.Trim().ToLower().removeAccent();
                            var album = vitem.Album.Trim().ToLower().removeAccent();
                            var classement = vitem.Classement;
                            foreach (string str in tab)
                            {
                                if (ok)
                                {
                                    if (string.IsNullOrEmpty(str))
                                        continue;
                                    var str_ = str.Trim();
                                    if (str_ == string.Empty)
                                        continue;

                                    ok = name.Contains(str_)
                                        || artist.Contains(str_)
                                        || album.Contains(str_)
                                        || classement.StartsWith(str_)
                                        || (conf.includeId && str == vitem.PieceId.ToString())
                                        ;
                                }
                                else
                                    break;

                            }
                        }


                        nb++;
                        if (ok)
                        {
                            if (conf.family)
                            {
                                foreach (Piece p in vitem.PieceGen.Master)
                                {
                                    if (!filterNext)
                                    {
                                        if (p.Virtual && !conf.includeVirtual)
                                            continue;
                                        if (p.VirtualByArtist && !conf.includeVirtualArtist)
                                            continue;
                                    }
                                    l.Add(p.PieceId);
                                }
                            }
                            else
                                l.Add(vitem.PieceId);

                            nbOk++;
                        }
                    }

                    log.log(string.Format("{0}/{1}", nbOk, nb));
                    // log.log(string.Format("calc:{0} item{1} {2} sélectionné{3}", nb, (nb > 1 ? "s" : ""), nbOk, (nbOk > 1 ? "s" : "")));   

                    lock (_lock)
                    {
                        if (_cancel)
                            return;
                    }


                    apply();


                }
                finally
                {
                    if (_cancel)
                    {
                        lock (_lock)
                            end = true;
                        log.log("tache terminée par cancel");
                    }
                }





            }

            public void apply()
            {
                step = "apply";

                bool __cancel = _cancel;

                if (!__cancel)
                {
                    lock (_lock)
                        __cancel = _cancel;
                }
                if (Dispatcher.CurrentDispatcher == App.Current.Dispatcher)
                {
                    if (string.IsNullOrWhiteSpace(filter) && ! filterNext)
                    {
                        coll.Filter = null;
                        return;
                    }

                    if (__cancel)
                        return;
                    step = "applyAppDispatcher";
                    try
                    {



                        if (work == null)
                        {
                            log.log("creation du tempo");
                            work = coll.DeferRefresh();
                        }
                        else
                        {
                            log.log("tempo déjà créé ");

                        }


                        coll.Filter = item =>
                        {
                            if (_cancel)
                                return false;

                            var t = item as TrackListViewModel;
                            if (t == null)
                                return false;
                            if (!l.Contains(t.PieceId))
                                return false;
                            return true;
                        };




                        if (!__cancel)
                        {
                            log.log("application");
                            work.Dispose();
                            work = null;
                            log.log("fin application");
                        }
                        else
                        {
                            log.log("abandon application");
                        }
                    }
                    finally
                    {
                        lock (_lock)
                            end = true;
                        log.log("tache terminée par application");
                    }
                }
                else
                {
                    App.Current.Dispatcher.BeginInvoke(new Action(apply), DispatcherPriority.Background);
                }
            }

            public override string ToString()
            {
                return string.Format("en cours:{0} step:{1} end:{2} cancel:{3}", filter0, step, End, Cancel);
            }

        }


        public static void doFilter(ICollectionView coll, string filter)
        {
            SimpleChrono log = new SimpleChrono(string.Format("\tfilter=>{0}\t", filter), App.log);

            log.log("");
            lock (_lock)
            {
                bool _cancelCurrent = false;
                bool _same = false;

                if (filterTask != null)
                {
                    log.log(filterTask.ToString());
                }

                _cancelCurrent = filterTask != null && !filterTask.End;
                _same = _cancelCurrent && filterTask.filter0.Equals(filter) && filterTask.filterNext == Instance.FilterNext;
                if (_same)
                {
                    log.log("identique");
                    return;
                }
                else if (_cancelCurrent)
                {
                    log.log("abandon tâche en cours");
                    filterTask.cancel();
                }

                else
                {
                    log.log("verrou libre");
                }

                filterTask = new FilterTask(filter,Instance.filterOnlyNext, coll, log);

            }





        }



        //public void set(ItrackProvider provider)
        //{
        //    try
        //    {
        //        if (provider == null)
        //        {
        //            this.provider = null;
        //            this.currentPl = null;
        //            return;
        //        }
        //        else if (this.provider == null)
        //        {
        //            this.provider = provider;
        //            this.currentPl = provider.PlayList;
        //            this.tracks = provider.PresentationTracks;
        //        }

        //        else
        //        {
        //            if (provider.PlayList == currentPl || state == playerstate.stop)
        //            {
        //                this.provider = provider;
        //                this.currentPl = provider.PlayList;
        //                this.tracks = provider.PresentationTracks;
        //            }

        //            else
        //            {
        //                if (_real == null || _real.PlayList != provider.PlayList)
        //                {
        //                    this.provider = new HiddenPlayList(currentPl, tracks);
        //                    this._real = provider;
        //                }
        //                else
        //                {
        //                    this.provider = _real;
        //                }
        //            }
        //        }

        //        _positionstate = positionstate.free;
        //        if (currentPl == null)
        //        {
        //            CurrentTrack = null;
        //            stop();
        //            return;
        //        }

        //    }
        //    finally
        //    {
        //        OnPropertyChanged("State");
        //        OnPropertyChanged("SrcPlayPause");
        //    }
        //}


        public void doFilter(String filter)
        {
            var provider = DisplayProvider;

            if (provider == null)
                return;
            provider.doFilter(filter);
            makeResume();
        }

        private ItrackProvider DisplayProvider
        {
            get
            {
                if (provider == null)
                    return null;
                if (isHidden && _real != null)
                {
                    return _real;
                }
                return provider;
            }
        }

        private string resume;

        public void makeResume()
        {
            string newResume = resume;
            try
            {

                IEnumerable items = null;
                var provider = DisplayProvider;
                if (provider == null)
                    return;
                var tracks = provider.PresentationTracks;
                int nbOrg = -1;
                items = tracks;
                if (items == null)
                    return;

                var selected = provider.SelectedTracks;
                if (selected.Count > 1)
                {
                    items = selected;
                    nbOrg = 0;
                    foreach (TrackListViewModel t in tracks)
                        nbOrg++;
                }
                int nb = 0, nbSelected = 0, nbPresent = 0;
                TimeSpan duration = new TimeSpan(), durationSelected = new TimeSpan(), durationPresent = new TimeSpan();
                HashSet<int> h = new HashSet<int>();

                foreach (TrackListViewModel track in items)
                {
                    if (!h.Add(track.PieceGen.MasterId))
                        continue;
                    nb++;
                    duration += track.Duration;
                    if (track.Enabled)
                    {
                        nbSelected++;
                        durationSelected += track.Duration;
                    }
                    if (track.Exists)
                    {
                        nbPresent++;
                        durationPresent += track.Duration;
                    }
                }

                ITextWriter sb = new pdb.util.StringBuilder();
                sb.Append(nb);
                sb.Append(" ");
                sb.Append("elt");
                if (nb > 1)
                    sb.Append("s");
                if (nbOrg >= 0)
                {
                    sb.Append(" sur ");
                    sb.Append(nbOrg);
                    sb.Append(",");
                }
                sb.Append(" ");
                humanDuration(sb, duration);
                sb.Append(" ( ");
                sb.Append(nbSelected);
                sb.Append(" ");
                sb.Append("elt");
                if (nbSelected > 1)
                    sb.Append("s");
                sb.Append(" ");
                humanDuration(sb, durationSelected);

                sb.Append(" )");

                if (nbPresent > 0)
                {
                    sb.Append(" presents: ");
                    sb.Append(nbPresent);
                    sb.Append(" ");
                    sb.Append("elt");
                    if (nb > 1)
                        sb.Append("s");
                    sb.Append(" ");
                    humanDuration(sb, durationPresent);
                }
                sb.Append("\t");

                var currentTrack = TrackListViewModel.HumanSelected;
                if (currentTrack != null)
                {
                    humanSize(sb, currentTrack.Size);
                    sb.Append(" ");
                    sb.Append(currentTrack.Location);
                }

                newResume = sb.ToString();
            }
            catch (Exception e0)
            {
                App.log.log(e0.ToString());
            }
            finally
            {
                if (newResume != resume)
                {
                    resume = newResume;
                    if (resumeChange != null)
                    {
                        try
                        {
                            resumeChange(this, EventArgs.Empty);
                        }
                        catch (Exception ex)
                        {
                            App.log.log(ex.ToString());
                        }
                    }
                }
            }
        }

        public string Resume
        {
            get
            {
                //if (resume == null)
                //    makeResume();
                return resume;
            }
        }

        private void humanSize(ITextWriter sb, long size)
        {
            sb.Append(size.HumanReadableSize(-1));
        }

        private void humanDuration(ITextWriter sb, TimeSpan duration)
        {
            TimeSpan courant = duration;
            TimeSpan reste = new TimeSpan();
            TimeSpan ts = new TimeSpan();
            double days = duration.TotalDays;
            int idays = (int)days;

            double hours = duration.TotalHours;
            int ihours = (int)hours;


            if (days >= 1)
            {
                ts = new TimeSpan(idays, 0, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(idays);
                sb.Append("j");
                //if (idays > 1)
                //    sb.Append("s");

                hours = reste.TotalHours;
                ihours = (int)hours;

                if (ihours == 0)
                    return;
                sb.Append(" ");
                sb.Append(ihours);
                sb.Append("h");
                //if (ihours > 1)
                //    sb.Append("s");
                return;
            }

            double mins = duration.TotalMinutes;
            int imins = (int)mins;

            if (hours > 1)
            {
                ts = new TimeSpan(ihours, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(ihours);
                sb.Append("h");
                //if (ihours > 1)
                //    sb.Append("s");

                mins = reste.TotalMinutes;
                imins = (int)mins;

                if (imins == 0)
                    return;
                sb.Append(" ");
                sb.Append(imins);
                sb.Append("m");
                //if (imins > 1)
                //    sb.Append("s");
                return;

            }

            ts = new TimeSpan(0, imins, 0);
            reste = courant.Subtract(ts);
            sb.Append(imins);
            sb.Append("m");
            //if (imins > 1)
            //    sb.Append("s");

            double secs = reste.TotalSeconds;
            int isec = (int)secs;


            if (isec == 0)
                return;
            sb.Append(" ");
            sb.Append(isec);
            sb.Append("s");
            //if (imins > 1)
            //    sb.Append("s");
            return;



        }

        # region infos

        private bool transitionState = false;
        public bool TransitionState { set { transitionState = value; OnPropertyChanged("SrcPlayPause"); } }

        public String SrcPlayPause
        {
            get
            {
                if (isHidden)
                    return @"images\Toolbar-MP3-Stop-icon.png";
                if (state != playerstate.play)
                    return @"images\Toolbar-MP3-Play-icon.png";
                return @"images\Toolbar-MP3-Pause-icon.png";
            }
        }


        //private int indexList = -1;
        //public int IndexList
        //{
        //    get { return indexList; }
        //    set
        //    {
        //        if (value != indexList)
        //        {
        //            indexList = value;
        //            this.OnPropertyChanged("IndexList");
        //        }
        //    }
        //}

        private double position = 0;
        public double Position
        {
            get
            {

                return position;
            }
            set
            {
                if (value != position)
                {
                    position = value;
                    player.Position = value;
                    this.OnPropertyChanged("Position");
                }
            }
        }

        private String currentName;
        public String CurrentName
        {
            get { return currentName; }
            set
            {
                if (value != currentName)
                {
                    currentName = value;
                    this.OnPropertyChanged("CurrentName");
                }
            }
        }

        private double volume = 0.5;
        public double Volume
        {
            get { return volume; }
            set
            {
                if (value != volume)
                {
                    volume = value;
                    player.Volume = value;
                    OnPropertyChanged("Volume");
                }
            }
        }


        private String currentAuthorAlbum;
        public String CurrentAuthorAlbum
        {
            get { return currentAuthorAlbum; }
            set
            {
                if (value != currentAuthorAlbum)
                {
                    currentAuthorAlbum = value;
                    this.OnPropertyChanged("CurrentAuthorAlbum");
                }
            }
        }

        private TimeSpan sinceBeginReadTrack;
        public TimeSpan ElapsedTime
        {
            get { return sinceBeginReadTrack; }
            set
            {
                if (value != sinceBeginReadTrack)
                {
                    sinceBeginReadTrack = value;
                    this.OnPropertyChanged("ElapsedTime");
                }
            }
        }

        private TimeSpan remainingTime;
        public TimeSpan RemainingTime
        {
            get { return remainingTime; }
            set
            {
                if (value != remainingTime)
                {
                    remainingTime = value;
                    this.OnPropertyChanged("RemainingTime");
                }
            }
        }

        private TimeSpan length;
        public TimeSpan Length
        {
            get { return length; }
            set
            {
                if (value != length && value > TimeSpan.FromMilliseconds(100))
                {
                    length = value;
                    this.OnPropertyChanged("Length");
                }
            }
        }
        #endregion
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\Commande\PlayList\ExportCmd.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using pdb.db;
using pdb.db.obj;
using pdb.gen;
using pdb.util;
using pdb.gen.Tuning;
using System.Runtime.InteropServices;
using pdb.gen.albums;
using pdb.obj;

namespace pdb.player.ViewModel.Commande.PlayList
{
    class StatAlbum
    {
        private string key;
        private int count;

        public void clear()
        {
            count = 0;
        }

        public StatAlbum(string key)
        {
            this.key = key;
        }

        public override bool Equals(object obj)
        {
            if (obj is StatAlbum)
            {
                return key.Equals(((StatAlbum)obj).key);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return key.GetHashCode();
        }

        public int Count { get { return count; } }
        public void record()
        {
            count++;
        }
    }

    class StatAlbums
    {
        private BgDictString0<StatAlbum> dict = new BgDictString0<StatAlbum>();

        public void clear()
        {
            foreach (var stat in dict)
            {
                stat.Value.clear();
            }
        }

        public StatAlbum getStat(Album album)
        {
            var key = album.Key;
            var s = dict[key];
            if (s == null)
            {
                s = new StatAlbum(key);
                dict.Add(key, s);
            }
            return s;
        }
    }


    public enum compressState
    {
        none,
        record,
        enCours,
        end,
        reload,
        cancel
    }
    class ExportCmd : CommandeBase
    {
        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool GetDiskFreeSpaceEx(string lpDirectoryName,
        out ulong lpFreeBytesAvailable,
        out ulong lpTotalNumberOfBytes,
        out ulong lpTotalNumberOfFreeBytes);

        private static long getFreeSpace()
        {
            ulong FreeBytesAvailable;
            ulong TotalNumberOfBytes;
            ulong TotalNumberOfFreeBytes;

            bool success = GetDiskFreeSpaceEx(conf.dir, out FreeBytesAvailable, out TotalNumberOfBytes,
                               out TotalNumberOfFreeBytes);
            if (!success)
                throw new System.ComponentModel.Win32Exception();
            return (long)TotalNumberOfFreeBytes;
        }



        private static IExportTracks ihm;
        public static IExportTracks Ihm { set { ihm = value; } }
        // private static bool cancel;
        // protected static string dir;
        protected static PlayListViewModel lastpl;
        protected static List<PiecePrior> presents;
        protected static Dict<int, PiecePrior> dict;
        protected static List<PiecePrior> list;
        protected static List<List<PiecePrior>> listes;
        protected static List<PlayListViewModel> playlists = new List<PlayListViewModel>();
        protected static StatAlbums statAlbums = new StatAlbums();

        //  protected static Dictionary<int, object> ids;
        protected static HashSet<int> idCopie;
        protected static HashSet<string> idCopieLoc;
        private static int nbLoop = 0;
        protected static Export conf;
        private static bool modeAlbum;
        //private static int nbByAlbumMin = int.MaxValue;
        //private static int nbByAlbumMax = int.MaxValue;
        //private static int nbLot = 100; 
        protected static int nbFicherSup;
        protected static int nbFichierAdd;
        const string CAPTION = "export";
        protected string ANNULATION_EXPORT = "Annulation export";

        //protected static BgDictString<List<PiecePrior>> locations = new BgDictString<List<PiecePrior>>();

        protected static ILogger logger = Logger.getLogger("export");

        protected static compressState state;
        public static void CalculExport()
        {
            if (conf != null && conf.oneShot)
                return;
            switch (state)
            {
                case compressState.none:
                    break;
                case compressState.record:
                    break;
                case compressState.enCours:
                    PlayListViewModel.resetExport(exportState.none);
                    state = compressState.reload;
                    break;
                case compressState.end:
                    state = compressState.reload;
                    break;
                case compressState.reload:
                    break;
                case compressState.cancel:
                    break;
                default:
                    break;
            }
        }

        protected class PiecePrior
        {
            private int prior0 = int.MaxValue;
            private int prior1 = int.MaxValue;
            public readonly Piece PieceGen;
            public PiecePrior(Piece piece, int prior)
            {
                this.PieceGen = piece;
                this.prior0 = prior;
            }

            public CListFile Files { get { return( PieceGen.Track as CPiece).Files; } }

            public int Prior0 { get { return prior0; } }
            public int Prior1 { get { return prior1; } }
           // public int MasterId { get { return Piece.MasterId; } }
            public int PieceId { get { return PieceGen.PieceId; } }
            public void setPrior(int prior)
            {
                if (prior < this.prior1)
                    this.prior1 = prior;
            }

            public static void mergePrior0(ICollection<PiecePrior> list)
            {
                if (list.Count <= 1)
                    return;
                int min = int.MaxValue;
                foreach (PiecePrior p in list)
                {
                    var p0 = p.prior0;
                    if (p0 < min)
                        min = p0;
                }
                foreach (PiecePrior p in list)
                {
                    p.prior0 = min;
                }
            }

            public static void mergePrior1(ICollection<PiecePrior> list)
            {
                if (list.Count <= 1)
                    return;
                int min = int.MaxValue;
                foreach (PiecePrior p in list)
                {
                    var p1 = p.prior1;
                    if (p1 < min)
                        min = p1;
                }
                foreach (PiecePrior p in list)
                {
                    p.prior0 = min;
                }
            }

            public override string ToString()
            {
                int rank = PieceGen.RankAlbumReverse;
                int nb = PieceGen.NbExportPresents;
                return string.Format("{0} {1} {2}\t {3} {4} {5}", rank, nb, PieceGen.TrackNumber, prior0, prior1, PieceGen.ToString());
                //  return rank + " " + PieceGen.TrackNumber + "\t" + prior0 + " " + prior1 + " " + PieceGen.ToString();
            }
        }

        protected class PriorComparer : IComparer<PiecePrior>
        {
            public int Compare(PiecePrior x, PiecePrior y)
            {
                int cmp = x.Prior1.CompareTo(y.Prior1);
                if (cmp != 0)
                    return cmp;
                return x.Prior0.CompareTo(y.Prior0);
            }
        }

        public ExportCmd()
        {

        }


        public override bool CanExecute(object parameter)
        {
            return ihm != null;
        }

        public override void Execute(object parameter)
        {
            if (state <= compressState.record)
                record();
            else
            {
                state = compressState.cancel;
                PlayListViewModel.resetExport(exportState.none);
            }
            OnPropertyChanged("Header");
        }
        private class TrackAlbumReverseComparer : IComparer<TrackListViewModel>
        {
            //  private static PieceClassementComparerInv comparer = new PieceClassementComparerInv();
            //private bool disabledAlway;

            //public TrackAlbumReverseComparer(bool disabledAlway)
            //{
            //    this.disabledAlway = disabledAlway; 
            //}

            public int Compare(TrackListViewModel x, TrackListViewModel y)
            {
                var xx = x.PieceGen;
                var yy = y.PieceGen;
                if (xx.PieceAlbum != yy.PieceAlbum)
                    return x.Index.CompareTo(y.Index);

                return xx.IndexExport.CompareTo(yy.IndexExport);

                //if (disabledAlway)
                //{
                //    if (x.Enabled != y.Enabled)
                //    {
                //        return -x.Enabled.CompareTo(y.Enabled); // ? -1 : 1;
                //    }
                //}
                //var xv = x.PieceGen.RapportClassement;
                //var yv = y.PieceGen.RapportClassement;

                //int cmp = 0;
                //if (xv > 0 && yv > 0)
                //{
                //    cmp = xv.CompareTo(yv);
                //    if (cmp != 0) return cmp;
                //    cmp = x.PieceGen.VirtualClassement.CompareTo(y.PieceGen.VirtualClassement);
                //    if (cmp != 0) return cmp;
                //}

                //cmp = x.TrackNumber.CompareTo(y.TrackNumber);
                //if (cmp != 0)
                //    return cmp;
                //return x.Location.CompareTo(y.Location);

            }
        }
        protected virtual List<PiecePrior> buildList(PlayListViewModel pl)
        {
          
            var list = new List<PiecePrior>();
            try
            {
                bool onlyEnabled = PlayerViewModel.Instance.OnlyEnabled && !modeAlbum;
                bool _modeAlbum = modeAlbum && !PlayerViewModel.Instance.SortByAlbum;

                // var ids = new Dictionary<int, object>();
                int i = 0;
                var tracks = new List<TrackListViewModel>(pl.ExportTracks);
                logger.log("export::buildList {0} {1} elements", pl, tracks.Count);
                if (conf.albumReverse)
                {
                    tracks.Sort(new TrackAlbumReverseComparer()); //conf.disabledAlway));

                }
                else
                    tracks.Sort((x, y) => x.Index.CompareTo(y.Index));

                int lastI = 0;
                Album lastAlbum = null;
                StatAlbum lastStatAlbum = null;
                //  int inext = -1; 
                int nbByAlbum = int.MaxValue;
                int limitMax = int.MaxValue;
                if (conf.modeAlbum)
                {
                    nbByAlbum = conf.nbMax;
                    limitMax = conf.limitMax;
                    if (limitMax < nbByAlbum)
                        limitMax = nbByAlbum;
                }
                int nbLot = 0;
                int ii = -1; 
            //   var ids = new HashSet<int>();
                while (true)
                {
                    int nbInThisAlbum = 0;
                    foreach (TrackListViewModel track in tracks)
                    {
                        ii++;
                        //  track.ExportStatus = exportState.miss; 
                        if (!onlyEnabled || track.Enabled)
                        {
                            // CPiece piece = track.Piece;
                            if (track.Exists)
                            {
                                if (track.Album == @"\500\201 - 300\225 # 1998 - Hank Williams - The Complete Hank Williams\CD3")
                                {
                                }

                                //int id = piece.MasterId;
                                //if (ids.ContainsKey(id))
                                //    continue;
                                int id = track.PieceGen.PieceId;
                                var pp = dict[id]; // list.Add(piece);
                                if (pp == null)
                                {
                                    pp = new PiecePrior(track.PieceGen, ii);
                                    dict[id] = pp; 
                                }
                                //if (ids.Contains(id))
                                //    continue;
                                if (!_modeAlbum)
                                {
                                    if (track.album == lastAlbum)
                                    {
                                        if (lastStatAlbum.Count > limitMax)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;
                                        if (track.Enabled || (conf.countFirsts && track.PieceGen.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && track.PieceGen.VirtualClassement <= lastAlbum.ClassementValueLight))
                                            nbInThisAlbum++;
                                        else if (nbInThisAlbum >= nbByAlbum)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;
                                    }
                                    else
                                    {
                                        nbInThisAlbum = 0;
                                        lastAlbum = track.album;// inext = lastAlbum.IndexClass(lastAlbum.Next);
                                        lastStatAlbum = statAlbums.getStat(lastAlbum);
                                        if (lastStatAlbum.Count > limitMax)
                                            continue;

                                        if (track.Enabled || (conf.countFirsts && track.PieceGen.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && track.PieceGen.VirtualClassement <= lastAlbum.ClassementValueLight))
                                            nbInThisAlbum++;
                                        else if (nbInThisAlbum >= nbByAlbum)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;

                                    }
                                   
                                    pp.setPrior(i);
                                    list.Add(pp);
                                    lastStatAlbum.record();
                                  //  ids.Add(id);
                                    i++;

                                    //  if (track.Enabled || conf.countAll)
                                    nbLot++;

                                    if (conf.modeAlbum && nbLot > conf.lot)
                                    {
                                        nbLot = 0;
                                        nbByAlbum--;
                                        if (nbByAlbum < conf.nbMin)
                                            nbByAlbum = conf.nbMin;
                                        if (nbByAlbum == 0)
                                            break;

                                        limitMax = conf.limitMax;
                                        if (limitMax < nbByAlbum)
                                            limitMax = nbByAlbum;

                                    }


                                }
                                else
                                {
                                    if (conf.modeAlbum)
                                    {
                                        if (track.album == lastAlbum)
                                            continue;
                                        else
                                        {
                                            nbLot++;
                                            if (nbLot > conf.lot)
                                            {
                                                nbLot = 0;
                                                nbByAlbum--;
                                                if (nbByAlbum < conf.nbMin)
                                                    nbByAlbum = conf.nbMin;
                                                if (nbByAlbum == 0)
                                                    break;

                                                limitMax = conf.limitMax;
                                                if (limitMax < nbByAlbum)
                                                    limitMax = nbByAlbum;
                                            }
                                        }
                                    }
                                    List<Piece> album = null;
                                    if (conf.albumReverse)
                                        album = App.gen.getTracksAlbumReverse(track.Track);
                                    else
                                        album = App.gen.getTracksAlbumByNumber(track.Track); // piece);
                                    if (album != null)
                                    {
                                        nbInThisAlbum = 0;
                                        lastAlbum = track.album;// inext = lastAlbum.IndexClass(lastAlbum.Next);  //.Album;
                                        foreach (var p in album)
                                        {
                                            var piece = p.Track as CPiece; 
                                            if (piece != null && piece.Exists)
                                            {
                                                if (!onlyEnabled || piece.Enabled)
                                                {
                                                    id = p.PieceId;

                                                    //if (ids.Contains(id))
                                                    //    continue;
                                                    var ppp = dict[id];
                                                    ppp.setPrior(i);
                                                    list.Add(ppp);
                                                 //   ids.Add(id);
                                                    i++;
                                                    if (piece.Enabled || (conf.countFirsts && p.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && p.VirtualClassement <= lastAlbum.ClassementValueLight))
                                                    {
                                                        nbLot++;
                                                        if (conf.modeAlbum && nbLot > conf.lot)
                                                        {
                                                            nbLot = 0;
                                                            nbByAlbum--;
                                                            if (nbByAlbum < conf.nbMin)
                                                                nbByAlbum = conf.nbMin;

                                                            limitMax = conf.limitMax;
                                                            if (limitMax < nbByAlbum)
                                                                limitMax = nbByAlbum;
                                                        }

                                                        nbInThisAlbum++;
                                                        if (nbInThisAlbum >= nbByAlbum)
                                                            break;
                                                    }
                                                }
                                            }

                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (!modeAlbum)
                        break;
                    if (nbByAlbum == int.MaxValue)
                        break;
                    if (nbByAlbum > 0)
                    {
                        if (i == lastI)
                            break;
                    }

                    lastI = i;
                    lastAlbum = null;
                    if (conf.modeAlbum)
                    {
                        if (conf.resetAfterLoop)
                            nbByAlbum = conf.nbMax;
                        if (nbByAlbum < conf.nbMin)
                            nbByAlbum = conf.nbMin;
                        if (nbByAlbum == 0)
                            nbByAlbum = 1;

                        limitMax = conf.limitMax;
                        if (limitMax < nbByAlbum)
                            limitMax = nbByAlbum;
                    }
                }
                listes.Add(list);
                //   ihm.InfoIHm("liste n° " + listes.Count + " " + list.Count + " éléments", CAPTION);
                OnPropertyChanged("Header");
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
            return list;
        }

        public override string Header
        {
            get
            {
                if (state > compressState.record)
                    return ANNULATION_EXPORT;

                return "Exporter la liste";
            }
        }



        private void record()
        {
            if (state == compressState.none)
            {
                state = compressState.record;
                OnPropertyChanged("Header");
                nbLoop = 0;
                conf = ihm.getConfExport("Configuration Export");

                //  dir = conf.dir; // ihm.folderDialog();

                if (string.IsNullOrEmpty(conf.dir))
                {
                    state = compressState.none;
                    return;
                }

                modeAlbum = conf.modeAlbum; // ihm.Confirm("par albums complets?", CAPTION);

                //if (modeAlbum)
                //{
                //    nbByAlbumMin = conf.nbMin; // ihm.getNb("Nombre de morceaux par passe?");
                //    nbByAlbumMax = conf.nbMax;
                //    nbLot = conf.lot;
                //}
                //else
                //    nbByAlbum = int.MaxValue;

                playlists.Clear();
            }

            bool? status = true;


            var pl = ihm.PlayList;
            if (!playlists.Contains(pl))
            {
                playlists.Add(pl);
                lastpl = pl;
            }

            status = ihm.TriChoix("liste n° " + playlists.Count + " " + pl.ExportTracks.Count + " éléments\r\n lancer l'export ?", CAPTION);



            if (status == null)
            {
                listes = null;
                playlists.Clear();
                state = compressState.none;
                OnPropertyChanged("Header");
                return;
            }
            if (false.Equals(status))
            {
                OnPropertyChanged("Header");
                return;
            }

            state = compressState.enCours;
            OnPropertyChanged("Header");

            var th = new Thread(export__);
            th.SetApartmentState(ApartmentState.STA);
            th.Start();
        }
        //protected static long totalSize = 0;
        //protected static long capacity = int.MaxValue;
        //protected static long freeSpace; 
        //private static void refreshInfoFreeSpace()
        //{
        //    DriveInfo drive = new DriveInfo(Path.GetPathRoot(conf.dir));
        //    var calculfree = freeSpace; 
        //    freeSpace = drive.AvailableFreeSpace;
        //    var delta = freeSpace - calculfree;
        //    if (delta > 0)
        //        App.log.log("difference free space " + delta); 

        //}

        private void buildListIni()
        {

            logger.log("export:buildListIni");
            statAlbums.clear();
            listes = new List<List<PiecePrior>>();
            presents = new List<PiecePrior>();
            dict = new Dict<int, PiecePrior>();
            //  locations = new BgDictString<List<PiecePrior>>();

            try
            {

                if (!conf.dir.EndsWith("\\"))
                    conf.dir += "\\";
                //  refreshInfoFreeSpace(); 

                List<Piece> l = null;


                if (lastpl.isSubList("album") || PlayerViewModel.Instance.SortByAlbum)
                {
                    l = App.gen.sortByAlbum();
                    l.Reverse();
                }
                else
                    l = App.gen.sortByClass();
                // l.Reverse();

                int i = 0;
                foreach (Piece p in l)
                {
                    //var piece = p.Track as CPiece;
                    if (!dict.ContainsKey(p.PieceId))
                    {
                        var pp = new PiecePrior(p, i);
                        i++;
                        presents.Add(pp);
                        dict[p.PieceId] = pp;

                        //var piece = p.Track as CPiece;
                        //foreach (CFile file in piece.Files)
                        //{
                        //    var lp = locations[file.File];
                        //    if (lp == null)
                        //    {
                        //        lp = new List<PiecePrior>();
                        //        lp.Add(pp);
                        //        locations.Add(file.File, lp);
                        //    }
                        //    else
                        //    {
                        //        lp.Add(pp);
                        //        PiecePrior.mergePrior0(lp);
                        //    }
                        //}

                    }
                }
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }

        }

        [STAThread]
        private void export__()
        {


            while (true)
            {
                try
                {
                    switch (state)
                    {
                        case compressState.none:
                            return;
                        case compressState.enCours:
                            break;
                        case compressState.end: Thread.Sleep(1000); continue;
                        case compressState.reload:
                            break;
                        case compressState.cancel:
                            {
                                state = compressState.none;
                                nbLoop = 0;
                                return;
                            }

                        default:
                            break;
                    }
                    state = compressState.enCours;
                    nbLoop++;


                    buildListIni();

                    foreach (PlayListViewModel pl in playlists)
                    {
                        buildList(pl);
                    }

                    //foreach (List<PiecePrior> lp in locations.Values)
                    //{
                    //    PiecePrior.mergePrior1(lp);
                    //}

                    // concaténation
                    int max = 0;
                    list = new List<PiecePrior>();
                    foreach (var _l in listes)
                    {
                        var count_ = _l.Count;
                        if (count_ > max)
                            max = count_;
                    }
                    int count = listes.Count;


                    for (int i = 0; i < max; i++)
                    {
                        for (int j = 0; j < count; j++)
                        {
                            var l = listes[j];
                            if (i < l.Count)
                            {
                                var p = l[i];
                                list.Add(p);
                            }
                        }
                    }






                    App.log.log("Export lancé " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments", CAPTION);
                    _export();
                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                    Thread.Sleep(1000);
                }

            }
        }

        protected virtual bool noMoreSpace()
        {
            return true;
        }
        protected virtual void prepareExport()
        {
        }

        protected void setExport(exportState state, PiecePrior p)
        {
            setExport(state, p.PieceGen);
        }

        protected void setExport(exportState state, ITrackNativeDates p)
        {
            p.ExportStatus = state;
            PlayListViewModel.setExport(p.PieceId, state);


            var h = TrackListViewModel.HumanSelected;
            if (h != null)
            {
                if (p.Album == h.Album)
                {
                    TrackListViewModel trackAlbum = PlayListViewModel.findTrack(App.bib.Musique, p.PieceId);
                    if (trackAlbum != null)
                    {
                        trackAlbum.ExportStatus = state;
                    }

                }
            }

            //var track = PlayListViewModel.findTrack(lastpl, p.PieceId);
            //if (track != null)
            //{
            //    track.ExportStatus = state;
            //}
            //var h = TrackListViewModel.HumanSelected;
            //if (h != null)
            //{
            //    if (p.Album == h.Album)
            //    {
            //        var album = App.getAlbum(h);
            //        var f = album.Find(t => t.PieceId == p.PieceId);
            //        if (f != null)
            //            track.ExportStatus = state;
            //    }
            //  }
        }

        private void _export()
        {

            PlayListViewModel.resetExport(exportState.none);
            try
            {
                foreach (PiecePrior piece in list)
                {
                    //if (piece.PieceGen.Album == @"\500\201 - 300\225 # 1998 - Hank Williams - The Complete Hank Williams\CD3")
                    //{
                    //}
                    try
                    {
                        if (state != compressState.enCours)
                            return;
                        //1. Vérification que le fichier n'existe pas déjà 
                        bool exists = false;
                        var files = piece.Files;
                        foreach (CFile file in files)
                        {
                            if (state != compressState.enCours)
                                return;
                            try
                            {
                                string path = conf.dir + file.File;
                                var fv = FileRegister.Check(path);
                                if (fv.Exists)
                                {
                                    if (fv.Length == file.Size)
                                    {
                                        exists = true;
                                        break;
                                    }
                                    else
                                    {
                                        fv.delete();
                                    }
                                }
                            }

                            catch
                            {
                            }
                        }



                        if (exists)
                        {
                            setExport(exportState.present, piece);
                            // PlayListViewModel.setExport(piece.Piece.PieceId, exportState.present);
                            //var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                            //if (track != null)
                            //{
                            //    track.ExportStatus = exportState.present;
                            //}
                        }
                        else
                            setExport(exportState.miss, piece);
                    }
                    catch (Exception e)
                    {
                        App.log.log(e.ToString());
                    }
                }

                nbFicherSup = 0; nbFichierAdd = 0;
                idCopie = new HashSet<int>();
                idCopieLoc = new HashSet<string>();
                presents.Sort(new PriorComparer());
                prepareExport();

                string orgDir = CFile.DefaultFolder;
                foreach (PiecePrior piece in list)
                {
                    try
                    {
                        if (state != compressState.enCours)
                            return;

                        int id = piece.PieceId;
                        if (idCopie.Contains(id))
                            continue;
                        var files = piece.Files;
                        bool contFile = false;
                        foreach (CFile file in files)
                        {
                            if (idCopieLoc.Contains(file.File))
                            {
                                contFile = true;
                                break;
                            }
                        }
                        if (contFile)
                            continue;

                        idCopie.Add(id); // idCopie[id] = piece;
                        foreach (CFile file in files)
                        {
                            idCopieLoc.Add(file.File); // [file.File] = piece;
                        }




                        //1. Vérification que le fichier n'existe pas déjà 
                        bool exists = false;
                        foreach (CFile file in files)
                        {
                            if (state != compressState.enCours)
                                return;
                            try
                            {
                                string path = conf.dir + file.File;
                                var fv = FileRegister.Check(path);
                                if (fv.Exists)
                                {

                                    if (fv.Length == file.Size)
                                    {
                                        exists = true;
                                        break;
                                    }
                                    else
                                    {
                                        fv.delete();
                                    }

                                }
                            }

                            catch
                            {
                            }
                        }



                        if (exists)
                        {
                            //    var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                            //    if (track != null)
                            //    {
                            //        track.ExportStatus = exportState.present; 
                            //    }
                            continue;
                        }

                        //2. Copie du meilleur fichier
                        CFile pertinent = files.getPertinentFile();
                        if (pertinent == null)
                            continue;


                        while (true)
                        {
                            if (state != compressState.enCours)
                                return;
                            try
                            {
                                FileInfo f = new FileInfo(pertinent.Path);
                                var freeSpace = getFreeSpace() - conf.marge;
                                long nextfreeAvailable = freeSpace - f.Length;
                                if (nextfreeAvailable < 0)
                                {
                                    if (noMoreSpace())
                                        return;
                                    continue;
                                }
                                App.log.log("copie\t" + piece + "->" + conf.dir + pertinent.File + " ( " + piece + " )");
                                f.copyTree(conf.dir + pertinent.File, true);
                                //  freeSpace = nextfreeAvailable; 
                                //  PlayListViewModel.setExport(piece.Piece.PieceId, exportState.copy);
                                setExport(exportState.copy, piece);
                                //var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                                //if (track != null)
                                //{
                                //    track.ExportStatus = exportState.copy;
                                //}
                                nbFichierAdd++;

                                break;
                            }
                            catch (System.IO.IOException io)
                            {
                                App.log.log(io.Message);
                                //  refreshInfoFreeSpace(); 
                                if (noMoreSpace())
                                    return;
                            }
                        }

                    }

                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }


                }
            }
            catch (Exception ex)
            {
                App.log.log(ex.ToString());

            }
            finally
            {
                var log = string.Format("Fin de l'export {0} liste{1} éléments\r\n{2} fichier{3} copié{3}\r\n{4} fichier{5} supprimé{6}",
                    listes.Count, (list.Count > 1 ? "s " : " "), nbFichierAdd, (nbFichierAdd > 1 ? "s" : ""), nbFicherSup, (nbFicherSup > 1 ? "s" : ""), (nbFicherSup > 1 ? "s" : ""));
                App.log.log(log, CAPTION);
                if (conf.oneShot)
                    ihm.InfoIHm(log, CAPTION);
                //  ihm.InfoIHm("Fin de l'export " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments\r\n" + idCopie.Count + " fichiers copiés\r\n" + nbFicherSup + "fichier" + (nbFicherSup > 1 ? "s" : "") + " supprimé" + (nbFicherSup > 1 ? "s" : ""), CAPTION);
                list = null;
                listes = null;

                if (state == compressState.enCours)
                    state = compressState.end;
                else
                    PlayListViewModel.resetExport(exportState.none);
                OnPropertyChanged("Header");

            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\DataGridPlayList.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using pdb.gen.Tuning;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.util;
using pdb.player.Vue.Util;
using System.Windows.Threading;
using System.Windows.Media;
using Math = System.Math;
using System.Linq;
using System.Linq.Expressions;

namespace pdb.player.Vue
{



    public partial class DataGridPlayList : UserControl, ItrackProvider, IRedraw, IExportTracks
    {
        private static int nb;
        private int ID;
        private Logger log;
        public static event EventHandler refreshOk;
        // private BgColorFormatConverter colorConvert = new BgColorFormatConverter();

        //  private BgDict<int, DataGridRow> dict = new BgDict<int, DataGridRow>(); 
        private TrackListViewModel currentTrack;

        public DataGridPlayList()
        {
            ID = nb;
            log = Logger.getLogger("DataGridPlayList" + ID);
            nb++;
            InitializeComponent();
            this.Loaded += DataGridPlayList_Loaded;
            App.refresh += new EventHandler(App_refresh);
            PlayListCommande.Provider = this;
        }

        void DataGridPlayList_Loaded(object sender, RoutedEventArgs e)
        {
            init(null);
            PlayListViewModel.selectedPlaylistChange += PlayListViewModel_selectedPlaylistChange;
            PlayListViewModel.addDrow(this);
            dg.PreviewKeyUp += new KeyEventHandler(dg_preview);
            TrackListViewModel.CurrentHumanSelectedChanged += new EventHandler(TrackListViewModel_CurrentHumanSelectedChanged);

            PlayerViewModel.Instance.checkNavIni(); 

            ExportCmd.Ihm = this;

        }

        void TrackListViewModel_CurrentHumanSelectedChanged(object sender, EventArgs e)
        {
            //if (currentTrack != null)
            //    currentTrack.refresh();
            ICollectionView view = CollectionViewSource.GetDefaultView(dg.ItemsSource);

            var hs = TrackListViewModel.HumanSelected;
            if (hs == null)
                return;
            var pl = PlayListViewModel.SelectedPlayList;
            bool reset = pl != sender;

            TrackListViewModel t = null;
            try
            {
                checkItems(true);

                t = PlayListViewModel.findTrack(pl, hs.PieceId);
                if (t == null)
                    return;
                t.IsSelected = true;

            }
            finally
            {
                currentTrack = t;
                //if (currentTrack != null)
                //    currentTrack.refresh();
                //TrackListViewModel.setHumanSelected(PlayList, TrackListViewModel.CurrentSelected); 

            }


            PlayerViewModel.Instance.makeResume();
        }

        Key key;
        void dg_preview(object sender, KeyEventArgs e)
        {
            // e.Handled = false; 
            key = e.Key;
            bool nav = false;

            switch (key)
            {
                case Key.Up:
                case Key.Down:
                case Key.PageDown:
                case Key.PageUp: nav = true; break;
                //case Key.LeftCtrl: case Key.RightCtrl : // TODO ajouter un élément
            }



            if (!nav)
                return;
            TrackListViewModel.setHumanSelected(PlayList, TrackListViewModel.CurrentSelected); //    .HumanSelected = TrackListViewModel.CurrentSelected;
        }


        void App_refresh(object sender, EventArgs e)
        {
            log.log("dg::App_refresh");
            redraw();
        }




        void PlayListViewModel_selectedPlaylistChange(object sender, EventArgs e)
        {
            if (ID == 0)
            {
                init(sender as PlayListViewModel);
            }
        }

        private void init(PlayListViewModel old)
        {
            if (!Dispatcher.CheckAccess())
            {
                Dispatcher.Invoke(new Action<PlayListViewModel>(init));
                return;
            }
            log.log("dg::init");
            SortDescriptionCollection sort = null;
            ICollectionView view = null;
            if (old != null)
            {
                view = CollectionViewSource.GetDefaultView(dg.ItemsSource);
                if (view != null)
                    sort = view.SortDescriptions;
                if (sort != null)
                    old.Sort = sort;
            }


            var pl = PlayListViewModel.SelectedPlayList;
            var currentPlaying = TrackListViewModel.CurrentPlaying;
            if (pl == null)
                return;
            base.DataContext = null;

            var source = dg.ItemsSource;

            dg.ItemsSource = null;
            var items = pl.AlltracksVm;
            view = CollectionViewSource.GetDefaultView(items);
            using (var w = view.DeferRefresh())
            {
                // items.refresh();

                base.DataContext = items;
                int i = 0;
                if (pl.isSubList("gen"))
                {
                }
                else
                {
                    //foreach (TrackListViewModel track in items)
                    //{
                    //    i++;
                    //    track.Index = i;
                    //}
                }
                sort = pl.Sort;
                List<SortDescription> _sort = null;
                if (sort != null)
                    _sort = new List<SortDescription>(sort);
                dg.ItemsSource = items;

                TrackListViewModel.CurrentPlaying = currentPlaying;

                dg.ApplySort(_sort, w);
            }
            PlayerViewModel.Instance.set(this);

            //if (_sort != null && _sort.Count > 0)
            //{
            //    view.SortDescriptions.Clear();
            //    foreach (var _s in _sort)
            //    {
            //        view.SortDescriptions.Add(_s);
            //        foreach (DataGridColumn _c in dg.Columns)
            //        {
            //            if (_s.PropertyName == _c.SortMemberPath)
            //            {
            //                _c.SortDirection = _s.Direction;
            //                break;
            //            }
            //        }
            //        break;

            //    }
            //}

            //foreach (TrackListViewModel tv in items)
            //    tv.PropertyChanged += new PropertyChangedEventHandler(tv_PropertyChanged);

            if (currentTrack != null)
                currentTrack.refresh();

            putExportTracks(pl, CollectionViewSource.GetDefaultView(dg.ItemsSource));
            this.scrol(); 
            OnRefresh();


        }
        private void OnRefresh()
        {
            if (refreshOk != null)
                refreshOk(this, EventArgs.Empty);
        }

        private void dg_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            try
            {
                var r = sender as DataGridRow;
                var t = r.Item as TrackListViewModel;
                PlayerViewModel.reset(this, t);
            }
            catch
            {
            }
        }

        private void checkItems(bool reset)
        {
            var l = new List<TrackListViewModel>();
           

            ICollectionView view = CollectionViewSource.GetDefaultView(dg.ItemsSource);
            var selectedTracks = new List<TrackListViewModel>(dg.SelectedItems.Count);
            foreach (TrackListViewModel t in dg.SelectedItems)
                selectedTracks.Add(t);
            var tracks = dg.Items;



            //    IDisposable w = view.DeferRefresh();
            try
            {


                if (reset)
                {
                    TrackListViewModel selected = null;
                    if (TrackListViewModel.HumanSelected != null)
                    {
                        selected = PlayListViewModel.findTrack(PlayList, TrackListViewModel.HumanSelected.PieceId);
                    }

                    foreach (TrackListViewModel track in view)
                    {
                        if (track == selected)
                            track.IsSelected = true;
                        else
                            track.IsSelected = false;

                        //track.refresh();
                    }
                    // dg.SelectedItems.Clear();
                    //  w.Dispose(); w = null;


                    if (selected != null)
                    {
                        l.Add(selected);
                        if (!dg.SelectedItems.Contains(selected))
                            dg.SelectedItems.Add(selected);
                    }
                    foreach (TrackListViewModel track in selectedTracks)
                    {
                        if (track != selected)
                        {
                            dg.SelectedItems.Remove(track);
                            track.IsSelected = false;
                            //track.refresh();
                        }
                    }
                }
                else
                {
                    foreach (TrackListViewModel track in selectedTracks)
                    {
                        l.Add(track);
                        track.IsSelected = true;

                        TrackListViewModel trackMusique = PlayListViewModel.findTrack(App.bib.Musique, track.PieceId);
                        if (trackMusique != null)
                            trackMusique.IsSelected = true;
                        //track.refresh();
                    }
                }
                //lock (this)
                //   this.selectedTracks = l;
            }
            finally
            {
                //if (w != null)
                //    w.Dispose();
            }

        }

        private void dg_MouseClick(object sender, MouseButtonEventArgs e)
        {
            //  e.Handled = true; 
            //var r = sender as DataGridRow;
            //var t = r.Item as TrackListViewModel;
            //TrackListViewModel.setHumanSelected(PlayList, t); //   .HumanSelected = t;
            //startPoint = e.GetPosition(null);

            checkItems(false);

            PlayerViewModel.Instance.makeResume();
        }



        // private List<TrackListViewModel> selectedTracks = new List<TrackListViewModel>();

        private List<TrackListViewModel> SelectedTracks
        {
            get
            {
                lock (this)
                {
                    var l = new List<TrackListViewModel>();
                    foreach (TrackListViewModel t in dg.ItemsSource)
                    {
                        if (t.IsSelected)
                            l.Add(t);
                    }
                    return l;
                }
            }
        }
        ICollectionView ItrackProvider.PresentationTracks
        {
            get { return CollectionViewSource.GetDefaultView(dg.ItemsSource); }
        }
        void ItrackProvider.Focus(int index)
        {

            // dg.SelectedIndex = index;
            //var indexbas = Math.Min(index + 100, dg.Items.Count - 1);
            //scrol(indexbas);
            this.scrollIndex = index; 
            scrol();
        }

        List<TrackListViewModel> ISelectedTracks.SelectedTracks
        {
            get
            {
                return SelectedTracks;
            }
        }
        private int scrollIndex; 
        void scrol()
        {
            if (!CheckAccess())
            {
                Dispatcher.Invoke(new Action(this.scrol));
            }
            else
            {
                if (dg.Items.Count == 0)
                    return;
                dg.ScrollIntoView(dg.Items[0]);
                int index = scrollIndex; 
                if (index < 0)
                    index = 0;
                if (index >= dg.Items.Count)
                    index = dg.Items.Count - 1;

                dg.ScrollIntoView(dg.Items[index]);
            }
        }
        public PlayListViewModel PlayList
        {
            get { return PlayListViewModel.SelectedPlayList; }
        }
        public void doFilter(string filter)
        {
            PlayerViewModel.doFilter((this as ItrackProvider).PresentationTracks, filter);
        }
        private bool IsUserVisible(FrameworkElement element, FrameworkElement container)
        {
            if (!element.IsVisible)
                return false;
            Rect bounds = element.TransformToAncestor(container).TransformBounds(new Rect(0.0, 0.0, element.ActualWidth, element.ActualHeight));
            Rect rect = new Rect(0.0, 0.0, container.ActualWidth, container.ActualHeight);
            return rect.Contains(bounds.TopLeft) || rect.Contains(bounds.BottomRight);
        }

        private static T FindVisualParent<T>(UIElement element) where T : UIElement
        {
            var parent = element;
            while (parent != null)
            {
                var correctlyTyped = parent as T;
                if (correctlyTyped != null)
                {
                    return correctlyTyped;
                }

                parent = VisualTreeHelper.GetParent(parent) as UIElement;
            }
            return null;
        }

        public void redraw()
        {
            if (!CheckAccess())
            {
                Dispatcher.BeginInvoke(new Action(this.redraw), DispatcherPriority.DataBind);
                return;
            }
            try
            {
                var pl = PlayListViewModel.SelectedPlayList;

                bool isgen = false;
                if (pl != null && pl.isSubList("gen"))
                    isgen = true;

                var items = dg.ItemsSource as AllTracksViewModel;

                if (items == null)
                {
                    dg.Items.Refresh();
                }
                else
                {
                    ICollectionView view = CollectionViewSource.GetDefaultView(dg.ItemsSource);
                    using (var w = view.DeferRefresh())
                    {
                        SortDescriptionCollection sort = view.SortDescriptions;

                        List<SortDescription> _sort = null;
                        if (sort != null)
                            _sort = new List<SortDescription>(sort);

                        int i = 0;
                        foreach (TrackListViewModel track in items)
                        {
                            i++;
                            if (!isgen)
                                track.Index = i;
                            //  track.refresh();
                        }

                        dg.ApplySort(_sort, w);
                        //if (_sort != null && _sort.Count > 0 && view.SortDescriptions.Count > 0)
                        //{
                        //    view.SortDescriptions.Clear();
                        //    foreach (var _s in _sort)
                        //    {
                        //        view.SortDescriptions.Add(_s);
                        //    }
                        //}
                        items.refresh();
                    }
                    putExportTracks(pl, view);

                }
                return;


                try
                {
                    isgen = false;

                    if (isgen)
                    {
                        log.log("dg::redraw::init");
                        init(pl);
                    }
                    else
                    {
                        log.log("dg::redraw::Refresh");
                        dg.Items.Refresh();
                    }
                }
                catch
                {
                    try
                    {
                        init(pl);
                    }
                    catch
                    {
                    }
                }
            }
            finally
            {
                OnRefresh();
            }

        }

        private void MenuItem_Click(object sender, RoutedEventArgs e)
        {
            var items = dg.SelectedItems;
            MessageBox.Show(items.Count.ToString());
        }

        public string folderDialog()
        {
            return App.Instance.folderDialog();
        }


        public System.ComponentModel.ICollectionView PresentationTracks
        {
            get
            {
                return ((ItrackProvider)this).PresentationTracks;
            }
        }






        public bool ModeAlbum
        {
            get { return MessageBox.Show("par albums complets", "export", MessageBoxButton.YesNo) == MessageBoxResult.Yes; }
        }

        public bool Continue
        {
            get { return MessageBox.Show("continuer le marché ?", "export", MessageBoxButton.YesNo) == MessageBoxResult.Yes; }
        }




        public void InfoIHm(string message, string caption)
        {
            App.Instance.InfoIHm(message, caption);
        }

        public bool Confirm(string question, string caption)
        {
            return App.Instance.Confirm(question, caption);
        }

        public bool? TriChoix(string question, string caption)
        {
            return App.Instance.TriChoix(question, caption);
        }

        public Export getConfExport(string question)
        {
            return App.Instance.getConfExport(question);
        }

        public Import getConfImport(string question)
        {
            return App.Instance.getConfImport(question);
        }

        public int getNb(string question)
        {
            return App.Instance.getNb(question);
        }

        public bool changeName(string title, IName data)
        {
            return App.Instance.changeName(title, data);
        }

        public PlayListViewModel selectPlayList(string title)
        {
            return App.Instance.selectPlayList(title);
        }



        //  private List<TrackListViewModel> list = new List<TrackListViewModel>(); 
        public List<TrackListViewModel> ListTrack
        {
            get { return null; }
        }

        private void putExportTracks(PlayListViewModel pl, ICollectionView view)
        {
            var list = new List<TrackListViewModel>();
            foreach (TrackListViewModel track in view)
                list.Add(track);
            pl.ExportTracks = list;
            //visibleItems = new List<TrackListViewModel>();

            //foreach (var item in view)
            //{
            //    var row = dg.ItemContainerGenerator.ContainerFromItem(item) as DataGridRow;
            //    if (row != null)
            //    {
            //        visibleItems.Add(item as TrackListViewModel); 
            //    }
            //}


        }
        //private List<TrackListViewModel> visibleItems = new List<TrackListViewModel>();
        //public List<TrackListViewModel> VisibleItems { get { return new List<TrackListViewModel>(visibleItems); } }

        Point startPoint;
        private void dg_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            startPoint = e.GetPosition(null);
        }

        private void dg_PreviewMouseMove(object sender, MouseEventArgs e)
        {
            var mousePos = e.GetPosition(null);
            var diff = startPoint - mousePos;

            if (Math.Abs(diff.X) > SystemParameters.MinimumHorizontalDragDistance
                || Math.Abs(diff.Y) > SystemParameters.MinimumVerticalDragDistance)
            {
                var treeView = sender as DataGrid;
                var treeViewItem = //(e.OriginalSource as DependencyObject).
                    Util.Util<DataGridRow>.FindAnchestor((DependencyObject)e.OriginalSource);
                //   FindAnchestor<TreeViewItem>((DependencyObject)e.OriginalSource);

                if (treeView == null || treeViewItem == null)
                    return;

                var folderViewModel = treeView.SelectedItem as TrackListViewModel;
                if (folderViewModel == null)
                    return;

                var dragData = new DataObject(folderViewModel);
                DragDrop.DoDragDrop(treeViewItem, dragData, DragDropEffects.Copy);
            }
        }
    }
}]]></content>
  </file>
  <file path="\pdb.util\Medianne.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using System.IO;

namespace pdb.util
{
    public enum selectedCoeff
    {
        none,
        noCoeff,
        main,
        min
    }

    public enum medianneMode
    {
        none = 0,
        strict = 1,
        light = 2,
        moy = 3

    }
    public enum removeLast
    {
        non = 0,
        unselected = 1,
        virtuel = 2,
        tous = 3
    }

    public enum modeMin
    {
        /// <summary>
        /// On ne gère pas
        /// </summary>
        non = 0,
        /// <summary>
        /// Morceaux supérieurs à la limite ( pas d'influence sur le résultat)
        /// </summary>
        orphelin = 1,
        /// <summary>
        /// Morceaux cochés et notés
        /// </summary>
        toujours = 2

    }

    public class HistoStat
    {
        public HistoStatItem min;
        public HistoStatItem max;

        public HistoStat()
        {
            min = new HistoStatItem(int.MaxValue);
            max = new HistoStatItem(-1);
        }
        public HistoStat(decimal val)
        {
            min = new HistoStatItem(val);
            max = new HistoStatItem(val);
        }

        //private string desc(decimal d)
        //{
        //    if (d < 0)
        //        return "";
        //    if (d >= int.MaxValue)
        //        return "";
        //    return d.ToString("0.000", System.Globalization.CultureInfo.InvariantCulture);
        //}

        public override string ToString()
        {
            //return string.Format("{0}({1}) {2}({3})", desc(min.absolute), desc(min.relative), desc(max.absolute), desc(max.relative)); 
            return string.Format("{0} {1}", min, max);
        }
    }

    public class HistoStatItem
    {
        public decimal relative;
        public decimal absolute;
        public HistoStatItem()
        {
            relative = -1;
            absolute = -1;
        }
        public HistoStatItem(decimal val)
        {
            relative = val;
            absolute = val;
        }

        public static string desc(decimal d)
        {
            if (d < 0)
                return "";
            if (d >= int.MaxValue)
                return "";
            return d.ToString("0.000", System.Globalization.CultureInfo.InvariantCulture);
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append(desc(absolute));
            if (absolute != relative)
            {
                sb.Append("(");
                sb.Append(desc(relative));
                sb.Append(")");
            }
            return sb.ToString();
        }


    }

    [Serializable]
    public class ConfMedianne : TuningBase
    {
        public medianneMode type;
        public decimal medianne = 0.5m;
        public bool quasi;

        public bool enabled;



        public bool removeFirst;
        public bool deleteFirst;
        public removeLast removeLast;

        public decimal expEnabled = 0m;

        public decimal zero = 0m;
        /// <summary>
        /// 
        /// </summary>
        public bool removeEnabled;




        public modeMin cmpMin;

        private ConfMedianneVirt _main;
        private ConfMedianneVirt _min;

        public ConfMedianneVirt Main { get { return _main; } }
        public ConfMedianneVirt Min { get { return _min; } }
        public ConfMedianne()
        {
            _main = new ConfMedianneVirt();
            _min = new ConfMedianneVirt();

        }

        public void makeIdem()
        {
            _min = _main;
        }

        public void duplicateMainIf()
        {
            if (_min == _main)
                _min = new ConfMedianneVirt(_main);
        }

        public ConfMedianne(ConfMedianne o, bool raz)
        {
            type = o.type;
            medianne = o.medianne;
            quasi = o.quasi;

            enabled = o.enabled;



            removeFirst = o.removeFirst;
            deleteFirst = o.deleteFirst;
            removeLast = o.removeLast;

            expEnabled = o.expEnabled;

            zero = o.zero;
            removeEnabled = o.removeEnabled;



            cmpMin = o.cmpMin;

            _main = new ConfMedianneVirt(o._main, raz);
            _min = new ConfMedianneVirt(o._min, raz);

        }

        public ConfMedianne(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var strType = "";
            builds("type", v => strType = v);
            type = (medianneMode)Enum.Parse(typeof(medianneMode), strType, true);
            builddec("medianne", v => medianne = v);
            buildb("quasi", v => quasi = v);
            buildb("enabled", v => enabled = v);
            buildb("removeFirst", v => removeFirst = v);
            buildb("deleteFirst", v => deleteFirst = v);
            builddec("expEnabled", v => expEnabled = v);
            builddec("zero", v => zero = v);
            buildb("removeEnabled", v => removeEnabled = v);
            string _modeMin = "";
            builds("cmpMin", v => _modeMin = v);
            if (!string.IsNullOrEmpty(_modeMin))
                cmpMin = (modeMin)Enum.Parse(typeof(modeMin), _modeMin, true);

            string _removeLast = null;
            builds("removeLast", v => _removeLast = v);
            removeLast = (removeLast)Enum.Parse(typeof(removeLast), _removeLast, true);

            _main = null;
            _min = null;
            var subs = XMLTool.NodeLookUp(child, "virts");
            if (subs != null)
            {
                foreach (XmlNode _n in subs.ChildNodes)
                {
                    if (_n is XmlElement)
                    {
                        if (_main == null)
                        {
                            _main = new ConfMedianneVirt(child, _n as XmlElement);

                        }
                        else if (_min == null)
                        {
                            _min = new ConfMedianneVirt(child, _n as XmlElement);
                        }
                    }
                }
                if (_min == null && _main != null)
                    _min = new ConfMedianneVirt(_main);
            }
        }

        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("cmp");
            write("type", type);
            write("medianne", medianne);
            write("quasi", quasi);
            write("enabled", enabled);
            write("removeFirst", removeFirst);
            write("deleteFirst", deleteFirst);
            write("expEnabled", expEnabled);
            write("zero", zero);
            write("removeEnabled", removeEnabled);
            write("cmpMin", cmpMin);
            write("removeLast", removeLast);

            writeStart("virts");
            _main.save(w);
            _min.save(w);
            writeEnd();

            writeEnd();



        }


        public void auto(selectedCoeff motif)
        {
            if (!enabled)
                return;
            if (motif == selectedCoeff.none)
                return;
            var coeffPrisEncompte = motif > selectedCoeff.noCoeff;
            if (_min == _main || _min.coeffVirt == 1m)
            {
                _main.calcAuto(coeffPrisEncompte, 1);
            }
            else
            {
                if (coeffPrisEncompte)
                {
                    if (motif == selectedCoeff.main)
                        _main.calcAuto(true, 1);
                    if (motif == selectedCoeff.min)
                        _min.calcAuto(true, 1);
                }
                else
                {
                    _main.calcAuto(false, 1);
                    _min.calcAuto(false, 1);
                }
            }
        }
    }

    [Serializable]
    public class ConfMedianneVirt : TuningBase
    {
        [NonSerialized]
        const string PATH_DYN = "..\\dynamic";
        private string Path { get { return string.Format("{0}{1}", DIR_CONF, fdata); } }
        private string PathDiff { get { return string.Format("{0}{1}", DIR_CONF, fdiff); } }
        private string PathDiffTmp { get { return string.Format("{0}{1}", DIR_CONF, fdiffTmp); } }
        // private string PathLastFull { get { return string.Format("{0}{1}", DIR_CONF, flast); } }
        const string PATH_DYN_DIFF = "..\\dynamic_diff";

        // const decimal EPSILON = 0.000001m;// 0.001m;
        const int NB_HISTO = 1000000;
        public int safe;
        public decimal coeffVirt = 1m;

        //private bool firstSave = true;
        //private static bool modeDiff;
        //public static bool ModeDiff
        //{
        //    get { return modeDiff; }
        //    set
        //    {
        //        modeDiff = value;
        //    }
        //}

        public string name;


        /// <summary>
        /// lié au mode db
        /// </summary>
        public dbMode mode;
        /// <summary>
        /// fichier ou est consigné l'historique courant
        /// </summary>
        public string fdata;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique
        /// </summary>
        public string fdiff;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique en mode full en vue de la sauvegarfe
        /// </summary>
        public string fdiffTmp;
        ///// <summary>
        ///// fichier ou est consigné la dernière sauvegarde full de l'historique
        ///// </summary>
        //public string flast;

        public int indexDiff = 0;

        public bool virtOnlyDisabled;
        public bool noAddEnd;
        public bool noAddAll;
        public bool virtAlignSelected;
        public bool virtAlignPrec;
        public bool coeffVirtAuto;
        public bool coeffVirtAdjust;

        public bool removeEpsilon;

        public bool forceCoeffVirt;
        public bool lissage;
        public bool cumul;

        public bool reSort;
        public bool noAdd;


        public bool auto;
        public decimal dcoeffp;
        public decimal dcoeffm;

        public int serialp = 1;
        public int serialm = 1;
        public int serialAlt = 1;
        public int serialElastique = 1; 
        /// <summary>
        /// atténuation progressive des coeffs
        /// </summary>
        public decimal dconvergence;
        public decimal dconvergence0;
        public decimal dconvergence01;

        public decimal dconvdeltap = 1m;
        public decimal dconvdeltam = 1m;

        /// <summary>
        /// anti atténuation
        /// </summary>
        public decimal danticonvergence = 1m;
        public decimal danticonvergence0;
        public decimal danticonvergence01;

        public decimal danticonvdeltap = 1m;
        public decimal danticonvdeltam = 1m;
        private bool _linkconv;
        private decimal linkProduct;
        private List<decimal> histo = new List<decimal>();
        //  private List<decimal> histoDiff = new List<decimal>();

        public decimal coeffOld = 1m;
        public bool oldAsZero;
        public bool coeffOldAuto;
        public int coeffOldAutoLevel;

        public bool linkconv { get { return _linkconv; } set { _linkconv = value; calcProduct(); } }

        private void calcProduct()
        {
            this.linkProduct = calcProduct(this.dcoeffp, this.dconvergence);
        }

        public decimal calcProduct(decimal dcoeffp, decimal dconvergence)
        {
            var linkProduct = this.linkProduct;
            try
            {
                linkProduct = dcoeffp / dconvergence;
                // 1 0,9 -> 10
                // 0.1 0,99 
            }
            catch
            {
            }

            return linkProduct;
        }

        private void calcConv()
        {
            this.dconvergence = calcConv(this.dcoeffp, this.linkProduct);
        }

        public decimal LinkProduct
        {
            get
            {
                if (linkProduct == 0m)
                    calcProduct();
                return linkProduct;
            }
            set
            {
                linkProduct = value;
                calcConv();

            }
        }

        public decimal calcConv(decimal dcoeffp, decimal linkProduct)
        {
            var dconvergence = this.dconvergence;
            try
            {
                // 1- conv = coeff / prod
                dconvergence = dcoeffp / linkProduct; //1/10
            }
            catch
            {

            }
            return dconvergence;
        }


        private bool? lastDelta;
        private bool? lastAutoDirection;
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        private int _nbSameDirection;
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        private int _nbSameDirectionBox;
        /// <summary>
        /// nb allez/retour pour calcul
        /// </summary>
        private int _nbAlt;
        /// <summary>
        /// bilan même sens vs allez-retour. Quand trop grand on agrandit le delta, quand trop petit on diminue
        /// </summary>
        private int _nbElastique;

        /// <summary>
        /// bilan même sens vs allez-retour. Quand trop grand on agrandit le delta, quand trop petit on diminue
        /// </summary>
        private int _nbElastique2; 
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        private int _nbAltHisto;

        private decimal epsilon = 0.001m;

        public ConfMedianneVirt()
        { }

        public ConfMedianneVirt(ConfMedianneVirt o, bool raz)
            : this(o)
        {
            if (raz)
            {
                safe = 0;
                coeffOld = 1;
                coeffVirt = 1;
            }
        }
        public ConfMedianneVirt(ConfMedianneVirt o)
        {
            name = o.name;
            mode = o.mode;
            fdata = o.fdata;
            fdiff = o.fdiff;
            fdiffTmp = o.fdiffTmp;
            //  flast = o.flast;
            safe = o.safe;
            coeffVirt = o.coeffVirt;
            virtOnlyDisabled = o.virtOnlyDisabled;
            noAddEnd = o.noAddEnd;
            noAddAll = o.noAddAll;
            virtAlignSelected = o.virtAlignSelected;
            virtAlignPrec = o.virtAlignPrec;
            coeffVirtAuto = o.coeffVirtAuto;
            coeffVirtAdjust = o.coeffVirtAdjust;
            removeEpsilon = o.removeEpsilon;
            forceCoeffVirt = o.forceCoeffVirt;
            lissage = o.lissage;
            cumul = o.cumul;
            reSort = o.reSort;
            noAdd = o.noAdd;
            auto = o.auto;
            dcoeffp = o.dcoeffp;
            dcoeffm = o.dcoeffm;
            dconvergence = o.dconvergence;
            dconvdeltap = o.dconvdeltap;
            dconvdeltam = o.dconvdeltam;
            danticonvergence = o.danticonvergence;
            danticonvdeltap = o.danticonvdeltap;
            danticonvdeltam = o.danticonvdeltam;
            _linkconv = o._linkconv;
            serialp = o.serialp;
            serialm = o.serialm;
            serialAlt = o.serialAlt;
            serialElastique = o.serialElastique; 

            _nbSameDirection = o._nbSameDirection;
            _nbSameDirectionBox = o._nbSameDirectionBox;
            _nbAlt = o._nbAlt;
            _nbAltHisto = o._nbAltHisto;
            _nbElastique = o._nbElastique;
            _nbElastique2 = o._nbElastique2; 

            coeffOld = o.coeffOld;
            coeffOldAuto = o.coeffOldAuto;
            oldAsZero = o.oldAsZero;
            coeffOldAutoLevel = o.coeffOldAutoLevel;
            epsilon = o.epsilon;

            dconvergence0 = o.dconvergence0;
            dconvergence01 = o.dconvergence01;
            danticonvergence0 = o.danticonvergence0;
            danticonvergence01 = o.danticonvergence01;

            lastDelta = o.lastDelta; 
            histo = new List<decimal>(o.histo);

        }
        public ConfMedianneVirt(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var str = "";
            builds("mode", v => str = v);
            if (!string.IsNullOrEmpty(str))
                mode = (dbMode)Enum.Parse(typeof(dbMode), str);
            builds("name", v => name = v);
            builds("fdata", v => fdata = v);
            builds("fdiff", v => fdiff = v);
            builds("fdiffTmp", v => fdiffTmp = v);
            // builds("flast", v => flast = v);
            builddec("coeffVirt", v => coeffVirt = v);
            buildi("safe", v => safe = v);

            buildb("virtOnlyDisabled", v => virtOnlyDisabled = v);
            buildb("noAddEnd", v => noAddEnd = v);
            buildb("noAddAll", v => noAddAll = v);
            buildb("virtAlignSelected", v => virtAlignSelected = v);
            buildb("virtAlignPrec", v => virtAlignPrec = v);
            buildb("coeffVirtAuto", v => coeffVirtAuto = v);
            buildb("coeffVirtAdjust", v => coeffVirtAdjust = v);

            buildb("removeEpsilon", v => removeEpsilon = v);
            buildb("forceCoeffVirt", v => forceCoeffVirt = v);
            buildb("lissage", v => lissage = v);
            buildb("cumul", v => cumul = v);
            buildb("reSort", v => reSort = v);
            buildb("noAdd", v => noAdd = v);
            buildb("auto", v => auto = v);
            builddec("dcoeffp", v => dcoeffp = v);
            builddec("dcoeffm", v => dcoeffm = v);
            builddec("dconvergence", v => dconvergence = v);
            builddec("dconvergence0", v => dconvergence0 = v);
            builddec("dconvergence01", v => dconvergence01 = v);
            builddec("dconvdeltap", v => dconvdeltap = v);
            builddec("dconvdeltam", v => dconvdeltam = v);

            builddec("danticonvergence", v => danticonvergence = v);
            builddec("danticonvergence0", v => danticonvergence0 = v);
            builddec("danticonvergence01", v => danticonvergence01 = v);
            builddec("danticonvdeltap", v => danticonvdeltap = v);
            builddec("danticonvdeltam", v => danticonvdeltam = v);
            buildb("linkconv", v => _linkconv = v);
            buildi("serialp", v => serialp = v);
            buildi("serialm", v => serialm = v);
            buildi("serialAlt", v => serialAlt = v);
            buildi("elastique", v => serialElastique = v);
            buildi("serial", v => _nbSameDirection = v);
            buildi("serialBox", v => _nbSameDirectionBox = v);
            buildi("serialAltC", v => _nbAlt = v);
            buildi("serialAltH", v => _nbAltHisto = v);
            buildi("elastiqueC", v => _nbElastique = v);
            buildi("elastiqueC2", v => _nbElastique2 = v);


            builddec("coeffOld", v => coeffOld = v);
            buildb("oldAsZero", v => oldAsZero = v);
            buildb("coeffOldAuto", v => coeffOldAuto = v);
            buildi("coeffOldAutoLevel", v => coeffOldAutoLevel = v);
            builddec("epsilon", v => epsilon = v);

            buildbn("lastDelta", v => lastDelta = v); 



            var xhisto = XMLTool.NodeLookUp(child, "histo");
            if (xhisto != null)
            {
                foreach (XmlElement sub in xhisto.ChildNodes)
                {
                    histo.Add(Convert.ToDecimal(sub.InnerText));
                }
            }
            else
            {
                if (File.Exists(Path))
                {
                    foreach (var line in File.ReadAllLines(Path))
                    {
                        if (string.IsNullOrEmpty(line))
                            continue;
                        histo.Add(Convert.ToDecimal(line));
                    }
                    indexDiff = histo.Count;

                    //if (histo.Count >0 )
                    //    coeffVirt = getCoeff(histo[histo.Count -1]);


                }

                if (File.Exists(PathDiff))
                {
                    var histoDiff = new List<decimal>();

                    foreach (var line in File.ReadAllLines(PathDiff))
                    {
                        if (string.IsNullOrEmpty(line))
                            continue;
                        histoDiff.Add(Convert.ToDecimal(line));
                    }

                    if (mode == dbMode.full)
                    {
                        histo.AddRange(histoDiff);
                        indexDiff = histo.Count;
                    }
                    else
                    {
                        indexDiff = histo.Count - histoDiff.Count;
                    }

                }



                if (mode == dbMode.full && File.Exists(PathDiff))
                    File.Delete(PathDiff);

                if (histo.Count > 0)
                {
                    int index = histo.Count - 1;
                    decimal current = histo[index];
                    //coeffVirt = getCoeff(current);
                    bool? sens = null;
                 
                    int nbSerie = 0;
                   // decimal delta = 0m;

                    var rr = 0m;
                    if (dcoeffp > 0)
                        rr = dcoeffm / dcoeffp;
                    if (rr > 0)
                    {
                        while (true)
                        {
                            index--;
                            if (index < 0)
                                break;
                            var aux = histo[index];
                            var _sens = current > aux;
                            if (sens == null)
                            {
                                sens = _sens;
                                lastAutoDirection = !_sens;
                             
                               // delta = current - aux;
                            }


                            if (sens != _sens)
                                break;
                            current = aux;
                            nbSerie++;

                        }

                        //_nbSameDirection = nbSerie;
                        //dcoeffp = Math.Abs(delta); dcoeffm = dcoeffp * rr;

                    }
                }
            }

            if (coeffOldAuto)
            {
                coeffOld = (decimal)Math.Pow(coeffVirt, coeffOldAutoLevel);
            }
            //if (histoDiff.Count > 0)
            //    coeffVirt = getCoeff(histo[histo.Count - 1]); 

        }

        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("v");
            write("name", name);
            write("mode", mode);
            write("serial", _nbSameDirection);
            write("serialBox", _nbSameDirectionBox);
            write("serialAltC", _nbAlt);
            write("serialAltH", _nbAltHisto);
            write("elastiqueC", _nbElastique);
            write("elastiqueC2", _nbElastique2);
            write("lastDelta", lastDelta); 

            write("serialAlt", serialAlt);
            write("elastique", serialElastique);
            write("fdata", fdata);
            write("fdiff", fdiff);
            write("fdiffTmp", fdiffTmp);

            write("coeffVirt", coeffVirt);
            write("safe", safe);

            write("virtOnlyDisabled", virtOnlyDisabled);
            write("noAddEnd", noAddEnd);
            write("noAddAll", noAddAll);
            write("virtAlignSelected", virtAlignSelected);
            write("virtAlignPrec", virtAlignPrec);
            write("coeffVirtAuto", coeffVirtAuto);
            write("coeffVirtAdjust", coeffVirtAdjust);

            write("removeEpsilon", removeEpsilon);
            write("forceCoeffVirt", forceCoeffVirt);
            write("lissage", lissage);
            write("cumul", cumul);
            write("reSort", reSort);
            write("noAdd", noAdd);
            write("auto", auto);
            write("dcoeffp", dcoeffp);
            write("dcoeffm", dcoeffm);
            write("dconvergence", dconvergence);
            write("dconvergence0", dconvergence0);
            write("dconvergence01", dconvergence01);
            write("dconvdeltap", dconvdeltap);
            write("dconvdeltam", dconvdeltam);

            write("danticonvergence", danticonvergence);
            write("danticonvergence0", danticonvergence0);
            write("danticonvergence01", danticonvergence01);
            write("danticonvdeltap", danticonvdeltap);
            write("danticonvdeltam", danticonvdeltam);
            write("linkconv", linkconv);
            write("serialp", serialp);
            write("serialm", serialm);



            write("coeffOld", coeffOld);
            write("oldAsZero", oldAsZero);
            write("coeffOldAuto", coeffOldAuto);

            write("coeffOldAutoLevel", coeffOldAutoLevel);
            write("epsilon", epsilon);


            var sb = new StringBuilder();
            var sbDiff = new StringBuilder();




            //if (modeDiff)
            //{
            //    histoDiff = null;
            //}
            //else
            //{
            //    if (histoDiff != null)
            //    {
            //        histo.AddRange(histoDiff);
            //        histoDiff = null;
            //    }

            //    if (File.Exists(PathDiff))
            //        File.Delete(PathDiff);
            //}

            int count = histo.Count;
            for (int i = 0; i < count; i++)
            {
                var v = Math.Round(histo[i], 15);
                var s = v.ToString();
                sb.AppendLine(s);
                if (i >= indexDiff)
                    sbDiff.AppendLine(s);
            }


            if (!string.IsNullOrEmpty(fdata))
            {
                AsyncFileWriter.Instance.post(Path, sb.ToString());
                if (mode == dbMode.diff)
                    AsyncFileWriter.Instance.post(PathDiff, sbDiff.ToString());
                else
                    AsyncFileWriter.Instance.post(PathDiffTmp, sbDiff.ToString());


                if (mode == dbMode.full && File.Exists(PathDiff))
                    File.Delete(PathDiff);
            }


            writeEnd();
        }
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        public int Serial { get { return _nbSameDirection; } set { _nbSameDirection = value; } }
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        public int SerialBox { get { return _nbSameDirectionBox; } }
        /// <summary>
        /// nb allez-retours pour calcul
        /// </summary>
        public int Alt { get { return _nbAlt; } }
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        public int AltHisto { get { return _nbAltHisto; } }
        /// <summary>
        /// Position de l'élastique. Positif : tend à agrandir le delta. du à plusieurs séries dans le même sens. Négatif : tend à diminuer le delta. du à plusieurs allez-retours consécutifs
        /// </summary>
        public int Elastique { get { return _nbElastique; } }
        public int Elastique2 { get { return _nbElastique2; } }

        public void calcAuto(bool selectedByCoeff, int nb)
        {


            if (-_nbSameDirectionBox > serialm)
                _nbSameDirectionBox = -serialm;
            if (_nbSameDirectionBox > serialp)
                _nbSameDirectionBox = serialp;

            if (-_nbElastique > serialElastique)
                _nbElastique = -serialElastique;
            if (_nbElastique > serialElastique)
                _nbElastique = serialElastique;


            if (-_nbElastique2 > serialElastique)
                _nbElastique2 = -serialElastique;
            if (_nbElastique2 > serialElastique)
                _nbElastique2 = serialElastique;


            if (_nbAlt < 0)
                _nbAlt = 0;
            if (_nbAlt > serialAlt)
                _nbAlt = serialAlt;


            var last = lastAutoDirection;
            var lastDelta_ = this.lastDelta; 
            lastAutoDirection = selectedByCoeff;

            if (last.HasValue)
            {
                if (last != selectedByCoeff)
                {
                    _nbSameDirection = 0;
                    _nbAlt++;
                    _nbAltHisto++;
                    _nbElastique--;
                    _nbElastique2 -= 2;
                    if (_nbSameDirectionBox > 0 && selectedByCoeff)
                        _nbSameDirectionBox--;
                    if (_nbSameDirectionBox < 0 && !selectedByCoeff)
                        _nbSameDirectionBox++;

                }
                else
                {
                    _nbAlt--;
                    _nbAltHisto = 0;
                    _nbElastique += 2;
                    _nbElastique2++; 
                    if (selectedByCoeff)
                    {
                        _nbSameDirectionBox--;
                    }
                    else
                    {
                        _nbSameDirectionBox++;
                    }
                }

                if (selectedByCoeff)
                {
                    _nbSameDirection--;
                }
                else
                {
                    _nbSameDirection++;
                }
            }

            if (!auto)
                return;

            var lastProduct = linkProduct;
            var rr = 1m;
            if (dcoeffp > 0)
                rr = dcoeffm / dcoeffp;

            var c0 = dcoeffp;
            var rrc = 1m;
            if (danticonvergence0 > 0)
                rrc = dconvergence0 / danticonvergence0;
            if (dcoeffp > 0 && dcoeffp * danticonvergence < epsilon)
            {
                danticonvergence = epsilon / dcoeffp;
                dconvergence = rrc * danticonvergence;
            }

            // si le delta ne bouge pas on diminue la convergence 

            /// au debut dconvergence à effet  fort 0.9 doit arriver à 0.999
            /// // quand j'applique la convergence, je fait baisser son effet

            if (last.HasValue)
            {
                var aux = dconvergence;
                //if (last != selectedByCoeff)
                if (_nbAlt > serialAlt || _nbElastique < -serialElastique || _nbElastique2 < -serialElastique)
                {
                    lastDelta = false; 
                    //if (selectedByCoeff)
                    //{

                    //dcoeffp *= dconvergence;
                    //dcoeffm *= dconvergence;
                    //if (dcoeffp < EPSILON) dcoeffp = EPSILON;
                    //if (dcoeffm < EPSILON) dcoeffm = EPSILON;

                    // la convergence est maintenant directement le % de baisse
                    //0.1 -> 0.9  ==> 1.1

                    var limit = dcoeffp - epsilon * rrc;

                    if (limit < 0 && dcoeffp >= 0)
                        limit = dcoeffp;
                    var r = 1 + dconvergence;
                    dcoeffp /= r;
                    dcoeffm /= r;

                    if (limit < dcoeffp)
                    {
                        dcoeffp = limit;
                        //  dconvergence = epsilon / (c0 - epsilon); 
                        if (rr > 0m) dcoeffm = rr * dcoeffp;
                    }

                    if (dcoeffp < epsilon)
                    { dcoeffp = epsilon; if (rr > 0m) dcoeffm = rr * dcoeffp; }
                    if (dcoeffm < epsilon)
                    { dcoeffm = epsilon; if (rr > 0m) dcoeffp = dcoeffm / rr; }



                    //   _nbSameDirection = 0;
                    //  lastAutoDirection = null;



                    if (_linkconv)
                        calcConv();
                    else
                    {

                        //  var delta = 1 - dconvergence; // 1- 0.9 = 0.1 // 1-0.1 = 0.9
                        // dconvergence /= (1 + dconvdeltam); // 0.09 // 0.81
                        //  dconvergence = 1 - delta; // 0.9 -> 0.91 // 0.1-> 0.19
                    }


                    // danticonvergence /= (1 + danticonvdeltam);
                    //var delta = 1 - danticonvergence; 
                    //delta *= (1- danticonvdeltam) ;
                    //danticonvergence = delta - 1; 
                    // if (danticonvergence < 1m) danticonvergence = 1;

                    //delta = danticonvergence - 1; // 0.1
                    //delta *= danticonvdeltam;  //0.09; 
                    //    danticonvergence = 1+delta; // 1.1 -> 1.09
                    // }



                }
                else
                {
                    bool applyanti = false;
                    if (selectedByCoeff && -_nbSameDirectionBox > serialm)
                        applyanti = true;
                    else if (!selectedByCoeff && _nbSameDirectionBox > serialp)
                        applyanti = true;
                    else if (_nbElastique > serialElastique)
                        applyanti = true;
                    else if (_nbElastique2 > serialElastique)
                        applyanti = true;
                    if (applyanti)
                    {
                        lastDelta = true;
                        var limit = dcoeffp + epsilon;
                        //if (dcoeffp * danticonvergence < epsilon)
                        //{
                        //    danticonvergence = epsilon / dcoeffp; 
                        //}
                        dcoeffp *= (1 + danticonvergence);
                        dcoeffm *= (1 + danticonvergence);
                        //   danticonvergence *= (1 + danticonvdeltap);



                        if (danticonvergence > 0 && limit > dcoeffp)
                        {
                            dcoeffp = limit;
                        }

                        if (rr > 0)
                            dcoeffm = rr * dcoeffp;

                    }
                    else
                        lastDelta = null; 
                    if (_linkconv)
                        calcConv();
                    else if (applyanti)
                    {
                        //   dconvergence *= (1 + dconvdeltap);
                        //   var delta = 1 - dconvergence; // 1- 0.9 = 0.1 // 1-0.1 = 0.9
                        //var delta = 1 - dconvergence; //0.1 -> 0.9  0.5->0.5
                        //delta /= (1+ dconvdeltap); // 0.81 0.25
                        //dconvergence = 1 - delta;  // 0.18 0.75
                        // dconvergence *= dconvdeltap; // 0.11 // 0.99
                        //    dconvergence = 1 - delta; // 0.9 -> 0.89 // 0.01
                        if (dconvergence > 1 - epsilon)
                            dconvergence = 1 - epsilon;
                        if (dconvergence < epsilon)
                            dconvergence = epsilon;
                    }

                }

                bool onAugmente = lastDelta.HasValue && lastDelta == lastDelta_; 


                if (c0 == dcoeffp || !onAugmente)
                {

                    var d = danticonvergence;

                    danticonvergence /= (1 + danticonvdeltam);
                    if (danticonvergence < danticonvergence01)
                        danticonvergence = danticonvergence01;
                    dconvergence /= (1 + dconvdeltam);
                    if (dconvergence < dconvergence01)
                        dconvergence = dconvergence01;
                }
                else
                {
                    dconvergence *= (1 + dconvdeltap);
                    if (dconvergence > dconvergence0)
                        dconvergence = dconvergence0;
                    danticonvergence *= (1 + danticonvdeltap);
                    if (danticonvergence > danticonvergence0)
                        danticonvergence = danticonvergence0;
                }

                misc.log("convergence {0:0.##}->{1:0.######}", c0, dcoeffp);
                misc.log("evol convergence {0:0.######}->{1:0.######}", aux, dconvergence);
            }

            if (selectedByCoeff)
            {
                ///
                // 1.01 -0.2
                if (coeffVirt - dcoeffm <1)
                {
                    dcoeffm =  coeffVirt-1 ; // ==0.01
                    if (rr != 0)
                        dcoeffp = dcoeffm / rr; 
                }
                makeDelta(false, dcoeffm, nb);
            }
            else
                makeDelta(true, dcoeffp, nb);








        }

        public decimal CoeffT { get { return (decimal)Math.Pow(coeffVirt, safe); } }
        public decimal CoeffOld { get { return (decimal)Math.Pow(coeffVirt, coeffOldAutoLevel); } }

        private decimal getCoeff(decimal coeffT) { return Math.Pow(coeffT, (1.0m / safe)); }

        private void makeDelta(bool sens, decimal delta, int nb)
        {
          
            try
            {                
                decimal coeffT = coeffVirt; // CoeffT;
                while (histo.Count >= NB_HISTO)
                    histo.RemoveAt(0);


                string montee = sens ? "up" : "down";
                var c0 = coeffT;
                if (sens)
                {
                    for (int i = 0; i < nb; i++)
                        coeffT += delta;
                }
                else
                {
                    for (int i = 0; i < nb; i++)
                        coeffT -= delta;
                }
                if (coeffT < 1)
                {
                    coeffT = 1;
                }

                // var coeff = getCoeff(coeffT); // (decimal)Math.Pow((double)coeffT, (1.0 / (double)safe));

                misc.log("{0} {1:0.######} {2:0.######}->{3:0.######}", montee, delta, c0, coeffT);

                coeffVirt = coeffT; // coeff;
             
                if (coeffOldAuto)
                {
                    coeffOld = CoeffOld;
                }
                histo.Add(coeffVirt);
            }
            catch
            {
            }

         

        }

        public HistoStat calcStat(selectedCoeff motif, int nb)
        {
            var stat = new HistoStat();
            int _nb = 0;
            int count = histo.Count;
            for (int i = count - 1; i >= 0; i--)
            {
                var h = histo[i];

                // min 
                if (h < stat.min.absolute)
                    stat.min.absolute = h;
                // calcul du plus faible qui n'a pas fonctionné

                if (h < stat.min.relative)
                {
                    if (i + 1 < count)
                    {
                        var suivant = histo[i + 1];
                        if (suivant < h)
                            stat.min.relative = h;
                    }
                    else
                    {
                        if (motif > selectedCoeff.noCoeff || motif == selectedCoeff.none)
                            stat.min.relative = h;
                    }
                }

                //max
                if (h > stat.max.absolute)
                    stat.max.absolute = h;
                // calcul du max qui fonctionne
                if (h > stat.max.relative)
                {
                    if (i + 1 < count)
                    {
                        var suivant = histo[i + 1];
                        if (suivant > h)
                            stat.max.relative = h;
                    }
                    else
                    {
                        if (motif <= selectedCoeff.noCoeff)
                            stat.max.relative = h;
                    }
                }

                _nb++;
                if (_nb >= nb)
                    break;
            }

            return stat;
        }

        private decimal calcMin(int nb, bool sens)
        {
            decimal min = CoeffT;
            int _nb = 0;
            int count = histo.Count;
            for (int i = count - 1; i >= 0; i--)
            {
                var h = histo[i];

                if ((sens && h > min) || (!sens && h < min))
                {
                    // calcul du max qui fonctionne
                    if (sens)
                    {
                        if (i + 1 < count)
                        {
                            var suivant = histo[i + 1];
                            if (suivant > h)
                                min = h;
                        }
                    }
                    // calcul du plus faible qui n'a pas fonctionné
                    else
                        if (i + 1 < count)
                        {
                            var suivant = histo[i + 1];
                            if (suivant < h)
                                min = h;
                        }
                }

                _nb++;
                if (_nb >= nb)
                    break;
            }
            return min;
        }

        public decimal coeffTMin(int nb)
        {
            return calcMin(nb, false);
        }

        public decimal coeffTMax(int nb)
        {
            return calcMin(nb, true);
        }



    }
    public class CalcMedianne
    {

        const decimal PRECISION = 0.0000001m;
        const decimal EPSILON = 0.0000000000001m;
        const decimal EPSILON_LOG = EPSILON;
        private static int index;
        public static int Index { get { return index; } }



        public static DecimalIndex getMedianne(IList<decimal> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }



        private static decimal getLn(decimal rapport)
        {
            if (rapport <= 0)
                return 0m;
            return Convert.ToDecimal(10 + Math.Log10(rapport));
        }
        private static decimal getRapport(decimal ln)
        {
            return Convert.ToDecimal(Math.Pow(10, ln - 10));
        }

        private static DecimalIndex calcmedianneVirt(IList<decimal> _list, decimal coeffMedianne, bool quasi)
        {

            int count = _list.Count;

            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                {

                    _list.RemoveAt(count - i);
                }

                var aux = getMedianne_(_list, coeffMedianne);
                if (aux == 0m)
                    continue;
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                }

                if (_list[count - i - 1] > 0m)
                    break;


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }


        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1];
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var dx = medianne - index;


            // var ret = val0 + pente * dx;


            // moyenne avec calcul de log
            var log0 = Math.Log(val0 + EPSILON_LOG);
            var log1 = Math.Log(val1 + EPSILON_LOG);
            // pente = log1 - log0;
            var log = log0 + (log1 - log0) * dx;
            return Math.Exp(log) - EPSILON_LOG;


        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}]]></content>
  </file>
  <file path="\pdb.util\TuningBase.cs">
    <content><![CDATA[using System;
using System.Xml;

namespace pdb.util
{
    [Serializable]
    public enum dbMode
    {
        full,
        diff
    }

    [Serializable]
    public class TuningBase
    {
        public const string DIR_CONF = @"..\conf\";
        public delegate void sets(string value);
        public delegate void setd(double value);
        public delegate void setdec(decimal value);
        public delegate void seti(int value);
        public delegate void setin(int? value);
        public delegate void setb(bool value);
        public delegate void setbn(bool? value);
        public delegate void setDate(DateTime value);
        [NonSerialized]
        protected XmlElement parent;
        [NonSerialized]
        protected XmlElement child;

        public TuningBase()
            : this(null, null)
        {
        }

        public TuningBase(XmlElement node) : this(null, node) { }

        public TuningBase(XmlElement parent, XmlElement child)
        {
            this.parent = parent;
            this.child = child;
        }
        protected XmlWriter w;
        public virtual void save(XmlWriter w) { this.w = w; }

        protected void writeStart(string name)
        {
            w.WriteStartElement(name);
        }
        protected void writeEnd()
        {
            w.WriteEndElement();
        }
        protected void write(string name, object value)
        {
            string val = "";
            if (value != null)
            {
                if (value is bool || value is bool?)
                    val = (bool)value ? "true" : "false";
                else
                    val = value.ToString();
            }
            w.WriteAttributeString(name, val);
        }



        protected void buildd(string name, setd setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
            elt = child[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
        }

        protected void builddec(string name, setdec setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(Convert.ToDecimal(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(Convert.ToDecimal(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setd(Convert.ToDecimal(elt.InnerText));
            elt = child[name];
            if (elt != null)
                setd(Convert.ToDecimal(elt.InnerText));
        }

        protected void buildi(string name, seti seti)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
            elt = child[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
        }

        protected void buildin(string name, setin seti)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
            elt = child[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
        }

        protected void builds(string name, sets sets)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                sets(att.InnerText);
            att = child.Attributes[name];
            if (att != null)
                sets(att.InnerText);

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                sets(elt.InnerText);
            elt = child[name];
            if (elt != null)
                sets(elt.InnerText);
        }

        protected void buildb(string name, setb setb)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setb("true" == att.InnerText);
            att = child.Attributes[name];
            if (att != null)
                setb("true" == att.InnerText);

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setb("true" == elt.InnerText);
            elt = child[name];
            if (elt != null)
                setb("true" == elt.InnerText);
        }

        private void _buildbn(string str, setbn setb)
        {
            if ("true".Equals(str))
                setb(true);
            else if ("false".Equals(str))
                setb(false);
            else setb(null);
        }
        protected void buildbn(string name, setbn setb)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                _buildbn(att.InnerText, setb);

            att = child.Attributes[name];
            if (att != null)
                _buildbn(att.InnerText, setb);


            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                _buildbn(elt.InnerText, setb);
            elt = child[name];
            if (elt != null)
                _buildbn(elt.InnerText, setb);
        }

        protected void buildDate(string name, setDate setDate)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setDate(Convert.ToDateTime(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setDate(Convert.ToDateTime(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setDate(Convert.ToDateTime(elt.InnerText));
            elt = child[name];
            if (elt != null)
                setDate(Convert.ToDateTime(elt.InnerText));
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;
using pdb.gen.Virtuel;
using pdb.gen.Tuning;

namespace pdb.gen
{
    /// <summary>
    /// G�re l'application propri�taire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private static Logger logger = Logger.getLogger("gen", true);
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des données consolidées morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        private List<Piece> allClassedInAlbumEnabled = new List<Piece>();
        private List<Piece> all = new List<Piece>();
        /// <summary>
        /// Liste des données morceux dupliqués 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        private Albums albums; // = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private static volatile object _lock = new object();
        private bool _consolidEnCours;


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private CPlayList root = new CPlayList("root", null, creator);
        public CPlayList Root { get { return root; } }
        private CPlayList musique;
        private CPlayList classement;
        private CPlayList listes;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new CPlayList("musique", root, creator);
            classement = new CPlayList("classement", root, creator);
            listes = new CPlayList("listes", root, creator);
            albums = new Albums(this);
        }

        private void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating;
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        public void buildClassTree()
        {
            buildClassTree(classement);
        }


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }
        private bool _fisrtConsolid = true;
        public Albums Albums { get { return albums; } }
        public void MakeConsolid(IEnumerable<ITrackNativeDates> dbList)
        {
            try
            {
                waitForConsolid();
                logger.log("consolid");
                listPiece = new List<Piece>();
                listPieceInAlbum = new List<Piece>();
                all = new List<Piece>();

                // albums = new Albums(this);
                VirtualPiece.init();
                m_listTrackClassed = new List<Piece>();
                allClassed = new List<Piece>();
                allClassedInAlbumEnabled = new List<Piece>();
                //  htIds = new BgDict<int, Piece>();
                foreach (ITrackNativeDates track in dbList)
                {

                    if (!track.isPodcast)
                    {
                        Piece piece = null;
                        int pieceId = track.PieceId;
                        if (htIds.ContainsKey(pieceId))
                        {
                            piece = htIds[pieceId];
                            piece.initRank();
                        }
                        else
                        {
                            piece = new Piece(track);
                            htIds.Add(pieceId, piece);
                        }

                        all.Add(piece);

                    }
                }
                // link
                foreach (Piece piece in all)
                {
                    int parentId = piece.PieceParentId;
                    if (parentId > 0)
                    {
                        piece.Parent = htIds[parentId];
                    }
                }

                // liste FORT + albums

                albums.checkBuild();
                logger.log("build albums");
                foreach (Piece piece in all)
                {
                    if (piece.Parent == null)
                    {
                        listPiece.Add(piece);
                        foreach (Piece p in piece)
                        {
                            if (albums.check(p))
                                listPieceInAlbum.Add(p);
                        }
                    }
                }

                if (_albumVirtual && _fisrtConsolid)
                {
                    logger.log("build albums virtuels");
                    var listCandidat = new List<Piece>();
                    var dictTmp = new BgDictString<Album>();
                    foreach (Piece piece in all)
                    {
                        if (piece.Parent == null)
                        {
                            piece.buildVirtualAlbums(listCandidat);
                        }
                    }
                    foreach (Piece p in listCandidat)
                        albums.checkVirtual(p, dictTmp);
                    var listAlbums = new List<Album>(dictTmp.Values);
                    listAlbums.Sort(new VirtualAlbumComparer());
                    albums.checkVirtuals(listAlbums, listPieceInAlbum);

                }

                albums.buildDone();



                StackAlbum.Instance.init(all);



                foreach (Piece piece in listPieceInAlbum)
                {
                    if (!string.IsNullOrEmpty(piece.ClassName))
                    {
                        allClassed.Add(piece);
                        if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                            allClassedInAlbumEnabled.Add(piece);
                    }
                }

                if (_fisrtConsolid)
                    albums.sortVirtual();
                Ranking();
            }
            finally
            {
                lock (_lock)
                {
                    _fisrtConsolid = false;
                    _consolidEnCours = false;
                }
            }

        }

        public void buildMusique()
        {
            var d = new HashSet<int>();
            foreach (Piece piece in all)
            {
                if (d.Add(piece.PieceId))
                    musique.addObj(piece);
            }


            foreach (Piece piece in listPieceInAlbum)
            {
                if (d.Add(piece.PieceId))
                    musique.addObj(piece);
            }


#if GEN_ALBUM

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.TrackByNumber;

                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }
#endif

        }

        public void buildLists(CPlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(CPlayList mine, CPlayList ext)
        {
            foreach (PlComponent c in ext)
            {
                if (c is CPlayList)
                {
                    var subExt = c as CPlayList;
                    var sub = new CPlayList(subExt.Name, mine);
                    sub.ID = subExt.ID;
                    // mine.add(sub);
                    buildList(sub, subExt);
                }
                else
                {
                    var t = c as IFile;
                    var piece = htIds[t.PieceId];
                    mine.add(new TrackList(piece));
                }
            }
        }

        internal Album getAlbum(TrackList track)
        {
            return albums.getAlbum(track);
        }

        public HashList<Piece> getTracksAlbum(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return new HashList<Piece>();
            return album.Tracks;
        }

        public List<Piece> getTracksAlbumReverse(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackSortedByExportPriority.List;
        }

        public List<Piece> getTracksAlbumByNumber(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackByNumber;
        }

        //public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        //{
        //    var album = getAlbum(track);
        //    if (album == null)
        //        return;
        //    foreach (var p in album.Tracks)
        //    {
        //        container.Add(p);
        //    }
        //}

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();

                var list = new List<Piece>();
                var d = new HashSet<int>();
                foreach (Piece piece in all)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                foreach (Piece piece in listPieceInAlbum)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }

               
                list.Sort(new AllPieceComparer2());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking()
        {
            QRanking();
            LRanking();
            QLRanking();

            logger.log("setTuningDateValues");
            var list = new List<Piece>(listPiece);

            foreach (Piece piece in list)
            {
                piece.Rank.TimeRest = -1;
            }
            foreach (Piece piece in list)
            {
                piece.FirstClass = false;
                CRank rank = piece.Rank;
                var sortValue = CTuning.Calc(rank, CConf.Sort);
                rank.SortValue = sortValue;

                ListSelection.setTuningDateValues(piece);
            }

            logger.log("PieceRestComparer->RankRest ");
            list.Sort(new PieceRestComparer());

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            logger.log("list.Sort(new PieceDeltaComparer());");
            list.Sort(new PieceDeltaComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankDelta = i + 1;
            }

            logger.log("PieceSortComparer->Sort ");
            list.Sort(new PieceSortComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            logger.log("AlbumsSort ");
            var all = new List<Piece>(listPieceInAlbum);

            albums.makeSort();
            logger.log("AllPieceComparer->RankAllAlbum ");
            all.Sort(new AllPieceComparer());
            for (int i = 0; i < all.Count; i++)
            {
                all[i].RankAllAlbum = i + 1;
            }

            CTuning.Total = listPieceInAlbum.Count;

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackNativeDates> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackNativeDates track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux not�s
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.ClassementValueDecimal);
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                logger.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                logger.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        logger.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating);
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                logger.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    logger.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    logger.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    logger.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    logger.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                logger.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    logger.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            logger.log("Qranking");



            CPieceComparerByGoodness l_pieceComparer = new CPieceComparerByGoodness();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }


            //on ordonne les morceaux top-down => sont privil�gi�s les plus en vue
            listPiece.Sort(l_pieceComparer);

            //compactage de la liste en tenant compte des mieux not�s
            m_list = new CListPiece(listPiece);

            logger.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.ClassName != "")
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            logger.log("Qranking:track classed :" + m_listTrackClassed.Count);
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }

            Console.WriteLine("Qranking:total class�s : " + m_listTrackClassed.Count);

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                    break;
            }
            return Convert.ToInt32(qRank);
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur longueur
        /// </summary>
        /// <remarks></remarks>
        private void LRanking()
        {
            logger.log("LRanking");
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByLenght());
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.LRank = l_iIndex + 1;
            }
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur qualit� +longueur en cas d'�galit�
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            logger.log("QLRanking");
            m_listQL = new List<Piece>(m_listTrackClassed);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByQualityAndLength());
            int count = l_aux.Count;
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.QLRank = l_iIndex + 1;
            }

            l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.Rank.TwiceInv = l_iIndex + 1;
            }

            if (CConf.Condensation)
            {
                var l = new List<Piece>(this.listPiece);
                l.Sort(new CPieceComparerByQualityAndLength2());
                new Condenseur(m_listQL).gener2();

            }

        }

        public void builStats(Action rappel)
        {
            try
            {
                bool generDistrib = step % 10 == 0;

                if (_albumSortMode.createCourant)
                {
                    var unselected = m_listQL.FindAll(t => !t.Enabled);
                    new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("courant4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("courant4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createInter)
                {
                    var unselected = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent); //  ( CalcDate.getLastModif(t.DatesClassement) > _albumSortMode.lastModif && t.ClassementProvisoire));
                    new StatBuilder(unselected).gener3("stats3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("stats4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("stats4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createAll)
                {
                    new StatBuilder(m_listQL).gener3("all.txt", generDistrib);


                    //  new StatBuilder(m_listQL).gener3(generDistrib);
                    var stat = new StatBuilder(m_listQL) { Loupe = 1 };
                    stat.gener4("all.txt");
                    stat = new StatBuilder(m_listQL) { Loupe = 2 };
                    stat.gener4("all.txt");
                    //stat = new StatBuilder(m_listQL) { Loupe = 3 };
                    //stat.gener4("stats4.txt");
                }


            }
            catch (Exception ex)
            {
                logger.log(ex.ToString());
            }
            finally
            {
                if (rappel != null)
                    rappel();
            }
        }


        public DynamicStat generStat(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).gener(className);
        }

        public List<Piece> getTracks(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).getPieces(className);
        }



        public void timeRanking()
        {
            logger.log("timeRanking");
            foreach (var piece in allClassed)
                piece.Rank.TimeRest = -1;
            foreach (var piece in allClassed)
                ListSelection.setTuningDateValues(piece);


        }

        /// <summary>
        /// redirection des index metier de la table m�tier vers la table locale
        /// Copie des valeurs pertinentes(classlist)
        /// </summary>
        /// <remarks></remarks>
        public void eraseGrouping()
        {
            thCommentGo = false;
            thGroupingGo = false;
            logger.log("eraseGrouping");
            foreach (Piece piece in listPieceInAlbum)
            {
                piece.setGrouping("", false);
                piece.Comment = "";
            }
        }
        public void writeGrouping()
        {
            logger.log("writeGrouping");
            var list = new List<Piece>(listPieceInAlbum);
            // list.Sort(new CPieceComparerByQualityAndLength());
            list.Sort(new AllPieceComparer2());

            var writeGrouping = CConf.ConfGen.WriteGrouping;
            foreach (Piece piece in list)
            {
                try
                {
                    piece.writeGrouping(writeGrouping);
                }
                catch (Exception ex)
                {
                    logger.log("writeGrouping::" + ex.ToString());
                }

            }
        }


        private bool thGroupingGo;
        private bool thCommentGo;

        public bool GroupinGO
        {
            set
            {
                thGroupingGo = value;
                if (value)
                {
                }
            }
        }
        public bool CommentGo
        {
            set
            {
                thCommentGo = value;
                if (value)
                {
                }
            }
        }



        //private void writeGroupingAsync()
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        try
        //        {
        //            if (!thGroupingGo)
        //                return;
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}

        //private void writeCommentAsync()
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in listPiece)
        //    {
        //        try
        //        {
        //            if (!thCommentGo)
        //                return;
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeComment::" + ex.ToString());
        //        }
        //    }
        //}

        public void writeGrouping(Piece piece)
        {
            var writeGrouping = CConf.ConfGen.WriteGrouping;
            piece.writeGrouping(writeGrouping);

        }
        // private bool _sortByAlbum = true;
        //   public bool SortByAlbum { get { return _albumSortMode.Enabled; } }

        private ConfAlbumSort _albumSortMode;
        public ConfAlbumSort SortAlbumMode { set { _albumSortMode = value; } get { return _albumSortMode; } }

        private bool _albumVirtual = CConf.ConfGen.AlbumVirtual;
        public bool AlbumVirtual { get { return _albumVirtual; } set { _albumVirtual = value; } }

        public void writeComment()
        {
            logger.log("writeComment");
            var list = new List<Piece>(listPiece);
            list.Sort(new CPieceComparerByQualityAndLength());

            var writeComment = CConf.ConfGen.WriteComment;
            foreach (Piece piece in list)
            {
                try
                {
                    piece.writeComment(writeComment);
                }
                catch (Exception ex)
                {
                    logger.log("writeComment::" + ex.ToString());
                }
            }




        }

        public void writeComment(Piece piece)
        {
            var writeComment = CConf.ConfGen.WriteComment;
            try
            {
                piece.writeComment(writeComment);
            }
            catch (Exception ex)
            {
                logger.log("writeComment::" + ex.ToString());
            }
        }



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter m_listWriterAlb;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public static object Lock { get { return _lock; } }
        public void createRot(string a_baseName, params IListWriter[] writers)
        {
            lock (_lock)
            {
                var conf = CConf.ConfGen;

                logger.log("Clegacy:createRot {0}", a_baseName);
                List<Piece> l_list = new List<Piece>(m_listTrackClassed);
                List<Piece> l_listAlb = new List<Piece>(allClassedInAlbumEnabled);
                var l_all = new List<Piece>(listPieceInAlbum);
                //  List<Piece> source = null;
                ////  if (SortByAlbum)
                //      source = allClassedInAlbumEnabled;
                //  else
                //      source = m_listTrackClassed;
                //  foreach (Piece l_piece in source)
                //  {
                //      //if (l_piece.belongsTo(a_baseName))
                //      //{
                //      l_list.Add(l_piece);
                //      // }
                //  }





                listWriterAll = new CLegacyListWriter(l_all);






                //      m_listWriter.reset();
                m_listWriter = new CLegacyListWriter(l_list);
                foreach (IListWriter writer in writers)
                    m_listWriter.addWriter(writer);
                //    logger.log("fin creation des writers 0");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {
                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriter.writeGen(mode, duration, "g", false, false);
                            if (conf.GenE)
                                m_listWriter.writeGen(mode, duration, "e", true, false);
                        }
                    }
                }

                if (conf.GenCheck)
                    m_listWriter.writeCheckClassement(0);

                for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
                {
                    m_listWriter.writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                    if (conf.GenE)
                        m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
                }
                m_listWriterAlb = new CLegacyListWriter(l_listAlb);

                foreach (IListWriter writer in writers)
                    m_listWriterAlb.addWriter(writer);

                //  logger.log("fin creation des writers alb");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {

                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriterAlb.writeGen(albums, mode, duration, "g", false);
                        }
                    }
                }

                foreach (IListWriter writer in writers)
                    listWriterAll.addWriter(writer);
                listWriterAll.writeGen(albums, null, null, "all", false);
                //  misc.log("Clegacy:fin createRot {0}", a_baseName);
                return;

                writeRot(1);

                m_listWriter.writeCheckClassement(1);

                m_listWriter.reset();
                writeRotMin(-1);
                writeRotMin(10);
                writeRotMin(1);
            }
        }
        private void writeRotMin(int a_nbHour)
        {
            logger.log("----------------------");
            m_listWriter.writeRotMin(a_nbHour);
        }
        private void writeRot(int a_base)
        {
            m_listWriter.writeRot(a_base);

        }
        #endregion
    }
}



]]></content>
  </file>
</db>
