<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\pdb.player\ViewModel\TrackListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Windows;
using pdb.obj;
using pdb.util;
using pdb.gen;
using pdb.db.obj;
using pdb.gen.albums;

namespace pdb.player.ViewModel
{

    public class TrackListViewModel : BibViewModelBase, ITrackNativeDates
    {




        #region répercut
        //  private static BgDict<int, List<TrackListViewModel>> dictT = new BgDict<int, List<TrackListViewModel>>();
        #endregion
        private TrackList track;
        private PieceViewModel piece;
        private static TrackListViewModel currentPlaying;
        private static TrackListViewModel currentSelected;
        public TrackList Track { get { return track; } }
        public CPiece Piece { get { return piece.Piece; } }
        public Piece PieceGen { get { return track.Piece; } }
        public Piece Master { get { return PieceGen.Master; } }

        public void remove()
        {
            //var list = dictT[PieceId];
            //if (list == null)
            //    return;
            //list.Remove(this);
        }

        public void refresh()
        {
            piece.eraseCommentGrouping();
            OnPropertyChanged("ExportStatus");
            OnPropertyChanged("TV");
            OnPropertyChanged("Comment");
            OnPropertyChanged("Grouping");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("ClassementVirtuel");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("");
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                base.IsSelected = value;
                if (value)
                    CurrentSelected = this;
            }
        }

        private int index;
        public int Index
        {
            get { return index; }
            set
            {
                if (value != index)
                {
                    index = value;
                    OnPropertyChanged("Index");
                }
            }
        }

        public int StackValue { get {return PieceGen.StackValue; } }
        public int StackIndex { get { return PieceGen.StackIndex; } }

        public static event EventHandler CurrentSelectedChanged;
        public static TrackListViewModel CurrentSelected
        {
            get
            {
                return currentSelected;
            }
            set
            {
                if (value != currentSelected)
                {
                    currentSelected = value;
                    if (CurrentSelectedChanged != null)
                        CurrentSelectedChanged("Track", EventArgs.Empty);
                }
            }
        }

        public static event EventHandler CurrentHumanSelectedChanged;
        private static TrackListViewModel humanSelected;
        public static TrackListViewModel HumanSelected
        {
            get { return humanSelected; }
            //set
            //{
            //    if (value != humanSelected)
            //    {
            //        humanSelected = value;
            //        if (CurrentHumanSelectedChanged != null)
            //            CurrentHumanSelectedChanged("Human", EventArgs.Empty);
            //    }
            //}
        }

        public static void setHumanSelected(PlayListViewModel pl, TrackListViewModel track)
        {
            if (track != humanSelected)
            {
                humanSelected = track;
                  if (CurrentHumanSelectedChanged != null)
                      CurrentHumanSelectedChanged(pl, EventArgs.Empty);
            }
        }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
                //if (value != track.Enabled)
                //{
                //    track.Piece.Enabled = value;
                //    OnPropertyChanged("Enabled");
                //}
            }
        }
        //  private exportState exportState;
        //public int ExportState
        //{
        //    get
        //    {
        //        return (int)exportState;
        //    }
        //}

        public static EventHandler ExportStatusChange;
        private static void OnExportStatusChange(TrackListViewModel tv)
        {
            if (ExportStatusChange != null)
                ExportStatusChange(tv, EventArgs.Empty);
        }

        public static event EventHandler ClassementChange;
        private static void OnClassementChange(TrackListViewModel tv)
        {
            if (ClassementChange != null)
                ClassementChange(tv, EventArgs.Empty);
        }

        public TrackListViewModel TV { get { return this; } }

        public exportState ExportStatus
        {
            get
            {
                return PieceGen.ExportStatus; // exportState;
            }
            set
            {
                if (PieceGen.ExportStatus != value)
                {
                    PieceGen.ExportStatus = value;
                    OnPropertyChanged("ExportStatus");
                    OnPropertyChanged("TV");
                    refresh();
                    OnExportStatusChange(this);
                    //refresh();
                    OnPropertyChanged("Background");

                }
            }
        }

        public selectedCoeff SelectedMotif
        {
            get
            {
                if (PieceGen == null)
                    return selectedCoeff.none; 
                return PieceGen.SelectedMotif; 
            }
        }

       






        public TrackListViewModel(TrackList track, PlayListViewModel playlist)
            : base(track, playlist)
        {
            this.track = track;
            this.piece = PieceViewModel.getPiece(track); // new PieceViewModel(track); // track.Piece.Track as CPiece; 
            piece.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(piece_PropertyChanged);
            int id = track.PieceId;
            //if (!dictT.ContainsKey(id))
            //{
            //    var list = new List<TrackListViewModel>();
            //    dictT.Add(id, list);
            //}

            //dictT[id].Add(this);

        }

        void piece_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            OnPropertyChanged(e.PropertyName);
        }

        public String StrPlaying
        {
            get
            {
                if (playing) return "<))";
                return "";
            }
        }
        public string MedianneStatus
        {
            get
            {
                var p = PieceGen;
                if (p.Medianne)
                    return ">>";
                if (p.MedianneLight)
                    return ">";
                if (p.Border)
                    return "-";
                if (p.BorderMin)
                    return "-";
                if (p.BorderEffect)
                    return "--";
              
                return "";
            }
        }

        private bool playing;
        public bool Playing
        {
            get { return playing; }
            set
            {
                if (value != playing)
                {
                    playing = value;
                    if (playing)
                    {
                        CurrentPlaying = this;
                    }
                    OnPropertyChanged("Playing");
                    OnPropertyChanged("StrPlaying");
                }
            }
        }

        public static TrackListViewModel CurrentPlaying
        {
            get
            {
                return currentPlaying;
            }
            set
            {
                if (value != currentPlaying)
                {
                    if (currentPlaying != null)
                        currentPlaying.Playing = false;
                    currentPlaying = value;
                }
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
                //if (value != track.Rating)
                //{
                //    track.Rating = value;
                //    onPropertyChanged("Rating");
                //}
            }
        }

        //  private pdb.db.obj.CPiece CPiece { get { return track.Piece.Track as pdb.db.obj.CPiece; } }


        //public static readonly DependencyProperty ClassementProperty =
        //DependencyProperty.Register("Classement", typeof(String),
        // typeof(PieceViewModel), new UIPropertyMetadata(null));
        public String Classement
        {
            get
            {
                return piece.Piece.StrClassement;
            }
            set
            {
                App.gen.Albums.signalClassChange(track); 
                // piece.StrClassement = value;
                if (value != piece.Piece.StrClassement)
                {
                    try
                    {

                        PlayerViewModel.makeauto(this); 
                        App.bib.setClassement(this, value);
                       
                          

                        // piece.Piece.StrClassement = value;

                    }
                    catch
                    {
                    }
                    piece.Classement = value;
                    OnClassementChange(this);
                    // onPropertyChanged("Classement");


                }
                App.go();
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
                //if (value != piece.Year)
                //{
                //    track.Year = value;
                //    onPropertyChanged("Year");
                //}
            }
        }


        //public static readonly DependencyProperty CommentProperty =
        //DependencyProperty.Register("Comment", typeof(string),
        //typeof(PieceViewModel), new UIPropertyMetadata(null)); 
        public string Comment
        {
            get
            {
                return piece.Comment;
            }
            set
            {
                //piece.Comment = value; 
                if (value != piece.Comment)
                {
                    //  track.Comment = value;
                    piece.Comment = value;
                    OnPropertyChanged("Comment");

                }
            }
        }

        public string Grouping
        {
            get { return piece.Grouping; }
            set
            {
                //  piece.Grouping = value;
                if (value != piece.Grouping)
                {
                    piece.Grouping = value;
                    // track.setGrouping(value, true);
                    OnPropertyChanged("Grouping");
                }
            }
        }




        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }


        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set
            {
                piece.Duration = value;
                //if (!Exists)
                //    return; 
                //if (value != Duration)
                //{
                //    var deltaMs = Math.Abs(value.TotalMilliseconds - Duration.TotalMilliseconds);
                //    if (deltaMs >= 1)
                //    {
                //        track.Duration = value;
                //        if (deltaMs >= 1000)
                //            onPropertyChanged("Duration");
                //    }
                //}
            }
        }

        public string Location
        {
            get { return piece.Location; }
        }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
                //if (value != track.Artist)
                //{
                //    track.Artist = value;
                //    onPropertyChanged("Artist");
                //}
            }
        }

        public string Album
        {
            get
            {
                if (track.Virtual)
                    return track.Album;
                return piece.Album;
            }
            set
            {
                if (!track.Virtual)
                    piece.Album = value;
                //if (value != track.Album)
                //{
                //    track.Album = value;
                //    onPropertyChanged("Album");
                //}
            }
        }

        public string Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
                //if (value != track.Name)
                //{
                //    track.Piece.Name = value;
                //    onPropertyChanged("Name");
                //}
            }
        }

        public int TrackNumber
        {
            get
            {
                return piece.TrackNumber;
            }
            set
            {
                piece.TrackNumber = value;
                //if (value != track.TrackNumber)
                //{
                //    track.TrackNumber = value;
                //    onPropertyChanged("TrackNumber");
                //}
            }
        }


        public void setClassement(string className, int rating)
        {
            piece.Piece.setClassement(className, rating);
            PieceGen.invalidateCache();

        }

        public string ClassName
        {
            get
            {
                return piece.Piece.ClassName;
            }
            set
            {
                piece.Piece.ClassName = value;
            }
        }


        public DateTime PlayedDate
        {
            get { return piece.Piece.PlayedDate; }
        }

        public string ArtWork
        {
            get
            {
                return piece.Piece.ArtWork;
            }
            set
            {
                piece.Piece.ArtWork = value;
            }
        }

        public void setGrouping(string value, bool prior)
        {
            piece.Piece.setGrouping(value, prior);
            piece.Grouping = value;
            // onPropertyChanged("Grouping");
        }

        public string ClassementVirtuel { get { return PieceGen.ClassementVirtuel; } }

        public decimal CoeffVirtuel { get { return PieceGen.CoeffVirtuel; } }

        public string ClassementVirtuel2 { get { return PieceGen.ClassementVirtuel2; } }

        public decimal CoeffVirtuel2 { get { return PieceGen.CoeffVirtuel2; } }

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.Piece.ClassPlayLists; }
        }

        public List<DateTime> Dates
        {
            get { return new List<DateTime>(piece.Piece.Dates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.Piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return track.Piece.ClassEvol; }
        }

        public long Size { get { return Piece.Size; } }

        public bool Exists { get { return Piece.Exists; } }

        //public void onPropertyChanged(string propertyName)
        //{
        //    var list = dictT[PieceId];
        //    if (list == null)
        //    {
        //        OnPropertyChanged(propertyName);
        //    }
        //    else
        //    {
        //        foreach (TrackListViewModel t in dictT[PieceId])
        //            t.OnPropertyChanged(propertyName);
        //    }
        //}




        public int PieceId
        {
            get { return track.PieceId; }
        }


        public int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }

        public void setParent(TrackListViewModel parent)
        {
            piece.Piece.Parent = parent.Piece;
            track.Piece.Parent = parent.track.Piece;
        }

        public void fusion(TrackListViewModel toDelete)
        {
            App.Db.List.fusion(piece.Piece, toDelete.Piece);

        }





        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public DateTime? UpdateClassement { get { return PieceGen.UpdateClassement; } }
        public DateTime? AlbumUpdateClassement { get { return PieceGen.AlbumUpdateClassement; } }

        public DateTime? LastRead { get { return PieceGen.LastRead; } }
        public DateTime? AlbumLastRead { get { return PieceGen.AlbumLastRead; } }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\DataGridPlayList.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.DataGridPlayList"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             mc:Ignorable="d" 
             d:DesignHeight="300" d:DesignWidth="300" >
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0" x:Name="dg" x:Uid="2D638B20-D34A-48B9-88E8-9F00F1BAA78D" ConfCouleur="main"
                            AutoGenerateColumns="False" IsSynchronizedWithCurrentItem="False"                   
                            SelectedItem="{Binding SelectedTrack, Mode=TwoWay}"               
                  >
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="{Binding Export.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding Export}" />
                    <MenuItem Header="{Binding ExportCompress.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding ExportCompress}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />



                </ContextMenu>
            </DataGrid.ContextMenu>
            
          
            <DataGrid.Columns>
                

                <DataGridTextColumn Binding="{Binding Index,Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>

                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>
                      
                    </DataGridTemplateColumn.CellTemplate>
                    
                    
                </DataGridTemplateColumn>

                <!--<DataGridCheckBoxColumn Header="" Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->
                  
                <DataGridCheckBoxColumn Header="" Binding="{Binding Exists,Mode=OneWay}" />
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Piste"  Binding="{Binding TrackNumber,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Comment" Binding="{Binding Comment,Mode=OneWay}"/>
                <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                
               
                <DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                <DataGridTextColumn Header="StackValue" Binding="{Binding StackValue, Mode=OneWay}"  >
                    <DataGridTextColumn.CellStyle>
                        <Style TargetType="DataGridCell" >
                            <Setter Property="ToolTip" Value="{Binding NbAlbumMoved, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                         </Style>
                    </DataGridTextColumn.CellStyle>
                  
                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Lecture"  Binding="{Binding LastRead, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Lecture Album"  Binding="{Binding AlbumLastRead, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>
                






            </DataGrid.Columns>
           
            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseMove" Handler="dg_PreviewMouseMove" />
                 
                    
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <!--<Setter Property="IsEnabled" Value="{Binding Exists}" />-->
                    <Setter Property="FontWeight" Value="Normal" />
                    <!--<Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}" />-->
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="Foreground" Value="Brown" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exists}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                     
                    </Style.Triggers>-->                    
                </Style>
            </DataGrid.ItemContainerStyle>
            <!--<DataGrid.RowStyle>
                <Style TargetType="{x:Type DataGridRow}">
                    <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                </Style>
            </DataGrid.RowStyle>-->
            <DataGrid.CellStyle>               
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=main, UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />
                   
                   

                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <!--<EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />-->
                    <Setter Property="BorderThickness" Value="0" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                    
                </Style>
            </DataGrid.RowStyle>

        </l:EnhancedDataGrid>
        <DockPanel Grid.Row="1" >
            <!--<TextBlock DockPanel.Dock="Bottom" Text="{Binding NbAlbumMovedDesc}" />-->
            <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMoved,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,10,0"/>

            <TextBlock DockPanel.Dock="Bottom" Text="{Binding Resume}" Background="{Binding TV, Converter={StaticResource colorExport00}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
        </DockPanel>
    </Grid>

</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Conf\ConfVirt.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using pdb.util;

namespace pdb.player.Vue.Conf
{
    public interface IConfSort
    {
        string CoeffEnabled { get; }
        bool DuplicateItem { get; }
    }
    /// <summary>
    /// Interaction logic for ConfVirt.xaml
    /// </summary>
    public partial class ConfVirt : UserControl
    {
        private ConfMedianneVirt conf;
        private IConfSort parent;
        

        public ConfVirt()
        {
            InitializeComponent();
        }

        public ConfVirt(ConfMedianneVirt conf, IConfSort parent)
            : this()
        {
            this.conf = conf;
            this.parent = parent;
            display();
            onchange();
        }

        public ConfMedianneVirt Conf
        {
            set
            {
                this.conf = value; 
            }
        }


        public void display()
        {


            cb_lissage.IsChecked = conf.lissage;
            cb_removeEpsilon.IsChecked = conf.removeEpsilon;
            cb_reSort.IsChecked = conf.reSort;


            cb_cumul.IsChecked = conf.cumul;
            cb_noAdd.IsChecked = conf.noAdd;
            tb_safe.Text = conf.safe.ToString();
            tb_coeff.Text = conf.coeffVirt.ToString();


            cb_virtOnlyDisabled.IsChecked = conf.virtOnlyDisabled;
            cb_forceCoeffVirt.IsChecked = conf.forceCoeffVirt;
            cb_virtAlignPrec.IsChecked = conf.virtAlignPrec;
            cb_virtAlignSelected.IsChecked = conf.virtAlignSelected;
            cb_coeffVirtAdjust.IsChecked = conf.coeffVirtAdjust;
            cb_coeffVirtAuto.IsChecked = conf.coeffVirtAuto;


            cb_noaddEnd.IsChecked = conf.noAddEnd;
            cb_noaddAll.IsChecked = conf.noAddAll;

            cb_auto.IsChecked = conf.auto;
            tb_dcoeffp.Text = conf.dcoeffp.ToString("0.###");
            tb_dcoeffm.Text = conf.dcoeffm.ToString("0.###");
            tb_convergence.Text = conf.dconvergence.ToString("0.###");

        }

        public void record()
        {


            conf.lissage = cb_lissage.IsChecked.Value;
            conf.removeEpsilon = cb_removeEpsilon.IsChecked.Value;
            conf.reSort = cb_reSort.IsChecked.Value;

            conf.cumul = cb_cumul.IsChecked.Value;
            conf.noAdd = cb_noAdd.IsChecked.Value;
            conf.safe = Convert.ToInt32(tb_safe.Text);
            conf.coeffVirt = Convert.ToDecimal(tb_coeff.Text);

            conf.virtOnlyDisabled = cb_virtOnlyDisabled.IsChecked.Value;
            conf.forceCoeffVirt = cb_forceCoeffVirt.IsChecked.Value;
            conf.virtAlignPrec = cb_virtAlignPrec.IsChecked.Value;
            conf.virtAlignSelected = cb_virtAlignSelected.IsChecked.Value;
            conf.coeffVirtAuto = cb_coeffVirtAuto.IsChecked.Value;
            conf.coeffVirtAdjust = cb_coeffVirtAdjust.IsChecked.Value;

            conf.noAddEnd = cb_noaddEnd.IsChecked.Value;
            conf.noAddAll = cb_noaddAll.IsChecked.Value;

            conf.auto = cb_auto.IsChecked.Value; 
            conf.dcoeffp = Convert.ToDecimal(tb_dcoeffp.Text);
            conf.dcoeffm = Convert.ToDecimal(tb_dcoeffm.Text);
            conf.dconvergence = Convert.ToDecimal(tb_convergence.Text); 


        }



        private void onchange2()
        {
            try
            {
                var safe = Convert.ToInt32(tb_safe.Text);
                var coeffT = Convert.ToDouble(tb_coeffT.Text);
                var coeff = Math.Pow(coeffT, (1.0 / (double)safe));
                tb_coeff.Text = coeff.ToString();
            }
            catch
            {
            }
        }

        private void tb_safe_KeyUp(object sender, System.Windows.Input.KeyEventArgs e)
        {
            onchange();
        }

        private void tb_coeffT_KeyUp(object sender, System.Windows.Input.KeyEventArgs e)
        {
            onchange2();
        }

        public void onchange()
        {



            if (true == cb_coeffVirtAdjust.IsChecked)
            {
                try
                {
                    var safe = Convert.ToInt32(tb_safe.Text);
                    var coeffEnabled = Convert.ToDecimal(parent.CoeffEnabled);
                    var coeffVirt = Math.Pow((double)coeffEnabled, 1.0 / (safe + 1.0));
                    tb_coeff.Text = coeffVirt.ToString();
                }
                catch
                {
                }
            }

            try
            {
                var safe = Convert.ToInt32(tb_safe.Text);
                var coeff = Convert.ToDouble(tb_coeff.Text);
                var coeffT = Math.Pow(coeff, (double)safe);
                tb_coeffT.Text = coeffT.ToString("0.###");
            }
            catch
            {
            }

        }

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using iTunesLib;
using pdb.ordo;
using pdb.podcast.Build;
using pdb.util;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util.list;

namespace pdb.podcast
{
    public enum selectMode
    {
        none = 0,
        standAlone = 1,
        simple = 2,
        serial = 3,
        histo = 4
    }

    public class TrackInfoItunes : pdb.it.TrackInfoItunes, IPub
    {
        private int albumRating; public int AlbumRating { get { return albumRating; } }
        private bool ratingComputed; public bool RatingComputed { get { return ratingComputed; } }

        private DateTime offset;
        public DateTime Offset
        {
            set
            {
                if (offset == DateTime.MinValue)
                    offset = value;
            }
            get { return offset; }
        }

        private static volatile object _lock = new object();
        private static int volumeMin = int.MinValue;
        public static int VolumeMin { set { volumeMin = value; } }
        protected static string defaultFolder;
        //private static bool _updateNative;
        //public static bool UpdateNative { get { return _updateNative; } set { _updateNative = value; } }
        public static string DefaultFolder
        {
            set
            {
                if (defaultFolder == null)
                {
                    defaultFolder = value;
                    if (!defaultFolder.EndsWith("\\"))
                        defaultFolder += ("\\");
                }
            }
            get { return defaultFolder; }
        }

        private int _dbId;

        public int DbId { get { return _dbId; } set { if (_dbId <= 0) _dbId = value; } }

        private static int NB = 0;
        private int iddebug;

        public TrackInfoItunes()
        {
            NB++;
            iddebug = NB;
        }

        private static BackGroundTaskMgr bgMove;  //new BackGroundTaskMgr("Move"); 

        private SequentialDictString<LimitItem> listSelected = new SequentialDictString<LimitItem>();
        //public List<LimitItem> Providers { get { return listSelected; } }

        private SequentialDictString<LimitItem> listLoad0 = new SequentialDictString<LimitItem>();
        private SequentialDictString<LimitItem> listStandAlone = new SequentialDictString<LimitItem>();
        // public List<LimitItem> Providers0 { get { return listLoad0; } }

        //private List<LimitItem> listLoadRecursif = new List<LimitItem>();
        //public List<LimitItem> ProvidersRecursif { get { return listLoadRecursif; } }

        //private List<LimitItem> listLoadGuest = new List<LimitItem>();
        //public List<LimitItem> ProvidersGuest { get { return listLoadGuest; } }



        /// <summary>
        /// Seule limite contenant le track
        /// </summary>
        private LimitItem exclu;
        public LimitItem Exclu { get { return exclu; } set { exclu = value; } }

        public void addPhase1(LimitItem item)
        {
            var key = item.ID;
            if (!listLoad0.ContainsKey(key))
                listLoad0.Add(key, item);
        }
        public bool containsload(LimitItem item)
        {
            var key = item.ID;
            return listLoad0.ContainsKey(key);
        }

        //public bool containsStandAlone(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listStandAlone.ContainsKey(key);
        //}

        public bool containsSelect(LimitItem item)
        {
            var key = item.ID;
            return listSelected.ContainsKey(key);
        }
        public bool isPreselected { get { return listLoad0.Count > 0; } }
        public ICollection<LimitItem> Providers1 { get { return listStandAlone.Values; } }
        public ICollection<LimitItem> Providers { get { return listSelected.Values; } }
        public LimitItem Provider
        {
            get
            {
                if (listSelected.Count == 0)
                    return null;
                return listSelected.List[0];
            }
        }
        public string GetProvider()
        {
            var provider = Provider;
            if (provider == null)
                return "";
            return provider.ToString();
        }

        public void addRecursif(LimitItem item)
        {
            //if (!listLoadRecursif.Contains(item))
            //    listLoadRecursif.Add(item);
        }

        public void addGuest(LimitItem item)
        {
            //if (!listLoadGuest.Contains(item))
            //    listLoadGuest.Add(item);
        }

        public static TrackInfoItunes createCopy(TrackInfoItunes org)
        {
            var copy = org.MemberwiseClone() as TrackInfoItunes;
            copy.clearLists();
            return copy;
        }

        const string REFONTE = "v1";
        public override void build(IITFileOrCDTrack track)
        {
            base.build(track);

            if (Strange)
                return;

            this.albumRating = track.AlbumRating;
            this.ratingComputed = track.ratingKind == ITRatingKind.ITRatingKindComputed;

#if MOVE
            var loc = track.Location;
            FileInfo file = new FileInfo(loc);
            if (loc.StartsWith("Y:"))
                return;
            string dest = "Y" + loc.Substring(1);


            try
            {
                misc.log("deplacer " + loc);
                string newDest = file.moveTree(dest, false);
                misc.log("-------> " + newDest);
                track.Location = newDest;
                //try
                //{
                //    File.Delete(loc);
                //}

                //catch (Exception del)
                //{

                //    misc.log(del.ToString());
                //}

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
#else

            if (!isPodcast)
                return;

            duree = new util.timeSpan(Duration);

            if (track.PlayedCount > 0)
            {
                played = markAsPlayed(Rating, PlayedDate);
            }

            var loc = track.Location;
            //if (loc.ToUpper().Contains("FABRIQUE"))
            //{
            //    int toto = 0; 
            //}
            bool target = true;
            var cuDtFileFormat = new DateTimeFormatInfo();
            cuDtFileFormat.FullDateTimePattern = "yyyy.MM.dd_HH.mm";
            string[] tab = loc.Split('_');
            var count = tab.GetLength(0);
            if (count >= 2)
            {
                var part = tab[0] + "_" + tab[1];
                DateTime dtFile;
                bool fileIsDate = DateTime.TryParse(part, cuDtFileFormat, DateTimeStyles.None, out dtFile);
                target = !fileIsDate;
            }


            //bool target = loc.ToUpper().Contains(@"D:\ZIQUE\PODCASTS\LA FABRIQUE DE L") && loc.ToUpper().Contains("HISTOIRE");

            try
            {

                pub = track.ReleaseDate;

                var cuDtFormat = new DateTimeFormatInfo();
                cuDtFormat.FullDateTimePattern = "yyyy/MM/dd";

                var cuDtFormat2 = new DateTimeFormatInfo();
                cuDtFormat2.FullDateTimePattern = "yyyy/MM/dd HH:mm";

                if (pub > MIN)
                {
                    string commentByReleaseDate = pub.ToString(cuDtFormat2.FullDateTimePattern);
                    if (Comment != commentByReleaseDate)
                    {
                        misc.log("chgt Comment � partir de releaseDate {0} de {1} vers {2} {3}", pub, Comment, commentByReleaseDate, this);
                        Comment = commentByReleaseDate;
                    }

                    return;
                }

                // ici pas de release Date

                string comment = track.Comment;

                try
                {
                    string partDate = comment.Split(' ')[0];
                    DateTime dtComment = DateTime.MinValue;

                    bool dtCommentBuild = false;

                    dtCommentBuild = DateTime.TryParse(partDate, cuDtFormat, DateTimeStyles.None, out dtComment);

                    bool dtCommentBuild2 = false;
                    if (dtCommentBuild)
                        dtCommentBuild2 = DateTime.TryParse(comment, cuDtFormat2, DateTimeStyles.None, out dtComment);


                    //if (dtComment.DayOfYear > 1)
                    //    return;

                    Regex reg = new Regex(@"(\d{2}.\d{2}.\d{4})");
                    string description = track.Description;

                    if (string.IsNullOrEmpty(description))
                        description = "";

                    DateTime dtDesc = DateTime.MinValue;
                    if (reg.IsMatch(description))
                    {
                        string strDescriptionDate = reg.Match(description).Groups[1].Value;

                        dtDesc = Convert.ToDateTime(strDescriptionDate);
                    }

                    if (dtDesc > DateTime.MinValue)
                    {
                        string newComment = dtDesc.ToString(cuDtFormat2.FullDateTimePattern);
                        if (newComment != track.Comment)
                        {
                            if (dtCommentBuild2 && dtComment.Minute != 0)
                                return;
                            misc.log("chgt Comment à partir de description {0} de {1} vers {2} {3}", description, comment, newComment, this);
                            track.Comment = newComment;
                        }
                    }
                    else if (dtCommentBuild2)
                    {

                    }






                }
                catch (Exception ex)
                {
                    misc.logError("impossible de gérer " + this, ex);
                }
            }
            finally
            {

                if (target)
                {

                    FileInfo file = new FileInfo(loc);
                    DirectoryInfo dirTrack = file.Directory;
                    DirectoryInfo dirPodcast = dirTrack.Parent;
                    if (!dirPodcast.Name.Equals(REFONTE))
                    {
                        DirectoryInfo dirV1 = new DirectoryInfo(dirPodcast.FullName + Path.DirectorySeparatorChar + REFONTE);
                        if (!dirV1.Exists)
                            dirV1.Create();

                        string dest = dirV1.FullName + Path.DirectorySeparatorChar + dirTrack.Name + Path.DirectorySeparatorChar + file.Name;  // loc.Replace(@"D:\", @"E:\");

                        string dirDest = Path.GetDirectoryName(dest);
                        string fileName = Path.GetFileName(dest);
                        fileName = pub.ToString("yyyy.MM.dd_HH.mm") + "_" + fileName;

                        dest = dirDest + Path.DirectorySeparatorChar + fileName;
                        try
                        {
                            misc.log("deplacer " + loc);
                            string newDest = file.copyTree(dest, null);
                            misc.log("-------> " + newDest);
                            track.Location = newDest;
                            try
                            {
                                File.Delete(loc);
                            }

                            catch (Exception del)
                            {

                                misc.log(del.ToString());
                            }

                        }
                        catch (Exception ex)
                        {
                            misc.log(ex.ToString());
                        }
                    }
                }

            }
#endif

        }


        private static IDictionary<int, DateTime> maxPlayed = new Dictionary<int, DateTime>();
        public static IDictionary<int, DateTime> MaxPlayed { set { maxPlayed = value; } }
        public static bool markAsPlayed(int rating, DateTime date)
        {
            if (maxPlayed.ContainsKey(rating))
                return date > maxPlayed[rating];
            return true;
        }
        public override void build(XmlNode xTrack)
        {
            base.build(xTrack);
            //if (Name.Contains("Aubenas"))
            //{
            //    int toto = 0;
            //}
            if (!isPodcast)
                return;
            if (Strange)
                return;
            string key = "";

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Rating Computed")
                        ratingComputed = true;
                    continue;
                }

                if (string.IsNullOrEmpty(value))
                    continue;
                switch (key)
                {
                    case "Date Added": added = Convert.ToDateTime(value); break;
                    case "Release Date": pub = Convert.ToDateTime(value); break;
                    case "Play Count": int playCount = Convert.ToInt32(value);
                        if (playCount > 0)
                            played = markAsPlayed(Rating, PlayedDate);
                        break;
                    case "Album Rating": albumRating = Convert.ToInt32(value); break;
                }

            }

            //for (int i = 0; i < xTrack.ChildNodes.Count; i += 2)
            //{
            //    XmlNode xKey = xTrack.ChildNodes[i];
            //    string value = xTrack.ChildNodes[i + 1].InnerText;
            //    string key = xKey.InnerText;

            //    if (string.IsNullOrEmpty(value))
            //        continue;
            //    switch (xKey.InnerText)
            //    {
            //        case "Date Added": added = Convert.ToDateTime(value); break;
            //        case "Release Date": pub = Convert.ToDateTime(value); break;
            //        case "Play Count": int playCount = Convert.ToInt32(value); if (playCount > 0) played = true; break;
            //        case "Album Rating": albumRating = Convert.ToInt32(value); break;


            //    }
            //}


            PubLoader.setPub(false);

            #region move vers pubLoader
            //
            //string _comment = Comment;
            //DateTime dateComment = DateTime.MinValue;

            //try
            //{
            //    dateComment = Convert.ToDateTime(_comment);
            //}
            //catch
            //{
            //}

            //if ((pub < MIN || pub.DayOfYear == 1)  && (dateComment > MIN && dateComment.DayOfYear > 1))
            //{
            //    pub = dateComment; 
            //}
            //string name = Name;
            //checkDate1(name);
            //checkDate2(name);
            //checkDate3(name);

            //bool pubYear = false;

            //if (!string.IsNullOrEmpty(Location))
            //{
            //    string fileName = Path.GetFileName(Location);
            //    checkDate1(fileName);
            //    checkDate2(fileName);
            //    checkDate3(fileName);
            //}

            //if (pub <= MIN)
            //{
            //    if (Year > 1970)
            //    {
            //        DateTime dtYear = new DateTime(Year, 1, 1);
            //        pub = dtYear;
            //        pubYear = true;
            //    }
            //}



            //if (added < MIN) added = MIN;

            //// DateTime dt_ = pub;
            //if (pub <= MIN)
            //    pub = added;
            //string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
            //if (pubYear)
            //    comment = getFileNameCmp(comment);
            //if (this.Comment != comment)
            //{
            //    try
            //    {
            //        string commentFound = this.Comment;
            //        string truc = commentFound;
            //        if (truc.Contains("_")) 
            //        {
            //            //d�j� fait
            //            return; 
            //        }
            //          //  truc = truc.Split('_')[0];

            //        DateTime iComment = Convert.ToDateTime(truc);
            //        if (iComment.DayOfYear != 1 && pub.DayOfYear == 1)
            //        {
            //            pub = iComment;
            //        }
            //        else
            //        {

            //            this.Comment = comment;
            //        }
            //    }
            //    catch
            //    {
            //        this.Comment = comment;
            //    }
            //}


            //

            #endregion




            duree = new util.timeSpan(Duration);
        }


        //private PubLoader pubLoader;
        //internal PubLoader PubLoader { get { if (pubLoader == null) pubLoader = new PubLoader(this); return pubLoader; } }
        internal PubLoader PubLoader { get { return new PubLoader(this); } }

        public static DateTime MIN = new DateTime(1970, 1, 1);
        #region move verspubLoader

        //
        //private static Regex regex1 = new Regex(@".*(\d\d\.\d\d\.\d\d\d\d).*");
        //private static Regex regex2 = new Regex(@".*(\d\d\d\d)(\d\d)(\d\d).*");
        //private static Regex regex3 = new Regex(@".*(\d\d)\.(\d\d)\.(\d\d)_(\d\d)\.(\d\d)_.*");

        //private string getFileNameCmp(string comment)
        //{
        //    string fileName = Path.GetFileNameWithoutExtension(location);

        //    if (fileName.Contains(" "))
        //    {
        //        var tab = fileName.Split(' ');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Contains("_"))
        //    {
        //        var tab = fileName.Split('_');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Length > 3)
        //        return comment;

        //    int nb = 0;
        //    bool isNum = Int32.TryParse(fileName, out nb);

        //    if (!isNum)
        //        return comment;

        //    while (fileName.Length < 3)
        //    {
        //        fileName = "0" + fileName;
        //    }
        //    return comment + "_" + fileName;
        //}
        //private void checkDate1(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex1.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex1.Match(info);
        //            string strDate = m.Groups[1].Value;
        //            DateTime dt = Convert.ToDateTime(strDate);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate2(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex2.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            DateTime dt = new DateTime(year, month, day);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate3(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex3.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            int hh = Convert.ToInt16(m.Groups[4].Value);
        //            int mm = Convert.ToInt16(m.Groups[5].Value);

        //            DateTime dt = new DateTime(year, month, day, hh, mm, 0);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        #endregion

        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{
        //    this.track = track;
        //    this.artist = track.Artist;
        //    this.album = track.Album;
        //    this.name = track.Name;
        //    this.trackNumber = track.TrackNumber;
        //    this.rating = track.Rating;
        //    this.year = track.Year;
        //    this.comment = track.Comment;
        //    this.enabled = track.Enabled;
        //    this._isPodCast = track.Podcast;
        //    this.playedDate = track.PlayedDate;
        //    this.location = track.Location;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.played = track.PlayedCount > 0;
        //    this.pub = track.ReleaseDate;

        //    checkDate1(name);
        //    checkDate2(name);

        //    if (!string.IsNullOrEmpty(location))
        //    {
        //        string fileName = Path.GetFileName(location);
        //        checkDate1(fileName);
        //        checkDate2(fileName);
        //    }

        //    if (pub <= MIN)
        //    {
        //        if (year > 1970)
        //        {
        //            DateTime dtYear = new DateTime(year, 1, 1);
        //            pub = dtYear;
        //        }
        //    }


        //    this.added = track.DateAdded;
        //    if (added < MIN) added = MIN;

        //    // DateTime dt_ = pub;
        //    if (pub <= MIN)
        //        pub = added;
        //    string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
        //    if (track.Comment != comment)
        //        track.Comment = comment;

        //}




        //public int TrackId { get { return track.trackID; } }
        //public int ID { get { return track.TrackDatabaseID; } }

        //public IITFileOrCDTrack Track { get { return track; } }


        #region ITrackNative Membres




        /// <summary>
        /// Date de publication
        /// </summary>
        private DateTime pub;
        public DateTime Pub { get { return pub; } }

        /// <summary>
        /// date d'ajout
        /// </summary>
        private DateTime added;
        public DateTime Added { get { return added; } }

        /// <summary>
        /// Podcast de type info
        /// </summary>
        private bool info;

        public bool Info
        {
            get { return info; }
            set { if (value) info = true; }
        }

        /// <summary>
        /// Podcast rare (moins de trois fois par semaine)
        /// </summary>
        private bool rare;
        public bool Rare
        {
            get { return rare; }
            set { if (value) rare = true; }
        }

        private bool played;
        public bool Played { get { return played; } }

        //private string feed;
        //public string Feed { get { return feed; } set { feed = value; } }

        private selectMode selected;
        private bool inJournal = false;

        public bool FreeInJournal { get { return Selected && !inJournal; } }
        public void markInJournal() { inJournal = true; }
        //    public bool StandAlone { get { return selected > selectMode.none; } }
        public bool Selected { get { return selected >= selectMode.simple; } }
        public bool Histo { get { return selected == selectMode.histo; } }
        public bool Serial { get { return selected == selectMode.serial; } }
        // public selectMode Select { get { return selected; } }


        private void clearLists()
        {
            selected = selectMode.none;
            exclu = null;
            inJournal = false;
            listSelected = new SequentialDictString<LimitItem>();
            listLoad0 = new SequentialDictString<LimitItem>();
            listStandAlone = new SequentialDictString<LimitItem>();
            indexRoot = -1;
            offset = default(DateTime);
            //listLoadGuest.Clear();
            //listLoadRecursif.Clear();

        }

        // private static Regex regInfoShort = new Regex(@".+(\d\d\.\d\d\.\d\d)");
        public void updateNative()
        {
            PubLoader.setPub(true);

            int volume = Volume;
            if (Album.Contains("RFI"))
            {
                if (volume != -20)
                    Volume = -20;
            }
            else
            {
                if (volume < volumeMin)
                    Volume = volumeMin;
            }


            if (pub > MIN)
            {


                string infoShort = pub.ToString("dd.MM.yy");
                string infoPubName = pub.ToString("dd.MM.yyyy");
                string infoPubName2 = pub.ToString("dd/MM/yyyy");
                string infoPubName3 = pub.ToString("dd/MM/yy");
                string infoYear = Year.ToString();
                if (pub.DayOfYear == 1)
                {
                    infoPubName = pub.Year.ToString();
                    infoPubName2 = infoPubName;
                    infoPubName3 = infoPubName;
                    infoShort = infoPubName;
                }

                string name = Name;
                string str = name;


                while (str.Contains(infoShort))
                    str = str.Replace(infoShort, "");
                while (str.Contains(infoPubName))
                    str = str.Replace(infoPubName, "");
                while (str.Contains(infoPubName2))
                    str = str.Replace(infoPubName2, "");
                while (str.Contains(infoPubName3))
                    str = str.Replace(infoPubName3, "");


                //if (regInfoShort.IsMatch(str))
                //{
                //    var strdate = regInfoShort.Match(str).Groups[1].Value;
                //    str = str.Replace(strdate, "");
                //}


                var strDayOfWeek = "";
                switch (pub.DayOfWeek)
                {
                    case DayOfWeek.Friday: strDayOfWeek = "v";
                        break;
                    case DayOfWeek.Monday: strDayOfWeek = "l";
                        break;
                    case DayOfWeek.Saturday: strDayOfWeek = "s";
                        break;
                    case DayOfWeek.Sunday: strDayOfWeek = "d";
                        break;
                    case DayOfWeek.Thursday: strDayOfWeek = "j";
                        break;
                    case DayOfWeek.Tuesday: strDayOfWeek = "ma";
                        break;
                    case DayOfWeek.Wednesday: strDayOfWeek = "me";
                        break;
                    default:
                        break;
                }
                //Michel Rocard (1/5) l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 17.06.13 l

                var s1 = strDayOfWeek + " ";
                strDayOfWeek = " " + strDayOfWeek;

                while (str.EndsWith(strDayOfWeek))
                    str = str.Remove(str.Length - strDayOfWeek.Length);
                while (str.EndsWith(s1))
                    str = str.Remove(str.Length - s1.Length);

                //if (str.Contains(infoPubName))
                //    str = str.Replace(infoPubName, infoShort);
                //else if (name.Contains(infoPubName2))
                //    str = str.Replace(infoPubName2, infoShort);

                //else
                //{
                //    if (!str.Contains(infoShort))
                //    {
                //        str = str + " " + infoShort;
                //    }
                //    else
                //    {
                //        if (Year > 1980 && str.Contains(infoYear))
                //            str = str.Replace(infoYear, "").Trim();
                //    }
                //}
                var strBUG = "30.12.99";
                if (str.Contains(strBUG))
                    str = str.Replace(strBUG, "");

                str = str.Replace("  ", " ");
                str = str.Replace("  ", " ");
                str = str.Replace("  ", " ").Trim();

                str += " ";
                str += infoShort; 


                str += strDayOfWeek;

                if (!str.Equals(name))
                    Name = str;
            }
        }
        public void select(selectMode value, LimitItem limit)
        {

            var key = limit.ID;

            if (value == selectMode.standAlone)
            {
                if (!listStandAlone.ContainsKey(key))
                    listStandAlone.Add(key, limit);
            }
            else
            {
                if (!listSelected.ContainsKey(key))
                    listSelected.Add(key, limit);
            }


            if (selected == value)
                return;

            if (value > selectMode.standAlone)
            {

                selected = value;


            }

        }


        #endregion

        public override string ToString()
        {
            int level = Rating / 20;
            string strPub = pub > MIN ? pub.ToShortDateString() : "";
            string strYear = Year > 0 ? Year.ToString() : "";
            return level.ToString() + " " + Album + " " + Name + " " + strYear + " " + strPub;
        }

        public void copy(string ziqueDest, string log)
        {
            if (string.IsNullOrEmpty(location))
                return;

            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                string strPub1 = pub.ToString("dd.MM.yyyy");
                string strPub2 = pub.ToString("yy.MM.dd");

                string fileName = Path.GetFileName(location);

                if (pub > MIN && !fileName.StartsWith(strPub1) && !fileName.StartsWith(strPub2))
                    fileName = strPub2 + "_" + fileName;

                string strDir = dir.Name;
                if (!string.IsNullOrEmpty(Album))
                    strDir = Album;



                string dest = ziqueDest + Path.DirectorySeparatorChar + strDir + Path.DirectorySeparatorChar + fileName;
                misc.log(" {0} {1} à copier vers {2}", log, location, dest);
                try
                {
                    string newDest = file.copyTree(dest, false);

                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

        }

        public void move(string ziqueOrg, string ziqueDest, DateTime limit)
        {
            if (pub >= limit)
                return;

            if (string.IsNullOrEmpty(location))
                return;
            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                if (location.StartsWith(ziqueOrg + @"Podcasts"))
                {
                    misc.log(" � d�placer" + location);
                    string dest = location.Replace(ziqueOrg, ziqueDest);

                    string dirDest = Path.GetDirectoryName(dest);
                    string fileName = Path.GetFileName(dest);
                    fileName = pub.ToString("yy.MM.dd_HH.mm") + "_" + fileName;

                    dest = dirDest + Path.DirectorySeparatorChar + fileName;
                    try
                    {
                        string newDest = file.copyTree(dest, false);
                        if (bgMove == null)
                        {
                            lock (_lock)
                            {
                                if (bgMove == null)
                                    bgMove = BackGroundTaskMgr.getMgrlarge("Move");
                            }
                        }
                        //  file.CopyTo(dest, true);
                        bgMove.add(new BgTaskCopy(this, location, newDest));
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }
                }
            }


        }

        private class BgTaskCopy : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskCopy(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Location = value;

                    misc.log("copie effectu�e " + value);
                    try
                    {
                        File.Delete(Desc);
                    }
                    catch (Exception ex)
                    {
                        misc.log("impossible de supprimer " + Desc + " " + ex.ToString());
                    }
                    success = true;
                }
                catch (Exception e)
                { misc.log("NIET " + e.Message); }

                if (!success && info.Track != null)
                {
                    //misc.log("invalidation track " + info);
                    ////  info.track = null;
                }

            }
        }



        DateTime IPub.Pub
        {
            get
            {
                return pub;
            }
            set
            {
                pub = value;
            }
        }

        string IPub.Comment
        {
            get
            {
                return Comment;
            }
            set
            {
                setGrouping(this.Comment, true);
                Comment = value;
            }
        }

        string IPub.Name
        {
            get { return Name; }
        }

        string IPub.Location
        {
            get { return location; }
        }

        int IPub.Year
        {
            get { return Year; }
        }

        DateTime IPub.Added
        {
            get
            {
                return added;
            }
            set
            {
                added = value;
            }
        }
        DateTime IPub.Offset { get { return offset; } }
        private pdb.util.timeSpan duree;
        public pdb.util.timeSpan Duree { get { return duree; } }

        private long _size = -1;
        public long Size
        {
            get
            {
                if (_size < 0)
                {
                    var f = FileRegister.Check(Location);
                    if (f.Exists)
                        _size = f.Length;
                    else
                        _size = 0;
                }
                return _size;
            }
        }

        private int indexRoot = -1;
        public int IndexRoot { get { return indexRoot; } set { indexRoot = value; } }


    }
}



]]></content>
  </file>
  <file path="\pdb.podcast\DB\Db.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.Xml;
using pdb.util.Generic.Parse;
using pdb.util.Generic;
using System.Reflection;

namespace pdb.podcast.DB
{
    class Db
    {
        public const int CURRENT_VERSION = 1;
        const string SEQ_PIECE = "seq";
        private static int pieceSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private BgDictString<TrackInfoItunes> dict = new BgDictString<TrackInfoItunes>();
     //   private XmlSerializer xmlSerializer;

        public Db()
        {
            //xmlSerializer = new XmlSerializer()
            //{
            //    FillLists = false,
            //    ManageListsWithArbo= false,
            //    IncludeDeclaration = true,
            //    ClearEmpy = true,             
            //    DateFormat = "dd/MM/yyyy HH:mm:ss",  
            //};

          
        }


        public void write(string file)
        {
            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;
            using (XmlWriter writer = XmlWriter.Create(file + ".tmp", settings))
            {
                writer.WriteStartElement("db");
                writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                foreach (TrackInfoItunes track in dict.Values)
                {
                    write(writer, track); 
                }
                writer.WriteEndDocument();
                writer.Flush();
            }

            //File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
        }

        private static void write(XmlWriter writer, TrackInfoItunes track)
        {
            writer.WriteStartElement("t");
            writer.WriteAttributeString("a", track.Album);
            writer.WriteAttributeString("n", track.Name);
            writer.WriteAttributeString("p", track.Pub.ToString());
            if (track.Rare)
                writer.WriteAttributeString("r", "y"); 
            if (track.Info)
                writer.WriteAttributeString("i", "y"); 
            writer.WriteEndElement(); 

        }

        private static void write(XmlWriter writer, PropertyInfo prop)
        {

        }
      
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Medianne.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;

namespace pdb.util
{
    public enum selectedCoeff
    {
        none,
        noCoeff,
        main,
        min
    }

    public enum medianneMode
    {
        none = 0,
        strict = 1,
        light = 2,
        moy = 3

    }
    public enum removeLast
    {
        non = 0,
        unselected = 1,
        virtuel = 2,
        tous = 3
    }

    public enum modeMin
    {
        /// <summary>
        /// On ne gère pas
        /// </summary>
        non = 0,
        /// <summary>
        /// Morceaux supérieurs à la limite ( pas d'influence sur le résultat)
        /// </summary>
        orphelin = 1,
        /// <summary>
        /// Morceaux cochés et notés
        /// </summary>
        toujours = 2

    }
    [Serializable]
    public class ConfMedianne : TuningBase
    {
        public medianneMode type;
        public decimal medianne = 0.5m;
        public bool quasi;

        public bool enabled;



        public bool removeFirst;
        public bool deleteFirst;
        public removeLast removeLast;

        public decimal expEnabled = 0m;

        public decimal zero = 0m;
        /// <summary>
        /// 
        /// </summary>
        public bool removeEnabled;




        public modeMin cmpMin;

        private ConfMedianneVirt _main;
        private ConfMedianneVirt _min;

        public ConfMedianneVirt Main { get { return _main; } }
        public ConfMedianneVirt Min { get { return _min; } }
        public ConfMedianne()
        {
            _main = new ConfMedianneVirt();
            _min = new ConfMedianneVirt();

        }

        public void makeIdem()
        {
            _min = _main;
        }

        public void duplicateMainIf()
        {
            if (_min == _main)
                _min = new ConfMedianneVirt(_main);
        }
        public ConfMedianne(ConfMedianne o)
        {
            type = o.type;
            medianne = o.medianne;
            quasi = o.quasi;

            enabled = o.enabled;



            removeFirst = o.removeFirst;
            deleteFirst = o.deleteFirst;
            removeLast = o.removeLast;

            expEnabled = o.expEnabled;

            zero = o.zero;
            removeEnabled = o.removeEnabled;



            cmpMin = o.cmpMin;

            _main = new ConfMedianneVirt(o._main);
            _min = new ConfMedianneVirt(o._min);

        }

        public ConfMedianne(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var strType = "";
            builds("type", v => strType = v);
            type = (medianneMode)Enum.Parse(typeof(medianneMode), strType, true);
            builddec("medianne", v => medianne = v);

            buildb("quasi", v => quasi = v);

            buildb("enabled", v => enabled = v);



            buildb("removeFirst", v => removeFirst = v);
            buildb("deleteFirst", v => deleteFirst = v);





            builddec("expEnabled", v => expEnabled = v);
            builddec("zero", v => zero = v);
            buildb("removeEnabled", v => removeEnabled = v);




            string _modeMin = "";
            builds("cmpMin", v => _modeMin = v);
            if (!string.IsNullOrEmpty(_modeMin))
                cmpMin = (modeMin)Enum.Parse(typeof(modeMin), _modeMin, true);


            string _removeLast = null;
            builds("removeLast", v => _removeLast = v);
            removeLast = (removeLast)Enum.Parse(typeof(removeLast), _removeLast, true);

            _main = null;
            _min = null;
            var subs = XMLTool.NodeLookUp(child, "virts");
            if (subs != null)
            {
                foreach (XmlNode _n in subs.ChildNodes)
                {
                    if (_n is XmlElement)
                    {
                        if (_main == null)
                        {
                            _main = new ConfMedianneVirt(child, _n as XmlElement);

                        }
                        else if (_min == null)
                        {
                            _min = new ConfMedianneVirt(child, _n as XmlElement);
                        }
                    }
                }
                if (_min == null && _main != null)
                    _min = new ConfMedianneVirt(_main);
            }
        }


        public void auto(selectedCoeff motif)
        {
            if (!enabled)
                return;
            if (motif == selectedCoeff.none)
                return;
            var coeffPrisEncompte = motif > selectedCoeff.noCoeff;
            if (_min == _main || _min.coeffVirt==1m)
            {
                _main.calcAuto(coeffPrisEncompte, 1);
            }
            else
            {
                if (coeffPrisEncompte)
                {
                    if (motif == selectedCoeff.main)
                        _main.calcAuto(true, 1);
                    if (motif == selectedCoeff.min)
                        _min.calcAuto(true, 1);
                }
                else
                {
                    _main.calcAuto(false, 1);
                    _min.calcAuto(false, 1);
                }
            }
        }
    }

    [Serializable]
    public class ConfMedianneVirt : TuningBase
    {
        const decimal EPSILON = 0.001m; 
        public int safe;
        public decimal coeffVirt = 1m;

        public bool virtOnlyDisabled;
        public bool noAddEnd;
        public bool noAddAll;
        public bool virtAlignSelected;
        public bool virtAlignPrec;
        public bool coeffVirtAuto;
        public bool coeffVirtAdjust;

        public bool removeEpsilon;

        public bool forceCoeffVirt;
        public bool lissage;
        public bool cumul;

        public bool reSort;
        public bool noAdd;


        public bool auto;
        public decimal dcoeffp;
        public decimal dcoeffm;
        public decimal dconvergence;

        private bool? lastAutoDirection; 

        public ConfMedianneVirt()
        { }
        public ConfMedianneVirt(ConfMedianneVirt o)
        {
            safe = o.safe;
            coeffVirt = o.coeffVirt;
            virtOnlyDisabled = o.virtOnlyDisabled;
            noAddEnd = o.noAddEnd;
            noAddAll = o.noAddAll;
            virtAlignSelected = o.virtAlignSelected;
            virtAlignPrec = o.virtAlignPrec;
            coeffVirtAuto = o.coeffVirtAuto;
            coeffVirtAdjust = o.coeffVirtAdjust;
            removeEpsilon = o.removeEpsilon;
            forceCoeffVirt = o.forceCoeffVirt;
            lissage = o.lissage;
            cumul = o.cumul;
            reSort = o.reSort;
            noAdd = o.noAdd;
            auto = o.auto;
            dcoeffp = o.dcoeffp;
            dcoeffm = o.dcoeffm;
            dconvergence = o.dconvergence;
        }
        public ConfMedianneVirt(XmlElement parent, XmlElement child)
            : base(parent, child)
        {

            builddec("coeffVirt", v => coeffVirt = v);
            buildi("safe", v => safe = v);

            buildb("virtOnlyDisabled", v => virtOnlyDisabled = v);
            buildb("noAddEnd", v => noAddEnd = v);
            buildb("noAddAll", v => noAddAll = v);
            buildb("virtAlignSelected", v => virtAlignSelected = v);
            buildb("virtAlignPrec", v => virtAlignPrec = v);
            buildb("coeffVirtAuto", v => coeffVirtAuto = v);
            buildb("coeffVirtAdjust", v => coeffVirtAdjust = v);

            buildb("removeEpsilon", v => removeEpsilon = v);
            buildb("forceCoeffVirt", v => forceCoeffVirt = v);
            buildb("lissage", v => lissage = v);
            buildb("cumul", v => cumul = v);
            buildb("reSort", v => reSort = v);
            buildb("noAdd", v => noAdd = v);
            buildb("auto", v => auto = v);
            builddec("dcoeffp", v => dcoeffp = v);
            builddec("dcoeffm", v => dcoeffm = v);
            builddec("dconvergence", v => dconvergence = v);


        }

        public void calcAuto(bool selectedByCoeff, int nb)
        {
            if (!auto)
                return;
            var last = lastAutoDirection;
            lastAutoDirection = selectedByCoeff; 
            if (selectedByCoeff)
                makeDelta(false, dcoeffm, nb);
            else
                makeDelta(true, dcoeffp, nb);

            var c0 = dcoeffp;
            if (dconvergence > 0 && last.HasValue && last != selectedByCoeff)
            {
                dcoeffp *= dconvergence;
                dcoeffm *= dconvergence;
                if (dcoeffp < 0.01m) dcoeffp = 0.01m;
                if (dcoeffm < 0.01m) dcoeffm = 0.01m; 
                misc.log("convergence {0:0.##}->{1:0.##}", c0, dcoeffp);
                lastAutoDirection = null; 
            }

          

        }

        private void makeDelta(bool sens, decimal delta, int nb)
        {
            try
            {
                decimal coeffT = (decimal)Math.Pow((double)coeffVirt, safe);
                string montee = sens ? "up" : "down";
                var c0 = coeffT;
                if (sens)
                {
                    for (int i = 0; i < nb; i++)
                        coeffT += delta;
                }
                else
                {
                    for (int i = 0; i < nb; i++)
                        coeffT -= delta;
                }
                if (coeffT < 1)
                    coeffT = 1;

                var coeff = (decimal)Math.Pow((double)coeffT, (1.0 / (double)safe));

                misc.log("{0} {1} {2:0.##}->{3:0.##}", montee, delta, c0, coeffT);
                coeffVirt = coeff;
            }
            catch
            {
            }


        }

    }
    public class CalcMedianne
    {
        const decimal PRECISION = 0.0000001m;
        private static int index;
        public static int Index { get { return index; } }


        public static DecimalIndex getMedianne(IEnumerable list, decimal coeffMedianne)
        {
            var _list = new List<decimal>();
            foreach (object o in list)
            {
                _list.Add(Convert.ToDecimal(o));
            }
            return getMedianne(_list, coeffMedianne);
        }

        public static DecimalIndex getMedianne(IList<decimal> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }

        //public static DecimalIndex getMedianneLight(IList<decimal> list, ConfMedianne mode)
        //{

        //    DecimalIndex ret = new DecimalIndex();
        //    var medianne = getMedianne_(list, mode.medianne);
        //    ret.d = medianne;
        //    ret.index = index;
        //    if (list.Count == 1)
        //        return ret;

        //    int indexV = 0;

        //    int count = list.Count;

        //    if (mode.safe > 0)
        //    {

        //        int i0 = count - 1;

        //        for (int i = 0; i < count; i++)
        //        {
        //            if (list[i] == 0m)
        //            {
        //                i0 = i;
        //                break;
        //            }
        //        }
        //        if (i0 == 0)
        //            return ret;

        //        //for (int i00 = 1; i00 <= i0; i00++)
        //        //{
        //        //    decimal coeff = (decimal)i00 / (decimal)i0;
        //        List<decimal> _list = new List<decimal>(list);
        //        //for (int i = i00; i < count; i++)
        //        //    _list[i] = 0m;
        //        //liste partielle originale
        //        //  List<decimal> _list0 = new List<decimal>(_list);
        //        int _count = Math.Min(count, i0 + mode.safe);
        //        decimal[] virt = new decimal[_count];
        //        for (int i = 0; i < i0; i++)
        //        {
        //            decimal _coeff = 1m;
        //            decimal _base = _list[i];
        //            for (int j = i + 1; j < _count; j++)
        //            {
        //                _coeff /= mode.coeffVirt;
        //                virt[j] += _base * _coeff;
        //            }
        //        }

        //        decimal value = int.MaxValue;
        //        int ii = 0;
        //        for (ii = 1; ii < count && ii < _count; ii++)
        //        {
        //            value = _list[ii];
        //            var calc = virt[ii];
        //            if (value < calc)
        //            {
        //                if (mode.lissage || value == 0m)
        //                {
        //                    value = calc;
        //                    _list[ii] = value;
        //                }

        //            }
        //            else
        //                indexV = ii;
        //        }
        //        if (mode.removeEpsilon)
        //        {
        //            // j'ai 5 virtuel alors que j'ai deux safe
        //            ///xx---
        //            int nb = 0;
        //            for (int i = indexV + 1; i < _count; i++)
        //            {
        //                nb++;
        //                if (nb <= mode.safe)
        //                    continue;
        //                _list[i] = 0m;
        //            }

        //        }

        //        if (mode.reSort)
        //        {
        //            _list.Sort();
        //            _list.Reverse();
        //        }

        //        //for (int i = 0; i < nbAdd; i++)
        //        //    _list.RemoveAt(0); 


        //        var retAux = calcmedianneVirt(_list, mode.medianne, mode.quasi);
        //        //retAux.d *= coeff;
        //        if (retAux > ret)
        //        {
        //            ret = retAux;
        //            //  ret.index += nbAdd; 
        //        }
        //        //}


        //    }
        //    else
        //        ret = calcmedianneVirt(list, mode.medianne, mode.quasi);

        //    //  ret = getRapport(ret);


        //    return ret;
        //}


        public static DecimalIndex getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi, int nbVirt)
        {
            DecimalIndex ret = new DecimalIndex();
            var medianne = getMedianne_(list, coeffMedianne);
            ret.d = medianne;
            ret.index = index;
            if (list.Count == 1)
                return ret;

            int count = list.Count;


            // decimal ret = medianne; //int.MinValue;

            if (nbVirt > 0)
            {

                int i0 = count - 1;

                for (int i = 0; i < count; i++)
                {
                    if (list[i] == 0m)
                    {
                        i0 = i;
                        break;
                    }
                }
                if (i0 == 0)
                    return ret;

                for (int i00 = 1; i00 <= i0; i00++)
                {
                    decimal coeff = (decimal)i00 / (decimal)i0;
                    List<decimal> _list = new List<decimal>(list);
                    for (int i = i00; i < count; i++)
                        _list[i] = 0m;
                    int _count = Math.Min(count, i00 + nbVirt);
                    decimal[] virt = new decimal[_count];
                    for (int i = 0; i < i00; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = _list[i];
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= 10m;
                            virt[j] += _base * _coeff;
                        }
                    }
                    // decimal prec = -1m;  
                    int _nbVirt = 0;
                    decimal value = int.MaxValue;
                    int ii = 0;
                    for (ii = 1; ii < count && ii < _count; ii++)
                    {
                        //   prec = value;
                        value = _list[ii];
                        var calc = virt[ii];
                        if (value < calc)
                        {
                            if (_nbVirt >= nbVirt)
                                break;
                            _nbVirt++;
                            value = calc;  //Math.Min(prec, calc);
                            _list[ii] = value;

                        }
                        else
                            _nbVirt = 0;
                    }
                    for (int i = ii; i < count && i < _count; i++)
                    {
                        _list[i] = 0m;
                    }
                    //_list.Sort();
                    //_list.Reverse(); 



                    var retAux = calcmedianneVirt(_list, coeffMedianne, quasi);
                    retAux.d *= coeff;
                    if (retAux > ret)
                        ret = retAux;
                }


            }
            else
                ret = calcmedianneVirt(list, coeffMedianne, quasi);

            //  ret = getRapport(ret);

            //if (ret < medianne)
            //    ret = medianne;
            return ret;
        }

        private static decimal getLn(decimal rapport)
        {
            if (rapport <= 0)
                return 0m;
            return Convert.ToDecimal(10 + Math.Log10((double)rapport));
        }
        private static decimal getRapport(decimal ln)
        {
            return Convert.ToDecimal(Math.Pow(10, (double)ln - 10));
        }

        private static DecimalIndex calcmedianneVirt(IList<decimal> _list, decimal coeffMedianne, bool quasi)
        {

            int count = _list.Count;

            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                {

                    _list.RemoveAt(count - i);
                }

                var aux = getMedianne_(_list, coeffMedianne);
                if (aux == 0m)
                    continue;
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                }

                if (_list[count - i - 1] > 0m)
                    break;


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }


        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1];
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var pente = (val1 - val0);
            var dx = medianne - index;
            var dy = pente * dx;
            return val0 + dy;

        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}]]></content>
  </file>
  <file path="\PieceDb.Consolid\Piece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;

namespace pdb.gen
{
    public enum infoMedianne : short
    {
        none = 0,
        med = 1,
        medLight = 2,
        border = 4,
        borderEff = 8,
        borderMin = 16
    }
    /// <summary>
    /// Ajout de données utiles Ranq
    /// </summary>
    public class Piece : ITrackMetaData, IFile, ITrackNativeDates
    {
        private ITrackNativeDates track;
        public bool Virtual { get { return PieceId < 0; } }
        // private String className = "";
        private static CultureInfo en = new CultureInfo("en-US");
        //  private static List<displayCategory> minCategories;

        protected static Consolid gen;
        public static Consolid Gen { set { gen = value; } }

        static Piece()
        {
            //   minCategories = new List<displayCategory> { displayCategory.rankTime, displayCategory.timeValue, displayCategory.dates, displayCategory.pertinentDates };
        }

        public ITrackNativeDates Track { get { return track; } }

        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank
        {
            get
            {
                if (parent == null)
                    return m_rank;
                return parent.m_rank;
            }
        }

        private infoMedianne _infoMedianne;
        public void eraseInfoMedianne() { _infoMedianne = infoMedianne.none; }
        public infoMedianne InfoMedianne { get { return _infoMedianne; } }
        public bool Medianne
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.med);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Medianne)
                    return;
                _infoMedianne |= infoMedianne.med;
            }
        }
        public bool MedianneLight
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.medLight);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (MedianneLight)
                    return;
                _infoMedianne |= infoMedianne.medLight;
            }
        }

        public bool Border
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.border);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Border)
                    return;
                _infoMedianne |= infoMedianne.border;
            }
        }

        public bool BorderEffect
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderEff);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderEffect)
                    return;
                _infoMedianne |= infoMedianne.borderEff;
            }
        }

        public bool BorderMin
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderMin);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderMin)
                    return;
                _infoMedianne |= infoMedianne.borderMin;
            }
        }


        public void initRank()
        {
            _rapportClassement = -1;
            _infoMedianne = infoMedianne.none;
            _classementProvisoireRecent = null;

            // _lnClassement = int.MinValue; 
            Rank.init();
        }

        public int QRank
        {
            get { return Rank.Quality; }
            set { Rank.Quality = value; }
        }

        public int LRank
        {
            get { return Rank.Lenght; }
            set { Rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return Rank.Twice; }
            set { Rank.Twice = value; }
        }

        public int RankAllAlbum
        {
            get { return m_rank.RankAllAlbum; }
            set { m_rank.RankAllAlbum = value; }
        }

        public int RankAlbum { get { if (album == null) return 0; return album.Rank.Sort; } }

        public bool AlbumAbsent { get { if (album == null) return true; return album.Absent; } }

        public bool SameAlbum(Piece x)
        {
            return album == x.album; 
        }

        public int IndexExport { get { if (album == null) return -1; return album.IndexExport(this); } }

        //  public TuningData TuningData { get { return m_rank.Rest; } set { m_rank.Rest = value; } }
        #endregion



        public bool FirstClass { get { return track.FirstClass; } set { track.FirstClass = value; } }
        private Album album;

        internal Album PieceAlbum { get { return album; } set { album = value; } }
        public int StackValue { get { if (album == null) return 0; return album.StackValue; } }
        public int StackIndex { get { if (album == null) return 0; return album.StackIndex; } }
        public bool Moved { get { if (album == null) return false; return album.Moved; } set { if (album != null) album.Moved = value; } }
        //private static int _sID = 0;
        //private int _dID;
        internal Piece(ITrackNativeDates track)
        {
            //_sID++;
            //_dID = _sID;
            this.track = track; initRank();

#if VOL
            int volumeMin = CConf.VolumeMin;
            if (Volume < volumeMin)
                Volume = volumeMin;
#endif
        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList()
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        public String ClassName { get { return track.ClassName; } set { track.ClassName = value; } }

        public void setClassement(string className, int rating)
        {
            if (className == null)
                return;
            track.setClassement(className, rating);
            invalidateCache();

        }

        public void invalidateCache()
        {
            _classNameAndRating = null;
            _classementValueDecimal = -1;
            _rapportClassement = -1;
            _classementProvisoireRecent = null;

            if (parent != null)
                parent.invalidateCache();

        }

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in track.PLayLists)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        #region CPieceComparer compatibilité
        public List<CPlayList> ClassPlayLists
        {
            get { return track.ClassPlayLists; }
        }
        /// <summary>
        /// ClassList principale
        /// </summary>
        public CPlayList ClassPlayList
        {
            get
            {
                List<CPlayList> classLists = track.ClassPlayLists;
                if (classLists.Count > 0)
                    return classLists[0];
                return null;
            }
        }


        public int RatingCmp
        {
            get
            {
                int rating = track.Rating;
                if (rating < 0)
                    return 0;
                return rating;
            }
        }
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return ClassName.isInteger();
            }
        }

        private string _classNameAndRating;
        public String ClassNameAndRating
        {
            get
            {
                if (_classNameAndRating == null)
                {
                    if (!isClassListNumeric)
                        _classNameAndRating = "";
                    _classNameAndRating = ClassName + ((track.Rating / 20).ToString());
                }
                return _classNameAndRating;
            }
        }

        private decimal _classementValueDecimal = -1;
        public decimal ClassementValueDecimal
        {
            get
            {
                if (_classementValueDecimal < 0)
                {
                    if (!isClassListNumeric) return 0;
                    string classNameAndRating = ClassNameAndRating.Insert(1, ",");
                    _classementValueDecimal = Convert.ToDecimal(classNameAndRating);
                }
                return _classementValueDecimal;
            }
        }
        //private double _classementValue = -1; 
        //public double ClassementValue
        //{
        //    get
        //    {
        //        if (_classementValue == -1)
        //        {
        //            if (!isClassListNumeric)
        //                _classementValue = 0;
        //            else
        //            {
        //                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
        //                _classementValue= Convert.ToDouble(classNameAndRating);
        //            }
        //        }

        //        return _classementValue; 
        //    }
        //}

        private decimal _rapportClassement = -1;
        public decimal RapportClassement
        {
            get
            {
                if (parent != null)
                    return parent.RapportClassement;
                if (_rapportClassement != -1)
                    return _rapportClassement;

                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                _rapportClassement = resultat;
                // _classementVirtuel = resultat; 
                return _rapportClassement;
            }
        }


        //private decimal _lnClassement = -1;
        //public decimal LnClassement
        //{
        //    get
        //    {
        //        if (_lnClassement == int.MinValue)
        //        {
        //            var rapport = RapportClassement;
        //            if (rapport <= 0m)
        //                _lnClassement = 0m;
        //            else
        //                _lnClassement = Math.Log10(rapport) + 10;
        //        }
        //        return _lnClassement; 
        //    }
        //}
        static int NB_DEC = 4;
        public static string getReadableCl(string str)
        {
            int count = str.Length;
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {
                        if (i >= NB_DEC)
                        {
                            i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();
        }

        public static string getClassementEquiv(decimal valRapport)
        {
            if (valRapport < 0)
                return "";
            if (valRapport == 0m)
                return "0";
            decimal v = 0;
            decimal r = valRapport;
            StringBuilder sb = new StringBuilder();
            int _ok = Int16.MaxValue;

            for (int i = 0; i < 13; i++)
            {
                v = 6 * r;
                int a = (int)(v + 0.0001m);
                if (a > 0 && i < _ok)
                {
                    _ok = i;
                }
                r = v - a;
                if (r < 0)
                    r = 0;
                sb.Append(a);


                if (i >= _ok + 4)
                    break;
            }
            var str = sb.ToString();
            str = str.Insert(str.Length - 1, ".");
            return getReadableCl(str);
        }




        public decimal RapportClassementDecimal
        {
            get
            {
                if (parent != null)
                    return parent.RapportClassementDecimal;
                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1m;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                return resultat;
            }
        }

        public int classPrecision()
        {
            string classNameAndRating = ClassNameAndRating;
            int precision = 0;
            char[] tab = classNameAndRating.ToCharArray();
            int count = tab.GetLength(0);

            int iIndexDepart = -1;
            int iIndexFin = -1;
            for (int i = 0; i < count; i++)
            {
                Char c = tab[i];
                if (iIndexDepart < 0)
                {
                    if (c != '0')
                        iIndexDepart = i;
                }

                if (c != '0')
                    iIndexFin = i;
            }

            precision = iIndexFin - iIndexDepart + 1;

            return precision;
        }
        #endregion

        #region compatibilité CList
        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        public bool checkIdentity(ITrackIdentity other)
        {
            //return track.Location == other.Location; 
            String location = track.Location;
            return (location.Equals((other.Location)) || CUtil.DefinedEquals(track.Artist, track.Album, track.Name, track.TrackNumber, other.Artist, other.Album, other.Name, other.TrackNumber));
        }
        #endregion

        #region ITrackNative Membres

        public string Artist
        {
            get
            {
                return track.Artist;
            }
            set
            {
                if (track.Artist != value)
                {
                    try
                    {
                        //                 misc.log("change artist from '{0}' to'{1}'", track.Artist, value);
                        track.Artist = value;
                    }
                    catch { misc.log("unable to change artist {0}  {1}", track.Artist, value); }
                }
            }
        }

        public virtual string Album
        {
            get
            {
                return track.Album;
            }
            set
            {
                if (track.Album != value)
                {
                    try
                    {
                        //                   misc.log("change Album from '{0}' to'{1}'", track.Album, value);
                        track.Album = value;
                    }
                    catch { misc.log("unable to change album {0}  {1}", track.Album, value); }
                }
            }
        }

        public string Name
        {
            get
            {
                return track.Name;
            }
            set
            {
                if (track.Name != value)
                {
                    try
                    {
                        //                 misc.log("change Name from '{0}' to'{1}'", track.Name, value);
                        track.Name = value;
                    }
                    catch { misc.log("unable to change name {0}  {1}", track.Name, value); }
                }
            }
        }

        public virtual int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (track.TrackNumber != value)
                {
                    try
                    {
                        //              misc.log("change TrackNumber from '{0}' to'{1}'", track.TrackNumber, value);
                        track.TrackNumber = value;
                    }
                    catch { misc.log("unable to change TrackNumber {0}  {1}", track.TrackNumber, value); }
                }
            }
        }

        public int Rating
        {
            get
            {
                return track.Rating;
            }
            set
            {
                if (track.Rating != value)
                {
                    try
                    {
                        //                misc.log("change Rating from '{0}' to'{1}'", track.Rating, value);
                        track.Rating = value;
                    }
                    catch { misc.log("unable to change Rating {0}  {1}", track.Rating, value); }
                }
            }
        }

        public int Year
        {
            get
            {
                return track.Year;
            }
            set
            {
                if (track.Year != value)
                {
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Year = value;
                    }
                    catch { misc.log("unable to change Year {0}  {1}", track.Year, value); }
                }
            }
        }

#if VOL
        public int Volume
        {
            get
            {
                int volumeMin = CConf.VolumeMin;
                int trackVolume = track.Volume;
                if (trackVolume < volumeMin)
                {
                    Volume = volumeMin;
                }
                return trackVolume;
            }
            set
            {
                if (track.Volume != value)
                {
                    int volumeMin = CConf.VolumeMin;
                    int _value = Math.Max(value, volumeMin);
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Volume = _value;
                    }
                    catch { misc.log("unable to change Volume {0}  {1}", track.Volume, _value); }
                }
            }
        }
#endif

        public string Comment
        {
            get
            {
                //if (string.IsNullOrEmpty(track.Comment))
                //    gen.writeComment(this);
                return track.Comment;
            }
            set
            {
                //if (track.Comment != value)
                //{
                try
                {
                    //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
                    track.Comment = value;
                }
                catch { misc.log("unable to change Comment {0}  {1}", track.Comment, value); }
                //}
            }
        }

        public virtual string Grouping
        {
            get
            {
                if (string.IsNullOrEmpty(track.Grouping))
                {
                    gen.writeGrouping(this);
                }
                return track.Grouping;
            }
            //set
            //{
            //    //if (track.Grouping != value)
            //    //{
            //        try
            //        {
            //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
            //            track.Grouping = value;
            //        }
            //        catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
            //    //}
            //}

        }





        public virtual void setGrouping(string value, bool prior)
        {
            try
            {
                //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
                track.setGrouping(value, prior);
            }
            catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        }

        public bool Enabled
        {
            get
            {
                return track.Enabled;
            }
            set
            {
                if (track.Enabled != value)
                {
                    try
                    {
                        //      misc.log("change Enabled from '{0}' to'{1}'", track.Enabled, value);
                        track.Enabled = value;
                    }
                    catch { misc.log("unable to change Enabled {0}  {1}", track.Enabled, value); }
                }
            }
        }



        public bool isPodcast
        {
            get { return track.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return track.PlayedDate; }
        }

        public string Location
        {
            get { return track.Location; }
        }

        public TimeSpan Duration
        {
            get { return track.Duration; }
            set { track.Duration = value; }
        }

        #endregion

        public List<DateTime> Dates
        {
            get { return track.Dates; }
        }
        public string ArtWork
        {
            get { return track.ArtWork; }
            set { track.ArtWork = value; }
        }

        public List<DateTime> DatesClassement { get { return track.DatesClassement; } }
        public DateTime? UpdateClassement
        {
            get
            {

                var dc = CalcDate.getLastModif(DatesClassement);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }
        public DateTime? AlbumUpdateClassement
        {
            get
            {
                if (album == null)
                    return null;
                return album.UpdateClassement;
            }
        }

        public DateTime? LastRead
        {
            get
            {

                var dc = CalcDate.getLastModif(Dates);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public DateTime? AlbumLastRead
        {
            get
            {
                if (album == null)
                    return null;
                return album.LastRead;
            }
        }

        public String ClassEvol { get { return track.ClassEvol; } }


        public void writeCommentGrouping()
        {
            var mode = CConf.ConfGen.WriteComment;
            writeComment(mode);
            var modeg = CConf.ConfGen.WriteGrouping;
            writeGrouping(modeg);

        }

        //public List<CPlayList> PLayLists
        //{
        //    get { return track.PLayLists; }
        //}

        /// <summary>
        /// Calculer le commentaire
        /// </summary>
        public void writeComment(writeGrouping mode)
        {
            if (parent != null)
                return;
            if (mode == Tuning.writeGrouping.none)
                return;


            if (mode == Tuning.writeGrouping.mix)
            {
                StringBuilder sbEnd = new StringBuilder();

                sbEnd.Append(ClassName);
                sbEnd.Append(".");
                sbEnd.Append((RatingCmp / 20).ToString());
                sbEnd.Append(ClassEvol);
                string strEnd = sbEnd.ToString();
                string found = "";

                string[] tab = Comment.Split(' ');
                int count = tab.GetLength(0);
                if (count > 0)
                {
                    found = tab[count - 1];
                    if (found.Equals(strEnd))
                        return;
                }
                writeComment(Tuning.writeGrouping.all);
            }

            StringBuilder sb = new StringBuilder();
            //string l_pref = "";
            //string l_str = "";

            string l_strList = ClassName;
            //if (ClassPlayList != null)
            //    l_strList = ClassName;

            ////if (m_classement.Imported)
            ////{
            //if (l_strList != ClassName)
            //{
            //    sb.Append("m (");
            //    sb.Append(ClassName);
            //    sb.Append(") "); 
            //  //  l_pref = "m (" + ClassName + ") ";
            //}
            ////}
            int l_rank = Rank.Twice;

            if (l_rank > 0)
            {
                CTuning.format(sb, l_rank);
                sb.Append(" ");
                //    if (l_rank < 1000)
                //    {
                //        if (CTuning.Total > 1000)
                //        {
                //            l_str += "0";
                //        }
                //        if (l_rank < 100)
                //        {
                //            l_str += "0";
                //            if (l_rank < 10)
                //            {
                //                l_str += "0";
                //            }
                //        }
                //    }


                var r = CTuning.Rapport(Rank.Quality);






                var quality = CConf.Select.Quality;
                //if (quality.Mode != listMode.substract || quality.Exp != 1 || quality.Offset != 0 || CConf.Select.TimePriority != 0)
                //{
                double tx0 = Convert.ToInt32(1000 * r);
                sb.Append(tx0.ToString());
                sb.Append(" ");
                //}

                //  double l_tx = Convert.ToInt32(1000 * CTuning.Calc(m_rank, CConf.Select)); //   RapportNorm(m_rank.Quality, CConf.Sort.Quality));
                var l_tx = CConf.ConfGen.Vie.TotalDays() / CTuning.Calc(m_rank, CConf.Select);
                //  double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
                //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
                //getTx(m_rank.Lenght)
                //     l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();


                sb.Append(l_tx.FormatCustom(3, 4)); //   ToString("G2", en));
                //if (l_tx < 100 || l_tx >= 1000)
                //    sb.Append(l_tx.ToString("G2", en));
                //else
                //    sb.Append(Convert.ToInt64(l_tx).ToString("D", en)); 



                sb.Append(" ");
                var rest = r;

                for (int i = 0; i < 4; i++)
                {
                    var ee = rest * 6.0m;
                    int e = (int)System.Math.Floor(ee);
                    rest = ee - e;
                    sb.Append(e);
                }



                sb.Append(" ");


                //sb.Append(l_tx2.ToString());
                //sb.Append(" ");
                //sb.Append((100 * m_rank.SortValue).ToString("0"));
                //sb.Append(" ");

                //sb.Append(Dates.Count.ToString()); sb.Append(" ");

                //sb.Append(DatesClassement.Count.ToString()); sb.Append(" ");

                //sb.Append(ListSelection.buildListReadOrClassementModified(this).Count.ToString()); sb.Append(" ");

                //   sb.Append((100 * m_rank.TimeRest).ToString("0")); sb.Append(" ");



                sb.Append(l_strList);
                sb.Append(".");
                sb.Append((RatingCmp / 20).ToString());

            }

            sb.Append(ClassEvol);



            Comment = sb.ToString();
            //Comment = l_pref + l_str + ClassEvol;
        }

        public override string ToString()
        {
            return track.ToString();
        }

        public override bool Equals(object obj)
        {
            Piece p = obj as Piece;
            if (p == null)
                return false;
            return PieceId.Equals(p.PieceId);


        }

        private decimal _classementVirtuel;

        public string ClassementVirtuel { get { return Piece.getClassementEquiv(_classementVirtuel); } }
        public decimal VirtualClassement { get { return _classementVirtuel; } }
        public void setClassementVirtuel(decimal virt)
        {
            _classementVirtuel = virt;
        }

        public decimal CoeffVirtuel
        {
            get
            {
                if (_classementVirtuel == 0)
                    return 0;
                return RapportClassement / _classementVirtuel;
            }
        }

        private decimal _classementVirtuel2;

        public string ClassementVirtuel2 { get { return Piece.getClassementEquiv(_classementVirtuel2); } }
        public decimal VirtualClassement2 { get { return _classementVirtuel2; } }
        public void setClassementVirtuel2(decimal virt)
        {
            _classementVirtuel2 = virt;
        }

        public decimal CoeffVirtuel2
        {
            get
            {
                if (_classementVirtuel2 == 0)
                    return 0;
                return RapportClassement / _classementVirtuel2;
            }
        }

        public override int GetHashCode()
        {
            return PieceId.GetHashCode();
        }

        private bool haveToUpdateGrouping = false;
        public void MarkAsUpdateGrouping() { haveToUpdateGrouping = true; }

        public void writeGrouping(writeGrouping writeGrouping)
        {
            var cat = CConf.ConfGen.DisplayCategories;
            //if (!CConf.ConfGen.WithOrder)
            //    cat = minCategories; 
            if (writeGrouping == Tuning.writeGrouping.none)
                return;

            //if (m_rank.Twice <= 0)
            //    return;
            if (haveToUpdateGrouping)
            {
                setGrouping(getGroup(cat), true);
            }

            else if (writeGrouping == Tuning.writeGrouping.mix)
            {
                bool haveToUpdate = false;
                string org = Grouping;
                if (org != null)
                {
                    string[] data = org.Split(' ');

                    try
                    {
                        foreach (datesMode mode in Enum.GetValues(typeof(datesMode))) //  CConf.ConfGen.Modes) //  Enum.GetValues(typeof(datesMode)))
                        {
                            DisplayGrouping found = cat.Find(c => (int)c.category == (int)mode);
                            //displayCategory found = cat.Find(c => (int)c == (int)mode);
                            if (found != null)
                            {
                                int indexOfTime = cat.IndexOf(found);

                                string timeValue = data[indexOfTime];
                                string newValue = getTimeValue(mode, found.mode);
                                if (!newValue.Equals(timeValue))
                                {
                                    haveToUpdate = true;
                                    break;
                                }
                            }
                        }
                    }
                    catch
                    {
                        haveToUpdate = true;
                    }
                }
                else
                {
                    haveToUpdate = true;
                }
                if (haveToUpdate)
                    setGrouping(getGroup(cat), true);
            }
            else
                setGrouping(getGroup(cat), false);
        }



        private string getTimeValue(datesMode modeDates, timeMode modeTime)
        {
            switch (modeTime)
            {
                case timeMode.simple: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates)).FormatCustomTs(2);
                case timeMode.complex: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustomTs(2);
                case timeMode.last:
                case timeMode.equiv:
                case timeMode.equivNorm:
                    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    if (modeTime == timeMode.equivNorm)
                        return ts.FormatCustomTs(3, 2, 4);
                    return ts.FormatCustomTs(2);

                case timeMode.delta:
                case timeMode.deltaNorm:

                    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
                    var delta = tsf - ts0;
                    delta = delta * 100;
                    //if (modeTime == timeMode.deltaNorm)
                    //    return delta.FormatCustom(3, 2, 4);
                    return "(" + delta.FormatCustomTs(2) + ")";
                default:
                    throw new NotImplementedException();

            }

            //if (modeTime == timeMode.complex)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustom(2);
            //else if (modeTime == Tuning.timeMode.simple)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates)).FormatCustom(2);
            ////   return m_rank.TimeRest.FormatCustom(2); //.ToString("G2", en); 
            //else if (modeTime == timeMode.equiv || modeTime == timeMode.equivNorm)
            //{
            //    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);

            //    if (modeTime == timeMode.equivNorm || modeTime == timeMode.deltaNorm)
            //        return ts.FormatCustom(3, 2, 4);
            //    return ts.FormatCustom(2);
            //}
            //else
            //{
            //    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
            //    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
            //    var delta = tsf - ts0;

            //    if (modeTime == timeMode.equivNorm)
            //        return delta.FormatCustom(3, 2, 4);
            //    return delta.FormatCustom(2);
            //}
        }



        private string getGroup(List<DisplayGrouping> categories)
        {
            StringBuilder sb = new StringBuilder();

            bool begin = false;

            displayCategory last = displayCategory.none;
            foreach (var category in categories)
            {
                try
                {
                    if (begin //&& (int)category.category <= (int)displayCategory.pipe
                        && last != displayCategory.croc1 && last != displayCategory.par1
                        && category.category != displayCategory.croc2 && category.category != displayCategory.par2)
                        sb.Append(" ");
                    begin = true;

                    switch (category.category)
                    {
                        case displayCategory.rankSort:
                            CTuning.format(sb, Rank.Sort); break;
                        case displayCategory.rankDelta:
                            CTuning.format(sb, Rank.RankDelta); break;
                        case displayCategory.rankTime:
                            CTuning.format(sb, Rank.RankRest); break;
                        case displayCategory.rankAllAlbum:
                            CTuning.format(sb, RankAllAlbum); break;
                        case displayCategory.rankAlbum:
                            if (album != null)
                                sb.Append(album.Rank.Sort); break;
                        case displayCategory.rankAlbumReverse:
                            if (album != null)
                            {
                                int rank = album.Rank.Sort;
                                rank = 1 + gen.Albums.Count - rank;
                                sb.Append(rank);
                            }
                            break;
                        case displayCategory.rankEquiv:
                            if (album != null)
                                sb.Append(album.Equiv);
                            break;
                        case displayCategory.rankEquivLight:
                            if (album != null)
                                sb.Append(album.EquivLight);
                            break;
                        case displayCategory.rankEquivLight0:
                            if (album != null)
                                sb.Append(album.EquivLight0);
                            break;
                        case displayCategory.albumMoy:
                            if (album != null)
                            {
                                sb.Append(album.Moyenne);
                            }
                            break;
                        case displayCategory.lenght:
                            sb.Append(Convert.ToInt32(100 * CTuning.Rapport(Rank.Lenght))); break; //   CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length))); break;
                        case displayCategory.sortValue:
                            sb.Append((1000 * Rank.SortValue).ToString("####", en)); break;
                        case displayCategory.tplay:
                            sb.Append(getTimeValue(datesMode.play, category.mode)); break;
                        case displayCategory.tclass:
                            sb.Append(getTimeValue(datesMode.@class, category.mode)); break;
                        case displayCategory.tclassMin:
                            sb.Append(getTimeValue(datesMode.classMin, category.mode)); break;
                        case displayCategory.tmix:
                            sb.Append(getTimeValue(datesMode.mix, category.mode)); break;
                        case displayCategory.tmixMin:
                            sb.Append(getTimeValue(datesMode.mixMin, category.mode)); break;
                        case displayCategory.timeCoeff:
                            sb.Append((100 * Rank.TimeCoeff).ToString("G3", en)); break;
                        case displayCategory.dplay:
                            sb.Append(ListSelection.getPlayDates(this).Count.ToString()); break;
                        case displayCategory.dclass:
                            sb.Append(ListSelection.getDatesClassement(this).Count.ToString());
                            break;
                        case displayCategory.dclassMin:
                            sb.Append(ListSelection.getClassDatesMin(this).Count.ToString()); break;
                        case displayCategory.dmix:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, false).Count.ToString());
                            break;
                        case displayCategory.dmixMin:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, true).Count.ToString());
                            break;
                        case displayCategory.pipe:
                            sb.Append("|");
                            break;
                        case displayCategory.par1: sb.Append("("); break;
                        case displayCategory.par2: sb.Append(")"); break;
                        case displayCategory.croc1: sb.Append("["); break;
                        case displayCategory.croc2: sb.Append("]"); break;

                        default:
                            break;
                    }


                    last = category.category;
                }

                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }
            }
            return sb.ToString();
        }

        public virtual int PieceId
        {
            get
            {
                return track.PieceId;
            }
        }


        private Piece parent;
        public Piece Parent
        {
            get { return parent; }
            set
            {
                if (value == null)
                {
                    if (parent != null)
                    {
                        parent.removeChild(this);
                        this.PieceParentId = -1;
                    }
                }
                else
                {
                    parent = value;
                    this.PieceParentId = value.PieceId;
                    parent.addChild(this);
                }
            }
        }
        public Piece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        private List<Piece> childs = new List<Piece>();
        public List<Piece> Childs { get { return childs; } }
        private void addChild(Piece child)
        {
            if (child != null && parent != null)
                throw new ApplicationException(string.Format("on ne doit pas affecter un enfant à un non-maitre. enfant:{0} parent {1}", child, parent));

            if (!childs.Contains(child))
                childs.Add(child);
        }

        private void removeChild(Piece child)
        {
            childs.Remove(child);
        }

        public virtual int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion

        private exportState exportState;
        public exportState ExportStatus
        {
            get
            {
                return exportState; // exportState;
            }
            set
            {
                exportState = value;
            }
        }




        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public void buildVirtualAlbums(List<Piece> list)
        {

            foreach (var path in track.RelativesPath)
            {

                var tab = path.Split('\\');
                var sb = new StringBuilder();

                sb.Append(@"\");
                var count = tab.GetLength(0);
                for (int i = 0; i < count; i++)
                {
                    var _s = tab[i];
                    if (string.IsNullOrEmpty(_s))
                        continue;

                    var virt = createVirtualAlbum(sb.ToString());
                    list.Add(virt);
                    if (i > 0)
                        sb.Append(@"\");
                    sb.Append(_s);




                }
            }
        }

        private Piece createVirtualAlbum(string path)
        {
            var virt = new VirtualAlbumPiece(track, Master, path);
            return virt;
        }

        public bool IsNext
        {
            get
            {
                if (album == null)
                    return false;
                return this == album.Next;
            }
        }
        const int NB_CHAR_COMPLETE = 4;

        //public bool AutoCoeff1 { get { if (album == null) return false; return album.SelectedByCoeff; } }
        //public bool AutoCoeff2 { get { if (album == null) return false; return album.SelectedByCoeff2; } }
        public selectedCoeff SelectedMotif
        {
            get
            {
                if (album == null || !IsNext) return selectedCoeff.none;
                return album.SelectedCoeff;
            }
        }


        public static DateTime SeuilProvisoire;
        private bool? _classementProvisoireRecent;
        public bool ClassementProvisoireRecent
        {
            get
            {
                return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        private bool getClassementProvisoireRecent()
        {
            if (!ClassementProvisoire)
                return false;
            var list = DatesClassement;
            var last = CalcDate.getLastModif(list);
            if (last > SeuilProvisoire)
                return true;
            return false;
        }

        public bool ClassementProvisoire
        {
            get
            {
                if (RapportClassement == 0)
                    return false;
                var str = ClassName;
                int count = str.Length;
                if (count < 4)
                    return true;
                if (count >= 8)
                    return false;

                var tab = str.ToCharArray();
                int nb = 0;
                for (int i = 0; i < count; i++)
                {
                    if (nb > 0)
                        nb++;
                    else
                    {
                        if (tab[i] != '0')
                        {
                            nb++;
                        }
                    }
                }
                if (nb >= NB_CHAR_COMPLETE)
                    return false;

                return true;

            }
        }
    }

    public enum exportState
    {
        none = 0,
        miss = 1,
        present = 2,
        copy = 3,
        delete = 4
    }


}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.util;
using System;
using System.Globalization;
using pdb.gen.Tuning;
using pdb.gen.conf;
using System.Linq;

namespace pdb.gen.albums
{


    public class Album
    {

        private string name;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }
        private int stackValue;
        public int StackValue { get { return stackValue; } set { stackValue = value; } }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;

        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private List<Piece> list = new List<Piece>();
        private static int _sID = 0;
        private int _dID;


        public Album(string name)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        private string equiv = "";
        public string Equiv { get { return equiv; } }

        private string equivLight = "";
        public string EquivLight { get { return equivLight; } }

        private string equivLight0 = "";
        public string EquivLight0 { get { return equivLight0; } }

        private string moyenne = "";
        public string Moyenne { get { return moyenne; } }

        public bool Moved { get; set; }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            if (list.Contains(piece))
                return false;
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);
            piece.PieceAlbum = this;
            return true;
        }

        public List<Piece> Tracks
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceClassementComparer());
                return l;
            }
        }

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}
        HashList<Piece> trackSortedByExportPriority;
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = Tracks;
                    if (next == null)
                        trackSortedByExportPriority = new HashList<Piece>(source);
                    else
                    {
                        trackSortedByExportPriority = new HashList<Piece>();
                        int indexNext = source.IndexOf(next);
                        trackSortedByExportPriority.Add(next);

                        int count = source.Count;
                        int offset = 0;
                        while (true)
                        {
                            offset++;
                            bool _continue = false;
                            // on prend le précédent et le suivant
                            var index = indexNext - offset;

                            if (index >= 0 && index < count)
                            {
                                trackSortedByExportPriority.Add(source[index]); _continue = true;
                            }
                            index = indexNext + offset;
                            if (index >= 0 && index < count)
                            {
                                trackSortedByExportPriority.Add(source[index]); _continue = true;
                            }

                            if (!_continue)
                                break;
                        }

                    }
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                if (FileRegister.Exist(next.Location))
                    return false;
                return true;
            }
        }

        private bool atLeastOneEnabled;
        public bool AtLeastOneEnabled { get { return atLeastOneEnabled; } }

        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }



        public void makeSort(decimal coeffEnabled, ConfMedianne mode, ConfMedianne mode0) //IList<double> reference, IList<Piece> pieces)
        {
            try
            {
                selectedCoeff = util.selectedCoeff.noCoeff;
                //if (name == "The College Dropout")
                //{
                //}
                decimal offset = conf.AlbumMoyOffset;
                int count = list.Count;
                if (count == 0)
                    return;
                list.Sort(new PieceSortComparer());
                var listSortedValues = new List<decimal>();
                for (int i = 0; i < count; i++)
                {
                    listSortedValues.Add(list[i].Rank.SortValue);
                    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                        classed = true;
                }

                m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                decimal moy = 0m;
                #region calcul brut
                #region init
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;
                    //if (coeffEnabled != 1m && p.Enabled)
                    //{
                    //    rapportClassement /= coeffEnabled;
                    //}
                    p.setClassementVirtuel(list[i].RapportClassement);

                    list[i].eraseInfoMedianne();

                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                list.Sort(new PieceClassementComparer());
                listSortedValues = new List<decimal>();
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].VirtualClassement);

                #endregion

                if (count > 0)
                    moy /= count;
                classMoy = moy;



                var med = CalcMedianne.getMedianne(listSortedValues, medianne);
                classementValue = med.d;
                if (classementValue > 0m)
                    list[med.index].Medianne = true;

                var _med0 = AlbumMedianne.getMedianneLight(new List<Piece>(list), coeffEnabled, mode0, false);




                equivLight0 = Piece.getClassementEquiv(_med0.d);

                #endregion
                #region calcul virtuel
                #region init (prise en compte coeff des enabled)
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;
                    if (coeffEnabled != 1m && p.Enabled)
                    {
                        rapportClassement /= coeffEnabled;
                    }
                    p.setClassementVirtuel(rapportClassement);
                    p.setClassementVirtuel2(rapportClassement);
                }
                list.Sort(new PieceClassementComparer());
                #endregion
                int i0 = 0;
                AlbumMedianne.buildVirtual(new List<Piece>(list), mode, mode.Min, coeffEnabled, false, ref i0);

                med = AlbumMedianne.getMedianneLight(new List<Piece>(list), coeffEnabled, mode, true);
                classementValueLight = med.d;

                #endregion

                equiv = Piece.getClassementEquiv(classementValue); // (10000 * m_rank.SortValue).ToString("00000.0", cu); 


                moyenne = Piece.getClassementEquiv(classMoy);
                var modeMin = mode.cmpMin;


                if (modeMin == util.modeMin.orphelin)
                {
                    Piece min = null;
                    decimal _min = int.MaxValue;
                    foreach (Piece p in list)
                    {
                        var v = p.RapportClassement;

                        if (p.Enabled) // && FileRegister.Exist(p.Location))
                        {
                            if (v < _min)
                            {
                                _min = v;
                                min = p;
                            }
                        }
                    }

                    if (min != null)
                    {
                        Next = min;
                        _min = min.VirtualClassement2;
                        if (_min > classementValueLight)
                            classementValueLight = _min;
                    }
                }
                else if (modeMin == util.modeMin.toujours)
                {
                    Piece nextZero = null;

                    Piece min = null;
                    decimal _min = int.MaxValue;
                    foreach (Piece p in list)
                    {
                        var v = p.RapportClassement;

                        if (p.Enabled) // && FileRegister.Exist(p.Location))
                        {
                            if (v == 0)
                            {
                                if (nextZero == null)
                                    nextZero = p;
                            }

                            else if (v < _min)
                            {
                                _min = v;
                                min = p;
                            }
                        }
                    }

                    if (min != null)
                    {
                        _min = min.VirtualClassement2;
                    }

                    if (nextZero != null)
                    {
                        // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                        // j'applique le seuil que s'il est inférieur à la médiane
                        if (_min < classementValueLight)
                        {
                            Next = min;
                            classementValueLight = _min;

                            if (min.CoeffVirtuel2 > 1)
                                selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                        }
                        else
                        {
                            var p = list[med.index];
                            if (_med0.d > med.d) // if (p.CoeffVirtuel > 1)
                                selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                            Next = nextZero;
                        }
                    }
                    else
                    {
                        // tous notés => on prend le plus faible
                        if (min != null)
                        {
                            classementValueLight = _min;
                            if (min.CoeffVirtuel2 > 1) // if (min.CoeffVirtuel2 > 1)
                                selectedCoeff = selectedCoeff.min; //selectedByCoeff2 = true;
                        }
                        Next = min;
                    }

                }

                //if (modeMin > modeMin.non)
                //{
                //    int nb = 0;
                //    Piece min = null;
                //    decimal _min = int.MaxValue;
                //    foreach (Piece p in list)
                //    {
                //        var v = p.RapportClassement;
                //        if (v > 0 && !p.Enabled)
                //            nb++;
                //        if (modeMin == util.modeMin.orphelin || v > 0)
                //        {
                //            if (p.Enabled && FileRegister.Exist(p.Location))
                //            {

                //                if (v < _min)
                //                {
                //                    _min = v;
                //                    min = p;
                //                }
                //            }
                //        }
                //    }

                //    if (min != null)
                //    {
                //        _min = min.VirtualClassement;
                //        if (nb > 0)
                //            _min *= (decimal)nb / (decimal)count;
                //        if (modeMin == modeMin.toujours || _min > classementValueLight)
                //            classementValueLight = _min;
                //    }


                //}
                equivLight = Piece.getClassementEquiv(classementValueLight);


            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }



        }



        public decimal getTrackSortValue(int index)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }

        public void makeSelection()
        {
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private void initRank()
        {
            m_rank.init();
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return name.Equals(o.name);
        }
        public override int GetHashCode()
        {
            return name.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using pdb.util;
using System.Collections.Generic;
using System;
using pdb.obj;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    public class Albums : IAlbumInit
    {
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
        }
        private BgDictString<Album> dict = new BgDictString<Album>();
        private Consolid consolid;
        private StackAlbum stack = StackAlbum.Instance;
        private void check_(Piece piece)
        {
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                var album = dict[__album];
                if (album == null)
                {
                    album = new Album(__album);
                    album.Virtual = piece.Virtual;
                    dict.Add(__album, album);
                }
                album.add(piece);

            }


        }

        public int Count { get { return dict.Count; } }

        private string getKey(string _album)
        {
            string str = "-";
            if (!string.IsNullOrEmpty(_album))
            {
                str = _album.Trim();
            }
            return str;
        }

        public void sortVirtual()
        {
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }
        }

        public void check(Piece piece)
        {
            check_(piece);
            foreach (Piece child in piece.Childs)
                check_(child);
        }

        public Album getAlbum(TrackList piece)
        {
            return piece.Piece.PieceAlbum;
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                return dict[__album];
            }
            return null;
        }

        public void makeSort()
        {

            var confSort = consolid.SortAlbumMode;
            stack.Capacity = confSort.stackSize;
            ///check to find first light
            ConfMedianne confMedianne = null;
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp;
            }

            var conf0 = new ConfMedianne(confMedianne);
            conf0.Main.safe = 0;
            conf0.Min.safe = 0;

          

            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSort(confSort.coeffEnabled, confMedianne, conf0); //listRef, reference); 
            }

            list.Sort(new AlbumClassComparer(consolid.SortAlbumMode));
            list.Reverse();
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            // prise en compte de la stack
            stack.build();
            var listStack = stack.Albums;
            foreach (Album s in listStack)
            {
                string key = getKey(s.Name);
                var alb = dict[key];
                stack.merge(s, alb);
            }
            //list.Sort(new AlbumClassComparerStack());
            //for (int i = 0; i < list.Count; i++)
            //{
            //    list[i].Rank2 = i + 1; 
            //}
        }

        public List<Album> makeSelection()
        {
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSelection();
            }
            list.Sort(new AlbumRestComparer());
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }
            return list;
        }


        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }
        public List<Album> ListByUpdate
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumLastModifClassementComparer());

                return list;
            }
        }

        public void signalClassChange(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return;
            stack.Add(album);
        }



    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\StackAlbum.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.util;
using System.IO;

namespace pdb.gen.albums
{
    interface IAlbumInit
    {
        List<Album> ListByUpdate { get; }
    }
    class StackAlbum
    {
        private static AsyncFileWriter asyncFw = AsyncFileWriter.Instance; 
        const string PATH = @"..\stack.txt"; 
        private StackAlbum()
        {
            try
            {
                //string[] lines = File.ReadAllLines(PATH);
                //foreach (string line in lines)
                //{
                //    if (string.IsNullOrEmpty(line))
                //        continue;
                //    Add(new Album(line));
                //}
            }
            catch
            {
            }

        }
        private static StackAlbum _instance;
        private static volatile object _lock = new object();
        public void init(IAlbumInit provider)
        {
            if (list != null)
                return;
           
            var _list = provider.ListByUpdate;
            this.list = new HashList<Album>(_list); 
            foreach (Album album in _list)
                Add(album); 
        }
        public static StackAlbum Instance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_lock)
                    {
                        if (_instance == null)
                            _instance = new StackAlbum();
                    }
                }
                return _instance;
            }
        }
        private HashList<Album> list; 
        private int capacity;
        public int Capacity
        {
            set
            {
                if (capacity != value)
                {
                    capacity = value;
                }
            }
        }

        public void build()
        {
            int i = list.Count - 1;
            int nb = 0;
            int ii = list.Count;

            for (; i >= 0; i--)
            {
                nb++;
                if (nb <= capacity)
                    list[i].StackValue = nb;
                else
                    list[i].StackValue = 0;
                list[i].StackIndex = nb;
            }
            //for (; i >= 0 && nb < capacity; i--)
            //{
            //    nb++;
            //    list[i].StackValue = nb;
            //    list[i].StackIndex = i + 1;
            //}
            //for (; i >= 0; i--)
            //{
            //    list[i].StackValue = 0;
            //    list[i].StackIndex = i+1;
            //}

            var sb = new StringBuilder(); 
            foreach (var album in list)
            {
                sb.AppendLine(album.Name); 
            }

            asyncFw.post(PATH, sb.ToString()); 
        }

        public void Add(Album album)
        {
            if (list.Contains(album))
                list.Remove(album);
            list.Add(album);
        }

        public List<Album> Albums { get { return new List<Album>(list); } }
        public void merge(Album mine, Album their)
        {
            if (mine == null || their == null)
                return; 
            int index = list.IndexOf(mine);
            their.StackValue = mine.StackValue;
            their.StackIndex = mine.StackIndex;
            list[index] = their;

        }
    }
}
]]></content>
  </file>
</db>
