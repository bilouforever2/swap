<db path="C:\Bernard\db1\PieceDb3Ref">
    <file path="\pdb.util\Medianne.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;

namespace pdb.util
{
    public class CalcMedianne
    {
        const decimal PRECISION = 0.0000001m;


        public static decimal getMedianne(IEnumerable list, decimal coeffMedianne)
        {
            var _list = new List<decimal>();
            foreach (object o in list)
            {
                _list.Add(Convert.ToDecimal(o));
            }
            return getMedianne(_list, coeffMedianne);
        }

        public static decimal getMedianne(IList<decimal> list, decimal coeffMedianne)
        {
            return getMedianne_(list, coeffMedianne);
        }


        public static decimal getMedianneLight(IList<decimal> list, decimal coeffMedianne, bool quasi, int nbVirt)
        {
            var medianne = getMedianne_(list, coeffMedianne);
            if (list.Count == 1)
                return medianne;

            int count = list.Count;


            decimal ret = medianne; 

            if (nbVirt > 0)
            {

                int i0 = count - 1;

                for (int i = 0; i < count; i++)
                {
                    if (list[i] == 0m)
                    {
                        i0 = i;
                        break;
                    }
                }

                for (int i00 = 1; i00 <= i0; i00++)
                {

                    List<decimal> _list = new List<decimal>(list);
                    for (int i = i00; i < count; i++)
                        _list[i] = 0m;
                    int _count = Math.Min(count, i00 + nbVirt);
                    decimal[] virt = new decimal[_count];
                    for (int i = 0; i < i00; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = _list[i];
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= 10m;
                            virt[j] += _base * _coeff;
                        }
                    }
                    // decimal prec = -1m;  
                    int _nbVirt = 0;
                    decimal value = int.MaxValue;
                    for (int i = 1; i < count; i++)
                    {
                        //   prec = value;
                        value = _list[i];
                        var calc = virt[i];
                        if (value < calc)
                        {
                            _nbVirt++;
                            value = calc;  //Math.Min(prec, calc);
                            _list[i] = value;
                            if (_nbVirt >= nbVirt)
                                break;
                        }
                        else
                            _nbVirt = 0;
                    }
                    //_list.Sort();
                    //_list.Reverse(); 



                    var retAux = calcmedianneVirt(_list, coeffMedianne, quasi);
                    if (retAux > ret)
                        ret = retAux;
                }


            }
            else
                ret = calcmedianneVirt(list, coeffMedianne, quasi);
            if (ret < medianne)
                ret = medianne;
            return ret;
        }


        private static decimal calcmedianneVirt(IList<decimal> _list, decimal coeffMedianne, bool quasi)
        {
            int count = _list.Count;
            decimal ret = 0m;
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);

                var aux = getMedianne_(_list, coeffMedianne);
                if (aux == 0m)
                    continue;
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret)
                    ret = aux;
                if (_list[count - i - 1] > 0m)
                    break;

            }
            return ret;
        }


        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit Ãªtre compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
                return list[count - 1];

            var medianne = coeffMedianne * (count - 1);

            int i0 = (int)medianne;
            int i1 = i0 + 1;
            var val0 = list[i0];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(i0)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
                return val1;

            var pente = (val1 - val0);
            var dx = medianne - i0;
            var dy = pente * dx;
            return val0 + dy;

        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}
]]></content>
  </file>
</db>
