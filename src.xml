<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;
using pdb.db.piece.type;


namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log;
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;


        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }
        private static DetailClassementViewModel detailClassementViewModel;
        internal static DetailClassementViewModel DetailClassementViewModel { set { detailClassementViewModel = value; } }

        public App()
            : base()
        {
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private void CheckException(string from, object sender, object ex)
        {
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {

                pdb.player.ViewModel.Colors.MementoColor.recover();

                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init("pdb.player");
                log = Logger.getLogger("Program");
                misc.init(log);

                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");


                var xmlConf = CConf.loadConf();
                export = CConf.Export;
                import = CConf.Import;

                gen = new Consolid();
                var mementoAlbum = Memento.Instance.confAlbum;
                if (mementoAlbum != null && mementoAlbum.Composants.Count > 0)
                    gen.SortAlbumMode = mementoAlbum;
                else
                    gen.SortAlbumMode = CConf.ConfGen.AlbumSort;
                Memento.Instance.confAlbum = gen.SortAlbumMode;
                Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif; 

                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);
              
                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni();
                Db.loadData();

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                Memento.Instance.save(); 
                thLoop = new Thread(loop);
                thLoop.Start();

                MemUtil.Start(CConf.GcCollect);
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        public static void go()
        {
            lock (_lock)
            {
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        private static void goInit()
        {
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;
            gen.MakeConsolid(Db.List.getList());

            if (CConf.ResetOneCl)
            {
                Classement min = Classement.create("00003.0"); decimal mind = min.ClassementValueDecimal;
                Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;

                foreach (Piece p in gen.sortByClass())
                {
                    decimal clValue = p.ClassementValueDecimal;
                    if (clValue > zer0d)
                    {
                        if (clValue >= zer0d)
                        {
                            var dPiece = Db.getPiece(p.PieceId);
                            var strNewCl = "0000" + dPiece.getClassement().ToString();
                            var newCl = Classement.create(strNewCl);
                            p.Enabled = true;

                            p.setClassement(newCl.ClassList, newCl.Rating);
                            dPiece.Classement.eraseClassement2(newCl);
                        }
                        else
                            p.Enabled = false;
                    }
                }
                /*
                var _albums = gen.Albums;
                foreach (var album in _albums.List)
                {
                    if (album.Name == "Mémos vocaux" || album.Name == "Pictures at an Exhibition")
                    {
                    }
                    var l = album.Tracks;
                    decimal pluspetitNonNull = int.MaxValue;
                    foreach (Piece t in l)
                    {
                        decimal clValue = t.ClassementValueDecimal;
                        if (clValue > zer0d)
                        {
                            if (clValue < pluspetitNonNull)
                                pluspetitNonNull = clValue;
                        }

                    }
                    foreach (Piece t in l)
                    {
                        if (t.Parent == null)
                        {
                            decimal clValue = t.ClassementValueDecimal;
                            if (t.isClassListNumeric && clValue > zer0d)
                            {
                                if (clValue > pluspetitNonNull)
                                {
                                    var dPiece = Db.getPiece(t.PieceId);
                                    t.Enabled = true;
                                    t.setClassement("0", 0);
                                    dPiece.Classement.eraseClassement2();
                                }
                            }
                        }
                    }
                }*/
                gen.MakeConsolid(Db.List.getList());
            }


            gen.buildMusique();
            gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


            gen.timeRanking();
            gen.eraseGrouping();
            // gen.writeComment();
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
            gen.createRot(CConf.ListBase, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            gen.CommentGo = true;
            gen.GroupinGO = true;
            //  PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual;
            PlayerViewModel.Instance.ConfAlbumSort = gen.SortAlbumMode;
            Memento.Instance.confAlbum = gen.SortAlbumMode; 
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
        }

        private static void _go()
        {
            try
            {
                Memento.Instance.save(); 
                var confSort = PlayerViewModel.Instance.ConfAlbumSort;
                if (confSort != null)
                    Piece.SeuilProvisoire = confSort.lastModif;
                detailClassementViewModel.IhmInDispo = ihmInDispo.rot;
                gen.CommentGo = false;
                gen.GroupinGO = false;
                bib.Aborted = true;
                Db.saveAsync();
                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;
                // if (__end || __go) return;

                if (PlayerViewModel.Instance.CreateRot)
                {
                    //  gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
                    //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 
                    gen.MakeConsolid(Db.List.getList()); //   bib.Musique.Tracks);
                    //  if (__end || __go) return;
                    AlbumCtl.Instance.init();
                    //   if (__end || __go) return;
                    gen.timeRanking();
                    //  if (__end || __go) return;
                    ChronoData.DateAuto = true;

                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);

                    //      if (__end || __go) return;
                    bib.Aborted = false;
                    ListWriterMgr.Async = false;
                    //listWriter = new ListWriter(root);
                    try
                    {
                        CConf.loadConf();
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                    // gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                    gen.createRot(CConf.ListBase, App.bib);
                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);


                    //log.log("visibles"); 
                    //foreach (TrackListViewModel visible in Player.VisibleItems)
                    //{
                    //    if (__end || __go) return;
                    //    visible.PieceGen.writeCommentGrouping();
                    //    visible.refresh(); 
                    //}
                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;
                    //gen.writeComment();
                    //if (__end || __go) return;
                    //gen.writeGrouping();
                    if (refresh != null)
                        refresh(PHASE2, EventArgs.Empty);

                    if (__end || __go) return;

                    gen.CommentGo = true;
                    gen.GroupinGO = true;



                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);
                    // _refresh = true;
                    detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
                    gen.builStats();
                    //bib = new BibViewModel(Db.Root); 
                    //gen.createRot(CConf.ListBase, bib);
                    //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                    gen.CommentGo = true;
                    gen.GroupinGO = true;


                }


            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                if (refresh != null && PlayerViewModel.Instance.CreateRot)
                    refresh(PHASE2, EventArgs.Empty);

                detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                ExportCmd.CalculExport();
            }


        }

        public static event EventHandler refresh;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            App.bib.Aborted = true;
            Db.WriteDB1();
            Db.WriteDB2();
            App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.Track);
            if (l == null)
                return null;
            foreach (ITrackMetaData p in l)
            {

                TrackListViewModel trackList = PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                    return null;
                case MessageBoxResult.No:
                    return false;
                case MessageBoxResult.None:
                    return null;
                case MessageBoxResult.OK:
                    return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export;
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog();
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir;
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\CPieceComparer.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.gen.conf;
using pdb.obj;
using pdb.util;
namespace pdb.gen
{
    public class CPieceComparerByGoodness : IComparer<Piece>
    {
        /// <summary>
        /// compareur de listes
        /// </summary>
        private static CPlayListComparer c_comparer = new CPlayListComparer();
        public static bool modeBatch = true;
        public int Compare(Piece x, Piece y)
        {
            if (!modeBatch)
            {
                if (x.ClassPlayList == null)
                {
                    if (y.ClassPlayList == null)
                    {
                        return -(x.RatingCmp.CompareTo(y.RatingCmp));
                    }
                    else
                    {
                        return 1;
                    }
                }
                if (y.ClassPlayList == null)
                {
                    return -1;
                }
            }

            // gérer le cas ou les deux listes sont imbriquées
            // 3.4 > 33.5 et 3.2 < 33.0

            //if (x.isClassListNumeric && y.isClassListNumeric)
            //{
            String strX = x.ClassNameAndRating;
            String strY = y.ClassNameAndRating;
            var cmpnameRat = compareClassNameAndRating(strX, strY);
            if (cmpnameRat != 0) return cmpnameRat;
            //}
            if (!modeBatch)
            {

                CPlayList plX = x.ClassPlayList;
                CPlayList plY = y.ClassPlayList;

                //if( plX.isSubList(plY) || plY.isSubList(plX))
                //{
                //    string xName = plX.Name;
                //    string yName = plY.Name; 

                //}


                int l_plCmp = c_comparer.Compare(plX, plY);
                if (l_plCmp == 0)
                {
                    return -(x.RatingCmp.CompareTo(y.RatingCmp));
                }
                else
                {
                    return l_plCmp;
                }
            }
            else
                return -(x.RatingCmp.CompareTo(y.RatingCmp));


        }

        public static int compareClassNameAndRating(string strX, string strY)
        {
            int max = strX.Length > strY.Length ? strX.Length : strY.Length;
            for (int i = 0; i < max; i++)
            {
                int iX = strX.getInt(i); // CUtil.getInt(strX, i);
                int iY = strY.getInt(i);//CUtil.getInt(strY, i);
                if (iX != iY)
                    return -iX.CompareTo(iY);
            }
            return 0;
        }

    }

    public class CPieceComparerByGoodness2 : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return x.Rank.Quality.CompareTo(y.Rank.Quality);
        }
    }

    public class CPieceComparerByQualityAndLength : IComparer<Piece>
    {

        private static IComparer<Piece> c_comparer = new CPieceComparerByGoodness2();
        public virtual int Compare(Piece x, Piece y)
        {
            int l_cmp = c_comparer.Compare(x, y);
            if (l_cmp == 0)
                return -x.Rank.Lenght.CompareTo(y.Rank.Lenght);
            return l_cmp;
        }
    }

    public class CPieceComparerByQualityAndLength2 : IComparer<Piece>
    {
        int IComparer<Piece>.Compare(Piece x, Piece y)
        {
            return x.Rank.Twice.CompareTo(y.Rank.Twice);
        }
    }

    public class CPieceComparerByQualityAndLengthInv : IComparer<Piece>
    {

        private static IComparer<Piece> c_comparer = new CPieceComparerByGoodness2();
        public virtual int Compare(Piece x, Piece y)
        {
            int l_cmp = c_comparer.Compare(x, y);
            if (l_cmp == 0)
                return x.Rank.Lenght.CompareTo(y.Rank.Lenght);
            return l_cmp;
        }
    }

    public class CPieceComparerByQualityAndLengthInv2 : IComparer<Piece>
    {
        int IComparer<Piece>.Compare(Piece x, Piece y)
        {
            return x.Rank.TwiceInv.CompareTo(y.Rank.TwiceInv);
        }
    }

    /// <summary>
    /// tri pour la copie : En premier : les plus bas et les activés
    /// </summary>
    public class CPieceComparerByQualityLengthAndEnable : CPieceComparerByQualityAndLength
    {
        public override int Compare(Piece x, Piece y)
        {
            if (x.Enabled == y.Enabled)
            {
                return -base.Compare(x, y);
            }
            if (x.Enabled)
                return -1;
            return 1;
        }
    }


    public class CPieceComparerByLenght : IComparer<Piece>
    {

        public int Compare(Piece x, Piece y)
        {
            return x.Duration.CompareTo(y.Duration);
        }
    }

    public class CPieceComparerByLenght2 : IComparer<Piece>
    {

        public int Compare(Piece x, Piece y)
        {
            return x.Rank.Lenght.CompareTo(y.Rank.Lenght);
        }
    }

    public class CPieceInListComparer : IComparer<Piece>
    {

        //Public Function Compare(ByVal x As CPiece, ByVal y As CPiece) As Integer Implements System.Collections.Generic.IComparer(Of CPiece).Compare
        //    Dim val1 As Double = x.Rapport * Math.Pow(x.Duration, CDb.SortTimeProp)
        //    Dim val2 As Double = y.Rapport * Math.Pow(y.Duration, CDb.SortTimeProp)

        //    Dim l_cmp As Integer = val1.CompareTo(val2)
        //    If l_cmp <> 0 Then
        //        Return l_cmp
        //    Else
        //        Return x.Duration.CompareTo(y.Duration)
        //    End If
        //End Function
        /// <summary>
        /// Comparaison de deux fichiers en fonction du cumul des deux paramètre qualité et longueur
        /// 
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        /// <remarks>En gros on ajoute le log des classements qualité et longueur, pondérés par le coefficient sortimeProp
        /// 0 --> que la longueur prise en compte
        /// 1 --> que la qualité</remarks>
        public int Compare(Piece x, Piece y)
        {
            var val1 = CTuning.Calc(x.Rank, CConf.Sort);
            var val2 = CTuning.Calc(y.Rank, CConf.Sort);

            int l_cmp = val1.CompareTo(val2);
            if (l_cmp != 0)
            {
                return l_cmp;
            }
            else
            {
                return x.Duration.CompareTo(y.Duration);
            }

        }


    }

    public class PieceRestComparer : IComparer<Piece>
    {

        public int Compare(Piece x, Piece y)
        {
            //if ((x.Album == "A Lovaggkiraly" && x.Name == "Piste 04" && y.Album == "Only Built 4 Cuban Linx" && y.Name == "Shark Niggas (Biters)")
            //    || (y.Album == "A Lovaggkiraly" && y.Name == "Piste 04" && x.Album == "Only Built 4 Cuban Linx" && x.Name == "Shark Niggas (Biters)"))
            //{
            //    int toto = 0; 
            //}
            int cmp = x.Rank.TimeRest.CompareTo(y.Rank.TimeRest);
            if (cmp != 0)
                return cmp;

            return x.Rank.TwiceInv.CompareTo(y.Rank.TwiceInv);
            //cmp = x.QRank.CompareTo(y.QRank);
            //if (cmp != 0)
            //    return cmp; 

            //return - x.LRank.CompareTo(y.LRank);

        }
    }

    public class PieceRestComparer2 : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            throw new NotImplementedException();
        }
    }



    public class PieceDeltaComparer : IComparer<Piece>
    {

        public int Compare(Piece x, Piece y)
        {
            int cmp = x.Rank.Delta.CompareTo(y.Rank.Delta);
            if (cmp != 0)
                return cmp;
            return x.QLRank.CompareTo(y.QLRank);

        }
    }

    public class PieceSortComparer : IComparer<Piece>
    {

        public int Compare(Piece x, Piece y)
        {
            int cmp = x.Rank.SortValue.CompareTo(y.Rank.SortValue);
            if (cmp != 0)
                return cmp;
            return -x.QLRank.CompareTo(y.QLRank);

        }
    }


    //public class PieceClassementDisplayComparer : IComparer<Piece>
    //{
    //    private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
    //    public int Compare(Piece x, Piece y)
    //    {
    //        var xv = x.RapportClassement;
    //        var yv = y.RapportClassement;
    //        int cmp = 0;
    //        if (xv == 0m || yv == 0m)
    //            cmp = x.RapportClassement.CompareTo(y.RapportClassement);
    //        if (cmp != 0) return -cmp;
    //        cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
    //        if (cmp != 0) return -cmp;
    //        return tn.Compare(x, y);
    //        //  return -x.RapportClassement.CompareTo(y.RapportClassement);
    //    }
    //}

    public class PieceClassementComparer : IComparer<Piece>
    {
        private bool oldAsZero; 
        public PieceClassementComparer(bool oldAsZero)
        {
            this.oldAsZero = oldAsZero; 
        }
        private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
        public int Compare(Piece x, Piece y)
        {
         
            if (oldAsZero)
            {
                bool xRecent = x.LastClassementRecent;
                bool yRecent = y.LastClassementRecent; 
                if(xRecent !=yRecent)
                {
                    if (xRecent)
                        return -1;
                    return 1; 
                }
            }
           int cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
            if (cmp != 0) return -cmp;
            cmp = x.RapportClassement.CompareTo(y.RapportClassement);
            if (cmp != 0) return -cmp;
            return tn.Compare(x, y);
            //  return -x.RapportClassement.CompareTo(y.RapportClassement);
        }
    }
    ///// <summary>
    ///// Donne l'ordre de copie si on s'intéresse aux morceaux les moins notés
    ///// </summary>
    //public class PieceClassementComparerInv : IComparer<Piece>
    //{
    //    public int Compare(Piece x, Piece y)
    //    {
    //        //if (x.Enabled != y.Enabled)
    //        //{
    //        //    return x.Enabled ? -1 : 1;
    //        //}

    //        if (x.IsNext != y.IsNext)
    //        {
    //            if (x.IsNext)
    //                return -1;
    //            return 1; 
    //        }
    //        var xv = x.RapportClassement;
    //        var yv = y.RapportClassement;

    //        int cmp = 0;
    //        if (xv > 0 && yv > 0)
    //        {
    //            cmp = xv.CompareTo(yv);
    //            if (cmp != 0) return cmp;
    //            cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
    //            if (cmp != 0) return cmp;
    //        }

    //        cmp = x.TrackNumber.CompareTo(y.TrackNumber);
    //        if (cmp != 0)
    //            return cmp;
    //        return x.Location.CompareTo(y.Location);
    //        //  return -x.RapportClassement.CompareTo(y.RapportClassement);
    //    }
    //}

    ///// <summary>
    ///// Donne l'ordre de copie si on s'intéresse aux morceaux les moins notés et si on veut optimiser autour du Next
    ///// </summary>
    //public class PieceClassementComparerExport : IComparer<Piece>
    //{
    //    public PieceClassementComparerExport(HashList<Piece> source)
    //    {
    //        this.source = source; 
    //    }
    //    private readonly HashList<Piece> source;
    //    public int Compare(Piece x, Piece y)
    //    {
    //        return source.IndexOf(x).CompareTo(source.IndexOf(y)); 
    //    }
    //}

    public class PieceDurationValueComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return -x.Duration.CompareTo(y.Duration);
        }
    }

    public class PieceSortComparerList : IComparer<Piece>
    {

        public int Compare(Piece x, Piece y)
        {
            return x.Rank.Sort.CompareTo(y.Rank.Sort);
            //int cmp = x.Rank.SortValue.CompareTo(y.Rank.SortValue);
            //if (cmp != 0)
            //    return cmp;
            //return x.QLRank.CompareTo(y.QLRank);

        }
    }

    public class PieceTrackNumberComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            var cmp = x.TrackNumber.CompareTo(y.TrackNumber);
            if (cmp != 0)
                return cmp;
            return x.Location.CompareTo(y.Location);
            //  return x.TrackNumber.CompareTo(y.TrackNumber);
        }
    }


}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.util;
using System;
using System.Globalization;
using pdb.gen.Tuning;
using pdb.gen.conf;
using System.Linq;

namespace pdb.gen.albums
{


    public class Album
    {

        private string name;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }
        private int stackValue;
        public int StackValue { get { return stackValue; } set { stackValue = value; } }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;

        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private List<Piece> list = new List<Piece>();
        private static int _sID = 0;
        private int _dID;


        public Album(string name)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        private string equiv = "";
        public string Equiv { get { return equiv; } }

        private string equivLight = "";
        public string EquivLight { get { return equivLight; } }

        private string equivLight0 = "";
        public string EquivLight0 { get { return equivLight0; } }

        private string moyenne = "";
        public string Moyenne { get { return moyenne; } }

        public bool Moved { get; set; }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            if (list.Contains(piece))
                return false;
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);
            piece.PieceAlbum = this;
            return true;
        }

        private HashList<Piece> _tracksSortByClassement;
        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceClassementComparer(false));
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        //public int IndexClass(Piece p)
        //{
        //    return Tracks.IndexOf(p);
        //}

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}
        HashList<Piece> trackSortedByExportPriority;
        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0; ;
                    int dx = ix - inext;
                    int dy = iy - inext;

                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.RapportClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.RapportClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    cmp = System.Math.Abs(dx).CompareTo(System.Math.Abs(dy));
                    if (cmp != 0)
                        return cmp;
                    //ici même distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);
                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le précédent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                if (FileRegister.Exist(next.Location))
                    return false;
                return true;
            }
        }

        private bool atLeastOneEnabled;
        public bool AtLeastOneEnabled { get { return atLeastOneEnabled; } }

        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }



        public void makeSort(ConfAlbumSort conf, ConfMedianne mode, ConfMedianne mode0) //IList<double> reference, IList<Piece> pieces)
        {
            try
            {
                selectedCoeff = util.selectedCoeff.noCoeff;
                //if (name == "The College Dropout")
                //{
                //}
                decimal offset = Album.conf.AlbumMoyOffset;
                int count = list.Count;
                if (count == 0)
                    return;
                list.Sort(new PieceSortComparer());
                var listSortedValues = new List<decimal>();
                for (int i = 0; i < count; i++)
                {
                    listSortedValues.Add(list[i].Rank.SortValue);
                    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                        classed = true;
                }

                m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                decimal moy = 0m;
                #region calcul brut
                #region init
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;
                    //if (coeffEnabled != 1m && p.Enabled)
                    //{
                    //    rapportClassement /= coeffEnabled;
                    //}
                    p.setClassementVirtuel(list[i].RapportClassement);

                    list[i].eraseInfoMedianne();

                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                list.Sort(new PieceClassementComparer(false));
                //listSortedValues = new List<decimal>();
                //for (int i = 0; i < count; i++)
                //    listSortedValues.Add(list[i].VirtualClassement);

                #endregion

                if (count > 0)
                    moy /= count;
                classMoy = moy;



                var med = AlbumMedianne.getMedianne(new List<Piece>(list), medianne);
                classementValue = med.d;
                if (classementValue > 0m)
                    list[med.index].Medianne = true;

                var _med0 = AlbumMedianne.getMedianneLight(new List<Piece>(list), conf, mode0, false);




                equivLight0 = Piece.getClassementEquiv(_med0.d);

                #endregion
                #region calcul virtuel
                #region init (prise en compte coeff des enabled)
                var coeffEnabled = conf.coeffEnabled;
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;
                    if (coeffEnabled != 1m && p.Enabled)
                    {
                        rapportClassement /= coeffEnabled;
                    }
                    p.setClassementVirtuel(rapportClassement);
                    p.setClassementVirtuel2(rapportClassement);
                }
                list.Sort(new PieceClassementComparer(false));
                #endregion
                int i0 = 0;
                AlbumMedianne.buildVirtual(new List<Piece>(list), mode, mode.Min, conf, false, ref i0);

                med = AlbumMedianne.getMedianneLight(new List<Piece>(list), conf, mode, true);
                classementValueLight = med.d;

                #endregion

                equiv = Piece.getClassementEquiv(classementValue); // (10000 * m_rank.SortValue).ToString("00000.0", cu); 


                moyenne = Piece.getClassementEquiv(classMoy);
                var modeMin = mode.cmpMin;


                if (modeMin == util.modeMin.orphelin)
                {
                    Piece min = null;
                    decimal _min = int.MaxValue;
                    foreach (Piece p in list)
                    {
                        var v = p.RapportClassement;

                        if (p.Enabled) // && FileRegister.Exist(p.Location))
                        {
                            if (v < _min)
                            {
                                _min = v;
                                min = p;
                            }
                        }
                    }

                    if (min != null)
                    {
                        Next = min;
                        _min = min.VirtualClassement2;
                        if (_min > classementValueLight)
                            classementValueLight = _min;
                    }
                }
                else if (modeMin == util.modeMin.toujours)
                {
                    if (conf.oldAsZero)
                        list.Sort(new PieceClassementComparer(true));
                    Piece nextZero1 = null;
                    Piece nextZero2 = null;

                    Piece min1 = null;
                    Piece min2 = null;
                    Piece min = null;
                    decimal _min1 = int.MaxValue;
                    decimal _min2 = int.MaxValue;
                    decimal _minzero1 = int.MaxValue;
                    decimal _minzero2 = int.MaxValue;
                    bool realZero = false; 
                    foreach (Piece p in list)
                    {
                        var v1 = p.VirtualClassement;
                        var v2 = p.VirtualClassement2;

                        if (p.Enabled) // && FileRegister.Exist(p.Location))
                        {
                            if (v1 == 0 || (conf.oldAsZero && !p.LastClassementRecent))
                            {
                                if (v1 < _minzero1)
                                {
                                    _minzero1 = v1; 
                                    nextZero1 = p;
                                    if (v1 == 0)
                                        realZero = true; 
                                }
                            }

                            if (v2 == 0 || (conf.oldAsZero && !p.LastClassementRecent))
                            {
                                if (v2 < _minzero2)
                                {
                                    _minzero2 = v2;  
                                    nextZero2 = p;
                                    if (v2 == 0)
                                        realZero = true; 
                                }
                                    
                            }



                            if (v1 > 0 && v1 < _min1)
                            {
                                _min1 = v1;
                                min1 = p;
                            }

                            if (v2 > 0 && v2 < _min2)
                            {
                                _min2 = v2;
                                min2 = p;
                            }
                        }
                    }
                    decimal _min = 0;
                    if (_min1 <= _min2)
                    {
                        min = min1;
                        _min = _min1;
                    }
                    else
                    {
                        min = min2;
                        _min = _min2;
                    }

                    Piece nextZero = null;
                    decimal _minzero = int.MaxValue; 
                    if (_minzero1 <= _minzero2)
                    {
                        nextZero = nextZero1; _minzero = _minzero1; 
                    }
                    else
                    {
                        nextZero = nextZero2; _minzero = _minzero2; 
                    }

                    if (nextZero != null)
                    {

                        if (realZero)
                        {
                            // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                            // j'applique le seuil que s'il est inférieur à la médiane
                            if (_min < classementValueLight)
                            {
                                if (min != null)
                                {
                                    Next = min;
                                    classementValueLight = _min;
                                    if (Next.CoeffVirtuel > 1)
                                        selectedCoeff = selectedCoeff.main;
                                    if (_min < _min1)
                                        selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                                }
                            }
                            else
                            {
                              //  var p = list[med.index];
                                if (_med0.d > med.d) // if (p.CoeffVirtuel > 1)
                                    selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                                Next = nextZero;
                                //if (Next.CoeffVirtuel > 1)
                                //    selectedCoeff = selectedCoeff.main; 
                                //if (_min < _min1)
                                //    selectedCoeff = selectedCoeff.min; 
                            }
                        }
                        else
                        {
                            if (_min < classementValueLight)
                            {
                                if (min != null)
                                {
                                    Next = min;
                                    classementValueLight = _min;

                                    if (Next.CoeffVirtuel > 1)
                                        selectedCoeff = selectedCoeff.main;
                                    if (_min < _min1)
                                        selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                                }
                               
                            }
                            else if (_minzero < classementValueLight)
                            {
                                Next = nextZero;
                                classementValueLight = _minzero;

                                if (Next.CoeffVirtuel > 1)
                                    selectedCoeff = selectedCoeff.main; 
                                if (_minzero < _minzero1)
                                    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                            }

                            else
                            {
                                Next = min;
                                classementValueLight = _min;
                                //  var p = list[med.index];
                                if (Next.CoeffVirtuel > 1)
                                    selectedCoeff = selectedCoeff.main; 
                                if (_med0.d > med.d) // if (p.CoeffVirtuel > 1)
                                    selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                               
                            }
                        }
                    }
                    else
                    {
                        // tous notés => on prend le plus faible
                        Next = min;
                        if (min != null)
                        {
                            classementValueLight = _min;
                            // if (min.CoeffVirtuel2 > 1) // if (min.CoeffVirtuel2 > 1)
                            //if (Next.CoeffVirtuel > 1)
                            //    selectedCoeff = selectedCoeff.main; 
                            //if (_min < _min1)
                            //    selectedCoeff = selectedCoeff.min; //selectedByCoeff2 = true;
                        }
                      
                    }

                }

                //if (modeMin > modeMin.non)
                //{
                //    int nb = 0;
                //    Piece min = null;
                //    decimal _min = int.MaxValue;
                //    foreach (Piece p in list)
                //    {
                //        var v = p.RapportClassement;
                //        if (v > 0 && !p.Enabled)
                //            nb++;
                //        if (modeMin == util.modeMin.orphelin || v > 0)
                //        {
                //            if (p.Enabled && FileRegister.Exist(p.Location))
                //            {

                //                if (v < _min)
                //                {
                //                    _min = v;
                //                    min = p;
                //                }
                //            }
                //        }
                //    }

                //    if (min != null)
                //    {
                //        _min = min.VirtualClassement;
                //        if (nb > 0)
                //            _min *= (decimal)nb / (decimal)count;
                //        if (modeMin == modeMin.toujours || _min > classementValueLight)
                //            classementValueLight = _min;
                //    }


                //}
                equivLight = Piece.getClassementEquiv(classementValueLight);


            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }



        }



        public decimal getTrackSortValue(int index)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }

        public void makeSelection()
        {
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private void initRank()
        {
            m_rank.init();
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return name.Equals(o.name);
        }
        public override int GetHashCode()
        {
            return name.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {
                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }
    }
}
]]></content>
  </file>
</db>
