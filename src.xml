<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\pdb.podcast\pdb.podcast.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{6503C759-0373-4B68-A28B-1CB5FF0E6208}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.podcast</RootNamespace>
    <AssemblyName>pdb.podcast</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <TargetFrameworkProfile>
    </TargetFrameworkProfile>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;vendee_</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;MOVE_</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.podcast.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.podcast.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <OutputPath>bin\</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <OutputPath>bin\Release\</OutputPath>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Interop.iTunesLib">
      <HintPath>..\pieceDb.iT\bin\Interop.iTunesLib.dll</HintPath>
      <EmbedInteropTypes>True</EmbedInteropTypes>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Auto\AutoBuilder.cs" />
    <Compile Include="Auto\AutoBuilderItem.cs" />
    <Compile Include="Selection\CauseData.cs" />
    <Compile Include="Auto\Interfaces.cs" />
    <Compile Include="Auto\TrackBorderItem.cs" />
    <Compile Include="Build\FilePub.cs" />
    <Compile Include="Build\IPub.cs" />
    <Compile Include="Build\PubLoader.cs" />
    <Compile Include="Delta\Memory.cs" />
    <Compile Include="Exporter.cs" />
    <Compile Include="Load\LimitItemLoader.cs" />
    <Compile Include="Load\LimitLoader.cs" />
    <Compile Include="Load\LimitsLoader.cs" />
    <Compile Include="Menage.cs" />
    <Compile Include="Feed.cs" />
    <Compile Include="Feeds.cs" />
    <Compile Include="Load\FeedsLoader.cs" />
    <Compile Include="Load\FeedLimitItemLoader.cs" />
    <Compile Include="Report\DirStat.cs" />
    <Compile Include="Report\FeedLimitItemStat.cs" />
    <Compile Include="Report\FeedsLimitItemStat.cs" />
    <Compile Include="Report\FeedStat.cs" />
    <Compile Include="Report\GroupStat.cs" />
    <Compile Include="Report\IStat.cs" />
    <Compile Include="Report\LimitItemStat.cs" />
    <Compile Include="Report\LimitStat.cs" />
    <Compile Include="Report\Stat.cs" />
    <Compile Include="Loader.cs" />
    <Compile Include="PlayListFilter.cs" />
    <Compile Include="PodcastComparer.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Report\DoubleStat.cs" />
    <Compile Include="Report\StatFloat.cs" />
    <Compile Include="Report\TrackConteneur.cs" />
    <Compile Include="Report\TripleStat.cs" />
    <Compile Include="Selection\CauseItem.cs" />
    <Compile Include="Selection\CauseRegister.cs" />
    <Compile Include="Selection\Causes.cs" />
    <Compile Include="Selection\Conv.cs" />
    <Compile Include="TrackInfoItunes.cs" />
    <Compile Include="Tuning\Auto.cs" />
    <Compile Include="Tuning\Conf.cs" />
    <Compile Include="Tuning\ConfDate.cs" />
    <Compile Include="Tuning\DirConf.cs" />
    <Compile Include="Tuning\Html.cs" />
    <Compile Include="Tuning\Journal.cs" />
    <Compile Include="Tuning\Limit.cs" />
    <Compile Include="Tuning\LimitItem.cs" />
    <Compile Include="Tuning\LimitItemBase.cs" />
    <Compile Include="Tuning\Limits.cs" />
    <Compile Include="Tuning\Move.cs" />
    <Compile Include="Tuning\SelectParam.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823D1D-851C-456B-AC4C-B0BEEC173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\pieceDb.iT\pdb.it.csproj">
      <Project>{CF5DB63F-4790-4351-9050-B30DED32F052}</Project>
      <Name>pdb.it</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <Content Include="conf.xml">
      <SubType>Designer</SubType>
    </Content>
  </ItemGroup>
  <ItemGroup>
    <None Include="app.config" />
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\pdb.podcast\Program.cs">
    <content><![CDATA[using iTunesLib;
using pdb.it;
using pdb.obj;
using pdb.ordo;
using pdb.podcast.Auto;
using pdb.podcast.Load;
using pdb.podcast.Report;
using pdb.podcast.Tuning;
using pdb.util;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using Conf = pdb.podcast.Tuning.Conf;
using pdb.podcast.Selection;

namespace pdb.podcast
{
    /// <summary>
    /// crée des listes de lecture pour les Podcasts
    /// </summary>
    class Program : IAbortTask
    {
        //const char DIR_SEP = Path.DirectorySeparatorChar; 
        static Loader loader;
        //private Feeds feeds;
        public static Logger log;
        public static Logger logAuto; 
        static int step = -1;
        static Program _instance = new Program();
       
        private static AsyncFileWriter asyncFw = new AsyncFileWriter();
        private static Chrono chrono = new Chrono();
        private static Logger logChrono; 



        private static XmlWriter writer;
        //DirConf root;
        //DirConf oldRoot;

        private string _empreinte;

        static void Main(string[] args)
        {

            Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
            log = Logger.getLogger("Program");
            logChrono = Logger.getLogger("Chrono",true);
            logAuto = Logger.getLogger("Auto", true);
            logAuto.NoReset = true; 

            FileRegister.init(new BgDictString0<FileValue>());
            _instance.go(args);
        }

        void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            Console.WriteLine("\nThe read operation has been interrupted.");
            Console.WriteLine("  Key pressed: {0}", e.SpecialKey);
            Console.WriteLine("  Cancel property: {0}", e.Cancel);
            if (loader == null)
                return;
            e.Cancel = true;


            if (e.SpecialKey == ConsoleSpecialKey.ControlC)
            {
                _end = true; 
                PlayList.AbortOpe();
                BackGroundTaskMgr.AbortSpecial();
                BackGroundTaskMgr.Reset();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
                Console.WriteLine("\nFin de l'opération d'enregistrement.");
                MemUtil.End();
                Logger.End();
                DisposableCounter.DisposeAll();
                Locker.releaseSingleProcess();
                AsyncFileWriter.End();
                Exporter.Abort(); 
                Environment.Exit(0);
            }
            else
            {
                BackGroundTaskMgr.PlayPause();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
            }
        }

        //private void scandir(string dir)
        //{
        //    scanFiles(new DirectoryInfo(dir));
        //}

        //private void scanFiles(DirectoryInfo dir)
        //{
        //    log.log("scan " + dir.FullName);
        //    foreach (FileInfo file in dir.GetFiles())
        //    {
        //        //if (dict.ContainsKey(file.FullName))
        //        //    continue;

        //        // log.log("try to build track from " + file.FullName);

        //        try
        //        {
        //            var t = loader.createTrack(-1, file.FullName);
        //            if (t == null)
        //                continue;
        //            TrackInfoItunes track = t as TrackInfoItunes;

        //            if (track == null)
        //                continue;
        //            //if (!track.isPodcast)
        //            //    continue;

        //            log.log("\t==>track créé:" + track);
        //            feeds.checkAll(track);

        //        }
        //        catch (Exception ex)
        //        {
        //            log.log(ex.ToString());
        //        }
        //    }

        //    foreach (DirectoryInfo sub in dir.GetDirectories())
        //        scanFiles(sub);
        //}


        public void go(string[] args)
        {
            int countArgs = args.GetLength(0);
            string confFile = "conf.xml";
            if (countArgs > 0)
                confFile = args[0];
            try
            {
                //BackGroundTaskMgr.Sens = - 1; 
                Thread.CurrentThread.Name = "Main";
                Console.CancelKeyPress += Console_CancelKeyPress;
                ThreadUtil.Log = false;
                misc.init(Logger.getLogger);
                MemUtil.Start();




                Conf.Instance.setConfFile(confFile);
                var xelt = Conf.Instance.load(false);
                if (Conf.Menage != menage.none)
                {
                    new Menage().go();
                    return;
                }
                BackGroundTaskMgr.Conf = Conf.Ordo;
                TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                TrackInfoItunes.MaxPlayed = Conf.PlayedDates;
                var itConf = new pdb.it.Conf(xelt);
               
                // loader = new Loader(itConf, true);

                loader = new Loader(itConf,
                    () =>
                    {
                        misc.Pre = "[Load " + step + "] ";

                        PlayList.AbortOpe();
                        BackGroundTaskMgr.AbortSpecial();
                        //   Thread.Sleep(1000); 
                        //  BackGroundTaskMgr.Start(); 
                    })

               ;
                loader.init();


                string ziqueOrg = loader.DefaultFolder;
                loader.PlayListFilter = new PlayListFilter(Conf.RootIt);

                BackGroundTaskMgr.Start();
                List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();
                List<TrackInfoItunes> list = new List<TrackInfoItunes>();

                // var bgClass = BackGroundTaskMgr.getMgr("Classement", 0);

                do
                {
                    try
                    {
                        chrono.end();
                        logChrono.log(chrono.display(3, "{0}:{1:#}")); 
                        chrono.reset("Program"); 
                         
                        step++;
                        Logger.Pre = "[" + step + "] ";
                        Logger.CreateNullLoggers = false;
                        xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                        loader.Conf = new it.Conf(xelt);
                       // AutoBuilder.Log();
                        BackGroundTaskMgr.Conf = Conf.Ordo;
                        TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                        ziqueOrg = loader.DefaultFolder;

#if vendee
                        listTrack = new List<ITrackInfoItunes>();
                        loader.reset(step == 0);

                        loader.ModeXml = false;
                        loader.loadTracks(listTrack);

                        var listV = new ArrayList();
                        loader.getNatives(listV);

                        new Vendee().go(listV);

                        return;

#endif

                        chrono.bip("debut"); 
                       
                        if (step == 0 || !Conf.Simulation)
                        {

                            loader.reset(step == 0, AutoBuilder.MustUpdate);
                            BackGroundTaskMgr.recordMsProc();
                            loader.Aborted = true;

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.Reset();
                            loader.saveIds();
                            BackGroundTaskMgr.recordMsProc();
                            Logger.Reset();
                            BackGroundTaskMgr.Start();


                            misc.Pre = "[" + step + "] ";


                            listTrack = new List<ITrackInfoItunes>();


                            xelt = Conf.Instance.load(false);
                            loader.Conf = new it.Conf(xelt);
                          //  AutoBuilder.Log();
                            BackGroundTaskMgr.Conf = Conf.Ordo;
                            TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            //xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            //loader.Conf = new it.Conf(xelt);
                            //BackGroundTaskMgr.Conf = Conf.Ordo;
                            //TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            if (Conf.DeleteDoublon)
                            {
                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            if (Conf.GetDescription)
                            {
                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            string copyAll = Conf.CopyAll;
                            if (!string.IsNullOrEmpty(copyAll))
                            {
                                loader.loadTracks(listTrack);
                                List<TrackInfoItunes> listToCopy = new List<TrackInfoItunes>();
                                foreach (ITrackInfoItunes _track in listTrack)
                                {

                                    if (_track.isPodcast)
                                    {
                                        var t = _track as TrackInfoItunes;
                                        listToCopy.Add(t);
                                    }


                                }
                                int count = listToCopy.Count;
                                int i = 0;
                                foreach (TrackInfoItunes track in listToCopy)
                                {
                                    i++;
                                    track.copy(copyAll, string.Format("{0}/{1}", i, count));
                                }
                                return;
                            }


                            loader.loadTracks(listTrack);

#if menage
                // var listC = new Dict<string, FileInfo>();
                var listD = new Dict<string, FileInfo>();

                Dict<string,ITrackInfoItunes> dict = new Dict<string, ITrackInfoItunes>();
                foreach (var track in listTrack)
                    dict[track.Location] = track;

               
                listFiles(listD, new DirectoryInfo(@"D:\zique\podcasts"));

                foreach (FileInfo file in listD)
                {
                    string location = file.FullName.Replace("D:", "C:");
                    FileInfo C = new FileInfo(location);
                    if (C.Exists)
                    {
                        //TrackInfoItunes track = dict[file.FullName] as TrackInfoItunes;
                        //if (track != null)
                        //{
                        //    log.log("suppression track" + track);
                        //    track.Delete();
                        //}
                        //else
                        //{
                            log.log("suppression simple de " + file.FullName);
                            file.Delete();
                        //}
                    }

                }

                return; 

#elif build

                            list = new List<TrackInfoItunes>();

                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location) || !File.Exists(location))
                                    {
                                        log.log("phase load :: tres bizarre sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }

                                    list.Add(t);
                                }

                            }
                            int nbIntegre = 0;
                            int nbSuppr = 0;
                            scanFiles(list, new DirectoryInfo(@"C:\zique\podcasts"), ref nbIntegre, ref nbSuppr);
                            log.log("fin scan : {0} intégrés, {1} supprimmés", nbIntegre, nbSuppr);
                            BackGroundTaskMgr.End();
                            return;
                        }
                    }


                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                }
                while (true);

#else
                            list = new List<TrackInfoItunes>();
                            Dict<string, TrackInfoItunes> dictLoc = new Dict<string, TrackInfoItunes>();
                            GroupStat trackStat = new GroupStat();
                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location) || !FileRegister.Exist(location)) //  File.Exists(location))
                                    {
                                        //log.log("phase load :: suppression du track sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }

                                    dictLoc[t.Location] = t;
                                    list.Add(t);
                                    if (!t.Played)
                                        trackStat.recordTrack(t, typeState.all);
                                    trackStat.recordTrack(t, typeState.all);
                                }
                            }
                            chrono.bip("loadTracks"); 

                            var descTrack = DescBuilder.create("Tracks");

                            LimitItem.includeDetail = true;
                            trackStat.report(descTrack);
                            log.log(descTrack.ToString());

                            var sbT = new StringBuilder();

                            //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\tracks.txt")))
                            //{
                            var trackFile = DescBuilder.create("Tracks", sbT);
                            trackStat.report(trackFile);
                            sbT.Flush();

                            asyncFw.post(@"..\Logs\tracks.txt", sbT.ToString());
                            //}
                            chrono.bip("desc tracks");
                            Logger.LogConsole = false; 
                            loader.loadLists();
                            Logger.LogConsole = true; 
                            chrono.bip("load list"); 

                        }

                        DirConf root = null;
                        while (true)
                        {

                            chrono.end();
                            logChrono.log(chrono.display(3, "{0}:{1:#}"));
                            chrono.reset("Program"); 

                            xelt = Conf.Instance.load(false);
                            loader.Conf = new it.Conf(xelt);
                            PlayList.StartOpe();
                            loader.Aborted = false;

                            Logger.CreateNullLoggers = !Conf.LogGen;


                            BackGroundTaskMgr.Conf = Conf.Ordo;
                            var list2 = new List<TrackInfoItunes>(list.Count); 
                            foreach (TrackInfoItunes track in list)
                            {
                                var copy = TrackInfoItunes.createCopy(track);
                                list2.Add(copy); 
                                //track.clearLists(); // = selectMode.none;
                            }
                            chrono.bip("track.clearLists");
                            // Feeds.createInstance();
                            root = Conf.DirConf;
                            var feeds = root.Feeds; 
                           

                            var fAuto = loader.TreePlayList.getComposite(Conf.RootIt);
                            if (Conf.GenFeed)
                            {
                                var fFeeds = fAuto.getComposite("Feed");

                                if (fFeeds != null)
                                {
                                    scanFeedsForRecordEmptyLists(feeds, fFeeds);
                                }
                            }

                            foreach (TrackInfoItunes track in list2)
                            {
                                feeds.check(track);
                            }
                            chrono.bip("feeds"); 

                            //if (Conf.Single)
                            //{
                            //    var listS = new List<TrackInfoItunes>();
                            //    for (int i = 0; i < Limits.NB; i++)
                            //    {
                            //        var list0 = feeds.getTracks(i, int.MaxValue, int.MaxValue, null, null, 1, null); //feeds.ListTrackSingle;
                            //        foreach (var t in list0)
                            //        {
                            //            if (!listS.Contains(t))
                            //                listS.Add(t);
                            //        }

                            //    }

                            //    string[] folder = new string[] { "Select", "tmp" };
                            //    buildList("_auto", listS, 0, folder);
                            //}

                            //var sb = DescBuilder.create();

                            //Création des listes
                            //  oldRoot = root;
                            
                            Exporter.TopRecord();
                            //***************** Lancement "pour de vrai" ***************************************
                            LimitItemLoader.ModeSelection = true; 
                            AutoBuilder.init(true);
                            loadCandidat(root);
                            // standAlone(root); 
                            phase2(root);
                            Selection(root);
                            //**********************************************************************************
                            //***************** Lancement "pour de faux" ***************************************
                            LimitItemLoader.ModeSelection = false;
                            phase2(root);
                            Selection(root);
                            LimitItemLoader.ModeSelection = true;
                            //**********************************************************************************
                            Exporter.TopCopy();
                            chrono.bip("selection"); 
                            foreach (TrackInfoItunes s in feeds.getSelectedTracks())
                            {
                                var items = s.Providers;
                                int count = items.Count;
                                foreach (LimitItem item in items)
                                {
                                    item.recordTrackMoy(s, count);
                                    if (count == 1)
                                        s.Exclu = item;
                                }
                            }
                            chrono.bip("selection exclu"); 


                            //****************************************
                            // lancement des sorties xml et html en asynchrone
                            postReport(root); 
                            //****************************************
                           
                           

                            //mem0.load();
                            //var listSe = feeds.getSelectedTracks(); 
                            //if (mem0.FileExists)
                            //{
                            //    foreach (TrackInfoItunes s in listSe)
                            //    {
                            //        var key = s.Location;
                            //        if (!mem0.dict.ContainsKey(key))
                            //            log.log("delta virtuel ajouté {0} ==> {1}", s, s.GetProvider());
                            //    }

                            //    foreach (string key in mem0.dict.Keys)
                            //    {
                            //        if (!feeds.existSelected(key))
                            //            log.log("delta virtuel supprimé {0}",mem0.dict[key]);
                            //    }
                            //}
                            //mem0.save(listSe); 

                          //  AutoBuilder.Log();
                            AutoBuilder.init(false);
                            bool cangoAuto = AutoBuilder.Check(feeds);
                            chrono.bip("AutoBuilder"); 
                            AutoBuilder.Log();
                            if (!cangoAuto && Conf.AutoBlock)
                            {
                                logAuto.log("arret par auto");
                                //Thread.Sleep(1000);
                                continue;
                            }
                            else
                            {
                                string newEmpreinte = Conf.DirConf.getEmpreinte();
                                if (newEmpreinte == _empreinte && !AutoBuilder.Stable)
                                {
                                    logAuto.log("arret par empreinte");
                                    continue;
                                }

                                _empreinte = newEmpreinte;

                                Logger.LogAll("****************************************************************************************");
                                Logger.LogAll("arret");
                                Logger.LogAll("****************************************************************************************");



                                // BackGroundTaskMgr.End();

                                Logger.Pre = "";

                                //   log.log(sb.ToString());
                                var sb2 = DescBuilder.create();

                                if (Conf.Simulation)
                                {
                                    Logger.LogAll("****************************************************************************************");
                                    Logger.LogAll("TEST");
                                    Logger.LogAll("****************************************************************************************");
                                }

                                var feedsRapport = new StringBuilder();
                                feeds.rapport(feedsRapport);
                                Logger.LogConsole = false; 
                                log.log(feedsRapport.ToString());
                                Logger.LogConsole = true; 
                                var tw = new StringBuilder();
                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\history.txt")))
                                //{
                                feeds.rapportSelected(tw);
                                asyncFw.post(@"..\Logs\history.txt", tw.ToString());
                                // }

                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\historyPre.txt")))
                                //{
                                tw = new StringBuilder();
                                feeds.rapportPreSelected(tw);
                                asyncFw.post(@"..\Logs\historyPre.txt", tw.ToString());
                                //}

                                // rapport détaillé
                                LimitItem.includeDetail = true;
                                Conf.DirConf.rapport(sb2);
                                Logger.LogConsole = false; 
                                log.log(sb2.ToString());
                                Logger.LogConsole = true; 


                                // rapport plus concis
                                var sb3 = DescBuilder.create();
                                LimitItem.includeDetail = false;
                                Conf.DirConf.rapport(sb3);
                                Logger.LogConsole = false; 
                                log.log(sb3.ToString());
                                Logger.LogConsole = true; 
                                chrono.bip("rapport"); 
                                break;
                            }
                        }

                        //mem1.load();

                        //if (mem1.FileExists)
                        //{
                        //    foreach (TrackInfoItunes s in listSe)
                        //    {
                        //        var key = s.Location;
                        //        if (!mem1.dict.ContainsKey(key))
                        //            log.log("delta reel ajouté {0} ==> {1}", s, s.GetProvider());
                        //    }

                        //    foreach (string key in mem1.dict.Keys)
                        //    {
                        //        if (!feeds.existSelected(key))
                        //            log.log("delta reel supprimé {0}", mem1.dict[key]);
                        //    }
                        //}
                        //mem1.save(listSe); 


                        Logger.CreateNullLoggers = false;
                        WritePlayList(root);

                       


                        // Sélection du dernier podcast de chaque album
                        if (!Conf.Single)
                        {
                            var feeds = root.Feeds;
                            int prior = 2;
                            var listP = Conf.SelectParams;

                            var listS = new List<TrackInfoItunes>();
                            string[] folder = null;
                            foreach (SelectParam p in listP)
                            {
                                if (p.etendue.Contains("s"))
                                {
                                    listS = new List<TrackInfoItunes>();
                                    folder = new string[] { "select", "tmp", p.name };
                                    feeds.getFirstSelectedTracks(listS, p);
                                    buildList("_select", listS, prior, folder);
                                }
                            }

                            for (int level = 0; level < Limits.NB; level++)
                            {
                                foreach (SelectParam p in listP)
                                {
                                    if (p.etendue.Contains(level.ToString()))
                                    {
                                        p.level = level;
                                        folder = new string[] { "select", "tmp", p.name };
                                        listS = new List<TrackInfoItunes>();
                                        feeds.buildFirstSelectedTrackLevel(listS, p);  //true, true, false, false);
                                        buildList("_" + level, listS, prior, folder);
                                    }
                                }
                            }

                        }

                        var journal = Conf.Journal;
                        if (journal != null)
                        {
                            var feeds = root.Feeds;
                            for (int j = 1; j <= Journal.NB_JOUR_MAX; j++)
                            {
                                List<TrackInfoItunes> listJ = null;
                                if (journal.NbJour >= j)
                                {
                                    listJ = feeds.buildJournal(journal);
                                }
                                else
                                    listJ = new List<TrackInfoItunes>();

                                var name = j.ToString();
                                if (j < 10)
                                    name = "0" + name;
                                buildList(name, listJ, 3, "journal");

                            }
                        }

                        if (Conf.GenFeed)
                        {
                            var feeds = root.Feeds;
                            var prior = Conf.GenFeedPrior;
                            foreach (Feed feed in feeds.List)
                            {
                                var list0 = feed.getSelectedTracks;
                                buildList(feed.Name, list0, prior, "Feed");
                            }
                        }

                        string zique = Conf.Move.Zique;



                        BackGroundTaskMgr trackMgr = BackGroundTaskMgr.getMgr("Track", 12);
                        var trackList = BackGroundTaskMgr.getMgr("TrackList", 0);


                        int ii = 0;
                        while (!BackGroundTaskMgr.ConfirmEnd(20000, 10))
                        {
                            ii++;
                            if (ii == 60)
                                ii = 0;
                            if (ii == 0)
                            {
                                ITextWriter sb = new StringBuilder();

                                log.log("Attente Classement " + sb.ToString());
                            }
                            Thread.Sleep(100);
                        }

                        // BackGroundTaskMgr.End();


                        misc.Pre = "[ OK " + step + "] ";
                        Logger.LogAll("*****************************************************************************************************");
                        Logger.LogAll("Pile Classement finie, attente nouvelle version");
                        Logger.LogAll("*****************************************************************************************************");



                        Logger.LogAll("****************************************************************************************");
                        Logger.LogAll("arret 2");
                        Logger.LogAll("****************************************************************************************");

                        DateTime limit = DateTime.Now.AddDays(-Conf.Move.Delta);

                        if (!string.IsNullOrEmpty(zique))
                        {
                            foreach (TrackInfoItunes track in list)
                            {
                                track.move(ziqueOrg, zique, limit);
                            }
                            return;
                        }
                        if (!Conf.Simulation)
                        {

                            Logger.Pre = "[ OK " + step + "] ";
                            Logger.LogAll("*****************************************************************************************************");
                            Logger.LogAll("attente nouvelle version");
                            Logger.LogAll("*****************************************************************************************************");
                        }
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                        Thread.Sleep(1000);
                    }


                }
                while (true);




#endif

                //while (!BackGroundTaskMgr.Finished)
                //    Thread.Sleep(30);
                //log.log("****************************************************************************************");
                //loader.SynchronizePodcast(); 
                //log.log("fin");
                //log.log("****************************************************************************************");
            }

            catch (Exception ex)
            {
                log.log(ex.ToString());
            }


        }

        #region report asynchrone

        private DirConf _attenteWriteHtml; 
        private volatile object _lockReportHtml = new object();
        private bool _end;
        ThreadUtil thReport ;

        private void postReport(DirConf dir)
        {
            if (thReport == null)
            {
                lock (_lockReportHtml)
                {
                    if (thReport == null)
                    {
                        thReport = new ThreadUtil(loopReportHtml, "ReportHtml");
                        thReport.Start(); 
                    }
                }
            }

            lock (_lockReportHtml)
                _attenteWriteHtml = dir; 
        }

        private void loopReportHtml()
        {
            DirConf traite = null; 
            while (!_end)
            {
                Thread.Sleep(30);
                if (_attenteWriteHtml == null)
                    continue;
                lock (_lockReportHtml)
                {
                    if (_attenteWriteHtml == null)
                        continue;
                    traite = _attenteWriteHtml;
                    _attenteWriteHtml = null; 
                }
                reportHtml(traite); 
            }
        }


        private void reportHtml(DirConf root)
        {
            try
            {

                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = System.Text.Encoding.UTF8;
                var _sb = new System.Text.StringBuilder();
                using (writer = XmlWriter.Create(_sb, settings))
                {
                    LimitsLoader.Writer = new WriterXml(writer);
                    DoubleStat.ModeHtml = false;
                    writer.WriteStartElement("tracks");
                    WriteTracks(root);
                    writer.WriteEndDocument();
                    writer.Flush();
                }

                asyncFw.post(@"..\tracks.xml", _sb.ToString());
             //   chrono.bip("xml");

                string html = @"..\tracks.html";
                //if (File.Exists(html))
                //    File.Delete(html);
                var sbHtml = new StringBuilder();
                //using (pdb.util.TextWriter sbHtml = new pdb.util.TextWriter(new StreamWriter(File.OpenWrite(html), System.Text.Encoding.UTF8)))
                //{
                LimitsLoader.Writer = new WriterHtml(sbHtml);
                DoubleStat.ModeHtml = true;
                sbHtml.Append(@"<!DOCTYPE html>
<html>
<head>
	<title>"
+ Environment.CurrentDirectory + @"</title>
	
	<style type='text/css'>
		body{
			margin:10px 30px;
			font-family:verdana;
			font-size:12px;
		}
		h1{
			font-family:verdana;
			font-size:14px;
			font-weight:bold;
			text-decoration:underline;
		}
        .low {
			color: rgb(0,125,255);
		}

        .med {
			font-weight:bold;
			color: rgb(0,140,0);
		}

        .high {
			font-weight:bold;
			font-size:14px;
			color: rgb(240,155,0);
		}
        
		.big {
			font-weight:bold;
			font-size:14px;
			text-decoration:underline;
			color: rgb(255,32,0);
		}

        .album {
			color: rgb(0,125,255);
		}
        .track {
            font-weight:bold;
			color: rgb(0,40,80);
		}
		div.tree div {
			padding-left:16px;
		}
		div.tree div.parent div {
			 display:none;
			 cursor:default;
		}
		div.tree div.parent {
			 cursor:pointer !important;
			 background:transparent url(plus.gif) no-repeat top left;
		}
		div.tree div.expanded {
			background:transparent url(moins.gif) no-repeat top left;
		}
	</style>
	<link rel='stylesheet' type='text/css' href='treeview.css' media='screen' /> 
	<script type='text/javascript' src='jquery.js'></script>
	<script type='text/javascript'>
	$(function() {
		$('div.tree div:has(div)').addClass('parent');
		$('div.tree div').click(function() {
			var o = $(this);
			o.children('div').toggle();
			o.filter('.parent').toggleClass('expanded');
			return false;
		});
	});
	</script>
</head>
<body>");
                WriteTracks(root);
                sbHtml.Append(@"</body>
</html>");

                sbHtml.Flush();

                //}
                asyncFw.post(html, sbHtml.ToString());
              //  chrono.bip("html");
            }
            catch (Exception ex)
            {
                log.log(ex.ToString()); 
            }
        }

        #endregion


        public static void buildList(string name, List<TrackInfoItunes> list_, List<string> folders)
        {
            buildList(name, list_, int.MaxValue, folders);
        }

        public static void buildListPrior(string name, List<TrackInfoItunes> list_, List<string> folders, int prior)
        {
            buildList(name, list_, prior, folders);
        }


        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, params string[] folders)
        {
            var lfolders = new List<string>(folders);
            buildList(name, list_, prior, lfolders);
        }

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, List<string> folders)
        {
            if (Conf.Simulation)
                return;
            //   log.log("build list {0}",name);
            var list = new List<IFile>(list_);
            var folder = loader.TreePlayList.getComposite(Conf.RootIt);
            folders = new List<string>(folders);

            var nname = name;
            if (name.Contains(Path.DirectorySeparatorChar.ToString()))
            {
                var tab = name.Split(Path.DirectorySeparatorChar);
                string str = null;
                for (int i = 0; i < tab.GetLength(0); i++)
                {
                    if (str != null)
                        folders.Add(str);
                    if (!string.IsNullOrEmpty(tab[i]))
                        str = tab[i];
                }
                if (!string.IsNullOrEmpty(str))
                    nname = str;
            }

            for (int i = 0; i < folders.Count; i++)
            {
                var aux = folder;
                folder = folder.getComposite(folders[i]);
                if (folder == null)
                    folder = loader.getOrCreateFolder(aux, folders[i], list.Count > 0);
                if (folder == null)
                    return;
            }

            //  var folder = loader.root.getComposite("auto").getComposite("PODUtil"); 
            var playlist = loader.getPlayList(folder, nname, list.Count > 0);
            if (playlist != null)
            {
                if (prior < int.MaxValue && prior >= 0)
                    playlist.setPrior(prior);
                //if (list.Count > 0)
                loader.mergeList(playlist, list, false, _instance, null);
                //else
                //    loader.removeList(folder, name);
            }



            //log.log("clear list {0}", name); 
            //loader.ClearList(playlist);
            //log.log("add items {0}", name); 
            //foreach (TrackInfoItunes track in list)
            //    loader.addItemToList(playlist, track); 


        }



        delegate void actionList(DirConf dir);
        private void recursif(DirConf dir, action pre, action post)
        {
            var fLoader = dir.Loader;
            //if (pre > action.none && pre < action.writeTracksPre)
            //    log.log("{0} {1}", pre, dir.getPath());
            fLoader.Action(pre);

            //Construction récursive sur l'arbre
            foreach (DirConf child in dir)
            {
                // DescBuilder sub = sb.createChild(child.getPath());
                recursif(child, pre, post);
            }
            //if (post > action.none && post < action.writeTracksPre)
            //    log.log("{0} {1}", post, dir.getPath());
            fLoader.Action(post);


        }

        private void loadCandidat(DirConf dir)
        {
            recursif(dir, action.loadCandidat, action.none);
        }


        //private void standAlone(DirConf dir)
        //{
        //    recursif(dir, action.standAlone, action.none); 
        //}

        private void phase2(DirConf dir)
        {
            recursif(dir, action.none, action.phase2);
        }



        /// <summary>
        /// Constitution d'un répertoire
        /// </summary>
        /// <param name="dir"></param>
        /// <param name="sb"></param>
        private void Selection(DirConf dir)
        {
            recursif(dir, action.selectionPre, action.selectionPost);

            // ne sert pas
            //dir.TransmissionListToParent();

        }

        private void WritePlayList(DirConf dir)
        {
            recursif(dir, action.writeLists, action.none);
        }

        private void WriteTracks(DirConf dir)
        {
            recursif(dir, action.writeTracksPre, action.writeTracksPost);
        }
#if build
        public void scanFiles(List<TrackInfoItunes> list, DirectoryInfo dir, ref int nbIntegre, ref int nbSuppr)
        {
            string album = dir.Name;
            var files = dir.GetFiles();
            if (files.GetLength(0) > 0)
            {
                foreach (FileInfo file in dir.GetFiles())
                {
                    string location = file.FullName.ToLower();
                    var trackByLocation = list.Find(t => t.Location != null && t.Location.ToLower().Equals(location));

                    if (trackByLocation != null)
                        continue;
                    var filePub = new FilePub(file.FullName);
                    new PubLoader(filePub).setPub();

                    TrackInfoItunes track = null;

                    foreach (TrackInfoItunes t in list)
                    {
                        if (album.Equals(t.Album))
                        {
                            if (filePub.Pub.Date == t.Pub.Date)
                            {
                                track = t;
                                break;
                            }
                        }
                    }
                    //  var track = list.Find(t => album.Equals(t) && filePub.Pub.Date.Equals(t.Pub.Date));
                    if (track == null)
                    {
                       
                        log.log("création Track à partir de " + file.FullName);
                        track = loader.createTrack(file.FullName) as TrackInfoItunes;

                        if (track == null)
                            continue;

                        // verif pub; 
                        TrackInfoItunes track2Verif = null;

                        if (track.Pub > TrackInfoItunes.MIN)
                        {
                            foreach (TrackInfoItunes t in list)
                            {
                                if (album.Equals(t.Album))
                                {
                                    if (track.Pub.Date == t.Pub.Date)
                                    {
                                        track2Verif = t;
                                        break;
                                    }
                                }
                            }
                        }

                        if (track2Verif != null)
                        {
                            log.log("Track créé {0} {1} {2} {3} MAIS doublon avec  {4} {5} {7} {8} {9} intégrés {10} supprimés", track.Name, track.Album, track.Pub, track.Location, 
                                track2Verif.Name, track2Verif.Album, track2Verif.Pub, track2Verif.Location, nbIntegre, nbSuppr);
                            track2Verif.Delete();
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                            nbSuppr++;
                            continue; 

                        }
                        log.log("Track créé {0} {1} {2} {3} {4} intégrés {5} supprimés", track.Name, track.Album, track.Pub, track.Location,nbIntegre,nbSuppr );
                        nbIntegre++;
                        list.Add(track);
                    }
                    else
                    {
                        if (track.Pub.DayOfYear > 1)
                        {
                            nbSuppr++;
                            log.log("suppression du track sur {0} en doublon avec {1} {2} {3} {4} {5} int�gr�s {6} supprim�s", file.FullName, track.Name, track.Album, track.Pub, track.Location, nbIntegre, nbSuppr);
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                        }
                    }

                }
                log.log("fin scan {0}: {1} intégrés, {2} supprimmés", album, nbIntegre, nbSuppr);
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                scanFiles(list, subDir, ref nbIntegre, ref nbSuppr);
            }
        }
#endif

#if menage

        private void listFiles(Dict<string, FileInfo> dict, DirectoryInfo dir)
        {
           
            foreach (FileInfo file in dir.GetFiles())
            {
                dict[file.FullName] = file;
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                listFiles(dict, subDir);
            }
        }
#endif

        /// <summary>
        /// A checkquer
        /// </summary>
        /// <param name="feeds"></param>
        /// <param name="current"></param>
        private void scanFeedsForRecordEmptyLists(Feeds feeds, PlayListComposite current)
        {
            foreach (PlComponent pl in current)
            {
                var plC = pl as PlayListComposite;
                if (plC == null)
                {
                    // log.log("{0} {1} pas un PlayListComposite", pl, pl.GetType());
                    continue;
                }

                if (plC.LeafsCount > 0)
                {
                    string album = plC.Name;
                    feeds.check(album);
                }

                scanFeedsForRecordEmptyLists(feeds, plC);

            }
        }




        #region IAbortTask Members

        public bool Aborted
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        #endregion


        private class Vendee
        {
            //  "Emission du 02/11/2008"
            private static Regex regex1 = new Regex(@".*(\d\d\/\d\d\/\d\d\d\d).*");
            private static Regex regex2 = new Regex(@".*(\d\d\/\d\d\/\d\d).*");
            private static Regex regex3 = new Regex(@".*(\d\d\/\d\d).*");
            private enum vendeeType
            {
                none,
                vacation,
                hebdo,
                chronique,
                ponton

            }
            public void go(ArrayList list)
            {
                var listV = new ArrayList();
                string VENDEE = "vendee ";
                foreach (IITFileOrCDTrack t in list)
                {
                    if (t.Album.Contains("Vendée Globe") || t.Album.Contains(VENDEE))
                        listV.Add(t);
                }

                // listTrack.FindAll(t => t.Album.Contains("Vendee Globe"));



                foreach (IITFileOrCDTrack track in listV)
                {
                    string name = track.Name.ToLower();
                    vendeeType _type = vendeeType.none;
                    foreach (vendeeType type in Enum.GetValues(typeof(vendeeType)))
                    {
                        if (name.Contains(type.ToString()))
                        {
                            track.Album = VENDEE + type.ToString();
                            _type = type;
                            break;
                        }
                    }

                    DateTime? dt = null;
                    dt = getDate(track.Name);

                    if (!dt.HasValue)
                        dt = getDate(track.Description);

                    if (!dt.HasValue)
                        dt = getDate(track.LongDescription);

                    if (dt.HasValue)
                    {
                        string _comment = dt.Value.ToString("yyyy/MM/dd");
                        string plus = "";
                        switch (_type)
                        {
                            case vendeeType.none:
                                break;
                            case vendeeType.vacation:
                            case vendeeType.ponton: plus = " 11:00"; break;
                            case vendeeType.hebdo: plus = " 14:00"; break;
                            case vendeeType.chronique: plus = " 12:00"; break;

                        }
                        track.Comment = _comment + plus;
                        track.Year = dt.Value.Year;
                    }



                }
            }

            private DateTime? getDate(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return null;
                string[] words = input.Split(' '); int count = words.GetLength(0);

                DateTime? ret = null;
                StringBuilder sb = null;
                int word = 0;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                        word++;

                        try
                        {
                            ret = Convert.ToDateTime(sb.ToString());
                        }
                        catch
                        {
                        }

                        if (ret.HasValue)
                        {
                            int month = ret.Value.Month;
                            int year = 2008;
                            if (month < 6)
                                year = 2009;
                            return new DateTime(year, month, ret.Value.Day);
                        }
                    }
                }
                try
                {
                    DateTime dt = Convert.ToDateTime(sb.ToString());
                    if (dt.Year < 2008 || dt.Year > 2009)
                        dt = new DateTime(2008, dt.Month, dt.Day);
                    return dt;
                }
                catch
                {
                    return null;
                }
                //if (regex1.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //else if (regex2.IsMatch(_input))
                //    return Convert.ToDateTime(regex2.Match(_input).Groups[1].Value); 
                //else if (regex3.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //return null; 
            }

            private string getDateString(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return "";
                string[] words = input.Split(' '); int count = words.GetLength(0);


                StringBuilder sb = null;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                    }
                }

                if (sb == null)
                    return input;

                return sb.ToString().Replace(".", "");
            }


        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using iTunesLib;
using pdb.ordo;
using pdb.podcast.Build;
using pdb.util;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util.list;

namespace pdb.podcast
{
    public enum selectMode
    {
        none = 0,
        standAlone = 1,
        simple = 2,
        serial = 3,
        histo = 4
    }

    public class TrackInfoItunes : pdb.it.TrackInfoItunes, IPub
    {
        private int albumRating;

        private static volatile object _lock = new object();
        private static int volumeMin = int.MinValue;
        public static int VolumeMin { set { volumeMin = value; } }

        private static BackGroundTaskMgr bgMove;  //new BackGroundTaskMgr("Move"); 

        private SequentialDictString<LimitItem> listSelected = new SequentialDictString<LimitItem>();
        //public List<LimitItem> Providers { get { return listSelected; } }

        private SequentialDictString<LimitItem> listLoad0 = new SequentialDictString<LimitItem>();
        private SequentialDictString<LimitItem> listStandAlone = new SequentialDictString<LimitItem>();
        // public List<LimitItem> Providers0 { get { return listLoad0; } }

        //private List<LimitItem> listLoadRecursif = new List<LimitItem>();
        //public List<LimitItem> ProvidersRecursif { get { return listLoadRecursif; } }

        //private List<LimitItem> listLoadGuest = new List<LimitItem>();
        //public List<LimitItem> ProvidersGuest { get { return listLoadGuest; } }



        /// <summary>
        /// Seule limite contenant le track
        /// </summary>
        private LimitItem exclu;
        public LimitItem Exclu { get { return exclu; } set { exclu = value; } }

        public void addPhase1(LimitItem item)
        {
            var key = item.ID;
            if (!listLoad0.ContainsKey(key))
                listLoad0.Add(key, item);
        }
        public bool containsload(LimitItem item)
        {
            var key = item.ID;
            return listLoad0.ContainsKey(key);
        }

        //public bool containsStandAlone(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listStandAlone.ContainsKey(key);
        //}

        public bool containsSelect(LimitItem item)
        {
            var key = item.ID;
            return listSelected.ContainsKey(key);
        }
        public bool isPreselected { get { return listLoad0.Count > 0; } }
        public ICollection<LimitItem> Providers1 { get { return listStandAlone.Values; } }
        public ICollection<LimitItem> Providers { get { return listSelected.Values; } }
        public LimitItem Provider
        {
            get
            {
                if (listSelected.Count == 0)
                    return null;
                return listSelected.List[0];
            }
        }
        public string GetProvider()
        {
            var provider = Provider; 
            if (provider == null)
                return "";
            return provider.ToString();
        }

        public void addRecursif(LimitItem item)
        {
            //if (!listLoadRecursif.Contains(item))
            //    listLoadRecursif.Add(item);
        }

        public void addGuest(LimitItem item)
        {
            //if (!listLoadGuest.Contains(item))
            //    listLoadGuest.Add(item);
        }

        public static TrackInfoItunes createCopy(TrackInfoItunes org)
        {
            var copy = org.MemberwiseClone() as TrackInfoItunes;
            copy.clearLists();
            return copy; 
        }

        const string REFONTE = "v1";
        public override void build(IITFileOrCDTrack track)
        {
            base.build(track);

            if (Strange)
                return;

#if MOVE
            var loc = track.Location;
            FileInfo file = new FileInfo(loc);
            if (loc.StartsWith("Y:"))
                return;
            string dest = "Y" + loc.Substring(1);


            try
            {
                misc.log("deplacer " + loc);
                string newDest = file.moveTree(dest, false);
                misc.log("-------> " + newDest);
                track.Location = newDest;
                //try
                //{
                //    File.Delete(loc);
                //}

                //catch (Exception del)
                //{

                //    misc.log(del.ToString());
                //}

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
#else

            if (!isPodcast)
                return;

            duree = new util.timeSpan(Duration);

            if (track.PlayedCount > 0)
            {
                played = markAsPlayed(Rating, PlayedDate);
            }

            var loc = track.Location;
            //if (loc.ToUpper().Contains("FABRIQUE"))
            //{
            //    int toto = 0; 
            //}
            bool target = true;
            var cuDtFileFormat = new DateTimeFormatInfo();
            cuDtFileFormat.FullDateTimePattern = "yyyy.MM.dd_HH.mm";
            string[] tab = loc.Split('_');
            var count = tab.GetLength(0);
            if (count >= 2)
            {
                var part = tab[0] + "_" + tab[1];
                DateTime dtFile;
                bool fileIsDate = DateTime.TryParse(part, cuDtFileFormat, DateTimeStyles.None, out dtFile);
                target = !fileIsDate;
            }


            //bool target = loc.ToUpper().Contains(@"D:\ZIQUE\PODCASTS\LA FABRIQUE DE L") && loc.ToUpper().Contains("HISTOIRE");

            try
            {

                pub = track.ReleaseDate;

                var cuDtFormat = new DateTimeFormatInfo();
                cuDtFormat.FullDateTimePattern = "yyyy/MM/dd";

                var cuDtFormat2 = new DateTimeFormatInfo();
                cuDtFormat2.FullDateTimePattern = "yyyy/MM/dd HH:mm";

                if (pub > MIN)
                {
                    string commentByReleaseDate = pub.ToString(cuDtFormat2.FullDateTimePattern);
                    if (Comment != commentByReleaseDate)
                    {
                        misc.log("chgt Comment � partir de releaseDate {0} de {1} vers {2} {3}", pub, Comment, commentByReleaseDate, this);
                        Comment = commentByReleaseDate;
                    }

                    return;
                }

                // ici pas de release Date

                string comment = track.Comment;

                try
                {
                    string partDate = comment.Split(' ')[0];
                    DateTime dtComment = DateTime.MinValue;

                    bool dtCommentBuild = false;

                    dtCommentBuild = DateTime.TryParse(partDate, cuDtFormat, DateTimeStyles.None, out dtComment);

                    bool dtCommentBuild2 = false;
                    if (dtCommentBuild)
                        dtCommentBuild2 = DateTime.TryParse(comment, cuDtFormat2, DateTimeStyles.None, out dtComment);


                    //if (dtComment.DayOfYear > 1)
                    //    return;

                    Regex reg = new Regex(@"(\d{2}.\d{2}.\d{4})");
                    string description = track.Description;

                    if (string.IsNullOrEmpty(description))
                        description = "";

                    DateTime dtDesc = DateTime.MinValue;
                    if (reg.IsMatch(description))
                    {
                        string strDescriptionDate = reg.Match(description).Groups[1].Value;

                        dtDesc = Convert.ToDateTime(strDescriptionDate);
                    }

                    if (dtDesc > DateTime.MinValue)
                    {
                        string newComment = dtDesc.ToString(cuDtFormat2.FullDateTimePattern);
                        if (newComment != track.Comment)
                        {
                            if (dtCommentBuild2 && dtComment.Minute != 0)
                                return;
                            misc.log("chgt Comment � partir de description {0} de {1} vers {2} {3}", description, comment, newComment, this);
                            track.Comment = newComment;
                        }
                    }
                    else if (dtCommentBuild2)
                    {

                    }






                }
                catch (Exception ex)
                {
                    misc.logError("impossible de g�rer " + this, ex);
                }
            }
            finally
            {

                if (target)
                {

                    FileInfo file = new FileInfo(loc);
                    DirectoryInfo dirTrack = file.Directory;
                    DirectoryInfo dirPodcast = dirTrack.Parent;
                    if (!dirPodcast.Name.Equals(REFONTE))
                    {
                        DirectoryInfo dirV1 = new DirectoryInfo(dirPodcast.FullName + Path.DirectorySeparatorChar + REFONTE);
                        if (!dirV1.Exists)
                            dirV1.Create();

                        string dest = dirV1.FullName + Path.DirectorySeparatorChar + dirTrack.Name + Path.DirectorySeparatorChar + file.Name;  // loc.Replace(@"D:\", @"E:\");

                        string dirDest = Path.GetDirectoryName(dest);
                        string fileName = Path.GetFileName(dest);
                        fileName = pub.ToString("yyyy.MM.dd_HH.mm") + "_" + fileName;

                        dest = dirDest + Path.DirectorySeparatorChar + fileName;
                        try
                        {
                            misc.log("deplacer " + loc);
                            string newDest = file.copyTree(dest, null);
                            misc.log("-------> " + newDest);
                            track.Location = newDest;
                            try
                            {
                                File.Delete(loc);
                            }

                            catch (Exception del)
                            {

                                misc.log(del.ToString());
                            }

                        }
                        catch (Exception ex)
                        {
                            misc.log(ex.ToString());
                        }
                    }
                }

            }
#endif

        }


        private static IDictionary<int, DateTime> maxPlayed = new Dictionary<int, DateTime>();
        public static IDictionary<int, DateTime> MaxPlayed { set { maxPlayed = value; } }
        public static bool markAsPlayed(int rating, DateTime date)
        {
            if (maxPlayed.ContainsKey(rating))
                return date > maxPlayed[rating];
            return true;
        }
        public override void build(XmlNode xTrack)
        {
            base.build(xTrack);
            //if (Name.Contains("Aubenas"))
            //{
            //    int toto = 0;
            //}
            if (!isPodcast)
                return;
            if (Strange)
                return;
            string key = "";

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    continue;
                }

                if (string.IsNullOrEmpty(value))
                    continue;
                switch (key)
                {
                    case "Date Added": added = Convert.ToDateTime(value); break;
                    case "Release Date": pub = Convert.ToDateTime(value); break;
                    case "Play Count": int playCount = Convert.ToInt32(value);
                        if (playCount > 0)
                            played = markAsPlayed(Rating, PlayedDate);
                        break;
                    case "Album Rating": albumRating = Convert.ToInt32(value); break;
                }

            }

            //for (int i = 0; i < xTrack.ChildNodes.Count; i += 2)
            //{
            //    XmlNode xKey = xTrack.ChildNodes[i];
            //    string value = xTrack.ChildNodes[i + 1].InnerText;
            //    string key = xKey.InnerText;

            //    if (string.IsNullOrEmpty(value))
            //        continue;
            //    switch (xKey.InnerText)
            //    {
            //        case "Date Added": added = Convert.ToDateTime(value); break;
            //        case "Release Date": pub = Convert.ToDateTime(value); break;
            //        case "Play Count": int playCount = Convert.ToInt32(value); if (playCount > 0) played = true; break;
            //        case "Album Rating": albumRating = Convert.ToInt32(value); break;


            //    }
            //}


            new PubLoader(this).setPub();

            #region move vers pubLoader
            //
            //string _comment = Comment;
            //DateTime dateComment = DateTime.MinValue;

            //try
            //{
            //    dateComment = Convert.ToDateTime(_comment);
            //}
            //catch
            //{
            //}

            //if ((pub < MIN || pub.DayOfYear == 1)  && (dateComment > MIN && dateComment.DayOfYear > 1))
            //{
            //    pub = dateComment; 
            //}
            //string name = Name;
            //checkDate1(name);
            //checkDate2(name);
            //checkDate3(name);

            //bool pubYear = false;

            //if (!string.IsNullOrEmpty(Location))
            //{
            //    string fileName = Path.GetFileName(Location);
            //    checkDate1(fileName);
            //    checkDate2(fileName);
            //    checkDate3(fileName);
            //}

            //if (pub <= MIN)
            //{
            //    if (Year > 1970)
            //    {
            //        DateTime dtYear = new DateTime(Year, 1, 1);
            //        pub = dtYear;
            //        pubYear = true;
            //    }
            //}



            //if (added < MIN) added = MIN;

            //// DateTime dt_ = pub;
            //if (pub <= MIN)
            //    pub = added;
            //string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
            //if (pubYear)
            //    comment = getFileNameCmp(comment);
            //if (this.Comment != comment)
            //{
            //    try
            //    {
            //        string commentFound = this.Comment;
            //        string truc = commentFound;
            //        if (truc.Contains("_")) 
            //        {
            //            //d�j� fait
            //            return; 
            //        }
            //          //  truc = truc.Split('_')[0];

            //        DateTime iComment = Convert.ToDateTime(truc);
            //        if (iComment.DayOfYear != 1 && pub.DayOfYear == 1)
            //        {
            //            pub = iComment;
            //        }
            //        else
            //        {

            //            this.Comment = comment;
            //        }
            //    }
            //    catch
            //    {
            //        this.Comment = comment;
            //    }
            //}


            //

            #endregion




            duree = new util.timeSpan(Duration);
        }



        public static DateTime MIN = new DateTime(1970, 1, 1);
        #region move verspubLoader

        //
        //private static Regex regex1 = new Regex(@".*(\d\d\.\d\d\.\d\d\d\d).*");
        //private static Regex regex2 = new Regex(@".*(\d\d\d\d)(\d\d)(\d\d).*");
        //private static Regex regex3 = new Regex(@".*(\d\d)\.(\d\d)\.(\d\d)_(\d\d)\.(\d\d)_.*");

        //private string getFileNameCmp(string comment)
        //{
        //    string fileName = Path.GetFileNameWithoutExtension(location);

        //    if (fileName.Contains(" "))
        //    {
        //        var tab = fileName.Split(' ');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Contains("_"))
        //    {
        //        var tab = fileName.Split('_');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Length > 3)
        //        return comment;

        //    int nb = 0;
        //    bool isNum = Int32.TryParse(fileName, out nb);

        //    if (!isNum)
        //        return comment;

        //    while (fileName.Length < 3)
        //    {
        //        fileName = "0" + fileName;
        //    }
        //    return comment + "_" + fileName;
        //}
        //private void checkDate1(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex1.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex1.Match(info);
        //            string strDate = m.Groups[1].Value;
        //            DateTime dt = Convert.ToDateTime(strDate);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate2(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex2.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            DateTime dt = new DateTime(year, month, day);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate3(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex3.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            int hh = Convert.ToInt16(m.Groups[4].Value);
        //            int mm = Convert.ToInt16(m.Groups[5].Value);

        //            DateTime dt = new DateTime(year, month, day, hh, mm, 0);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        #endregion

        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{
        //    this.track = track;
        //    this.artist = track.Artist;
        //    this.album = track.Album;
        //    this.name = track.Name;
        //    this.trackNumber = track.TrackNumber;
        //    this.rating = track.Rating;
        //    this.year = track.Year;
        //    this.comment = track.Comment;
        //    this.enabled = track.Enabled;
        //    this._isPodCast = track.Podcast;
        //    this.playedDate = track.PlayedDate;
        //    this.location = track.Location;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.played = track.PlayedCount > 0;
        //    this.pub = track.ReleaseDate;

        //    checkDate1(name);
        //    checkDate2(name);

        //    if (!string.IsNullOrEmpty(location))
        //    {
        //        string fileName = Path.GetFileName(location);
        //        checkDate1(fileName);
        //        checkDate2(fileName);
        //    }

        //    if (pub <= MIN)
        //    {
        //        if (year > 1970)
        //        {
        //            DateTime dtYear = new DateTime(year, 1, 1);
        //            pub = dtYear;
        //        }
        //    }


        //    this.added = track.DateAdded;
        //    if (added < MIN) added = MIN;

        //    // DateTime dt_ = pub;
        //    if (pub <= MIN)
        //        pub = added;
        //    string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
        //    if (track.Comment != comment)
        //        track.Comment = comment;

        //}




        //public int TrackId { get { return track.trackID; } }
        //public int ID { get { return track.TrackDatabaseID; } }

        //public IITFileOrCDTrack Track { get { return track; } }


        #region ITrackNative Membres




        /// <summary>
        /// Date de publication
        /// </summary>
        private DateTime pub;
        public DateTime Pub { get { return pub; } }

        /// <summary>
        /// date d'ajout
        /// </summary>
        private DateTime added;
        public DateTime Added { get { return added; } }

        /// <summary>
        /// Podcast de type info
        /// </summary>
        private bool info;

        public bool Info
        {
            get { return info; }
            set { if (value) info = true; }
        }

        /// <summary>
        /// Podcast rare (moins de trois fois par semaine)
        /// </summary>
        private bool rare;
        public bool Rare
        {
            get { return rare; }
            set { if (value) rare = true; }
        }

        private bool played;
        public bool Played { get { return played; } }

        //private string feed;
        //public string Feed { get { return feed; } set { feed = value; } }

        private selectMode selected;
        private bool inJournal = false;

        public bool FreeInJournal { get { return Selected && !inJournal; } }
        public void markInJournal() { inJournal = true; }
    //    public bool StandAlone { get { return selected > selectMode.none; } }
        public bool Selected { get { return selected >= selectMode.simple; } }
        public bool Histo { get { return selected == selectMode.histo; } }
        public bool Serial { get { return selected == selectMode.serial; } }
       // public selectMode Select { get { return selected; } }


        private void clearLists()
        {
            selected = selectMode.none;
            exclu = null;
            inJournal = false;
            listSelected = new SequentialDictString<LimitItem>();
            listLoad0 = new SequentialDictString<LimitItem>();
            listStandAlone = new SequentialDictString<LimitItem>(); 
            //listLoadGuest.Clear();
            //listLoadRecursif.Clear();

        }

        private static Regex regInfoShort = new Regex(@".+(\d\d\.\d\d\.\d\d)");
        public void select(selectMode value, LimitItem limit)
        {

            var key = limit.ID;

            if (value == selectMode.standAlone)
            {
                if (!listStandAlone.ContainsKey(key))
                    listStandAlone.Add(key, limit);
            }
            else
            {
                if (!listSelected.ContainsKey(key))
                    listSelected.Add(key, limit);
            }


            if (selected == value)
                return;

            if (value > selectMode.standAlone)
            {

                selected = value;
                int volume = Volume;
                if (Album.Contains("RFI"))
                {
                    if (volume != -20)
                        Volume = -20;
                }
                else if (volume < volumeMin)
                    Volume = volumeMin;


                if (pub > MIN)
                {


                    string infoShort = pub.ToString("dd.MM.yy");
                    string infoPubName = pub.ToString("dd.MM.yyyy");
                    string infoPubName2 = pub.ToString("dd/MM/yyyy");
                    string infoPubName3 = pub.ToString("dd/MM/yy");
                    string infoYear = Year.ToString();
                    if (pub.DayOfYear == 1)
                    {
                        infoPubName = pub.Year.ToString();
                        infoPubName2 = infoPubName;
                        infoPubName3 = infoPubName;
                        infoShort = infoPubName;
                    }

                    string name = Name;
                    string str = name;

                    if (regInfoShort.IsMatch(str))
                    {
                        var strdate = regInfoShort.Match(str).Groups[1].Value;
                        str = str.Replace(strdate, "");
                    }






                    if (str.Contains(infoPubName))
                        str = str.Replace(infoPubName, infoShort);
                    else if (name.Contains(infoPubName2))
                        str = str.Replace(infoPubName2, infoShort);

                    else
                    {
                        if (!str.Contains(infoShort))
                        {
                            str = str + " " + infoShort;
                        }
                        else
                        {
                            if (Year > 1980 && str.Contains(infoYear))
                                str = str.Replace(infoYear, "").Trim();
                        }
                    }
                    var strBUG = "30.12.99";
                    if (str.Contains(strBUG))
                        str = str.Replace(strBUG, "");

                    str = str.Replace("  ", " ");
                    str = str.Replace("  ", " ");
                    str = str.Replace("  ", " ").Trim();

                    if (!str.Equals(name))
                        Name = str;
                }

            }

        }


        #endregion

        public override string ToString()
        {
            int level = Rating / 20;
            string strPub = pub > MIN ? pub.ToShortDateString() : "";
            string strYear = Year > 0 ? Year.ToString() : "";
            return level.ToString() + " " + Album + " " + Name + " " + strYear + " " + strPub;
        }

        public void copy(string ziqueDest, string log)
        {
            if (string.IsNullOrEmpty(location))
                return;

            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                string strPub1 = pub.ToString("dd.MM.yyyy");
                string strPub2 = pub.ToString("yy.MM.dd");

                string fileName = Path.GetFileName(location);

                if (pub > MIN && !fileName.StartsWith(strPub1) && !fileName.StartsWith(strPub2))
                    fileName = strPub2 + "_" + fileName;

                string strDir = dir.Name;
                if (!string.IsNullOrEmpty(Album))
                    strDir = Album;



                string dest = ziqueDest + Path.DirectorySeparatorChar + strDir + Path.DirectorySeparatorChar + fileName;
                misc.log(" {0} {1} à copier vers {2}", log, location, dest);
                try
                {
                    string newDest = file.copyTree(dest, false);

                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

        }

        public void move(string ziqueOrg, string ziqueDest, DateTime limit)
        {
            if (pub >= limit)
                return;

            if (string.IsNullOrEmpty(location))
                return;
            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                if (location.StartsWith(ziqueOrg + @"Podcasts"))
                {
                    misc.log(" � d�placer" + location);
                    string dest = location.Replace(ziqueOrg, ziqueDest);

                    string dirDest = Path.GetDirectoryName(dest);
                    string fileName = Path.GetFileName(dest);
                    fileName = pub.ToString("yy.MM.dd_HH.mm") + "_" + fileName;

                    dest = dirDest + Path.DirectorySeparatorChar + fileName;
                    try
                    {
                        string newDest = file.copyTree(dest, false);
                        if (bgMove == null)
                        {
                            lock (_lock)
                            {
                                if (bgMove == null)
                                    bgMove = BackGroundTaskMgr.getMgrlarge("Move");
                            }
                        }
                        //  file.CopyTo(dest, true);
                        bgMove.add(new BgTaskCopy(this, location, newDest));
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }
                }
            }


        }

        private class BgTaskCopy : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskCopy(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Location = value;

                    misc.log("copie effectu�e " + value);
                    try
                    {
                        File.Delete(Desc);
                    }
                    catch (Exception ex)
                    {
                        misc.log("impossible de supprimer " + Desc + " " + ex.ToString());
                    }
                    success = true;
                }
                catch (Exception e)
                { misc.log("NIET " + e.Message); }

                if (!success && info.Track != null)
                {
                    //misc.log("invalidation track " + info);
                    ////  info.track = null;
                }

            }
        }



        DateTime IPub.Pub
        {
            get
            {
                return pub;
            }
            set
            {
                pub = value;
            }
        }

        string IPub.Comment
        {
            get
            {
                return Comment;
            }
            set
            {
                setGrouping(this.Comment, true);
                Comment = value;
            }
        }

        string IPub.Name
        {
            get { return Name; }
        }

        string IPub.Location
        {
            get { return location; }
        }

        int IPub.Year
        {
            get { return Year; }
        }

        DateTime IPub.Added
        {
            get
            {
                return added;
            }
            set
            {
                added = value;
            }
        }
        private pdb.util.timeSpan duree;
        public pdb.util.timeSpan Duree { get { return duree; } }


    }
}



]]></content>
  </file>
  <file path="\pdb.podcast\Auto\AutoBuilder.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using pdb.podcast.Tuning;
using pdb.podcast.Report;
using pdb.podcast.Selection;
namespace pdb.podcast.Auto
{

    enum builderstate
    {
        none,
        enCours,
        stable
    }
    class AutoBuilder : IComparable<AutoBuilder>, IBorderTransmit
    {
        const char SEP = '\t';
        const string DAT = @"..\Data\";
        string file = "";
        private bool mustUpdate; public static bool MustUpdate = false;
        private double total = -1;
        private double delta;
        private double lastd;
        private double d;
        private double org;
        private double newv;
        private bool canGo;
        //private int lastGoodDelta;
        //private double lastGoodLevel;
        private int lastTotal;
        private int atomicMode;
        private int sameConfiguration;
        private double cmin;
        private double cmax;
        private double dmin;
        private double dmax;
        public const double EPSILON = 1e-10;
        //private bool dminAlready;
        //private bool dmaxAlready;
        private string _empreinte = "";
        private double delta0 = 0;
        private double lastDelta = 0;
        private Memory mem0;
        private Memory mem1;
        private Memory minMem;
        private Memory maxMem;
        private StringBuilder sb = new StringBuilder();
        // private static DateTime lastModif;
        private pdb.podcast.Tuning.Auto conf;
        private static List<AutoBuilder> list = new List<AutoBuilder>();
        private static int index;
        private IBuilderSource source; public IBuilderSource Source { get { return source; } }

        private LimitItemBase client;
        private static XmlElement xmlRoot;
        private static XmlDocument doc;
        private static bool started = false;
        private string name = "";
        private builderstate state;
        private int naturalOrder = 1;
        private List<AutoBuilderItem> items = new List<AutoBuilderItem>();
        private AutoBuilderItem choose;
        public const int STOP_MAX = 3;
        private int _stopLevel = STOP_MAX;



        private AutoBuilder(pdb.podcast.Tuning.Auto conf)
        {
            this.conf = conf;
            this.name = conf.name;
            mem0 = new Memory(DAT + "v." + conf.name + ".db.txt");
            mem1 = new Memory(DAT + "r." + conf.name + ".db.txt");
            this.file = DAT + "auto." + conf.name + ".log";
            foreach (pdb.podcast.Tuning.Auto sub in conf.items)
            {
                var item = new AutoBuilderItem(this, sub);
                items.Add(item);
            }
        }
        private void setConf(pdb.podcast.Tuning.Auto value)
        {

            conf = value;
            for (int i = 0; i < items.Count && i < conf.items.Count; i++)
            {
                items[i].setConf(conf.items[i]);
            }

        }

        private void setSource(IBuilderSource source)
        {
            this.source = source;
            source.addBorderObs(this);
        }
        private static AutoBuilder main;
        public static void build(XmlNode xAuto, IBuilderSource source)
        {
            if (xAuto is XmlElement)
            {
                var conf = new pdb.podcast.Tuning.Auto(null, null, xAuto as XmlElement);
                var name = conf.name;
                AutoBuilder builder = list.Find(a => a.name == name);
                if (builder == null)
                {
                    builder = new AutoBuilder(conf);
                    list.Add(builder);
                    builder.naturalOrder = list.Count;
                    index = list.Count - 1;
                    if (main == null)
                        main = builder;
                }
                builder.setConf(conf);
                builder.setSource(source);

            }
        }
        public static void setClient(LimitItemBase client, XmlNode node)
        {
            var att = node.Attributes["auto"];
            if (att == null)
                return;
            var name = att.Value;
            AutoBuilder builder = list.Find(a => a.name == name);
            if (builder == null)
                return;
            builder.client = client;

        }
        private void makeDelta(Memory mem, string mode, string file)
        {
            if (!File.Exists(file))
                File.WriteAllText(file, "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate\tAdd\tiAdd\ttSupp\tiSup\t\r\n");
            mem.load();
            var listSe = source.getSelectedTracks();
            var loaded = source.getAllTracks();
            if (mem.Loaded)
            {
                var auxDixt = new pdb.util.BgDictString<TrackInfoItunes>(); // BgDictString<string, TrackInfoItunes>();
                foreach (TrackInfoItunes s in listSe)
                {
                    var key = s.Location;
                    auxDixt[key] = s;
                    if (!mem.dict.ContainsKey(key))
                    {
                        var desc = new TrackItemdesc(s.ToString(), s.GetProvider());
                        string line = desc.ToString();
                        mem.ajouts.Add(desc);
                        mem.tajouts.Add(s);
                        sb.AppendLine(string.Format("{0} delta {1} ajouté {2}", name, mode, line));
                    }
                }
                foreach (string key in mem.dict.Keys)
                {
                    if (!auxDixt.ContainsKey(key))
                    {
                        var line = mem.dict[key];
                        mem.suppressions.Add(line);
                        if (loaded.ContainsKey(key))
                        {
                            var t = loaded[key];
                            mem.tsuppressions.Add(t);
                        }
                        sb.AppendLine(string.Format("{0} delta {1} supprimé {2}", name, mode, line));
                    }
                }
                if (mem.ajouts.Count > 0 || mem.suppressions.Count > 0)
                {
                    int imax = Math.Max(mem.ajouts.Count, mem.suppressions.Count);
                    using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                    {
                        //if (!exist)
                        //    tw.WriteLine("quand\tdiff\tcorr\torg\tnew\tAdd\tiAdd\ttSupp\tiSup");
                        tw.Write(DateTime.Now); tw.Write(SEP);
                        tw.Write((delta).ToString("0.###")); tw.Write(SEP);
                        tw.Write(d.ToString("0.###")); tw.Write(SEP);
                        tw.Write(org.ToString("0.###")); tw.Write(SEP);
                        tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                        tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                        tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                        tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                        tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                        tw.Write(atomicMode); tw.Write(SEP);
                        tw.Write(state); tw.Write(SEP);
                        for (int i = 0; i < imax; i++)
                        {
                            if (i > 0)
                            {
                                tw.WriteLine();
                                for (int j = 0; j < 11; j++)
                                    tw.Write(SEP);
                            }
                            if (i < mem.ajouts.Count)
                                tw.Write(mem.ajouts[i].track);
                            tw.Write(SEP);
                            if (i < mem.ajouts.Count)
                                tw.Write(mem.ajouts[i].item);
                            tw.Write(SEP);
                            if (i < mem.suppressions.Count)
                                tw.Write(mem.suppressions[i].track);
                            tw.Write(SEP);
                            if (i < mem.suppressions.Count)
                                tw.Write(mem.suppressions[i].item);
                            tw.Write(SEP);
                        }
                        tw.WriteLine();
                    }
                }
            }
            mem.save(listSe);
        }
        private void reset()
        {
            atomicMode = -1;
            cmin = 0;
            cmax = int.MaxValue;
            dmin = int.MaxValue;
            dmax = -dmin;
            //dminAlready = false;
            //dmaxAlready = false;
            minMem = null;
            maxMem = null;
            sameConfiguration = 0;
            _empreinte = "";
            delta0 = 0;
            lastDelta = 0;
            state = builderstate.none;
            foreach (AutoBuilderItem item in items)
                item.reset();
            _stopLevel = STOP_MAX;
        }
        private static void decrementIndex()
        {
            index--;
            if (index < 0)
                index = list.Count - 1;
        }
        //  private bool _modifFile; 

        public static bool Stable
        {
            get
            {

                foreach (AutoBuilder builder in list)
                    if (builder.state != builderstate.stable)
                        return false;
                return true;
            }
        }

        public static void init(bool first)
        {
            if (list.Count == 0)
                return;
            list.Sort();
            bool firstWIthTb = first && Conf.BorderTb;
            bool secondwithoutTb = !first && !Conf.BorderTb;
            bool readXml = firstWIthTb || secondwithoutTb;
            FileInfo f = null;
            if (readXml)
            {
                f = Conf.Instance.ConfFile;
                doc = new XmlDocument();
                doc.PreserveWhitespace = true;
                doc.Load(f.FullName);
                xmlRoot = doc.DocumentElement.SelectSingleNode("./dir") as XmlElement;
            }

            bool _modifFIle = false;
            foreach (AutoBuilder builder in list)
            {
                if (readXml)
                    builder.setValueOrg();
                if (first)
                    builder.causeRegister.Clear();
                if (builder.ToSave() && readXml)
                    _modifFIle = true;
            }

            if (_modifFIle)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }
        }

        private bool ToSave()
        {
            foreach (AutoBuilderItem item in items)
            {
                if (item.ToSave)
                    return true;
            }
            return false;
        }

        public void setValueOrg()
        {

            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return;
            foreach (AutoBuilderItem item in items)
                item.setOrg(xml);
        }
        public static bool Check(Feeds feeds)
        {
            if (list.Count == 0)
                return true;
            list.Sort();
            FileInfo f = Conf.Instance.ConfFile;

            bool _cango = true;
            MustUpdate = false;
            bool _modifFile = false;
            if (Conf.AutoSequence)
            {
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    var builder = list[i];
                    main = builder;
                    var cango = builder.check2();
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (builder.newv != builder.org || builder.ToSave())
                    {
                        _modifFile = true;
                    }
                    if (!cango || MustUpdate || _modifFile)
                        break;
                }
                if (i > 0)
                    _cango = false;
            }
            else
            {
                AutoBuilder builder = null;
                if (!started)
                {
                    started = true;
                    foreach (AutoBuilder b in list)
                        b.total = b.source.getTotalSize();
                }
                // application de la précédente modif
                builder = list[index];
                if (builder.state > builderstate.none)
                {
                    builder.makeEmpreinteNonSequence();
                    decrementIndex();
                }
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    builder = list[i];
                    bool cango = false;
                    bool _cont = false;
                    while (true)
                    {
                        if (i == index || _cont)
                        {
                            cango = builder.check();
                            index = i;
                            main = builder;
                            _cont = false;
                            break;
                        }
                        else
                            cango = builder.checkWithoutModify();
                        if (builder.state == builderstate.none)
                            _cont = true;
                        else
                            break;
                    }
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (i == index)
                    {
                        if (builder.newv != builder.org)
                        {
                            _modifFile = true;
                        }
                        else
                        {
                            //index--;
                            //if (index < 0)
                            //    index = list.Count - 1;
                        }
                    }
                    if (_modifFile)
                        break;
                }
            }
            if (_modifFile)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }

            foreach (AutoBuilder builder in list)
            {
                if (builder.state == builderstate.none)
                    _cango = false;
            }
            return _cango;
        }


        private void log(string txt)
        {
            Program.logAuto.log(string.Format("{0}", txt));
        }
        private void log(string txt, params object[] args)
        {
            string _txt = string.Format(txt, args);
            log(_txt);
        }
        private void makeEmpreinteNonSequence()
        {
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
            }
            _empreinte = newEmpreinte;
            total = source.getTotalSize();
        }
        private bool checkWithoutModify()
        {
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            try
            {
                if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }
                else
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                }
                if (Conf.AutoSequence || total < 0)
                    total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                if (delta >= 0)
                {
                    if (delta < conf.write)
                        canGo = true;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                }
                else if (delta < 0)
                {
                    mustUpdate = true;
                    canGo = false;
                }
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
            }
            return canGo;
        }
        private bool check()
        {
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.none)
                reset();
            else if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
                else
                {
                    mustUpdate = false;
                    canGo = true;
                    org = newv;
                    return true;
                }
            }
            if (Conf.AutoSequence || total < 0)
                total = source.getTotalSize();
            double target = conf.target;
            delta = target - total;
            log("delta {0}", delta);
            if (state == builderstate.none)
                delta0 = delta;
            state = builderstate.enCours;
            lastd = d;
            d = 0;
            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return true;
            string attTarget = conf.type.ToString();
            var att = xml.Attributes[attTarget];
            if (att == null)
                return true;
            org = Convert.ToDouble(att.Value);
            newv = org;
            try
            {
                if (delta * delta0 < 0)
                {
                    if (atomicMode < 0)
                    {
                        atomicMode = 0;
                        //if (minMem == null)
                        //    minMem = new Memory(mem0);
                        //if (maxMem == null)
                        //    maxMem = new Memory(mem0);
                        //if (minMem.suppressions.Count == 0)
                        //    minMem.suppressions = new List<TrackItemdesc>(maxMem.ajouts);
                        //if (maxMem.ajouts.Count == 0)
                        //    maxMem.ajouts = new List<TrackItemdesc>(minMem.suppressions);
                    }
                }
                bool cancelSameConf = false;
                bool cancelNb = false;
                if (atomicMode >= 0)
                {
                    atomicMode++;
                    if (Math.Abs(dmin - delta) < EPSILON)
                        sameConfiguration++;
                    else if (Math.Abs(dmax - delta) < EPSILON)
                        sameConfiguration++;
                    else
                        sameConfiguration = 0;
                    if (sameConfiguration > conf.idem)
                        cancelSameConf = true;
                    if (atomicMode > conf.cloop)
                        cancelNb = true;
                }
                if (delta >= 0)
                {
                    if (mem0.suppressions.Count > 0)
                        minMem = new Memory(mem0);
                    if (delta < conf.write)
                        canGo = true;
                    //  lastGoodLevel = org;
                    //if (maxMem != null && minMem != null)
                    //{
                    if (atomicMode > 0)
                    {
                        if (cancelSameConf) //|| (mem0.suppressions.Count == 1 && mem0.ajouts.Count ==0))
                        {
                            log("abandon recherche cartésienne cause idem");
                            state = builderstate.stable;
                            return true;
                        }
                        else if (cancelNb)
                        {
                            log("abandon recherche cartésienne cause cloop");
                            state = builderstate.stable;
                            return true;
                        }
                        //if (Math.Abs(dmin - delta) < 0.01)
                        //    dminAlready = true;
                        //else
                        //    dminAlready = false;
                        if (maxMem != null && minMem != null)
                        {
                            if (minMem.suppressions.Count == maxMem.ajouts.Count)
                            {
                                bool identique = true;
                                for (int i = 0; i < minMem.suppressions.Count; i++)
                                {
                                    if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
                                    {
                                        identique = false;
                                        break;
                                    }
                                }
                                if (identique)
                                {
                                    if (minMem.suppressions.Count == 1 || atomicMode > conf.verif)
                                    {
                                        mustUpdate = false;
                                        log("abandon recherche cartésienne cause cycle");
                                        state = builderstate.stable;
                                        _empreinte = newEmpreinte;
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    cmin = org;
                    dmin = delta;
                    // lastGoodDelta = (int)delta;
                    lastTotal = (int)total;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                    d = 0;
                    if (atomicMode > 0)
                    {
                        //if (atomicMode > conf.cloop)
                        //{
                        //    mustUpdate = false;
                        //    log("abandon recherche cartésienne cause cloop");
                        //    state = builderstate.stable;
                        //    _empreinte = newEmpreinte;
                        //    return true;
                        //}
                        //if (dminAlready && dmaxAlready)
                        //{
                        //    mustUpdate = false;
                        //    Program.logAuto.log("abandon recherche cartésienne cause cycle");
                        //    return true;
                        //}
                        d = 0.5 * (cmax - cmin);
                    }
                    else
                    {
                        double _d = int.MaxValue;
                        if (cmax >= 0 && cmin >= 0)
                            _d = cmax - cmin;
                        double aux = int.MaxValue;
                        // double aux2 = int.MaxValue;
                        foreach (Level level in conf.levels)
                        {
                            aux = (delta - level.d) * level.inf;
                            if (aux > d)
                                d = aux;
                        }
                        if (conf.coeff > 0)
                        {

                            if (org > conf.max)
                                d = conf.max - org;
                            else
                            {
                                d *= conf.coeff * (conf.max - org) / (conf.max - conf.min);
                            }
                            //else
                            //{
                            //    var de = Math.Abs(delta);
                            //    aux2 = de / (target + de) * (conf.max - org) * conf.coeff;
                            //}
                        }

                        //if (d == 0 || aux2 < d)
                        //    d = aux2;

                        if (d > _d)
                            d = _d;
                    }
                }
                else if (delta < 0)
                {
                    if (mem0.ajouts.Count > 0)
                        maxMem = new Memory(mem0);
                    mustUpdate = true;
                    canGo = false;
                    //if (maxMem != null && minMem != null)
                    //{
                    //    if (atomicMode < 0)
                    //        atomicMode = 0;
                    //    atomicMode++;
                    //}
                    cmax = org;
                    dmax = delta;
                    d = 0;
                    if (atomicMode > 0)
                    {
                        bool identique = false;
                        if (minMem != null && maxMem != null
                            && maxMem.ajouts.Count == minMem.suppressions.Count)
                        {
                            identique = true;
                            for (int i = 0; i < minMem.suppressions.Count; i++)
                            {
                                if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
                                {
                                    identique = false;
                                    break;
                                }
                            }
                        }
                        if (cancelSameConf)// || (mem0.ajouts.Count == 1 && mem0.suppressions.Count == 0))
                        {
                            log("retour derniere bonne valeur cause idem");
                            d = cmin - cmax;
                        }
                        else if (cancelNb)
                        {
                            log("abandon recherche cartésienne cause cloop");
                            d = cmin - cmax;
                        }
                        else if (identique && (minMem.suppressions.Count == 1 || atomicMode > conf.verif))
                        {
                            log("retour derniere bonne valeur cause cycle");
                            d = cmin - cmax;
                        }
                        //else if (atomicMode > conf.cloop)
                        //{                      
                        //    log("abandon recherche cartésienne cause cloop");
                        //    d = cmin - cmax;
                        //}
                        else
                            d = 0.5 * (cmin - cmax);
                    }
                    else
                    {

                        double _d = -int.MaxValue;
                        if (cmax >= 0 && cmin >= 0)
                            _d = cmin - cmax;
                        double aux = -int.MaxValue;
                        // double aux2 = -int.MaxValue;
                        foreach (Level level in conf.levels)
                        {
                            aux = (delta - conf.delta + level.d) * level.sup;
                            if (aux < d)
                                d = aux;
                        }
                        if (conf.coeff > 0)
                        {
                            if (org < conf.min)
                                d = (conf.min - org);
                            else
                            {
                                d *= conf.coeff * (org - conf.min) / (conf.max - conf.min);
                            }
                            //else
                            //{
                            //    var de = Math.Abs(delta);
                            //    aux2 = de / (target+de) * (conf.min - org) * conf.coeff;
                            //}
                        }

                        //if (d == 0 || aux2 > d)
                        //    d = aux2;

                        if (d < _d)
                            d = _d;
                    }
                    //d = (delta - conf.delta) * conf.sup;
                    //if (org <= lastGoodLevel)
                    //{
                    //    lastGoodLevel = -1;
                    //    lastGoodDelta = -1;
                    //    lastTotal = -1;
                    //}
                }
                if (Math.Abs(d) < 0.00000001)
                {
                    mustUpdate = false;
                    // unCart();
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    return true;
                }
                //if (dejaVu)
                //    Program.logAuto.log("déjà vu lastGoodLevel:{0} lastGoodDelta:{1}", lastGoodLevel, lastGoodDelta);
                log("correction {0}", d);
                newv = org + d;
                if (newv <= 0)
                    newv = 0;
                if (conf.coeff > 0)
                {
                    if (newv > conf.max)
                        newv = conf.max;
                    else if (newv < conf.min)
                        newv = conf.min;
                }
                newv = Math.Round(newv, 8);
                log(" valeur {0} --> {1}", org, newv);
                att.Value = newv.ToString();
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
                string strDate = "";
                var attD = xml.Attributes["date"];
                if (attD != null)
                    strDate = attD.Value;
                bool exist = File.Exists(file);
                using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                {
                    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                    if (!exist)
                        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                    tw.Write(DateTime.Now); tw.Write(SEP);
                    tw.Write(target.ToString("0.###")); tw.Write(SEP);
                    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(atomicMode); tw.Write(SEP);
                    tw.Write(state); tw.Write(SEP);
                    tw.WriteLine();
                }
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }

        private void calcChoose(bool up, bool strict, bool checkSelect)
        {
            choose = null;
            double dt = double.MaxValue;
            double gap = double.MaxValue;
            // bool trou = false;
            foreach (AutoBuilderItem item in items)
            {
                item.after(up, strict, checkSelect);
                item.setTension(up, strict, checkSelect);
                if (item.Stop(_stopLevel))
                {
                    if ((strict || checkSelect) && Conf.BorderGranSlam)
                    {
                        choose = null;
                        break;
                    }
                    continue;
                }
                double aux = double.MaxValue;
                // var tension = item.Tension;
                if (conf.selectFix)
                {
                    var tension = item.Tension;
                    aux = up ? tension : -tension;
                }
                else
                    aux = item.Dt;

                if (conf.selectAbs && !conf.selectFix && aux < 0)
                    aux *= -1;



                if (item.getCauses().Count == 0)
                {
                    // trou = true;
                    if ((strict || checkSelect) && Conf.BorderGranSlam)
                    {
                        choose = null;
                        break;
                    }
                    continue;
                }

                //var _gap = Math.Abs(aux);
                //if (_gap < gap)
                //    gap = _gap;

                if (aux < dt)
                {
                    dt = aux;
                    newv = item.NewV;
                    choose = item;
                }
            }
            //if (trou && conf.gap && gap < double.MaxValue)
            //{
            //    foreach (AutoBuilderItem item in items)
            //    {
            //        if (item.Stop)
            //            continue;
            //        item.gap(up, conf.selectFix, gap);
            //    }
            //}
        }

        private bool check2()
        {
            // _modifFile = false; 
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");




            if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
            {
                if (conf.pertinentExclu)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item != choose)
                            item.makePertinent();
                    }
                }
                else if (conf.pertinentAll)
                {
                    foreach (AutoBuilderItem item in items)
                        item.makePertinent();
                }
                else
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        item.checkAjout(mem0.tajouts);
                        item.checkAjout(mem0.tsuppressions);
                    }
                }


                //else if (choose != null)
                //    choose.makePertinent();
            }
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();

            try
            {
                if (state == builderstate.none)
                    reset();
                else if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }

                total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                log("delta {0}", delta);
                if (delta * lastDelta < 0)
                {
                    //if (delta > 0)
                    //{
                    //    // ok!
                    //    state = builderstate.stable;
                    //    _empreinte = newEmpreinte;
                    //    return true;
                    //}
                    // retour arrière
                    if (choose != null && (_stopLevel > 0 || delta < 0))
                    {
                        _stopLevel--;
                        choose.stop(_stopLevel);
                        canGo = false;
                        mustUpdate = true;
                        return false;
                    }
                    else
                    {
                        if (delta > 0)
                        {
                            // ok!
                            state = builderstate.stable;
                            _empreinte = newEmpreinte;
                            return true;
                        }
                    }
                }
                lastDelta = delta;
                if (state == builderstate.none)
                    delta0 = delta;
                state = builderstate.enCours;
                lastd = d;
                d = 0;

                bool up = delta > 0;
                if (up && delta < conf.delta)
                {
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    return true;
                }
                mustUpdate = true;
                //double dt = double.MaxValue;

                //bool real = true;
                //if (delta * delta0 < 0)
                //{
                //    if (choose != null)
                //    {
                //        _stopLevel--;
                //        choose.stop(_stopLevel);
                //    }
                //    canGo = false;
                //    mustUpdate = true;
                //    return false;
                //}
                if (conf.stopAll)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item.Stop(1))
                        {
                            state = builderstate.stable;
                            return true;
                        }
                    }
                }



                choose = null;
                if (_stopLevel >= 3 && conf.checkSelect && conf.checkStrict)
                    calcChoose(up, true, true);
                if (choose != null)
                    log("REEL - SELECT");
                else
                {
                    if (_stopLevel >= 2 && conf.checkStrict)
                        calcChoose(up, true, false);
                    if (choose != null)
                        log("REEL");
                    else
                    {
                        if (_stopLevel >= 1 && conf.checkSelect)
                            calcChoose(up, false, true);
                        if (choose != null)
                            log("SELECT");
                        else
                        {
                            calcChoose(up, false, false);
                        }
                    }
                }


                if (choose == null)
                {
                    log("choose null");
                    _stopLevel--;
                    if (_stopLevel < 0)
                    {
                        state = builderstate.stable;
                        return true;
                    }
                    else
                    {
                        canGo = false;
                        mustUpdate = true;
                        return false;
                    }
                }

                org = choose.Org;



                if (up)
                {
                    if (delta < conf.write)
                        canGo = true;
                    if (conf.checkEvol)
                    {
                        // var nextTrack = choose.rejected(real).candidat;
                        var size = choose.EvolSize; // Stat.getSizeinMo(nextTrack);
                        if (delta < size)
                        {
                            _stopLevel--;
                            // choose.stop();
                            if (conf.stopAll)
                            {
                                foreach (AutoBuilderItem item in items)
                                    item.stop(_stopLevel);
                                //state = builderstate.stable;
                                //return true;
                            }
                            else
                            {
                                choose.stop(_stopLevel);
                            }
                        }
                    }

                }
                else
                {
                }
                choose.save();
                Program.logAuto.log("===> " + choose.ToString());
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }

                using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                {
                    bool exist = File.Exists(file);
                    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                    if (!exist)
                        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                    tw.Write(DateTime.Now); tw.Write(SEP);
                    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
                    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(atomicMode); tw.Write(SEP);
                    tw.Write(state); tw.Write(SEP);
                    tw.WriteLine();
                }
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }

        public static void Log()
        {
            if (main == null)
                return;
            main.log();
        }
        public override string ToString()
        {
            var strMin = minMem == null ? "" : minMem.suppressions.Count.ToString();
            var strMax = maxMem == null ? "" : maxMem.ajouts.Count.ToString();
            var strName = string.Format("{0} ({1}) {2}", name, resolveOrder(), newv);
            var sb = new StringBuilder();
            sb.Append(string.Format("{0} {1} delta->{2} correction->{3}  mustUpdate->{4} canGo {5} atomic {6} idem {7} ({8}/{9})", strName, state, delta.ToString("0.###"), d.ToString("0.###"), mustUpdate, canGo, atomicMode, sameConfiguration, strMin, strMax));
            sb.AppendLine();
            foreach (AutoBuilderItem item in items)
                sb.Append(item);
            sb.AppendLine();
            return sb.ToString();

        }
        private void log()
        {
            Program.logAuto.log("");
            Program.logAuto.log("*****************************************************************************************");
            Program.logAuto.log("{0} {1}", name, sb.ToString());
            var type = "";
            if (choose != null)
                type = choose.type.ToString();
            Program.logAuto.log("{0} {1} total:{2}", name, type, total.ToString("0.###"));
            Program.logAuto.log("{0} {1} delta:{2}", name, type, delta.ToString("0.###"));
            Program.logAuto.log("{0} {1} stop:{2}", name, type, _stopLevel.ToString());

            //if (choose != null)               
            //   Program.logAuto.log("{0}", choose);

            //Program.logAuto.log("{0} cmin {1}", name, cmin.ToString("0.###"));
            //Program.logAuto.log("{0} dmin {1}", name, dmin.ToString("0.###"));
            //Program.logAuto.log("{0} cmax {1}", name, cmax.ToString("0.###"));
            //Program.logAuto.log("{0} dmax {1}", name, dmax.ToString("0.###"));
            if (mustUpdate)
            {
                //foreach (AutoBuilder builder in list)
                //{
                //    if (builder.d != 0)
                //    {
                log("correction {0}", d);
                log(" valeur {0} --> {1}", org, newv);
                //    }
                //}
            }
            else Program.logAuto.log("valeur non modifiée {0}", org);
            Program.logAuto.log("");
            foreach (AutoBuilder builder in list)
            {
                Program.logAuto.log(builder.ToString());
            }
            Program.logAuto.log("-------------------------------------------------------------------------------------------------------------------");
        }
        private XmlElement xml;
        public void lookup(XmlElement node)
        {
            var att = node.Attributes["auto"];
            if (att != null)
            {
                // && conf.name.Equals(att.Value))
                var targets = att.Value.Split(';');
                foreach (var target in targets)
                {
                    if (name.Equals(target))
                    {
                        xml = node;
                        return;
                    }
                }
            }
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    lookup(sub as XmlElement);
                    if (xml != null)
                        return;
                }
            }
        }
        private int resolveOrder()
        {
            if (conf.order < int.MaxValue)
                return conf.order;
            return naturalOrder;
        }
        public int CompareTo(AutoBuilder other)
        {
            if (other == this)
                return 0;
            var cmp = resolveOrder().CompareTo(other.resolveOrder());
            if (cmp == 0)
                throw new ApplicationException(string.Format("deux builders d'ordre identique {0}/{1}", this.name, other.name));
            return cmp;
        }

        private bool checkSignal;
        public void signal(TrackBorderItem tb)
        {
            checkSignal = false;
            var item = items.Find(i => i.type == tb.type);
            if (item != null)
            {
                if (client != null)
                {
                    if (!tb.source.isChildOf(client))
                        return;
                }
                item.signal(tb);
                checkSignal = true;
            }

        }

        public bool Checked
        {
            get { return checkSignal; }
        }

        private CauseRegister causeRegister = new CauseRegister();
        public CauseRegister CauseRegister { get { return causeRegister; } }

        //public void signal(CauseData cd)
        //{
        //    checkSignal = true;
        //    var item = items.Find(i => i.type == cd.type);
        //    if (item != null)
        //    {
        //        if (client != null)
        //        {
        //            if (!cd.limit.isChildOf(client))
        //                return;
        //        }
        //        causeRegister.signal(cd);
        //        //checkSignal = true;           
        //    }


        //}

        public void signal(CauseDatas cd)
        {
            checkSignal = true;
            if (client != null)
            {
                if (!cd.limit.isChildOf(client))
                    return;
            }
            int nb = 0;
            for (int i = 0; i < Causes.NB_TYPE; i++)
            {
                var data = cd.datas[i];
                if (data == null || data.virtuel)
                    continue;
                var item = items.Find(it => it.type == data.type);
                if (item == null)
                    cd.datas[i].virtuel = true;
                else
                    nb++;
            }

            //if (nb == 0)
            //    return; 

            causeRegister.signal(cd);

        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Auto\AutoBuilderItem.cs">
    <content><![CDATA[using pdb.podcast.Tuning;
using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using TimeSpan = pdb.util.timeSpan;
using pdb.podcast.Selection;
using pdb.podcast.Report;

namespace pdb.podcast.Auto
{
    class AutoBuilderItem : IBorder
    {


        /// <summary>
        /// Valeur initiale de la valeur gérée
        /// </summary>
        private double org;
        private double pertinentOrg = -1;
        private timeSpan tpertinentOrg;
        private TimeSpan torg;
        private TimeSpan tmin;
        private TimeSpan tmax;
        /// <summary>
        /// Valeur modifiée
        /// </summary>
        private double newv;
        private double evolSize;
        public double NewV { get { return newv; } }
        internal TrackBorderItem rejected(bool real) { return real ? _rejected : _rejectedLight; }
        internal TrackBorderItem selected(bool real) { return real ? _selected : _selectedLight; }
        internal void makePertinent() { pertinentOrg = org; }

        public void checkAjout(IEnumerable<TrackInfoItunes> list)
        {
            if (pertinentOrg == org)
                return;

            var lcauses = _causes;


            foreach (Causes causes in lcauses)
            {
                foreach (TrackInfoItunes t in list)
                {
                    if (causes.candidat.Location == t.Location)
                    {
                        pertinentOrg = org;
                        return;
                    }
                }

            }


        }

        private string name;

        /// <summary>
        /// Attribut concerné
        /// </summary>
        XmlAttribute att;
        XmlElement xml;
        double dd;
        double d;
        private bool lastStrict;
        private bool lastUp;
        private double lastDelta;

        private double lastOrg;

        private pdb.podcast.Tuning.Auto conf;
        public readonly borderType type;
        private AutoBuilder parent;
        public AutoBuilderItem(AutoBuilder parent, pdb.podcast.Tuning.Auto conf)
        {
            this.parent = parent;
            this.conf = conf;
            this.type = conf.type;
            this.name = string.Format("{0}:{1}", conf.name, type);
            if (conf.pente == 0)
                d = conf.max - conf.min;
            else
                d = conf.pente - conf.min;
            dd = d * d;
        }

        private bool _toSave;
        public bool ToSave { get { return _toSave; } }

        public double Org { get { return org; } }

        public void setConf(pdb.podcast.Tuning.Auto conf) { this.conf = conf; }

        #region border
        private TrackBorderItem _selected;
        private TrackBorderItem _selectedLight;
        private TrackBorderItem _rejected;
        private TrackBorderItem _rejectedLight;

        //private bool verify(TrackBorderItem tb)
        //{
        //    return true;
        //    double sourceValue = -1;
        //    var source = tb.source;
        //    switch (type)
        //    {
        //        case borderType.d: sourceValue = source.Duration; break;
        //        case borderType.fd: sourceValue = source.FeedDuration; break;
        //        case borderType.maxdate: sourceValue = (source.DateMax - Conf.Date0).TotalDays; break;
        //        default: return false;
        //    }

        //    if (Math.Abs(org - sourceValue) > 2.0E-7)
        //        return false;
        //    return true;
        //}
        private void setSelect(TrackBorderItem tb)
        {
            // pour down mémo des track sélectionnés

            _selected = tb;

        }

        private void setRejec(TrackBorderItem tb)
        {
            // A REVOIR

            //// pour up mémo des tracks rejetés
            ////1. S'il est par ailleurs déjà intégré, pas pertinent
            //if (parent.Source.contains(tb.candidat))
            //{
            //    return;
            //    if (_rejected != null)
            //    {
            //        if (_rejected.status > borderStatus.rejectedXtraLight)
            //            return;
            //        if (tb.val >= _rejected.val)
            //            return; 
            //    }

            //    tb.status = borderStatus.rejectedXtraLight; 
            //}


            ////2. On est en cours de construction donc il se peut que ce candidat soit in fine ajouté par d'autres
            //// intéret en up . S'il est dans la mémoire pas pertinent en up
            //if (parent.Mem.dict.ContainsKey(tb.candidat.Location))
            //    return;
            _rejected = tb;
        }


        public void signal(TrackBorderItem tb)
        {

            if (tb.Virtual && !Conf.BorderVirtual)
                return;
            if (tb.Selected)
            {
                if (tb.val >= torg)
                    return;
                if (tb.val <= tmin)
                    return;

                if (!tb.Virtual)
                {
                    if (_selected == null)
                        _selected = tb;
                    else if (tb.val > _selected.val)
                        _selected = tb;
                }

                if (_selectedLight == null)
                    _selectedLight = tb;
                else if (tb.val > _selectedLight.val)
                    _selectedLight = tb;

                //if (_selected == null)
                //    setSelect(tb);
                //else
                //{
                //    if (tb.status > _selected.status && !Conf.BorderIdem)
                //        setSelect(tb);
                //    else if (tb.status == _selected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val > _selected.val)
                //            setSelect(tb);
                //    }
                //}

            }
            else
            {

                if (tb.val <= torg)
                    return;
                if (tb.val >= tmax)
                    return;

                if (!tb.Virtual)
                {
                    if (_rejected == null)
                        _rejected = tb;
                    else if (tb.val < _rejected.val)
                        _rejected = tb;
                }

                if (_rejectedLight == null)
                    _rejectedLight = tb;
                else if (tb.val < _rejectedLight.val)
                    _rejectedLight = tb;


                //if (_rejected == null)
                //    setRejec(tb);
                //else
                //{
                //    if (tb.status > _rejected.status && !Conf.BorderIdem)
                //        setRejec(tb);
                //    else if (tb.status == _rejected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val < _rejected.val)
                //            setRejec(tb);
                //    }
                //}

            }
        }
        #endregion

        public void setOrg(XmlElement xml)
        {
            // Program.logAuto.log(ToString());
            _rejected = null;
            _selected = null;
            _toSave = false;
            this.xml = xml;
            att = this.xml.Attributes[type.ToString()];
            lastOrg = org;
            if (att == null)
                org = -1;
            else
                org = Convert.ToDouble(att.Value);

            if (org < conf.min)
            {
                org = conf.min;
                newv = org;
                save();
            }
            else if (org > conf.max)
            {
                org = conf.max;
                newv = org;
                save();
            }
            torg = getValue(org);
            tmin = getValue(conf.min);
            tmax = getValue(conf.max);
            if (pertinentOrg < 0)
                pertinentOrg = org;
            tpertinentOrg = getValue(pertinentOrg);
            //  misc.log(ToString());
        }
        private double dt; public double Dt { get { return dt; } }
        private double tension; public double Tension { get { return tension; } }
        private int _stop = AutoBuilder.STOP_MAX;
        public bool Stop(int level) { return _stop < level; }

        public void stop(int level)
        {
            newv = lastOrg;
            org = lastOrg;
            if (_stop > level)
                _stop = level;
            save();
        }
        public void reset()
        {
            _stop = AutoBuilder.STOP_MAX;
        }
        public void setTension(bool up, bool real, bool checkSelect)
        {

            dt = getDt(up, real, checkSelect);
        }

        private double getDt(bool up, bool real, bool checkSelect)
        {
            double t0 = _getTension(pertinentOrg);
            tension = _getTension(up, real, checkSelect);
            return (tension - t0) / conf.coeff;

        }

        private double getTension(bool up, bool real, bool selected)
        {
            return _getTension(up, real, selected) / conf.coeff;
        }

        private double getValue(TimeSpan val)
        {
            switch (type)
            {

                case borderType.d:
                case borderType.fd:
                    return val.TotalMinute;
                case borderType.maxdate: return val.TotalDay;
                case borderType.c:
                    break;
                default: return -1;

            }
            return -1;
        }

        private TimeSpan getValue(double val)
        {
            switch (type)
            {
                case borderType.d:
                case borderType.fd:
                    return TimeSpan.FromMinutes(val);
                case borderType.maxdate: return TimeSpan.FromDays(val);
                case borderType.c:
                    break;
                default: return new TimeSpan();

            }
            return new TimeSpan();
        }
        public double EvolSize { get { return evolSize; } }

        public List<Causes> getCauses()
        {
            return _causes;
        }

        //public List<Causes> getcauses(bool up, bool strict)
        //{
        //    List<Causes> list = null;
        //    if (up)
        //    {
        //        if (strict)
        //            list = _causesRejetStrict;
        //        else
        //            list = _causesRejet;
        //    }
        //    else
        //    {
        //        if (strict)
        //            list = _causesSelectStrict;
        //        else
        //            list = _causesSelect;
        //    }
        //    return list;
        //}

        public void gap(bool up, bool fix, double _gap)
        {
            _gap = Math.Abs(_gap);
            if (fix)
            {
                newv = Math.Abs(_gap);
            }
            else
            {
                if (up)
                    newv = org + _gap;
                else
                    newv = org - _gap;
            }
            save();
        }

        private double _getTension(bool up, bool strict, bool checkSelect)
        {
            lastStrict = strict;
            lastUp = up;
            // double t0 = getTension(org, dd);
            newv = org;
            evolSize = 0;
            var list = _causes;


            if (list.Count > 0)
            {
                int ifin = 2;
                bool bselect = !up;
                if (checkSelect)
                {
                    ifin = 1;
                }

                CauseItem cause = null;

                for (int i = 0; i < ifin; i++)
                {
                    var _cause = list[0].getCause(type, strict, !up, bselect);
                    bselect = !bselect;
                    if (_cause == null)
                        continue;
                    if (cause == null)
                        cause = _cause;
                    else
                    {
                        if (up)
                        {
                            if (_cause.val < cause.val)
                                cause = _cause; 
                        }
                        else
                        {
                            if (_cause.val > cause.val)
                                cause = _cause; 
                        }
                    }
                }
                if (cause == null)
                    return int.MaxValue;
                newv = Math.Round(getValue(cause.val), 8);
                foreach (var c in list)
                {
                    var cand = c.candidat;
                    evolSize += Stat.getSizeinMo(cand);
                }
            }
            else
                return int.MaxValue;


            //if (false)
            //{

            //    if (up)
            //    {
            //        var _rejected = strict ? this._rejected : this._rejectedLight;
            //        if (_rejected == null)
            //            return int.MaxValue;
            //        newv = Math.Abs(Math.Round(getValue(_rejected.val), 8));
            //        evolSize = Stat.getSizeinMo(_rejected.candidat);

            //    }
            //    else
            //    {
            //        var _selected = strict ? this._selected : this._selectedLight;
            //        if (_selected == null)
            //            return int.MaxValue;
            //        newv = Math.Round(getValue(_selected.val), 8);
            //    }
            //}

            return _getTension(newv);
        }

        public void save()
        {
            //  xml.SetAttribute(type.ToString(), newv.ToString()); 
            att.Value = newv.ToString();
            _toSave = true;
        }

        private List<Causes> _causes = new List<Causes>();
        //private List<Causes> _causesRejet = new List<Causes>();
        //private List<Causes> _causesSelect = new List<Causes>();

        //private List<Causes> _causesRejetStrict = new List<Causes>();
        //private List<Causes> _causesSelectStrict = new List<Causes>();



        //public void after()
        //{            
        //    _causesRejet = new List<Causes>();
        //    _causesSelect = new List<Causes>();
        //    _causesRejetStrict = new List<Causes>();
        //    _causesSelectStrict = new List<Causes>();
        //    after(true, true);
        //    after(true, false);
        //    after(false, true);
        //    after(false, false);
        //}
        public void after(bool up, bool strict, bool checkSelection)
        {
            _causes = new List<Causes>();
            var list = parent.CauseRegister.getList(false);
            int min = int.MaxValue;
            //  int minStrict = int.MaxValue;
            if (!up)
            {
                min = 0;
                //   minStrict = 0; 
            }
            int orgValue = torg.Value;
            foreach (Causes causes in list)
            {
                var candidat = causes.candidat;
                if (checkSelection)
                {
                    if (up && candidat.Selected)
                        continue;
                    if (!up && !candidat.Selected)
                        continue;
                }
                int ifin = 2;
                bool bselect = !up;
                if (checkSelection)
                {
                    ifin = 1;
                }

                for (int i = 0; i < ifin; i++)
                {


                    var cause = causes.getCause(type, strict, !up, bselect);
                    bselect = !bselect;
                    if (cause == null)
                        continue;
                    if (up && cause.Ok)
                        continue;
                    if (!up && !cause.Ok)
                        continue;
                    //if (value < 0)
                    //    value = -value;
                    int value = cause.val.Value;

                    if (up)
                    {

                        if (value == min)
                        {
                            _causes.Add(causes);

                        }
                        else if (value < min)
                        {
                            _causes.Clear();
                            _causes.Add(causes);
                            min = value;
                        }

                    }
                    else
                    {
                        if (value >= orgValue)
                            continue;

                        if (value == min)
                        {
                            _causes.Add(causes);
                        }
                        else if (value > min)
                        {
                            _causes.Clear();
                            _causes.Add(causes);
                            min = value;
                        }


                    }
                }

            }
        }


        private double _getTension(double org)
        {


            var d2 = org - conf.min;
            if (conf.pente > 0)
                return (d2 / d);

            var d1 = org - conf.max;

            return -1 + 2 * (d1 * d1 + d2 * d2) / dd;
        }



        public override string ToString()
        {
            var sb = new System.Text.StringBuilder();
            sb.AppendLine();
            sb.Append(name); sb.Append(" ");
            sb.Append(org); sb.Append(" ");

            sb.Append("stop="); sb.Append(_stop); sb.Append(" ");

            sb.Append("pertinent="); sb.Append(pertinentOrg); sb.Append(" ");
            sb.Append("tension="); sb.Append(tension); sb.Append(" ");
            sb.Append("dt="); sb.Append(dt); sb.Append(" ");

            var causes = _causes; // getcauses(lastUp, lastStrict);
            foreach (Causes cause in causes)
            {
                sb.AppendLine();
                var strStrict = lastStrict ? "strict " : "light ";
                var strselect = lastUp ? "rejet " : "select ";
                sb.Append(strselect);
                sb.Append(strStrict);
                sb.Append(cause.getCause(type, lastStrict, !lastUp, !lastUp));
                sb.Append(" "); sb.Append(cause.candidat);
            }

            //if (_causesRejetStrict.Count > 0)
            //{


            //    foreach (Causes cause in _causesRejetStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("rejet strict "); sb.Append(cause.getCause(type,true,false));                     
            //    }
            //}

            //else if (_causesRejet.Count > 0)
            //{

            //    foreach (Causes cause in _causesRejet)
            //    {
            //        sb.AppendLine();
            //        sb.Append("rejet light "); sb.Append(cause.getCause(type,false, false));      
            //    }
            //}

            //if (_causesSelectStrict.Count > 0)
            //{

            //    foreach (Causes cause in _causesSelectStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("select strict "); sb.Append(cause.getCause(type,true,true));      
            //    }
            //}

            //else if (_causesSelect.Count > 0)
            //{              
            //    foreach (Causes cause in _causesSelectStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("select light "); sb.Append(cause.getCause(type,false,true));      
            //    }
            //}



            if (_selected != null)
            {
                sb.AppendLine();
                sb.Append(_selected);
            }

            if (_rejected != null)
            {
                sb.AppendLine();
                sb.Append(_rejected);
            }
            sb.AppendLine();
            return sb.ToString();
        }


        public void signal(CauseDatas cd)
        {
            throw new NotImplementedException();
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Auto\TrackBorderItem.cs">
    <content><![CDATA[using pdb.podcast.Tuning;
using System;
using TimeSpan = pdb.util.timeSpan; 

namespace pdb.podcast.Auto
{
    public enum borderType
    {   
        d,
        fd,
        nb,
        maxdate,
        c
    }
    public enum borderStatus : byte
    {
        rejectedLight = 0,
        rejectedStrict = 1,
        selectedLight = 2,
        selectedStrict = 3
    }

    //[Flags]
    //public enum border : byte
    //{
    //    virtuel = 0,
    //    strict = 1,
    //    rejected = 0,
    //    selected = 2
    //}

    /// <summary>
    /// Infos sur la sélection ou la non sélection d'un podcast
    /// </summary>
    public class TrackBorderItem
    {
        /// <summary>
        /// Limite à l'orgine de l'info
        /// </summary>
        public readonly LimitItemBase source;
        /// <summary>
        /// Podcast
        /// </summary>
        public readonly TrackInfoItunes candidat;
        /// <summary>
        /// Type de paramètre pris en compte
        /// </summary>
        public readonly borderType type;
        /// <summary>
        /// Valeur actuelle pour le paramètre
        /// </summary>
        public readonly TimeSpan val;
        public readonly borderStatus status;

        public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, TimeSpan val, borderStatus status)
        {
            this.source = source;
            this.candidat = candidat;
            this.type = type;
            this.val = val;

            //int s = 2 * (selected ? 1 : 0) + (strict ? 1 : 0);
            this.status = status;
        }

        //public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, TimeSpan ts, borderStatus status) :
        //    this(source, candidat, type, ts.TotalMinutes, status)
        //{
        //}

        public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, DateTime t, borderStatus status) :
            this(source, candidat, type,  new TimeSpan(t - Conf.Date0), status)
        {
        }


        //public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, double val, border status)
        //    : this
        //        (source, candidat, type, val, (borderStatus)status)
        //{
        //}



        //public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, DateTime t, border status) :
        //    this(source, candidat, type, (t - Conf.Date0).TotalDays, status)
        //{
        //}

        //public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, TimeSpan ts, border status) :
        //    this(source, candidat, type, ts.TotalMinutes, status)
        //{
        //}


        //public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, TimeSpan val, bool selected, bool strict) :
        //    this(source, candidat, type, val, (borderStatus)(2 * Convert.ToByte(selected) + Convert.ToByte(strict)))
        //{
        //}


        //public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, DateTime t, bool selected, bool strict) :
        //    this(source, candidat, type,new TimeSpan(t-Conf.Date0),selected,strict)
        //{
        //}

        //public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, TimeSpan ts, bool selected, bool strict) :
        //    this(source, candidat, type, ts.TotalMinutes, selected,strict)
        //{
        //}

        public override bool Equals(object obj)
        {
            var o = obj as TrackBorderItem;
            if (o == null)
                return false;
            return candidat.Equals(o.candidat);
        }

        public override int GetHashCode()
        {
            return candidat.GetHashCode();
        }

        public override string ToString()
        {
            // string statut// Selected ? "selected" : "rejected";
            return string.Format("{0} {1} {2} {3} {4}", status, type, val, candidat, source);
        }
        public bool Selected { get { return status >= borderStatus.selectedLight; } }
        public bool Virtual { get { return (byte)status % 2 == 0; } }
    }

}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\FeedLimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
using timeSpan = pdb.util.timeSpan;

namespace pdb.podcast.Load
{
    public enum loadState
    {
        loadCandidat,
        standAlone,
        selection,
        end
    }
    public enum depotType
    {
        load,
        rapporte
    }
    /// <summary>
    /// Chargeur des pistes associées à un item de limite sur un dossier
    /// </summary>
    class FeedLimitItemLoader
    {
        private loadState state;
        /// <summary>
        /// Répertoire
        /// </summary>
        private DirConf dir;
        /// <summary>
        /// Limite
        /// </summary>
        public readonly LimitItem limit;
        /// <summary>
        /// Album
        /// </summary>
        private string album;
        /// <summary>
        /// Chargeur de limite
        /// </summary>
        private LimitsLoader parent;


        /// <summary>
        /// Nombre de piste max
        /// </summary>
        int nbMax;
        int loadNbMax;
        /// <summary>
        /// Durée cumulée max
        /// </summary>
        timeSpan durationMax;
        timeSpan loadDurationMax;

        ///// <summary>
        ///// Date de publication min
        ///// </summary>
        //DateTime dateMin;

        // private Logger logger;
        private Logger logLimit;
        private Logger logItem;

        /// <summary>
        /// Durée cumulée
        /// </summary>
        timeSpan currentDuration = new timeSpan();
        timeSpan currentDurationVirtuel = new timeSpan();
        timeSpan durationStop = new timeSpan();

        /// <summary>
        /// Nombre total
        /// </summary>
        int nb = 0;
        int nbVirtuel = 0;
        int nbStop = 0;

        private bool? endByFd;
        public bool EndByFd { get { if (endByFd == null) return false; return endByFd.Value; } }

        private bool _okFd; public bool OkFd { get { return _okFd; } }
        private bool _okNb; public bool OkNb { get { return _okNb; } }


        public void phase2()
        {
            currentDuration = new timeSpan();
            currentDurationVirtuel = new timeSpan();
            durationStop = new timeSpan();
            nb = 0;
            nbVirtuel = 0;
            nbStop = 0;
            state = loadState.selection;
            endByFd = null;
        }


        //private bool loadEqSel;
        //public bool LoadEqSel { get { return loadEqSel; } }

        public FeedLimitItemLoader(LimitItem limit, string album, LimitsLoader parent)
        {
            this.dir = limit.Dir;
            this.limit = limit;

            this.parent = parent;
            this.album = album;


            nbMax = limit.Nb;


            var feedDuration = limit.FeedDuration;
            int rating = limit.Rating;
            durationMax = timeSpan.FromMinutes(feedDuration);


            loadDurationMax = durationMax;
            loadNbMax = nbMax;

            bool loadEqSeld = true;
            bool loadEqSeln = true;

            if (limit.Dir.Cascading)
            {
                if (limit.LoadNb > nbMax)
                {
                    loadNbMax = limit.LoadNb;
                    loadEqSeln = false;
                }
                if (limit.LoadFeedDuration > feedDuration)
                {
                    loadDurationMax = timeSpan.FromMinutes(limit.LoadFeedDuration);
                    loadEqSeld = false;
                }

            }
            if (loadEqSeln)
                loadNbMax++;
            if (loadEqSeld)
                loadDurationMax = timeSpan.FromMinutes(loadDurationMax.TotalMinute + 200);

            logItem = Logger.getLogger(limit.ID + "\\" + album, null, false);
            logLimit = limit.Logger;
        }

        private void log(string txt)
        {
            logLimit.log(txt);
            logItem.log(txt);
        }

        private void log(string txt, params object[] other)
        {

            logLimit.log(txt, other);
            logItem.log(txt, other);
        }




        public timeSpan getCurrentDuration(bool real)
        {
            if (real)
                return currentDuration;
            return currentDurationVirtuel;
        }

        public timeSpan getDurationStop(bool real)
        {
            if (durationStop.Value == 0)
                return getCurrentDuration(real);
            return durationStop;
        }

        public int getNb(bool real)
        {

            if (real)
                return nb;
            return nbVirtuel;
        }
        public int getNbStop(bool real)
        {
            if (nbStop == 0)
                return getNb(real);
            return nbStop;
        }

        public int Nb { get { return nb; } }

        public bool control(TrackInfoItunes track, bool select, bool real)
        {
            //if (state == loadState.end)
            //    return false;


            string location = track.Location;
            if (string.IsNullOrEmpty(location))
                return false;



            //     string str = string.Format("{0} {1} {2} {3}", limit, nb, currentDuration.TotalMinutes.ToString("0"), track.ToString());
            string phase = select ? "ctl" : "load";

            if (!Logger.CreateNullLoggers)
            {
                string str = string.Format("{0} {1} {2} {3}", limit, nb, currentDuration, track.ToString());

                log("-->  {0} ok {1} ", phase, str);
            }

            var ok = checkStatus(string.Format("-->  {0}", phase), select, track, limit, real);

            if (!ok)
                return false;

            if (select && real && LimitItemLoader.ModeSelection)
            {
                var selected = selectMode.simple;
                if (dir.Histo)
                {
                    selected = selectMode.serial;
                    if (dir.HistoAll.HasValue && dir.HistoAll.Value)
                        selected = selectMode.histo;
                    if (dir.Serial)
                        selected = selectMode.serial;
                }
                else
                {
                    //if (!candidat.Serial && !candidat.Histo)
                    selected = selectMode.simple;
                }

                track.select(selected, limit);
                limit.Dir.Feeds.recordTrack(track, limit);
            }

            //report aux niveaux inférieurs
            if (real)
                parent.recordLimitItemCandidat(track, limit);
            return true;
        }




        private bool checkStatus(string phase, bool select, TrackInfoItunes track, LimitItem itemSource, bool real)
        {
            endByFd = null;
            _okFd = true;
            _okNb = true;
            bool ret = true;
            //        string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration.TotalMinutes.ToString("0"), track.ToString());
            //nbVirtuel = nb;
            //currentDurationVirtuel = currentDuration; 
            var nbBase = real ? nb : nbVirtuel;

            var _nb = nbBase + 1;
            var durationBase = real ? currentDuration : currentDurationVirtuel;
            var dur = durationBase + track.Duree;

            int _nbMax = select ? this.nbMax : this.loadNbMax;
            var _durationMax = select ? this.durationMax : this.loadDurationMax;

            if (_nb > _nbMax)
            {
                _okNb = false;
                if (real)
                {
                    if (LimitItemLoader.ModeSelection)
                        limit.NbFeedLimit = true;
                    if (!Logger.CreateNullLoggers)
                    {
                        string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration, track.ToString());
                        log("{0} stop nb {1} ", phase, str);
                    }
                    if (state != loadState.end)
                    {
                        state = loadState.end;
                        nbStop = _nb;
                    }
                }

                endByFd = false;
                ret = false;
            }



            // vérification des valeurs cumulées
            if (dur > _durationMax)
            {
                _okFd = false;
                if (real)
                {

                    if (!limit.DurationFeedLimit)
                    {
                        if (!Logger.CreateNullLoggers)
                        {
                            string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration, track.ToString());
                            log("{0} stop d. {1} ", phase, str);
                        }
                    }
                    if (LimitItemLoader.ModeSelection)
                        limit.DurationFeedLimit = true;
                    if (state != loadState.end)
                    {
                        state = loadState.end;
                        durationStop = dur;
                    }

                }

                //if (select || durationMax == loadDurationMax)
                //{
                //    if (ret)
                //    {
                //        var tb = new TrackBorderItem(limit, track, borderType.fd, dur, false);
                //        limit.signal(tb);
                //    }
                //    //limit.checkBorderFd(track, dur, false);
                //}

                if (endByFd == null)
                    endByFd = true;
                ret = false;
            }
            else
            {
                // endByFd = null;
                //if (select || durationMax == loadDurationMax)
                //{
                //    if (ret)
                //    {
                //        var tb = new TrackBorderItem(limit, track, borderType.fd, dur, true);
                //        limit.signal(tb);
                //    }
                //}
            }







            if (real)
            {
                nb += 1;
                currentDuration += track.Duree;
            }

            currentDurationVirtuel += track.Duree;
            nbVirtuel += 1;
            return ret;

        }

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\LimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
using pdb.podcast.Selection;
//using TimeSpan = pdb.util.timeSpan; 

namespace pdb.podcast.Load
{
    class LimitItemLoader
    {
        private static bool _selection;
        public static bool ModeSelection { get { return _selection; } set { _selection = value; } }
        private LimitItem limit;
        private LimitsLoader parent;
        private IDictionary<string, FeedLimitItemLoader> loaders = new BgDictString0<FeedLimitItemLoader>();
        //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacy = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacyRelax = new SequentialDictString<TrackInfoItunes>();
        private SequentialDictString<TrackInfoItunes> selected = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> exclu = new SequentialDictString<TrackInfoItunes>();
        /// <summary>
        /// Ensemble des tracks chargés en premier par la limite
        /// </summary>
        public List<TrackInfoItunes> use = new List<TrackInfoItunes>();
        private Logger log;
        timeSpan currentDuration = new timeSpan();
        timeSpan currentDurationVirtual = new timeSpan();
        timeSpan durationStop = new timeSpan();
        timeSpan currentContrib = new timeSpan();
        timeSpan trackDurationMax;
        timeSpan trackDurationMin;

        bool loadEqSel;

        public LimitItemLoader(LimitsLoader parent, LimitItem limit)
        {
            this.parent = parent;
            this.limit = limit;
            log = limit.Logger;

            trackDurationMax = timeSpan.FromMinutes(limit.Td);
            trackDurationMin = timeSpan.FromMinutes(limit.TdMin);
        }

        public void loadCandidats(List<TrackInfoItunes> _loaded)
        {
            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var duration = limit.Duration;
            //var _loadDuration = limit.LoadDuration; 
            loadEqSel = true;
            if (limit.Dir.Cascading)
            {
                var dd = limit.LoadDuration;
                if (dd > duration)
                {
                    loadEqSel = false;
                    duration = dd;
                }
            }

            if (loadEqSel)
                duration += 200;


            //var duration = limit.LoadDuration;
            var durationMax = timeSpan.FromMinutes(duration);
            var dateMin = limit.DateMin;
            var dateMax = limit.DateMax;

            foreach (TrackInfoItunes candidat in _loaded)
            {
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                if (standAlone.ContainsKey(location))
                    continue;

                var d = candidat.Pub;
                if (d < dateMin)
                    continue;

                var duree = candidat.Duree;
                if (duree > trackDurationMax)
                    continue;
                if (duree < trackDurationMin)
                    continue;
                Exporter.Record(candidat);

                bool okDate = d <= dateMax;
                //if (Conf.BorderVirtual)
                //    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, okDate, false));
                //if (!okDate)
                //    continue;
                //  var tb = new TrackBorderItem(limit, candidat, borderType.m    axdate, candidat.Pub, okDate);
                //  limit.signal(tb);

                //if (Conf.BorderVirtual)
                //{
                //     var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, border.);
                //      limit.signal(tb);
                //}

                //if (!okDate && !Conf.BorderVirtual)
                //    continue;


                var loader = getLoader(candidat.Album);
                bool _control = loader.control(candidat, false, okDate);

                //if (!_control && !Conf.BorderVirtual)
                //    continue;

                var currentDurationBase = (okDate && _control) ? currentDuration : currentDurationVirtual;
                var newDuration = currentDurationBase + candidat.Duree;
                bool okTotalDuration = newDuration <= durationMax;
                bool selected = _control && okTotalDuration; //
                bool okNb = loader.OkNb;

                ////question fd
                //if (loader.LoadEqSel)
                //{
                //    var dataRoot = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                //        loader.OkFd, loader.getDurationStop(okDate)
                //        , okNb, loader.getNbStop(okDate)
                //        , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, candidat, limit);

                //    Program.CauseRegister.signal(dataRoot); 

                //    var dataAuto =  new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                //        loader.OkFd, loader.getCurrentDuration(okDate)
                //        , okNb, loader.getNbStop(okDate)
                //        , okTotalDuration, newDuration, candidat, limit);

                //    limit.signal(dataAuto); 

                //    //Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
                //    //    loader.OkFd, loader.getDurationStop(okDate)
                //    //    , okNb, loader.getNbStop(okDate)
                //    //    , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

                //    //limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                //    //limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                //    //limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));



                //    if (okDate && _control && okTotalDuration)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedStrict));
                //    else if (okDate && okTotalDuration)
                //    {
                //        if (loader.EndByFd)
                //            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedStrict));
                //    }
                //    else if (Conf.BorderVirtual)
                //    {
                //        if (_control)
                //            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                //        else if (loader.EndByFd)
                //            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));
                //    }


                //    //if (!_control)
                //    //{
                //    //    if (okDate && okTotalDuration && loader.EndByFd)
                //    //    {
                //    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
                //    //        limit.signal(tb);
                //    //    }
                //    //    else if (Conf.BorderVirtual)
                //    //    {
                //    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
                //    //        limit.signal(tb);
                //    //    }
                //    //}
                //}

                //if (loadEqSel)
                //{
                //    // question d
                //    if (okDate && _control && okTotalDuration)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
                //    else if (okDate && _control)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
                //    else if (Conf.BorderVirtual)
                //    {
                //        if (okTotalDuration)
                //            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
                //        else
                //            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
                //    }
                //    //if (!okTotalDuration)
                //    //{
                //    //    if (okDate && _control)
                //    //    {
                //    //        var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict);
                //    //        limit.signal(tb);
                //    //    }
                //    //    else if (Conf.BorderVirtual)
                //    //    {
                //    //        var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight);
                //    //        limit.signal(tb);
                //    //    }
                //    //}

                //    // question date
                //    if (okDate && _control && okTotalDuration)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
                //    else if (_control && okTotalDuration)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
                //    else if (Conf.BorderVirtual)
                //    {
                //        if (okDate)
                //            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
                //        else
                //            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
                //    }

                //}



                //if (loadEqSel)
                //{
                //    if ((okDate && _control) || Conf.BorderVirtual)
                //    {
                //       var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okTotalDuration);
                //        limit.signal(tb);
                //    }
                //}

                //if ((okDate && _control))
                //{                   
                //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okTotalDuration,true);
                //    limit.signal(tb);
                //}

                //if (_control && okTotalDuration)
                //{
                //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate);
                //    limit.signal(tb);
                //}

                //if (okDate && okTotalDuration)
                //{
                //    if (!loader.limit.NbFeedLimit)
                //    {
                //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.CurrentDuration, _control);
                //        limit.signal(tb); 
                //    }
                //}

                // limit.checkBorderDates(candidat, selected);

                if (okDate && _control)
                    currentDuration += candidat.Duree; // newDuration; //
                currentDurationVirtual += candidat.Duree;

                // preloaded.Add(location, candidat);
                if (selected)
                {
                    standAlone.Add(location, candidat);
                    candidat.select(selectMode.standAlone, limit);

                }
                else if (okDate && _control && !okTotalDuration)
                {
                    //if (!limit.LoadDurationLimitAtteinte)
                    //    log.log("loadCandidats duréée limite atteinte {0}", (currentDuration)); //.TotalMinutes.ToString("0"));
                    //limit.LoadDurationLimitAtteinte = true;
                    if (durationStop.Value == 0)
                    {
                        durationStop = currentDuration;
                    }
                    // break;
                }

                //if (okDate && _control)
                //    currentDuration = newDuration; // += candidat.Duree;
                //   currentDurationVirtual += candidat.Duree;

            }

        }



        private bool control(TrackInfoItunes track, bool select, bool real)
        {
            var loader = getLoader(track.Album);
            return loader.control(track, select, real);
        }

        private FeedLimitItemLoader getLoader(string album)
        {

            FeedLimitItemLoader loader = null;
            if (!loaders.ContainsKey(album))
            {
                loader = new FeedLimitItemLoader(limit, album, parent);
                loaders.Add(album, loader);
                if (parent.state == loadState.selection)
                    loader.phase2();
            }
            else
                loader = loaders[album];
            return loader;
        }

        public void phase2()
        {
            currentDuration = new timeSpan();
            currentDurationVirtual = new timeSpan();

            if (_selection)
            {
                currentContrib = new timeSpan();
                limit.DurationLimitAtteinte = false;
                limit.ContributionLimitAtteinte = false;
                limit.DurationFeedLimit = false;
                limit.NbFeedLimit = false;
            }
            foreach (FeedLimitItemLoader loader in loaders.Values)
                loader.phase2();
        }

        public void recordGuest(TrackInfoItunes track, LimitItem itemSource)
        {
            if (itemSource == limit)
                return;
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            if (standAlone.ContainsKey(location))
                return;
            bool transmitTotal = limit.Dir.TransmitTotalGuest;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;


            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {

                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);
            }
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        {
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            if (standAlone.ContainsKey(location))
                return;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;
            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {
                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);

            }
        }

        public void Selection()
        {
            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var histo = limit.Dir.Histo;

            var relax = legacyRelax.List;

            if (histo)
                relax.Sort(new PodCastComparer());
            else
                relax.Sort(new PodCastComparerInv());
            selection(relax, false, false);

            var list = legacy.List;
            if (histo)
                list.Sort(new PodCastComparer());
            else
                list.Sort(new PodCastComparerInv());

            selection(list, false, true);



            var list2 = standAlone.List;
            if (histo)
                list2.Sort(new PodCastComparer());
            else
                list2.Sort(new PodCastComparerInv());

            selection(list2, true, true);

        }

        private void selection(ICollection<TrackInfoItunes> list, bool select, bool increment)
        {
            var duration = limit.Duration;
            var durationMax = timeSpan.FromMinutes(duration);
            var contributionMax = timeSpan.FromMinutes(limit.Contribution);



            foreach (TrackInfoItunes candidat in list)
            {
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;
                //if (_selection && selected.ContainsKey(location))
                //    continue;
                // vérification à postériori par rapports aux différents niveaux
                bool newContribut = candidat.Selected;

                var d = candidat.Pub;
                bool okDate = d <= limit.DateMax;
                var loader = getLoader(candidat.Album);
                bool _control = loader.control(candidat, select, okDate);

                //if (!loader.LoadEqSel)
                //{

                //    if (_control)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                //    else if (loader.EndByFd)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

                //}

                if (!increment && !_selection) //!loader.LoadEqSel &&
                {
                    //  if (!loader.OkNb)
                    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
                    // if (!loader.OkFd)
                    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

                    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
                    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

                    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                }

                //if (!control(candidat, select, okDuration))
                //    continue;

                if (increment)
                {

                    if (okDate && _control)
                        currentDuration += candidat.Duree;
                    currentDurationVirtual += candidat.Duree;

                    var newDuration = okDate && _control ? currentDuration : currentDurationVirtual;

                    bool okTotalDuration = newDuration <= durationMax;

                    if (!_selection)
                    {
                        //question fd
                        //if (!loader.LoadEqSel)
                        //{
                        var dataRoot = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                      loader.OkFd, loader.getDurationStop(okDate)
                      , loader.OkNb, loader.getNbStop(okDate)
                      , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, candidat, limit);

                        limit.Dir.CauseRegister.signal(dataRoot);

                        var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                            loader.OkFd, loader.getCurrentDuration(okDate)
                            , loader.OkNb, loader.getNb(okDate)
                            , okTotalDuration, newDuration, candidat, limit);

                        limit.signal(dataAuto);
                    }




                    //   Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
                    //loader.OkFd, loader.getDurationStop(okDate)
                    //, loader.OkNb, loader.getNbStop(okDate)
                    //, okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

                    //   limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                    //   limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                    //   limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));

                    if (Conf.BorderTb)
                    {
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict));
                        else if (okDate && okTotalDuration)
                        {
                            if (loader.EndByFd)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict));
                        }
                        //else if (Conf.BorderVirtual)
                        //{
                        //    if (_control)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedLight));
                        //    else if (loader.EndByFd)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedLight));
                        //}


                        //}

                        //if (!loadEqSel)
                        //{
                        // question d
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
                        else if (okDate && _control)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okTotalDuration)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
                        }


                        // question date
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
                        else if (_control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okDate)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
                        }

                        //}

                    }


                    ////question duree
                    //if (okDate && _control) // || Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, true); limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, false); limit.signal(tb);
                    //}

                    ////question fd

                    //if (_control)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict); limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight); limit.signal(tb);

                    //    }
                    //}
                    //else //if (!loader.limit.NbFeedLimit)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
                    //        limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
                    //        limit.signal(tb);
                    //    }
                    //}
                    ////question date
                    //if (_control && okDuration)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, true);
                    //    limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, false);
                    //    limit.signal(tb);
                    //}



                    //if (!_control && !Conf.BorderVirtual)
                    //    continue;
                    if (!okDate)
                        continue;

                    if (!_control)
                        continue;
                    if (!okTotalDuration)
                    {
                        if (!Logger.CreateNullLoggers)
                            log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

                        if (_selection)
                            limit.DurationLimitAtteinte = true;
                        if (durationStop.Value == 0)
                            durationStop = currentDuration;

                    }

                    if (!okTotalDuration)
                        continue;


                    if (_selection && !newContribut)
                    {

                        currentContrib += candidat.Duree;
                        if (currentContrib > contributionMax)
                        {
                            log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
                            limit.ContributionLimitAtteinte = true;
                            break;
                        }

                        use.Add(candidat);
                    }


                    if (_selection)
                    {

                        // enregistrement pour stockage et stats
                        limit.Dir.recordTrack(candidat, limit);

                        selected.Add(location, candidat);

                        if (select)
                            exclu.Add(location, candidat);
                    }





                }

            }
        }

        public LimitItem Item { get { return limit; } }

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\LimitsLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;

using pdb.podcast.Tuning;
using pdb.util.list;
using pdb.util;
using pdb.podcast.Report;
using System.Xml;
using pdb.podcast.Selection;

namespace pdb.podcast.Load
{
    public interface IWriter
    {
        void StartElement(string elt);
        void SetAttribute(string name, object value);
        void EndElement();
    }
    public class WriterXml : IWriter
    {
        private XmlWriter writer;
        public WriterXml(XmlWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            writer.WriteStartElement(elt);
        }

        public void SetAttribute(string name, object value)
        {
            writer.WriteAttributeString(name, value.ToString());
        }

        public void EndElement()
        {
            writer.WriteEndElement();
        }
    }

    public class WriterHtml : IWriter
    {
        private ITextWriter writer;
        int level;
        void beginLine()
        {
            writer.AppendLine();
            for (int i = 0; i < level; i++)
                writer.Append("\t");
        }
        public WriterHtml(ITextWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            StartElement(elt, null);
        }

        private void StartElement(string elt, string class_)
        {
            beginLine();
            if (string.IsNullOrEmpty(class_))
                writer.Append("<div>");
            else
            {
                writer.Append("<div class='");
                writer.Append(class_);
                writer.Append("'>");
            }
            if (elt.Length > 1)
            {
                writer.Append(elt);
                writer.Append("&nbsp;");
            }
            level++;
        }


        public void Start(string elt)
        {
            StartElement(elt, "tree");
        }

        public void SetAttribute(string name, object value)
        {
            if (name == "track")
            {
                writer.Append("<span class='track'>");
                writer.Append(value);
                writer.Append("</span>");

            }
            else if (name == "album")
            {
                writer.Append("<span class='album'>");
                writer.Append(value);
                writer.Append("</span>");
            }
            else
            {
                writer.Append(name);
                writer.Append("=");
                writer.Append(value);
            }
            writer.Append("&nbsp");

        }

        public void EndElement()
        {
            level--;
            beginLine();
            writer.Append("</div>");
        }
    }

    public
    class LimitsLoader
    {
        private DirConf dir;
        private Limits limit;
        // private IDictionary<string, TrackInfoItunes> loaded;
        private LimitLoader[] limites = new LimitLoader[Limits.NB];
        public loadState state;
        private Logger log;
        private static IWriter writer;
        public LimitsLoader(DirConf dir)
        {
            this.dir = dir;
            this.limit = dir.Limites;
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i] = new LimitLoader(this, limit[i]);
            }
            log = Logger.getLogger(dir.getPath() + "\\dir", null, false);
        }

        public void loadCandidats()
        {
            try
            {
                var feeds = dir.Feeds; 
                string feedName = null;
                bool histo = dir.Histo;
                bool? histoAll = dir.HistoAll;
                if (histo && false.Equals(histoAll))
                    feedName = dir.Name;

                bool? dirInfo = dir.Info;
                bool? dirRare = dir.Rare;

                var _loaded = feeds.Loaded;
                List<TrackInfoItunes> loaded = new List<TrackInfoItunes>();



                foreach (TrackInfoItunes track in _loaded)
                {

                    if (feedName != null && track.Album != feedName)
                        continue;

                    if (dirInfo.HasValue && dirInfo.Value != track.Info)
                        continue;

                    if (dirRare.HasValue && dirRare.Value != track.Rare)
                        continue;
                    loaded.Add(track);
                }

                if (histo)
                    loaded.Sort(new PodCastComparer());
                else
                    loaded.Sort(new PodCastComparerInv());



                for (int i = 0; i < Limits.NB; i++)
                {
                    limites[i].loadCandidats(loaded);
                }
            }
            finally
            {
                state = loadState.selection;
            }
        }

        private bool recordGuests;
        public void phase2()
        {
            state = loadState.selection;
            if (dir.Cascading)
                recordGuests = true;
            foreach (LimitLoader item in limites)
            {
                item.phase2();
            }
        }

        public void recordLimitItemCandidat(TrackInfoItunes track, LimitItem item)
        {

            if (!recordGuests)
                return;


            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].recordGuest(track, item);
            }
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        {
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].recordTrackFromChild(track, itemSource, transmitTotal);
            }
        }


        public void WriteLists()
        {
            if (dir.Parent == null || Conf.WritePlayLists)
            {
                // var preSel = feeds.PreSel;
                var list = dir.getListe();

                var limits = dir.Limites;
                var usegenPrior = Conf.GenUsePrior;
                var exclugenPrior = Conf.GenExcluPrior;

                for (int i = 0; i < Limits.NB; i++)
                {
                    var limit = limites[i];
                    List<TrackInfoItunes> items;
                    foreach (LimitItemLoader item in limit.Items)
                    {
                        // var index = limit.index(item);
                        if (Conf.WriteItems)
                        {
                            items = item.exclu.List; // list.FindAll(t => t.containsSelect(item));
                            buildList(item.Item.ID, items, "_sel");
                        }

                        if (Conf.WritePreSel)
                        {
                            items = item.standAlone.List; // preSel.FindAll(t => t.containsStandAlone(item));
                            buildList(item.Item.ID, items, "_sel0");
                        }
                        if (Conf.WriteUse)
                        {
                            items = item.use;
                            buildList(item.Item.ID, usegenPrior, items, "_use");
                        }
                        if (Conf.WriteExclu)
                        {
                            var limite = item.Item;
                            items = item.use.FindAll(t => t.Exclu == limite);
                            buildList(item.Item.ID, exclugenPrior, items, "_exclu");
                        }

                    }
                }

                //if (dir.Parent == null)
                //{
                if (dir.Parent == null)
                {

                    var lfolders = dir.Folders;

                    buildListPrior("_auto", list, lfolders);

                    var lHisto = list.FindAll(t => t.Histo);
                    buildList("_histo", lHisto, lfolders);

                    var lPasHisto = list.FindAll(t => !t.Histo);
                    buildList("_pasHisto", lPasHisto, lfolders);

                    var lSerie = list.FindAll(t => t.Serial);
                    buildList("_serie", lSerie, lfolders);
                }
                // }
            }
        }



        private static void buildList(string name, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, int.MaxValue, folder);
        }

        private static void buildList(string name, int prior, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, prior, folder);
        }

        private static void buildList(string name, List<TrackInfoItunes> list, List<string> folders)
        {
            Program.buildList(name, list, folders);
        }
        private static void buildListPrior(string name, List<TrackInfoItunes> list, List<string> folders)
        {
            Program.buildList(name, list, 0, folders);
        }



        private void writeStat(GroupStat stat, bool? onlyUse)
        {
            writeStat(stat.Total, onlyUse);
        }

        private void writeStat(DoubleStat stat, bool? onlyUse)
        {
            if (onlyUse == null)
                return;
            string strStat = "";
            if (true == onlyUse)
                strStat = stat.getUseValues();
            else
                strStat = stat.getStats();
            writer.SetAttribute("stats", strStat);
        }

        private void writeTrackList(List<TrackInfoItunes> list, bool includeAlbum, bool includeLevel, bool includeItem)
        {
            var conf = Conf.Html;
            int nbmax = conf.trackCause;
            int nb = 0; 
            foreach (TrackInfoItunes track in list)
            {
                nb++; 
                writer.StartElement("t");
                writer.SetAttribute("date", track.Pub);
                if (includeItem)
                {
                    writer.SetAttribute("i", track.GetProvider());
                    if (conf.trackItemDetail)
                    {
                        var lim = track.Provider;
                        if (lim != null)
                        {
                            var sb = new StringBuilder();
                            lim.writeStatHeader(sb);
                            lim.Stat.Total.buildValues(sb);
                            writer.SetAttribute("stats", sb.ToString());
                        }
                    }
                    
                }

                if (includeAlbum)
                    writer.SetAttribute("album", track.Album);
                if (includeLevel)
                    writer.SetAttribute("l", (track.Rating / 20).ToString());
                writer.SetAttribute("track", track.Name);
                if (nb <= nbmax)
                {
                    WriteCause(dir.CauseRegister.Get(track),true,true);
                    WriteCause(dir.CauseRegister.Get(track), true, false);
                    WriteCause(dir.CauseRegister.Get(track), false, true);
                    WriteCause(dir.CauseRegister.Get(track), false,false);

                }
                writer.EndElement();
            }
        }

        private List<TrackInfoItunes> getItems(DirConf dir, DoubleStat stat)
        {
            var items = new List<TrackInfoItunes>(stat.Use.List);
            if (dir.Histo)
                items.Sort(new PodCastComparer());
            else
                items.Sort(new PodCastComparerInv());
            return items;

        }

        internal void writeTracks(DirConf dir, GroupStat stat, bool? onlyUseStat, bool includeTrackItem)
        {
            writeStat(stat, onlyUseStat);

            var items = getItems(dir, stat.Total);
            if (items.Count == 0)
                return;

            int nbLevel = 0;



            #region tracks
            writer.StartElement("tracks");

            for (int i = 0; i < Limits.NB; i++)
            {
                var soutot = stat.SousTotaux[i];
                if (soutot.Empty)
                    continue;
                nbLevel++;
                if (nbLevel > 1)
                    break;
            }
            if (nbLevel > 1)
            {
                #region levels
                writer.StartElement("levels");
                for (int i = 0; i < Limits.NB; i++)
                {
                    var soutot = stat.SousTotaux[i];
                    if (soutot.Empty)
                        continue;
                    #region level
                    writer.StartElement("level");
                    writer.SetAttribute("level", i.ToString());
                    writeStat(soutot, true);
                    var subItems = getItems(dir, soutot);
                    #region subItems
                    writeTrackList(subItems, true, false, includeTrackItem);

                    #endregion

                    writer.EndElement();
                    #endregion

                }
                writer.EndElement();
                #endregion
            }

            writeTrackList(items, true, true, includeTrackItem);

            writer.EndElement();
            #endregion


            if (false != dir.HistoAll)
            {
                int nbAlbum = 0;
                foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                {
                    var listInAlbum = items.FindAll(t => t.Album == f.Album);
                    if (listInAlbum.Count == 0)
                        continue;
                    nbAlbum++;
                    if (nbAlbum > 1)
                        break;
                }
                if (nbAlbum > 1)
                {
                    #region albums
                    writer.StartElement("albums");
                    foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                    {
                        var listInAlbum = items.FindAll(t => t.Album == f.Album);
                        if (listInAlbum.Count == 0)
                            continue;
                        #region album
                        writer.StartElement("album");
                        writer.SetAttribute("name", f.Album);

                        writeStat(f.Totaux, true);
                        writeTrackList(listInAlbum, false, true, includeTrackItem);

                        writer.EndElement();
                        #endregion

                    }
                    writer.EndElement();
                    #endregion
                }
            }
        }
        public static IWriter Writer { set { writer = value; } }
        public void WriteTracksPre()
        {
            if (writer is WriterHtml && dir.Parent == null)
            {
                (writer as WriterHtml).Start("dir");
            }
            else
                writer.StartElement("dir");
            writer.SetAttribute("name", this.dir.Name);




            var dirStat = dir.Stat;
            if (dirStat == null)
                return;

            writeTracks(dir, dir.Conteneur.Tracks, true, true);

            var limits = dir.Limites;


            bool hasLimit = false;
            #region limites
            for (int i = 0; i < Limits.NB; i++)
            {
                var limit = limites[i];
                bool hasLimitItem = false;

                var limite = limit.Limit;
                var limitStat = limite.Stat;
                if (limitStat == null)
                    continue;
                if (limitStat.Total.Empty)
                    continue;


                if (!hasLimit)
                {
                    writer.StartElement("limites");
                    writeTracks(dir, dir.Stat, true, true);
                }
                hasLimit = true;

                #region limite
                writer.StartElement("limite");
                writer.SetAttribute("level", i.ToString());

                writeTracks(dir, limitStat, true, true);


                #region items
                foreach (LimitItemLoader item in limit.Items)
                {
                    var lim = item.Item;
                    var items = item.use;
                    if (items.Count == 0)
                        continue;
                    if (!hasLimitItem)
                        writer.StartElement("items");
                    hasLimitItem = true;

                    #region item
                    writer.StartElement("i");
                    writer.SetAttribute("name", lim.ToString().Replace(dir.getPath(), ""));
                    var sb = new StringBuilder();
                    lim.writeStatHeader(sb);
                    lim.Stat.Total.buildValues(sb);
                    writer.SetAttribute("stats", sb.ToString());

                    writeTracks(dir, lim.Stat, null, false);

                    writer.EndElement();
                    #endregion
                }
                if (hasLimitItem)
                    writer.EndElement();
                #endregion
                writer.EndElement();
                #endregion

            }
            if (hasLimit)
                writer.EndElement();
            #endregion


        }

        private void WriteCause(Causes causes, bool strict, bool ok)
        {
            //  writer.StartElement("causes");
            foreach (CauseItem cause in causes.getCauses(strict,ok, ok)) 
            {
                string str = "cause"; 
                if (strict)
                    str+="strict";
                if (!ok)
                    str += "nok"; 
                writer.StartElement(str);

            
                writer.SetAttribute("type", cause.type);
                writer.SetAttribute("val", cause.val);


                var lim = cause.limit as LimitItem;


                #region item
                //  writer.StartElement("i");
                writer.SetAttribute("name", lim.ToString());
                if (Conf.Html.trackCauseItemDetail)
                {
                    var sb = new StringBuilder();
                    lim.writeStatHeader(sb);
                    lim.Stat.Total.buildValues(sb);
                    writer.SetAttribute("stats", sb.ToString());
                }

                //   writer.EndElement();
                #endregion


                writer.EndElement();
            }
            //     writer.EndElement();
        }
        public void WriteTracksPost()
        {
            if (Conf.Html.writeCause >0)
            {
                if (dir.Parent == null)
                {
                    int nbMax = Conf.Html.writeCause;
                    int nb = 0; 
                    #region nonretenus
                    writer.StartElement("exclus");
                    var list =  dir.CauseRegister.getList(true);
                    foreach (Causes causes in list)
                    {
                        nb++;
                        if (nb > nbMax)
                            break; 
                        var track = causes.candidat;
                        writer.StartElement("t");
                        writer.SetAttribute("date", track.Pub);
                        writer.SetAttribute("album", track.Album);
                        writer.SetAttribute("l", (track.Rating / 20).ToString());
                        writer.SetAttribute("track", track.Name);

                        WriteCause(causes,true,true);
                        WriteCause(causes, true, false);

                        WriteCause(causes, false, true);
                        WriteCause(causes, false,false);
                        writer.EndElement();
                    }
                    writer.EndElement();
                    #endregion
                }
            }
            writer.EndElement();

        }

        public void SelectionPre()
        {
            if (dir.SelectionPre)
                selection();
        }

        public void SelectionPost()
        {
            if (!dir.SelectionPre)
                selection();
        }

        private void selection()
        {

            log.log("{0} Selection", dir);

            for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
            {
                var limit = limites[i];
                limit.Selection();

            }

        }

    }
}]]></content>
  </file>
  <file path="\pdb.podcast\Selection\CauseData.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using pdb.podcast.Tuning;
using pdb.podcast.Auto;

namespace pdb.podcast.Selection
{
    //public class CauseData
    //{
    //    public readonly bool ok;
    //    public readonly borderType type;
    //    public readonly timeSpan val;
    //    public readonly LimitItemBase limit;
    //    public readonly TrackInfoItunes candidat;
    //    public CauseData(bool ok, borderType type, timeSpan val, LimitItemBase limit, TrackInfoItunes candidat)
    //    {
    //        this.ok = ok;
    //        this.type = type;
    //        this.val = val;
    //        this.limit = limit;
    //        this.candidat = candidat;
    //    }
    //    public override string ToString()
    //    {
    //        return string.Format("{0} {1} {2} {3} {4}", ok, type, val, limit, candidat);
    //    }
    //}

    public class CauseDataValue
    {
        public readonly byte mode;
        public readonly borderType type;
        public readonly timeSpan val;
        public bool virtuel; 

        public CauseDataValue(bool ok, borderType type, timeSpan val, bool selected)
        {
            this.mode = Conv.getMode(ok, selected); 
            this.type = type;
            this.val = val;
        }

        public override string ToString()
        {
            return string.Format("ok={0} s={1} {2} {3} {4}", mode.Success(), mode.Selected(), type, val, virtuel);
        }

        public bool Ok { get { return mode.Success(); } }
    }

    public class CauseDatas
    {
        public readonly LimitItemBase limit;
        public readonly TrackInfoItunes candidat;
        public CauseDataValue[] datas = new CauseDataValue[Causes.NB_TYPE];
        public CauseDatas(bool okDate, timeSpan vdate,
                          bool okFd, timeSpan vfd,
                          bool okNb, int nb,
                          bool okD, timeSpan vd,
                          TrackInfoItunes candidat,
                          LimitItemBase limit)
        {
            this.limit = limit;
            this.candidat = candidat;
            var selected = candidat.Selected; 
            datas[(int)borderType.maxdate] = new CauseDataValue(okDate, borderType.maxdate, vdate, selected);
            datas[(int)borderType.fd] = new CauseDataValue(okFd, borderType.fd, vfd, selected);
            datas[(int)borderType.nb] = new CauseDataValue(okNb, borderType.nb, timeSpan.FromMinutes(nb), selected);
            datas[(int)borderType.d] = new CauseDataValue(okD, borderType.d, vd, selected);  
           
        }

        public CauseDatas(bool ok, borderType type, timeSpan val, LimitItemBase limit, TrackInfoItunes candidat)
        {
            this.limit = limit;
            this.candidat = candidat;
            datas[(int)type] = new CauseDataValue(ok, type, val, candidat.Selected); 
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Selection\CauseItem.cs">
    <content><![CDATA[using pdb.podcast.Auto;
using pdb.podcast.Tuning;
using pdb.util;

namespace pdb.podcast.Selection
{
    class CauseItem
    {
       
        public readonly LimitItemBase limit;
        public readonly borderType type;
        public readonly timeSpan val;
        public readonly byte mode;
        //public CauseItem(borderType type, bool success, timeSpan val, LimitItemBase limit,bool selected)
        //{
        //    this.mode = Conv.getMode(success, selected); 
        //    this.type = type;
        //    this.val = val;
        //    this.limit = limit;
        //}

        public CauseItem(CauseDataValue cd,LimitItemBase limit)
        {
            this.mode = cd.mode;
            this.type = cd.type;
            this.val = cd.val;
            this.limit = limit; 
        }

      

        public bool Ok { get { return mode.Success();  } }
        public bool Selected { get { return mode.Selected(); } }

        public override string ToString()
        {
            var str = "";
            if (!Ok)
                str = "nok";
            var strSelected = "s";
            if (!Selected)
                strSelected = "ns"; 
            return string.Format("{0} {1} {2} {3} {4}", type, str,strSelected, val, limit);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Selection\Causes.cs">
    <content><![CDATA[using pdb.podcast.Auto;
using pdb.podcast.Tuning;
using pdb.util;
using System;
using System.Collections.Generic;

namespace pdb.podcast.Selection
{
    class Causes
    {
        public Causes(TrackInfoItunes candidat)
        {
            this.candidat = candidat;
        }
        public readonly TrackInfoItunes candidat;
        public const int NB_TYPE = 4;
        private const int NB_MODE = 8; 
        private CauseItem[,] causes = new CauseItem[NB_MODE, NB_TYPE];
        //private CauseItem[] causesStrict = new CauseItem[NB];

        //private CauseItem[] causesRejet = new CauseItem[NB];
        //private CauseItem[] causesRejetStrict = new CauseItem[NB];
       // private bool selected;

        //public void check(bool okDate, timeSpan vdate,
        //                  bool okFd, timeSpan vfd,
        //                  bool okNb, int nb,
        //                  bool okD, timeSpan vd,
        //                  LimitItemBase limit)
        //{

        //    check(okDate, borderType.maxdate, vdate, limit);

        //    check(okFd, borderType.fd, vfd, limit);

        //    check(okNb, borderType.nb, timeSpan.FromMinutes(nb), limit);

        //    check(okD, borderType.d, vd, limit);

        //}

        public void check(CauseDatas cd)
        {
            //if (cd.candidat.Name == "Littérature chinoise en ligne 14.11.12")
            //{
            //}
            int nb = 0;
            int nbSuccess = 0;
            foreach (CauseDataValue cdv in cd.datas)
            {
                if (cdv == null)
                    continue;
                nb++;
                if (cdv.Ok)
                    nbSuccess++;
                if (!cdv.virtuel)
                    check(cdv, cd.limit, false);  //(cdv.ok, cdv.type, cdv.val, cd.limit, false);
            }
            if (nb < 2)
                return;
            if (nbSuccess < nb - 1)
                return;
            bool thisSuccess = nbSuccess == nb;
            foreach (CauseDataValue cdv in cd.datas)
            {
                if (cdv == null)
                    continue;
                if (cdv.virtuel)
                    continue;
                if (thisSuccess)
                    check(cdv, cd.limit, true); //(cdv.ok, cdv.type, cdv.val, cd.limit, true);
                else
                {
                    if (cdv.Ok)
                        continue;
                    check(cdv, cd.limit,true); //   cdv.ok, cdv.type, cdv.val, cd.limit, true);
                }
            }

            //if (!selected && thisSuccess)
            //{
            //    int mode = getMode(true, true);
            //    selected = true;
            //    for (int i = 0; i < NB; i++)
            //        causes[mode,i] = null;
            //}

            //if (selected)
            //{
            //    if (thisSuccess)
            //    {
            //        foreach (CauseDataValue cdv in cd.datas)
            //        {
            //            if (cdv == null)
            //                continue;
            //            if (cdv.virtuel)
            //                continue;
            //            check(cdv.ok, cdv.type, cdv.val, cd.limit, true);
            //        }
            //    }
            //}
            //else
            //{
            //    foreach (CauseDataValue cdv in cd.datas)
            //    {
            //        if (cdv == null)
            //            continue;
            //        if (cdv.ok)
            //            continue;
            //        if (cdv.virtuel)
            //            continue;
            //        check(cdv.ok, cdv.type, cdv.val, cd.limit, true);
            //    }
            //}
        }

        //private int getMode(bool strict, bool ok, bool selected)
        //{
        //    return 4 * Convert.ToInt32(strict) + (int)Conv.getMode(ok, selected);
        //}

        private int getMode(byte mode,  bool strict)
        {
            return 4 * Convert.ToInt32(strict) + (int)mode;
        }

        private void check(CauseDataValue cd, LimitItemBase limit, bool strict)
        {
            int index = (int)cd.type;
            int mode = getMode(cd.mode, strict);

            CauseItem cause = causes[mode, index];


            if (cause == null)
            {
                causes[mode, index] = new CauseItem(cd, limit);
            }
            else
            {
                bool record = false;
                var ok = cd.Ok;
                var val = cd.val; 
                if (ok && val.Value > cause.val.Value)
                    record = true;
                else if (!ok && val.Value < cause.val.Value)
                    record = true;
                if (record)
                    causes[mode, index] = new CauseItem(cd, limit);
            }
        }


        //private void check(bool ok, borderType type, timeSpan val, LimitItemBase limit, bool strict, bool selected)
        //{
        //    int index = (int)type;
        //    int mode = getMode(strict, ok, selected);

        //    // virtuel nok -> 0
        //    // virtuel ok -> 1
        //    // strict nok -> 2
        //    //strict ok -->3

        //    CauseItem cause = causes[mode, index];


        //    if (cause == null)
        //    {
        //        causes[mode, index] = new CauseItem(type, ok, val, limit,selected);
        //    }
        //    else
        //    {
        //        bool record = false;
        //        if (ok && val.Value > cause.val.Value)
        //            record = true;
        //        else if (!ok && val.Value < cause.val.Value)
        //            record = true;
        //        if (record)
        //            causes[mode, index] = new CauseItem(type, ok, val, limit,selected);
        //    }

        //}

        public List<CauseItem> getCauses(bool strict, bool ok, bool selected)
        {
            var m = Conv.getMode(ok, selected); 
            int mode = getMode(m, strict);
            var list = new List<CauseItem>();
            // var causes = strict ? this.causesStrict : this.causes;
            for (int i = 0; i < NB_TYPE; i++)
            {
                var cause = causes[mode, i];
                if (cause != null) // && cause.val.Value >0)
                    list.Add(cause);
            }

            return list;
        }

        public CauseItem getCause(borderType type, bool strict, bool ok, bool selected)
        {
            //var causes = strict ? this.causesStrict : this.causes;
            var mode = Conv.getMode(ok, selected); 
            return causes[getMode(mode,strict), (int)type];
        }

        public override string ToString()
        {
            var sb = new pdb.util.StringBuilder();
            sb.Append(candidat);
            sb.AppendLine();
            foreach (CauseItem item in causes)
            {
                if (item != null)
                    sb.AppendLine(item.ToString());
            }
            return sb.ToString();

        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Selection\Conv.cs">
    <content><![CDATA[using System;

namespace pdb.podcast.Selection
{
    public static class Conv
    {
        public static bool Success(this byte mode) { return (int)mode % 2 == 1; }
        public static bool Selected(this byte mode)  { return mode >= 2; }

        public static byte getMode(this bool succes, bool selected)
        {
            return (byte)(2 * Convert.ToInt16(selected) + Convert.ToInt16(succes));
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\LimitItem.cs">
    <content><![CDATA[using System;
using pdb.util;
using pdb.podcast.Report;
using pdb.podcast.Auto;
using System.Collections.Generic;
using pdb.podcast.Selection;

namespace pdb.podcast.Tuning
{
    /// <summary>
    /// Item de limite concernant la durée 
    /// </summary>
    public class LimitItem : LimitItemBase, IBuilderSource, IBorder
    {


        /// <summary>
        /// Détailler le rapport - à bouger
        /// </summary>
        public static bool includeDetail;


        public int Level { get { return limit.Level; } }
        public int Rating { get { return limit.Level * 20; } }



        private Limit limit;
        private TripleStat stats = new TripleStat();


        public override string ToString()
        {
            if (nb == 0 || feedDuration == 0)
                return Dir.ToString() + string.Format("\\{0}", limit.Level);
            return Dir.ToString() + string.Format("\\{0}:{1} {2} {3} {4} {5} {6} {7} {8}", limit.Level, getS("d", duration), getS("c", contribution), getS("fd", feedDuration), getS("nb", nb), getS("td", td), getS("tdMin", tdMin), getS("date", dateMin), getS("dateMax", dateMax));
        }

        private static string getS(string desc, int v)
        {
            if (v < int.MaxValue && v > 0)
                return string.Format("{0}={1}", desc, v);
            return "";
        }

        private static string getS(string desc, double v)
        {
            if (v < int.MaxValue && v > 0)
                return string.Format("{0}={1}", desc, v);
            return "";
        }

        private static string getS(string desc, DateTime v)
        {
            if (v > DateTime.MinValue && v < DateTime.MaxValue)
                return string.Format("{0}={1}", desc, v);
            return "";
        }



        public void recordTrackMoy(TrackInfoItunes track, int countItems)
        {
            stats.recordTrack(track, countItems);
        }


        private bool durationLimitAtteinte;
        private bool contributionLimitAtteinte;
        private bool durationFeedLimit;
        private bool nbFeedLimit;
        public bool DurationLimitAtteinte { get { return durationLimitAtteinte; } set { durationLimitAtteinte = value; } }
        public bool ContributionLimitAtteinte { get { return contributionLimitAtteinte; } set { contributionLimitAtteinte = value; } }
        //private bool loadDurationLimitAtteinte;
        //public bool LoadDurationLimitAtteinte { get { return loadDurationLimitAtteinte; } set { loadDurationLimitAtteinte = value; } }

        public bool DurationFeedLimit { set { durationFeedLimit = value; } get { return durationFeedLimit; } }
        public bool NbFeedLimit { set { nbFeedLimit = value; } get { return nbFeedLimit; } }

        #region border
        public bool checkPub(TrackInfoItunes candidat)
        {
            var d = candidat.Pub;
            if (d < dateMin)
                return false;
            if (d > dateMax)
                return false;
            return true;
        }
        #endregion
        //#region border
        ///// <summary>
        ///// track In le plus près de la limite dateMin
        ///// </summary>
        //TrackInfoItunes borderDateMinIn;
        ///// <summary>
        ///// Track rejeté le plus près de la limite dateMin
        ///// </summary>
        //TrackInfoItunes borderDateMinOut;

        ///// <summary>
        ///// track In le plus près de la limite dateMax
        ///// </summary>
        //TrackInfoItunes borderDateMaxIn;
        ///// <summary>
        ///// Track rejeté le plus près de la limite dateMax
        ///// </summary>
        //TrackInfoItunes borderDateMaxOut;

        ///// <summary>
        ///// Dernier accepté par rapport à la durée totale
        ///// </summary>
        //TrackInfoItunes borderDurationIn;
        ///// <summary>
        ///// Premier rejeté par rapport à la durée totale
        ///// </summary>
        //TrackInfoItunes borderDurationOut;

        //TimeSpan borderDurationValueIn;
        //TimeSpan borderDurationValueOut;

        ///// <summary>
        ///// Dernier accepté par rapport à la durée de feed
        ///// </summary>
        //TrackInfoItunes borderFdIn;
        ///// <summary>
        ///// Premier rejeté par rapport à la durée Feed
        ///// </summary>
        //TrackInfoItunes borderFdOut;

        //TimeSpan borderFdValueIn;
        //TimeSpan borderFdValueOut; 

        //public void clearBorder()
        //{
        //    borderDateMinIn = null;
        //    borderDateMinOut = null;
        //    borderDateMaxIn = null; 
        //    borderDateMaxOut = null;
        //    borderDurationIn = null;
        //    borderDurationOut = null;
        //    borderDurationValueIn = new TimeSpan();
        //    borderDurationValueOut = new TimeSpan();

        //    borderFdIn = null;
        //    borderFdOut = null;
        //    borderFdValueIn = new TimeSpan();
        //    borderFdValueOut = new TimeSpan(); 
        //}



        //// --------vIn----limit ------vout
        //public void checkBorderFd(TrackInfoItunes candidat, TimeSpan duration, bool selected)
        //{
        //    if (selected && duration.TotalMinutes <= this.feedDuration )
        //    {
        //        if (borderFdIn == null || duration > borderFdValueIn )
        //        {
        //            borderFdIn = candidat;
        //            borderFdValueIn = duration;
        //        }
        //    }
        //    else if (!selected && duration.TotalMinutes > this.feedDuration)
        //    {
        //        if (borderFdOut == null || duration < borderFdValueOut)
        //        {
        //            borderFdOut = candidat;
        //            borderFdValueOut = duration;
        //        }
        //    }
        //    else
        //    {
        //    }
        //    }

        //public void checkBorderDuration(TrackInfoItunes candidat, TimeSpan duration, bool selected)
        //{
        //    if (selected && duration.TotalMinutes <= this.duration)
        //    {
        //        borderDurationIn = candidat;
        //        borderDurationValueIn = duration;
        //    }
        //    else if (!selected && duration.TotalMinutes > this.duration)
        //    {
        //        if (borderDurationOut == null)
        //        {
        //            borderDurationOut = candidat;
        //            borderDurationValueOut = duration;
        //        }
        //    }
        //    else
        //    {
        //    }
        //}

        //public void checkBorderDates(TrackInfoItunes candidat, bool selected)
        //{
        //    // ---minOut --limit ---minIn ----
        //    var d = candidat.Pub;
        //    if (d < dateMin)
        //    {
        //        if (borderDateMinOut == null ||d > borderDateMinOut.Pub )
        //            borderDateMinOut = candidat;
        //    }
        //    else if (d>=dateMin && selected)
        //    {
        //        if (borderDateMinIn == null || d < borderDateMinIn.Pub)
        //            borderDateMinIn = candidat;

        //    }
        //    // ---maxIn --limit ---maxOut ----
        //    if (d > dateMax)
        //    {
        //        if (borderDateMaxOut == null || d < borderDateMaxOut.Pub)
        //            borderDateMaxOut = candidat;
        //    }
        //    else if (d <= dateMax &&selected)
        //    {
        //        if (borderDateMaxIn == null || d >borderDateMaxIn.Pub )
        //            borderDateMaxIn = candidat;
        //    }
        //}



        //#endregion

        public void writeStat(ITextWriter sbRapport)
        {
            writeStatHeader(sbRapport);
            stats.buildValues(sbRapport);

        }

        private LimitItemStat stat;
        internal LimitItemStat Stat
        {
            set
            {
                if (stat == null)
                    stat = value;
            }
            get { return stat; }
        }

        public void writeStatHeader(ITextWriter sbRapport)
        {
            //    if (loadDurationLimitAtteinte)
            //        sbRapport.Append("d");
            //    else
            //        sbRapport.Append(" ");

            if (durationLimitAtteinte)
                sbRapport.Append("d");
            else
                sbRapport.Append(" ");

          

            if (durationFeedLimit)
                sbRapport.Append("f");
            else
                sbRapport.Append(" ");

            if (nbFeedLimit)
                sbRapport.Append("n");
            else
                sbRapport.Append(" ");

            if (contributionLimitAtteinte)
                sbRapport.Append("c");
            else
                sbRapport.Append(" ");
            sbRapport.Append(" ");

        }

        public void getToTaux(ITextWriter sb)
        {

        }

        public void rapport(DescBuilder sb)
        {
            sb.Append("\t");
            //sb.Append(Dir.getPath());
            //sb.Append(" ");
            sb.Append(ToString());
            sb.Append(" ");
        }

        public DirConf Dir { get { return limit.Dir; } }
        public string id = null;
        public string ID
        {
            get
            {
                if (id == null)
                {
                    int index = limit.index(this);
                    if (index >= 0)
                        id = Dir.getPath() + "\\" + Level + "\\_" + (index + 1);
                    else
                        id = Dir.getPath() + "\\_" + Level;

                }
                return id;
            }
        }
        private Logger logger;

        public LimitItem(Limit limit)
        {
            this.limit = limit;
        }
        public Logger Logger
        {
            get
            {
                if (logger == null)
                {
                    logger = Logger.getLogger(ID, false);
                }
                return logger;
            }
        }

        public object Clone()
        {
            var limitiItem = new LimitItem(limit) { Nb = this.nb, Td = this.td, TdMin = this.tdMin, DateMin = this.dateMin, Contribution = this.contribution, Stat = this.stat };
            limitiItem.duration = this.duration;
            limitiItem.feedDuration = this.feedDuration;
            limitiItem.dateMax = this.dateMax;
            return limitiItem;

        }

        public Limit Limit { set { limit = value; } get { return limit; } }


        public List<TrackInfoItunes> getSelectedTracks()
        {
            if (stat == null)
                return new List<TrackInfoItunes>();
            return new List<TrackInfoItunes>(stat.Total.Use.List);
        }

        public double getTotalSize()
        {
            if (stat == null)
                return -1;
            return stat.Total.Use.getTotalSize();
        }

        public string getEmpreinte()
        {
            if (stat == null)
                return "NULL";
            return stat.Total.Use.getEmpreinte();
        }


        public void addBorderObs(IBorderTransmit auto)
        {
            throw new NotImplementedException();
        }

        public void signal(TrackBorderItem tb)
        {
            // en attendant d'implémenter les autos pour limitItem
            if (tb == null)
                return;
            switch (tb.type)
            {
                case borderType.d: if (!hduration) return;
                    break;
                case borderType.fd: if (!hfeedDuration) return;
                    break;
                case borderType.maxdate: if (!hdateMax) return;
                    break;
                default:
                    return;
            }
            limit.signal(tb);

        }


        public void signal(CauseDatas cd)
        {
            int nb = 0;
            for (int i = 0; i < Causes.NB_TYPE; i++)
            {
                var data = cd.datas[i];
                if (data == null)
                    continue;
                var type = data.type;

                switch (type)
                {
                    case borderType.d: if (!hduration) cd.datas[i].virtuel = true;
                        break;
                    case borderType.fd: if (!hfeedDuration) cd.datas[i].virtuel = true;
                        break;
                    case borderType.maxdate: if (!hdateMax) cd.datas[i].virtuel = true;
                        break;
                    default:
                        cd.datas[i].virtuel = true; break;
                }

                if (cd.datas[i] != null && !cd.datas[i].virtuel)
                    nb++;

            }

            //if (nb == 0)
            //    return; 
            this.limit.signal(cd);
        }


        public IDictionary<string, TrackInfoItunes> getAllTracks()
        {
            throw new NotImplementedException();
        }
    }
}
]]></content>
  </file>
</db>
