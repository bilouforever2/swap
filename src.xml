<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.player\ViewModel\AllTracksViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Windows.Input;
using System.Windows.Threading;
using pdb.player.ViewModel.Commande.Link;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.Commande;
using pdb.util;
using System.Globalization;

namespace pdb.player.ViewModel
{
    public enum listDisplay
    {
        all,
        onlyDisabled,
        onlyEnabled
    }

    public class AllTracksViewModel : List<TrackListViewModel>, INotifyCollectionChanged, INotifyPropertyChanged
    {
        public event NotifyCollectionChangedEventHandler CollectionChanged;
        public event PropertyChangedEventHandler PropertyChanged;
        //   private List<TrackListViewModel> tracks;
        private Dictionary<int, TrackListViewModel> dict;
        private object _lock = new object();
        private PlayListViewModel parent;
        private DispatcherOperation ope;
      


        private bool? onlyDisabled;
        private bool onlyFathers;
        public AllTracksViewModel(PlayListViewModel parent, bool? onlyDisabled, bool onlyFathers)
        {
            this.parent = parent;
            this.onlyDisabled = onlyDisabled;
            this.onlyFathers = onlyFathers;
            //   this.mode = mode; 
            build();
            PlayerViewModel.Instance.resumeChange += playerResumeChange;
            PlayerViewModel.autoChange += new EventHandler(PlayerViewModel_autoChange);
            //TrackListViewModel.CurrentHumanSelectedChanged += PlayerViewModel_autoChange; 
        }

        void PlayerViewModel_autoChange(object sender, EventArgs e)
        {
            OnPropertyChanged("AutoResume");        
        }


        void playerResumeChange(object sender, EventArgs e)
        {
            OnPropertyChanged("TV"); 
            OnPropertyChanged("Resume");
            OnPropertyChanged("AutoResume");  
        }

        public string Resume
        {
            get
            {
                return PlayerViewModel.Instance.Resume;
            }
            set
            {

            }
        }

        protected void OnCollectionChange(NotifyCollectionChangedEventArgs e)
        {
            // Be nice - use BlockReentrancy like MSDN said

            //var dispatcher = Dispatcher.CurrentDispatcher;
            //if (dispatcher.CheckAccess())
            //{
            //    if (CollectionChanged == null)
            //    {
            //    }
            //    else
            //    {
            //        CollectionChanged(this, e); 
            //    }
            //    return; 
            //}

            //dispatcher.Invoke(DispatcherPriority.DataBind, new Action<NotifyCollectionChangedEventArgs>(OnCollectionChange), e);



            var eventHandler = CollectionChanged;
            if (eventHandler != null)
            {
                Delegate[] delegates = eventHandler.GetInvocationList();
                // Walk thru invocation list
                foreach (NotifyCollectionChangedEventHandler handler in delegates)
                {
                    try
                    {
                        var dispatcherObject = handler.Target as DispatcherObject;
                        // If the subscriber is a DispatcherObject and different thread
                        if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                        // Invoke handler in the target dispatcher's thread
                        {
                            ope =
                               dispatcherObject.Dispatcher.BeginInvoke(DispatcherPriority.DataBind,
                                            handler, this, e);
                            ope.Completed += ope_Completed;


                        }
                        else // Execute handler as is
                            handler(this, e);
                    }
                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }
                }
            }
            else
            {
            }

            // PlayerViewModel.Instance.makeResume();

        }

        void ope_Completed(object sender, EventArgs e)
        {
            App.log.log(string.Format("AllTracksViewModel::OnCollectionChange {0} CollectionChanged completé", sender));
            PlayerViewModel.Instance.makeResume();
        }


        protected virtual void OnPropertyChanged(string propertyName)
        {
            var eventHandler = PropertyChanged;
            if (eventHandler == null)
            {
                //   int toto = 0;
            }
            else
            {
                //var dispatcher = Dispatcher.CurrentDispatcher;
                //if (dispatcher.CheckAccess())
                //    PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
                //else
                //    dispatcher.Invoke(new Action<string>(OnPropertyChanged), propertyName);

                Delegate[] delegates = eventHandler.GetInvocationList();
                // Walk thru invocation list
                foreach (PropertyChangedEventHandler handler in delegates)
                {
                    try
                    {
                        var dispatcherObject = handler.Target as DispatcherObject;
                        // If the subscriber is a DispatcherObject and different thread
                        if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                            // Invoke handler in the target dispatcher's thread
                            dispatcherObject.Dispatcher.BeginInvoke(DispatcherPriority.DataBind,
                                          handler, this, new PropertyChangedEventArgs(propertyName));
                        else // Execute handler as is
                            handler(this, new PropertyChangedEventArgs(propertyName));
                    }
                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }
                }
            }
        }

        public void refresh()
        {
            build();
            foreach (TrackListViewModel track in this)
                track.refresh();

        }

        //public void init()
        //{
        //    refresh();
        //    OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
        //}

        public TrackListViewModel TV { get { return TrackListViewModel.HumanSelected; } }

        public void build()
        {
            lock (_lock)
            {
                var list = new List<TrackListViewModel>();
                var dict = new Dictionary<int, TrackListViewModel>();
                buildAllTraks(list, dict, onlyDisabled, onlyFathers);
                if (this.dict == null)
                {
                    this.dict = new Dictionary<int, TrackListViewModel>();
                    foreach (TrackListViewModel track in list)
                    {
                        Add(track);
                        this.dict.Add(track.PieceId, track);
                       // track.PropertyChanged += track_PropertyChanged;
                    }

                    OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
                }
                else
                {

                    foreach (TrackListViewModel newTrack in list)
                    {
                        if (!this.dict.ContainsKey(newTrack.PieceId))
                        {
                            Add(newTrack);
                            this.dict.Add(newTrack.PieceId, newTrack);
                           // newTrack.PropertyChanged += track_PropertyChanged;
                            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, newTrack));
                        }
                    }

                    foreach (TrackListViewModel track in new List<TrackListViewModel>(this))
                    {
                        if (!dict.ContainsKey(track.PieceId))
                        {
                            Remove(track);
                            this.dict.Remove(track.PieceId);
                           // track.PropertyChanged -= track_PropertyChanged;
                            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, track));
                        }
                    }
                }
            }

            //Clear(); 
            //foreach (TrackListViewModel track in parent.Tracks)
            //    Add(track); 
        }

        //void track_PropertyChanged(object sender, PropertyChangedEventArgs e)
        //{
        //    switch (e.PropertyName)
        //    {
        //        case "Duration":
        //        case "Enabled":
        //            PlayerViewModel.Instance.makeResume();
        //            break;
        //    }
        //}

        public List<TrackListViewModel> AllTracks
        {
            get
            {
                build();
                return this;
            }
        }

        public List<TrackListViewModel> Tracks
        {
            get
            {
                return parent.Tracks;
            }
        }

        protected void buildAllTraks(List<TrackListViewModel> container, Dictionary<int, TrackListViewModel> dict, bool? onlyDisabled, bool onlyFathers)
        {
            foreach (TrackListViewModel t in parent.Tracks)
            {
                if (!t.Enabled || true !=onlyDisabled)
                {
                    if (onlyDisabled == null && t.Enabled)
                    {
                        if (!t.PieceGen.ClassementProvisoireRecent)
                            continue; 
                    }
                    if (t.PieceParentId < 0 || !onlyFathers)
                    {
                        if (!t.Track.Virtual || PlayerViewModel.Instance.WithVirtualAlbum)
                        {
                            
                            if (!dict.ContainsKey(t.PieceId))
                            {
                                dict.Add(t.PieceId, t);
                                container.Add(t);
                                //  t.Index = container.Count; 
                            }
                        }
                    }
                }

            }

            foreach (PlayListViewModel pl in parent)
            {
                AllTracksViewModel other = pl.AlltracksVm;
                //if (true == onlyDisabled)
                //    other = pl.AlltracksVmd;
                //else
                //    other = pl.AlltracksVm;
                other.buildAllTraks(container, dict, onlyDisabled, onlyFathers);
            }
        }

        #region cmd

        private ICommand _contextCmdCheck;
        public ICommand ContextCmdCheck { get { if (_contextCmdCheck == null) _contextCmdCheck = new CheckCmd(); return _contextCmdCheck; } }

        private ICommand _contextCmdUnCheck;
        public ICommand ContextCmdUnCheck { get { if (_contextCmdUnCheck == null) _contextCmdUnCheck = new UnCheckCmd(); return _contextCmdUnCheck; } }


        private ICommand _contextLinkFather;
        public ICommand LinkFather { get { if (_contextLinkFather == null) _contextLinkFather = new LinkFather(); return _contextLinkFather; } }

        private ICommand _contextLinkChild;
        public ICommand LinkChild { get { if (_contextLinkChild == null) _contextLinkChild = new LinkChild(); return _contextLinkChild; } }

        private ICommand _contextLinkFusion;
        public ICommand LinkFusion { get { if (_contextLinkFusion == null) _contextLinkFusion = new LinkFusion(); return _contextLinkFusion; } }

        private ICommand _contextUnLink;
        public ICommand LinkReset { get { if (_contextUnLink == null) _contextUnLink = new LinkReset(); return _contextUnLink; } }

        private ICommand _contextExport;
        public ICommand Export { get { if (_contextExport == null) _contextExport = new ExportCmd(); return _contextExport; } }

        private ICommand _contextExportCompress;
        public ICommand ExportCompress { get { if (_contextExportCompress == null) _contextExportCompress = new ExportCompress(); return _contextExportCompress; } }

        private ICommand _contextDelete;
        public ICommand DeleteTrack { get { if (_contextDelete == null) _contextDelete = new DeleteCmd(); return _contextDelete; } }

        public TrackListViewModel HumanSelected
        {
            get
            {
                return TrackListViewModel.HumanSelected;
            }
        }

        private ICommand _ContextCmdAddToList;
        public ICommand ContextCmdAddToList { get { if (_ContextCmdAddToList == null) _ContextCmdAddToList = new AddToList(App.Instance); return _ContextCmdAddToList; } }

        private ICommand _ContextCmdDbDeleteClassement;
        public ICommand ContextCmdDbDeleteClassement { get { if (_ContextCmdDbDeleteClassement == null) _ContextCmdDbDeleteClassement = new DbDeleteLastClassement(); return _ContextCmdDbDeleteClassement; } }

        private ICommand _ContextCmdDbDeleteRead;
        public ICommand ContextCmdDbDeleteRead { get { if (_ContextCmdDbDeleteRead == null) _ContextCmdDbDeleteRead = new DbDeleteLastRead(); return _ContextCmdDbDeleteRead; } }


        #endregion

        #region from Ihm
        private TrackListViewModel selectedTrack;
        public TrackListViewModel SelectedTrack
        {
            get
            {
                return selectedTrack;
            }
            set
            {
                selectedTrack = value;
                TrackListViewModel.setHumanSelected(parent, value); //  .HumanSelected = value;
                if (selectedTrack != null)
                    selectedTrack.IsSelected = true;
            }
        }
        #endregion

        private int nbAlbumMoved;

        public int NbAlbumMoved
        {
            get { return nbAlbumMoved; }
        }

        public string AutoResume
        {
            get
            {
               
                try
                {

                    var conf = App.gen.SortAlbumMode.ComposantsUtiles[0].Main;
                    var sb = new StringBuilder();
                    
                    sb.Append(conf.CoeffOld.ToString("0.000", CultureInfo.InvariantCulture)); sb.Append("  ");

                    sb.Append((1000 * conf.dcoeffp).ToString("### ### ##0.##\\.##")); sb.Append("m  ");
                    var percentConv = 0m;
                    if (conf.dconvergence > 0) percentConv = conf.dconvergence0 / conf.dconvergence;
                    sb.Append((percentConv).ToString("### ### ##0.##", CultureInfo.InvariantCulture)); sb.Append("  ");
                   
                    sb.Append(conf.Serial); sb.Append(" ");
                    sb.Append(conf.SerialBox); sb.Append(" ");
                    sb.Append(conf.Alt); sb.Append(" ");
                    sb.Append(conf.AltHisto); sb.Append("  ");
                    sb.Append(conf.Elastique.ToString("0.#")); sb.Append(" ");
                    sb.Append(conf.Elastique2.ToString("0.#"));
                    //var motif = selectedCoeff.none;
                    //var current = TrackListViewModel.HumanSelected;
                    //if (current != null)
                    //    motif = current.SelectedMotif; 
                  //  var stat10 = conf.calcStat(motif,10);
                   // sb.Append(stat10); sb.Append(" - ");
                 //   var stat100 = conf.calcStat(motif,100);
                  //  sb.Append(stat100); 

                    //sb.Append(conf.coeffTMin(10).ToString("0.000", CultureInfo.InvariantCulture)); sb.Append(" "); sb.Append(conf.coeffTMax(10).ToString("0.000", CultureInfo.InvariantCulture)); sb.Append(" - ");
                    //sb.Append(conf.coeffTMin(100).ToString("0.000", CultureInfo.InvariantCulture)); sb.Append(" "); sb.Append(conf.coeffTMax(100).ToString("0.000", CultureInfo.InvariantCulture)); 
                    return sb.ToString(); 
                   
                }
                catch
                {
                    return ""; 
                }
            }
        }
        public string NbAlbumMovedDesc
        {
            get
            {
                if (nbAlbumMoved < 0)
                    return "";
                if (nbAlbumMoved == 0)
                    return "pas d'album en quarantaine";
                return string.Format("{0} albums en quarantaine", nbAlbumMoved); 
            }
        }

        public void setNbAlbumMoved(int nb)
        {
            if (nb != nbAlbumMoved)
            {
                nbAlbumMoved = nb;
                OnPropertyChanged("NbAlbumMoved");
                OnPropertyChanged("NbAlbumMovedDesc");
            }

        }

        private int nbAlbumMovedUnavailable;
        public int NbAlbumMovedUnavailable
        {
            get
            {
                return nbAlbumMovedUnavailable; 
            }

            set
            {
                if (value != nbAlbumMovedUnavailable)
                {
                    nbAlbumMovedUnavailable = value;
                    OnPropertyChanged("NbAlbumMovedUnavailable"); 
                }
            }
        }

    }


}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\TrackListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Windows;
using pdb.obj;
using pdb.util;
using pdb.gen;
using pdb.db.obj;
using pdb.gen.albums;

namespace pdb.player.ViewModel
{

    public class TrackListViewModel : BibViewModelBase, ITrackNativeDates
    {




        #region répercut
        //  private static BgDict<int, List<TrackListViewModel>> dictT = new BgDict<int, List<TrackListViewModel>>();
        #endregion
        private TrackList track;
        private PieceViewModel piece;
        private static TrackListViewModel currentPlaying;
        private static TrackListViewModel currentSelected;
        public TrackList Track { get { return track; } }
        public CPiece Piece { get { return piece.Piece; } }
        public Piece PieceGen { get { return track.Piece; } }
        public Piece Master { get { return PieceGen.Master; } }

        public void remove()
        {
            //var list = dictT[PieceId];
            //if (list == null)
            //    return;
            //list.Remove(this);
        }

        public void refresh()
        {
            piece.eraseCommentGrouping();
            OnPropertyChanged("ExportStatus");
            OnPropertyChanged("TV");
            OnPropertyChanged("Comment");
            OnPropertyChanged("Grouping");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("ClassementVirtuel");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("");
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                if (value != base.IsSelected)
                {
                    base.IsSelected = value;
                    if (value)
                        CurrentSelected = this;
                    OnPropertyChanged("TV");
                }
            }
        }

        private int index;
        public int Index
        {
            get { return index; }
            set
            {
                if (value != index)
                {
                    index = value;
                    OnPropertyChanged("Index");
                }
            }
        }

        public int StackValue { get { return PieceGen.StackValue; } }
        public int StackIndex { get { return PieceGen.StackIndex; } }

        public static event EventHandler CurrentSelectedChanged;
        public static TrackListViewModel CurrentSelected
        {
            get
            {
                return currentSelected;
            }
            set
            {
                if (value != currentSelected)
                {
                    currentSelected = value;
                    if (CurrentSelectedChanged != null)
                        CurrentSelectedChanged("Track", EventArgs.Empty);
                }
            }
        }

        public static event EventHandler CurrentHumanSelectedChanged;
        private static TrackListViewModel humanSelected;
        private static int humanSelectedId;
        public static TrackListViewModel HumanSelected
        {
            get { return humanSelected; }
            //set
            //{
            //    if (value != humanSelected)
            //    {
            //        humanSelected = value;
            //        if (CurrentHumanSelectedChanged != null)
            //            CurrentHumanSelectedChanged("Human", EventArgs.Empty);
            //    }
            //}
        }

        public static void setHumanSelected(PlayListViewModel pl, TrackListViewModel track)
        {
            //if (humanSelected != null)
            //{
            //    humanSelected.refresh();
            //   // var b = humanSelected.Grouping; 
            //}
            if (track != humanSelected)
            {
                humanSelected = track;


                //  humanSelected.refresh();
                // var b = humanSelected.Grouping; 
                int id = 0;
                if (track != null) id = track.PieceId;
                if (id != humanSelectedId)
                {
                    humanSelectedId = id;
                    if (CurrentHumanSelectedChanged != null)
                        CurrentHumanSelectedChanged(pl, EventArgs.Empty);
                }
            }
        }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
                //if (value != track.Enabled)
                //{
                //    track.Piece.Enabled = value;
                //    OnPropertyChanged("Enabled");
                //}
            }
        }
        //  private exportState exportState;
        //public int ExportState
        //{
        //    get
        //    {
        //        return (int)exportState;
        //    }
        //}

        public static EventHandler ExportStatusChange;
        private static void OnExportStatusChange(TrackListViewModel tv)
        {
            if (ExportStatusChange != null)
                ExportStatusChange(tv, EventArgs.Empty);
        }

        public static event EventHandler ClassementChange;
        private static void OnClassementChange(TrackListViewModel tv)
        {
            if (ClassementChange != null)
                ClassementChange(tv, EventArgs.Empty);
        }

        public TrackListViewModel TV { get { return this; } }

        public exportState ExportStatus
        {
            get
            {
                return Piece.ExportStatus; // exportState;
            }
            set
            {
                if (Piece.ExportStatus != value)
                {
                    Piece.ExportStatus = value;
                    OnPropertyChanged("ExportStatus");
                    OnPropertyChanged("TV");
                    OnPropertyChanged("Background");
                    OnExportStatusChange(this);
                    //refresh();


                }
            }
        }

        public int IndexExport
        {
            get { return PieceGen.IndexExport; }
        }

        public selectedCoeff SelectedMotif
        {
            get
            {
                if (PieceGen == null)
                    return selectedCoeff.none;
                return PieceGen.SelectedMotif;
            }
        }








        public TrackListViewModel(TrackList track, PlayListViewModel playlist)
            : base(track, playlist)
        {
            this.track = track;
            this.piece = PieceViewModel.getPiece(track); // new PieceViewModel(track); // track.Piece.Track as CPiece; 
            //piece.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(piece_PropertyChanged);
            int id = track.PieceId;
            //if (!dictT.ContainsKey(id))
            //{
            //    var list = new List<TrackListViewModel>();
            //    dictT.Add(id, list);
            //}

            //dictT[id].Add(this);

        }

        //void piece_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        //{
        //    OnPropertyChanged(e.PropertyName);
        //}

        public String StrPlaying
        {
            get
            {
                if (playing) return "<))";
                return "";
            }
        }
        public string MedianneStatus
        {
            get
            {
                var p = PieceGen;
                if (p.Medianne)
                    return ">>";
                if (p.MedianneLight)
                    return ">";
                if (p.Border)
                    return "-";
                if (p.BorderMin)
                    return "-";
                if (p.BorderEffect)
                    return "--";

                return "";
            }
        }

        private bool playing;
        public bool Playing
        {
            get { return playing; }
            set
            {
                if (value != playing)
                {
                    playing = value;
                    if (playing)
                    {
                        CurrentPlaying = this;
                    }
                    OnPropertyChanged("Playing");
                    OnPropertyChanged("StrPlaying");
                }
            }
        }

        public static TrackListViewModel CurrentPlaying
        {
            get
            {
                return currentPlaying;
            }
            set
            {
                if (value != currentPlaying)
                {
                    if (currentPlaying != null)
                        currentPlaying.Playing = false;
                    currentPlaying = value;
                }
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                //piece.Rating = value;
                if (value != track.Rating)
                {
                    track.Rating = value;
                    OnPropertyChanged("Rating");
                }
            }
        }

        //  private pdb.db.obj.CPiece CPiece { get { return track.Piece.Track as pdb.db.obj.CPiece; } }


        //public static readonly DependencyProperty ClassementProperty =
        //DependencyProperty.Register("Classement", typeof(String),
        // typeof(PieceViewModel), new UIPropertyMetadata(null));
        public String Classement
        {
            get
            {
                return piece.Piece.StrClassement;
            }
            set
            {

                // piece.StrClassement = value;
                if (value != piece.Piece.StrClassement)
                {
                    piece.Classement = value;
                    PieceGen.invalidateCache();
                    App.gen.Albums.signalClassChange(track);
                    try
                    {

                        PlayerViewModel.makeauto(this);
                        App.bib.setClassement(this, value);



                        // piece.Piece.StrClassement = value;

                    }
                    catch
                    {
                    }

                    OnClassementChange(this);
                    App.go(true);
                    OnPropertyChanged("Classement");


                }

            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
               // piece.Year = value;
                if (value != piece.Year)
                {
                    track.Year = value;
                    OnPropertyChanged("Year");
                }
            }
        }


        //public static readonly DependencyProperty CommentProperty =
        //DependencyProperty.Register("Comment", typeof(string),
        //typeof(PieceViewModel), new UIPropertyMetadata(null)); 
        public string Comment
        {
            get
            {
                if (PieceGen.Virtual)
                    return "";
                return piece.Comment;
            }
            set
            {
                if (PieceGen.Virtual)
                    return;
                //piece.Comment = value; 
                if (value != piece.Comment)
                {
                    //  track.Comment = value;
                    piece.Comment = value;
                    OnPropertyChanged("Comment");

                }
            }
        }

        public string Grouping
        {
            get { return track.Piece.Grouping; }
            set
            {
                //  piece.Grouping = value;
                if (value != track.Piece.Grouping)
                {
                    track.Piece.setGrouping(value, true);
                    // track.setGrouping(value, true);
                    OnPropertyChanged("Grouping");
                }
            }
        }




        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }


        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set
            {
                piece.Duration = value;
                //if (!Exists)
                //    return; 
                //if (value != Duration)
                //{
                //    var deltaMs = Math.Abs(value.TotalMilliseconds - Duration.TotalMilliseconds);
                //    if (deltaMs >= 1)
                //    {
                //        track.Duration = value;
                //        if (deltaMs >= 1000)
                //            onPropertyChanged("Duration");
                //    }
                //}
            }
        }

        public string Location
        {
            get { return piece.Location; }
        }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
               // piece.Artist = value;
                if (value != track.Artist)
                {
                    track.Artist = value;
                    OnPropertyChanged("Artist");
                }
            }
        }

        public string Album
        {
            get
            {
                if (track.Virtual)
                {
                    if (track.Piece.VirtualByArtist)
                        return string.Format("[{0}]", track.Album);
                    return track.Album;
                }
                return piece.Album;
            }
            set
            {
              
                if (value != track.Album)
                {
                    if (!track.Virtual)
                        piece.Album = value;
                  
                    OnPropertyChanged("Album");
                }
            }
        }

        public string MasterAlbum
        {
            get
            {
                //    if (track.Virtual)
                //        return " " + PieceGen.Master.Album;
                return PieceGen.Master.Album;
            }
            set
            {
                if (value == null)
                    return;
                value = value.Trim();
                if (value != PieceGen.Master.Album)
                {
                    PieceGen.Master.Album = value;
                    OnPropertyChanged("MasterAlbum");
                }
            }
        }

        public Album album { get { return PieceGen.PieceAlbum; } }

        public string Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                //  piece.Name = value;
                if (value != track.Name)
                {
                    track.Piece.Name = value;
                    OnPropertyChanged("Name");
                }
            }
        }

        public int TrackNumber
        {
            get
            {
                return track.Piece.TrackNumber;
            }
            set
            {
              
                if (value != track.TrackNumber)
                {
                    if (!track.Virtual)
                        piece.TrackNumber = value;
                   
                    OnPropertyChanged("TrackNumber");
                }
            }
        }


        public void setClassement(string className, int rating)
        {
            piece.Piece.setClassement(className, rating);
            PieceGen.invalidateCache();

        }

        public string ClassName
        {
            get
            {
                return piece.Piece.ClassName;
            }
            set
            {
                piece.Piece.ClassName = value;
            }
        }


        public DateTime PlayedDate
        {
            get { return piece.Piece.PlayedDate; }
        }

        public string ArtWork
        {
            get
            {
                return piece.Piece.ArtWork;
            }
            set
            {
                piece.Piece.ArtWork = value;
            }
        }

        public void setGrouping(string value, bool prior)
        {
            track.Piece.setGrouping(value, prior);
            piece.Grouping = value; // TODO je fait quoi de ça ???
            // onPropertyChanged("Grouping");
        }

        public string ClassementVirtuel { get { return PieceGen.ClassementVirtuel; } }

        public decimal CoeffVirtuel { get { return PieceGen.CoeffVirtuel; } }

        public string ClassementVirtuel2 { get { return PieceGen.ClassementVirtuel2; } }

        public decimal CoeffVirtuel2 { get { return PieceGen.CoeffVirtuel2; } }

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.Piece.ClassPlayLists; }
        }

        public List<DateTime> Dates
        {
            get { return new List<DateTime>(piece.Piece.Dates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.Piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return track.Piece.ClassEvol; }
        }

        public long Size { get { return Piece.Size; } }

        public bool Exists { get { return Piece.Exists; } }

        //public void onPropertyChanged(string propertyName)
        //{
        //    var list = dictT[PieceId];
        //    if (list == null)
        //    {
        //        OnPropertyChanged(propertyName);
        //    }
        //    else
        //    {
        //        foreach (TrackListViewModel t in dictT[PieceId])
        //            t.OnPropertyChanged(propertyName);
        //    }
        //}




        public int PieceId
        {
            get { return track.PieceId; }
        }
        public int MasterId { get { return PieceGen.MasterId; } }


        public int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }

        public void setParent(TrackListViewModel parent)
        {
            track.Piece.albumMustRefresh();
            parent.track.Piece.albumMustRefresh();

            piece.Piece.Parent = parent.Piece.Master;
            track.Piece.Parent = parent.track.Piece;

            track.Piece.albumMustRefresh();
            parent.track.Piece.albumMustRefresh();
        }

        public void fusion(TrackListViewModel toDelete)
        {
            App.Db.List.fusion(piece.Piece, toDelete.Piece);

        }





        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public DateTime? UpdateClassement { get { return PieceGen.UpdateClassement; } }
        public DateTime? AlbumUpdateClassement { get { return PieceGen.AlbumUpdateClassement; } }

        public DateTime? LastRead { get { return PieceGen.LastRead; } }
        public DateTime? AlbumLastRead { get { return PieceGen.AlbumLastRead; } }

        public int NbClass { get { return PieceGen.NbClass; } }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }


        public string getLocation()
        {
            return piece.getLocation();
        }
    }
}
]]></content>
  </file>
    <file path="\PieceDb.Db\CDb.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Xml;
using pdb.db.obj;
using pdb.db.piece.data;
using pdb.obj;
using pdb.util;
using Math = System.Math; 

namespace pdb.db
{
    public enum mergePriority
    {
        left = -1,
        right = 1,
        none = 0
    }
    /// <summary>
    /// g�re la persistence
    /// </summary>  
    /// <remarks></remarks>
    public class CDb
    {
        public const int CURRENT_VERSION = 3;
        public static int Version;

        const string SEQ_PIECE = "seq_piece";
        const string SEQ_LIST = "seq_list";
        private static int pieceSequenceId = 0;
        private static int listSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private static int getListNextId { get { listSequenceId++; return listSequenceId; } }
        private FileInfo LOCAL_FILE;
        private FileInfo REMOTE_FILE;
        private FileInfo LastFullFile;
        private FileInfo DiffFile;
        private FileInfo SOV;
        private CListPiece m_list;
        private CListPiece lastFull; private CListPiece remoteOrg;
        private CListPiece trace;
        private DateTime now;
        private string sovRep;
        private DateTime lastSov;
        private int nbOpe;

        private bool loadRemote;
        private bool loadTrace;
        private bool loadLastFull;
        private bool loadDiff;



        private FileInfo remoteTrace;
        private DataConf conf;

        private dbMode mode;
        public dbMode Mode { get { return mode; } }
        public CDb(DataConf conf)
        {
            this.conf = conf;
            LOCAL_FILE = conf.dbLocal;
            REMOTE_FILE = conf.dbRemote;
            remoteTrace = conf.dbTrace;
            LastFullFile = conf.dbLastFull;
            DiffFile = conf.dbDiff;
            SOV = conf.dbSov;
            this.mode = conf.mode;

            init();
        }

        public string DefaultFolder { get { return conf.defaultFolder; } }

        private void init()
        {
            this.now = DateTime.Now;
            lastSov = now;
            sovRep = now.ToString("yy-MM-dd_HH-mm-ss");



            System.DateTime l_localDate = System.DateTime.MinValue;
            System.DateTime l_remoteDate = System.DateTime.MinValue;

            if (LOCAL_FILE.Exists)
                l_localDate = LOCAL_FILE.LastWriteTime;
            if (REMOTE_FILE.Exists)
                l_remoteDate = REMOTE_FILE.LastWriteTime;


            TimeSpan l_dif = l_localDate.Subtract(l_remoteDate);
            double l_sec = l_dif.TotalSeconds;
            if (REMOTE_FILE.Exists)
            {

                if (Math.Abs(l_sec) > 3 || (LOCAL_FILE.Exists && REMOTE_FILE.Length != LOCAL_FILE.Length))
                {
                    loadRemote = true;
                }
                else
                {
                    log("not load remote, same file");
                }
            }
            else
            {
                log("remote file does not exist");
            }

            if (remoteTrace != null && remoteTrace.Exists)
                loadTrace = true;




        }

        public void loadData()
        {
            // cas diff-> je mémorise lastFull, je r�cup�re l'instantan�
            // cas full -> je ne m�morise pas lastFull, je r�cup�re le diff et fait le merge

            // gestion des diff
            //if (mode == dbMode.diff)
            //{
            // je sauvegarde lastFull
            misc.log("mode:{0}  LastFullFile.Exists: {1} DiffFile.Exists: {2}", mode, LastFullFile.Exists, DiffFile.Exists);
            if (mode == dbMode.diff)
            {
                if (LastFullFile.Exists)
                {
                    log("load lastFull");
                    lastFull = loadData(LastFullFile);
                }
                else
                {
                    log("load local for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);
                }

                log("load local");
                m_list = loadData(LOCAL_FILE);
            }

            else
            {

                log("load local");
                m_list = loadData(LOCAL_FILE);
                if (DiffFile.Exists)
                {


                    log("load diff");
                    var diff = loadData(DiffFile);


                    log("consolid diff and local");
                    foreach (CPiece pdiff in diff)
                    {
                        m_list.Consolid(pdiff, mergePriority.right);
                    }

                    var sov = DiffFile.FullName.Replace(".xml", ".sov.xml");
                    DiffFile.CopyTo(sov, true);
                    DiffFile.Delete();


                    write();

                    log("load local consolidé for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);
                    addToZip(true, LOCAL_FILE.FullName);
                }
                else
                {
                    log("load local for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);

                    if (loadRemote)
                    {
                        log("load remote");
                        remoteOrg = loadData(REMOTE_FILE);
                        log("consolid remote and local");
                        m_list.Consolid(remoteOrg);
                    }
                }
            }


            if (loadTrace)
            {
                log("load trace");
                trace = loadData(remoteTrace);
            }
        }

        public void eraseClassementForEnabled()
        {

            foreach (CPiece piece in m_list)
            {
                if (piece.Enabled)
                {
                    piece.eraseClassement();
                }
            }
        }

        public List<ITrackIdentity> Files
        {
            get
            {
                return new List<ITrackIdentity>(m_list.getList());
            }
        }

        // r�cup�ration des infos externes
        public void LegacyConsolid(CListPiece list, DateTime date)
        {
            misc.log("Cdb::LegacyConsolid");

            DateTime now = DateTime.Now;
            ChronoData.refreshDate(date);

            foreach (CPiece ext in list)
            {
                m_list.legacyConsolid(ext);
            }

            m_list.bilanNatives();

           // setAlbumArtistFromFile();

        }

        public void LegacyConsolid(CPiece ext)
        {
            m_list.legacyConsolid(ext);
        }

        public void SynchroNative(DateTime date)
        {
            misc.log("Cdb::SynchroNative");
            ChronoData.refreshDate(date);
            foreach (CPiece piece in m_list)
            {
                piece.SynchroNative();
            }

        }

        //private void setAlbumArtistFromFile()
        //{
        //    foreach (ITrackMetaData piece in m_list)
        //    {
        //        setAlbumArtistFromFile(piece);
        //    }
        //}



        private void setAlbumArtistFromFile(ITrackMetaData piece)
        {

            try
            {
                string location = piece.Location;
                if (location.isNullorEmpty())
                    return;
                FileInfo file = new FileInfo(location);
                DirectoryInfo dAlbum = file.Directory;
                string dirAlbum = dAlbum.Name;
                string dirArtist = dAlbum.Parent.Name;
                string artist = piece.Artist;
                string album = piece.Album;

                string newArtist = artist;
                string newAlbum = album;




                if (artist.isNullorEmpty())
                {
                    if (!TrackIdentity.UNKNOW_ARTIST.Equals(dirArtist))
                        newArtist = dirArtist;
                    //if (!UNKNOW_ARTIST.Equals(newArtist))
                    //    piece.Artist = newArtist;
                }

                if (album.isNullorEmpty())
                {
                    if (!dirAlbum.Contains(TrackIdentity.UNKNOW_ALBUM))
                    {
                        newAlbum = dirAlbum;
                        if (newArtist.NotNullOrEmpty())
                        {
                            if (!TrackIdentity.UNKNOW_ARTIST.Equals(newArtist))
                                newAlbum = newAlbum.Replace(newArtist, "");
                        }
                    }
                }

                //if (TrackIdentity.UNKNOW_ARTIST.Equals(newArtist))
                //    piece.Artist = "";
                //else 
                if (newArtist != artist)
                    piece.Artist = newArtist;

                //if (TrackIdentity.UNKNOW_ALBUM.Equals(newAlbum))
                //    piece.Album = "";
                //else
                if (newAlbum != album)
                    piece.Album = newAlbum;

            }
            catch (Exception e)
            {
                misc.log(e.ToString());
            }
        }



        #region "sauvegarde"



        public void Sov(string fileIt)
        {
            var list = new List<string> { fileIt, LOCAL_FILE.FullName };
            if (loadRemote)
                list.Add(REMOTE_FILE.FullName);
            if (loadTrace)
                list.Add(remoteTrace.FullName);

            ZipUtil.compress(SOV.FullName, sovRep, list);
        }

        public void SovIni()
        {
            var list = new List<string> { LOCAL_FILE.FullName, LastFullFile.FullName, DiffFile.FullName };
            if (loadRemote)
                list.Add(REMOTE_FILE.FullName);
            if (loadTrace)
                list.Add(remoteTrace.FullName);

            list.AddRange(conf.othersIni); 

            ZipUtil.compress(SOV.FullName, sovRep, list);
        }

       
        #endregion

        public void removeVersions()
        {
            misc.log("Suppression des versions !!!");
            foreach (CPiece piece in m_list)
            {
                piece.removeVersions();
            }
        }

        public void Menage()
        {
            foreach (CPiece piece in m_list)
            {
                piece.Menage();
            }
        }

        public void WriteDB1()
        {

            misc.log("CDb:WriteDB1");

            lock (lockSave)
            {
                write();
                File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
                misc.log("CDb:fin WriteDB1");
            }

        }
        public void saveAsync()
        {
            lock (this)
            {
                _goSave = true;
                if (thSave == null)
                {
                    thSave = new Thread(loopSave);
                    thSave.Start();
                }
            }
        }
        private Thread thSave;
        private bool _goSave;
        private volatile object lockSave = new object();

        private void write()
        {
            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;
            using (XmlWriter writer = XmlWriter.Create(REMOTE_FILE.FullName + ".tmp", settings))
            {
                writer.WriteStartElement("db");
                writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                writer.WriteAttributeString(SEQ_LIST, listSequenceId.ToString());
                m_list.write(writer);
                writer.WriteEndDocument();
                writer.Flush();
            }

            File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);



            if (lastFull != null)
            {
                try
                {
                    var diff = DiffFile.FullName;
                    if (mode == dbMode.full)
                        diff = diff.Replace(".xml", ".d.xml");

                    using (XmlWriter writer = XmlWriter.Create(diff + ".tmp", settings))
                    {
                        writer.WriteStartElement("db");
                        writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                        writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                        m_list.writeDiff(writer, lastFull);
                        writer.WriteEndDocument();
                        writer.Flush();
                    }

                    File.Copy(diff + ".tmp", DiffFile.FullName, true);
                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

            WriteDB2();
        }
        private void loopSave()
        {
            while (true)
            {
                Thread.Sleep(1000);
                if (!_goSave)
                    continue;
                lock (this)
                    _goSave = false;

                lock (lockSave)
                {

                    try
                    {
                        write();
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                        lock (this)
                            _goSave = true;
                    }
                }

            }
        }

        public void WriteDB2()
        {

            misc.log("CDb:WriteDB2");
            lock (lockSave)
                REMOTE_FILE.CopyTo(LOCAL_FILE.FullName, true);
            misc.log("CDb:WriteDB2");

            nbOpe++;
            var now = DateTime.Now;
            var ts = now - lastSov;
            if (nbOpe >= conf.sovNb || ts > conf.sovMin)
            {
                nbOpe = 0;
                lastSov = now;
                DiffFile.Refresh();
                if (DiffFile.Exists)
                {
                    var list = new List<string> { DiffFile.FullName };
                    list.AddRange(conf.othersDiff); 
                    addToZip(true, list.ToArray());
                    //var cp = DiffFile.DirectoryName + Path.DirectorySeparatorChar + now.ToString("yy-MM-dd_HH-mm-ss") + DiffFile.Name;
                    //DiffFile.CopyTo(cp);
                    //var list = new List<string> { cp };
                    //ZipUtil.compress(SOV.FullName, sovRep, list);
                    //File.Delete(cp); 
                }


            }
        }

        private void addToZip(bool withHorodate, params string[] list)
        {
            ZipUtil.compress(SOV.FullName, sovRep, list, withHorodate);
        }


        public CListPiece List
        {
            get
            {
                return m_list;

            }

        }

        public CListPiece Remote
        {
            get
            {
                if (loadRemote)
                    return remoteOrg;
                return null;
            }

        }

        public CListPiece Trace
        {
            get { return trace; }
        }

        private XmlElement loadList(FileInfo file, List<CPiece> list)
        {
            XmlElement root = null;
            if (file.Exists)
            {
                XmlDocument l_doc = new XmlDocument();


                l_doc.Load(file.FullName);

                root = l_doc.DocumentElement;
                var xmlTool = new XMLTool(root);
                var version = xmlTool.getIntAttValue("version");
                if (version > 0)
                    Version = version;


                var seqPiece = xmlTool.getIntAttValue(SEQ_PIECE);
                if (seqPiece > pieceSequenceId)
                {
                    pieceSequenceId = seqPiece;
                }

                var seqList = xmlTool.getIntAttValue(SEQ_LIST);
                if (seqList > listSequenceId)
                {
                    listSequenceId = seqList;
                }

                var pieceRoot = root;
                if (version > 0)
                    pieceRoot = root.ChildNodes[0] as XmlElement;



                foreach (XmlElement l_xml in pieceRoot.ChildNodes)
                {
                    CPiece l_piece = new CPiece(l_xml);

                    list.Add(l_piece); //TODO provisoire
                    if (version > 0)
                        checkId(l_piece);
                    else
                    {
                        if (m_list != null)
                        {
                            m_list.checkId(l_piece); 
                        }
                        checkId(l_piece);
                    }
                    //}
                }
                misc.log("aux list: " + list.Count);




            }
            else
            {

            }

            return root;
        }



        private  CListPiece loadData(FileInfo file)
        {
            if (file.Exists)
            {

                List<CPiece> l_list = new List<CPiece>();
                var root = loadList(file, l_list);


                misc.log("aux list: " + l_list.Count);
                System.DateTime l_date = file.LastWriteTime; // File.GetLastWriteTime(a_path);

                //chasse aux doublons
                CListPiece l_ret = new CListPiece(l_list, l_date);
                misc.log(" list: " + l_ret.Count);

                var xLists = XMLTool.NodeLookUp(root, CListPiece.TOKEN_LISTS);

                l_ret.loadListes(xLists);
                return l_ret;
            }
            else
            {
                return new CListPiece();
            }

        }

        public static void checkId(CPiece l_piece)
        {
            if (l_piece.PieceId < 0)
                l_piece.setId(getPieceNextId);
            if (l_piece.PieceId > pieceSequenceId)
                pieceSequenceId = l_piece.PieceId;
        }

        public static void checkId(CPlayList pl)
        {
            if (pl.ID < 0)
                pl.ID = getListNextId;
            if (pl.ID > listSequenceId)
                listSequenceId = pl.ID;
        }
        private void log(String txt)
        {
            misc.log(txt);
        }

        public CPiece getPiece(string location)
        {
            return m_list.getPiece(location);
        }

        public CPiece getPiece(int id)
        {
            return m_list.getPiece(id);
        }
    }


}


]]></content>
  </file>
  <file path="\PieceDb.Db\piece\data\CPieceData.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.db.obj;
using pdb.db.piece.value;
using pdb.db.piece.version;
using pdb.util;



namespace pdb.db.piece.data
{

    /// <summary>
    /// Donnée + liste des versions
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public abstract class CPieceData<T> : IData, IEnumerable<CPieceDataVersion<T>>
    {
        /// <summary>
        /// Liste des versions
        /// </summary>
        protected List<CPieceDataVersion<T>> m_list = new List<CPieceDataVersion<T>>();
        private static CDataVersionComparerInv c_comparerInv = new CDataVersionComparerInv();

        private bool m_bOverride = false;
        public abstract string getToken();
        public abstract T getNullValue();
        public abstract CPieceDataValue<T> createPieceDataValue(XmlElement a_node);
        public abstract CPieceDataValue<T> createPieceDataValue(string a_value);
        public abstract CPieceDataValue<T> createPieceDataValueT(T value);
        // protected Bool empty = Bool.not_defined;
        //   protected static DateTime _now = DateTime.Now;

        protected IDataObserver observer;
        public IDataObserver Observer { set { observer = value; } }

        public bool Override { get { return m_bOverride; } }


        public static DateTime Now
        {
            get
            {
                return ChronoData.Now;
            }
        }

        #region signaux

        //public class PieceDataChangeNativeEventArgs : EventArgs
        //{
        //    public PieceDataChangeNativeEventArgs(T value) { this.Value = value; }
        //    readonly public T Value;
        //}

        //public class PieceDataChangeLocalEventArgs : EventArgs
        //{
        //    public PieceDataChangeLocalEventArgs(T Old, T New) { this.Old = Old; this.New = New; }
        //    readonly public T Old;
        //    readonly public T New;
        //}

        //  public event EventHandler<PieceDataChangeNativeEventArgs> changeNativeValue;
        private void OnchangeNativeValue(T value) { if (observer != null) changeNativeValue(value); }
        protected abstract void changeNativeValue(T value);

        //  public event EventHandler<PieceDataChangeLocalEventArgs> changeLocalValueByRemote;
        private void OnChangeLocalByRemote(T Old, T New)// { if (changeLocalValueByRemote != null) changeLocalValueByRemote(this, new PieceDataChangeLocalEventArgs(Old, New)); }
        {
            if (observer != null)
                observer.changeByRemote(getToken(), Old, New);
        }
        //  public event EventHandler<PieceDataChangeLocalEventArgs> changeLocalValueByNative;
        private void OnChangeLocalByNative(T Old, T New) // { if (changeLocalValueByNative != null) changeLocalValueByNative(this, new PieceDataChangeLocalEventArgs(Old, New)); }
        {
            if (observer != null)
                observer.changeByNative(getToken(), Old, New);
        }
        //public event EventHandler<PieceDataChangeLocalEventArgs> cannotMerge;
        private void OnCannotMerge(T Old, T New) { }

        // public event EventHandler change;
        private void onChange() { if (observer != null) observer.RefChange(); }
        #endregion


        public CPieceData(CPieceData<T> o)
        {
            foreach (CPieceDataVersion<T> v in o.m_list)
                m_list.Add(new CPieceDataVersion<T>(v)); 
        }

        public CPieceData(string a_value)
        {
            CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(a_value, this);
            m_list.Add(l_version);

        }

        public CPieceData(T value)
        {
            CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(value, this);
            m_list.Add(l_version);
        }

        public CPieceData()
        {
        }






        /// <summary>
        /// Ajoute si nécessaire les versions réciproques 
        /// </summary>
        /// <param name="a_list"></param>
        /// <remarks>On ne prend en compte que les versions de date définie</remarks>
        /// 




        public void mergeOnlyVersion(CPieceData<T> a_list)
        {
            foreach (CPieceDataVersion<T> l_version in a_list.m_list)
            {
                check(l_version);
            }
            sortAndCompact();
            foreach (CPieceDataVersion<T> l_remote in this.m_list)
            {
                a_list.check(l_remote);
            }
            a_list.sortAndCompact();
        }

        public void mergeAll(CPieceData<T> other, mergePriority a_priority)
        {
            T valueOrg = Value;
            mergeOnlyVersion(other);
            if (!this.Equals(other))
            {
                mergePriority l_ret = this.isMaster(other, a_priority);
                if (l_ret == mergePriority.left)
                {
                    OnChangeLocalByNative(other.Value, this.Value);
                    other.eraseSingleFrom(this);
                }
                else if (l_ret == mergePriority.right)
                {
                    this.eraseSingleFrom(other);
                }
                else
                {
                    OnCannotMerge(this.Value, other.Value);
                }
            }

            if (!Value.Equals(valueOrg))
            {
                onChange();
            }
        }

        /// <summary>
        /// Synchronise les infos de deux pieces (local-distant)
        /// </summary>
        /// <param name="remote">Piece sur fichier pdb_export</param>
        /// <remarks>on teste le cgangement de valeur</remarks>
        public virtual void Consolid(CPieceData<T> remote, mergePriority a_priority)
        {
            sortAndCompact();
            remote.sortAndCompact();
            T l_valueOrg = Value;
            mergeAll(remote, a_priority);

            if (!l_valueOrg.Equals(Value))
            {
                m_bOverride = true;
                OnChangeLocalByRemote(l_valueOrg, Value);
            }

            sortAndCompact();
            remote.sortAndCompact();

        }

        public bool Imported
        {
            get { return m_bOverride; }
        }

        protected virtual void LegacyConsolidByNative(CPieceData<T> local)
        {
            local.eraseSingleFrom(this);
        }

        protected virtual bool canErase()
        {
            return false;
        }

        public void removeVersions()
        {
            sortAndCompact();
            if (m_list.Count > 1)
            {
                m_list = new List<CPieceDataVersion<T>> { m_list[0] };
            }
        }






        public virtual void LegacyConsolid(CPieceData<T> local)
        {
            if (!this.Equals(local))
            {
                mergePriority l_merge = checklegacyModif(local);

                if (l_merge == mergePriority.right)
                {
                    this.m_bOverride = true;
                    this.eraseSingleFrom(local);
                    // this.empty = Bool.not_defined;
                    OnchangeNativeValue(Value);
                }
                else
                {
                    OnChangeLocalByNative(local.Value, this.Value);
                    if ((local.Significant || canErase()) && Now != local.LastModif)
                    {
                        CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(Now, m_list[0].Data);
                        local.m_list.Add(l_version);
                        local.sortAndCompact();
                    }
                    else
                    {
                        local.eraseSingleFrom(this);
                    }
                    //    local.empty = Bool.not_defined;
                }

            }
        }

        public virtual void SynchroNative(T native)
        {
            if (native != null && isSignificant(native) && !Value.Equals(native))
            {
                bool update = true;
                if (native is string)
                {
                    if (native.ToString().Trim().Equals(Value.ToString().Trim()))
                        update = false;
                }

                if (update)
                {
                    OnChangeLocalByNative(this.Value, native);
                    CPieceDataValue<T> newValue = createPieceDataValueT(native);
                    CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(Now, newValue);
                    m_list.Add(l_version);
                    sortAndCompact();
                }
            }
        }

        /// <summary>
        /// Dans le cas d'une égalité de principe, tenter une comparaison basée sur la complétude
        /// </summary>
        /// <param name="remote "></param>
        /// <returns>Indique si la comparaison a été faite</returns>
        /// <remarks></remarks>
        public bool choose(CPieceData<T> remote)
        {
            mergeAll(remote, mergePriority.none);
            // si le merge est effectif (ie l'un des deux a une date définie alors le erge est fait
            // pour provoquer un merge manuel il faut que les deux soient sans date et différents
            return Equals(remote);
        }
        public void mergeManual(CPieceData<T> other)
        {
            //Console.WriteLine("master ? 1 (final:1)   2 ( final:2 ) n:no");
            //string l_resp = Console.ReadLine();
            //if (l_resp == "1")
            //{
            //    Console.WriteLine("merge from first to second");
            //    //Console.WriteLine("merge from second to first")
            //    other.eraseSingleFrom(this);

            //}
            //else if (l_resp == "2")
            //{
            //    Console.WriteLine("merge from second to first");
            //    this.eraseSingleFrom(other);
            //}
            //else
            //{
            Console.WriteLine("abort merge");
            //Return choice.no
            //}
        }

        /// <summary>
        /// Parfois, des valeurs identiques sont indiquées commme des modifications. 
        /// Ordonnancement par ordre chronomogique, et élimination des doublons
        /// </summary>
        protected void sortAndCompact()
        {
            if (m_list.Count < 2) return;
            m_list.Sort(c_comparerInv);
            CPieceDataVersion<T> last = m_list[m_list.Count - 1];
            List<CPieceDataVersion<T>> aux = new List<CPieceDataVersion<T>>(m_list);
            for (int i = m_list.Count - 2; i >= 0; i--)
            {
                CPieceDataVersion<T> current = m_list[i];
                if (current.Data.Equals(last.Data))
                    aux.Remove(current);
                last = current;
            }
            m_list = aux;

        }

        private void eraseSingleFrom(CPieceData<T> a_list)
        {


            if (m_list.Count == 0)
            {
                CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(a_list.m_list[0].Date, a_list.m_list[0].Data);
                m_list.Add(l_version);

            }
            else
            {
                m_list[0].Data = a_list.m_list[0].Data;
            }
            //  empty = Bool.not_defined;

            onChange();


        }



        public bool Equals(CPieceData<T> obj)
        {
            return Value.Equals(obj.Value);
        }

        /// <summary>
        /// détermine quelle info est maitre dans la perspective de les merger
        /// </summary>
        /// <param name="remote"></param>
        /// <param name="a_priority"></param>
        /// <returns>True  : Je suis maître</returns>
        /// <remarks>Pre-condition:  me != remote</remarks>
        private mergePriority isMaster(CPieceData<T> remote, mergePriority a_priority)
        {
            if (this.Equals(remote))
                throw new PieceDbException(this.ToString() + " and " + remote.ToString() + " are equivalent");

            mergePriority l_consistencyComp = compareByConsistency(remote);
            if (l_consistencyComp != mergePriority.none)
                return l_consistencyComp;

            if (LastModif == System.DateTime.MinValue && remote.LastModif == System.DateTime.MinValue)
            {
                return a_priority;
            }
            else
            {
                return mergePriority.none;
                //  throw new PieceDbException("meme date de modif pourtant les fichiers sont différents!");
            }
        }
        protected virtual bool CheckLegacyConsistency()
        {
            return true;
        }
        private mergePriority checklegacyModif(CPieceData<T> local)
        {
            if (CheckLegacyConsistency())
            {
                mergePriority l_consistencyComp = compareByConsistency(local);
                if (l_consistencyComp != mergePriority.none)
                    return l_consistencyComp;
            }

            if (local.Imported) return mergePriority.right;
            return mergePriority.left;
        }

        private mergePriority checklegacyModif(T native)
        {
            if (CheckLegacyConsistency())
            {
                mergePriority l_consistencyComp = compareByConsistency(native);
                if (l_consistencyComp != mergePriority.none)
                    return l_consistencyComp;
                //right = native qui est master
            }
            if (this.Imported) return mergePriority.left;
            return mergePriority.right;
        }


        private mergePriority compareByConsistency(CPieceData<T> other)
        {
            if (!Significant && other.Significant)
                return mergePriority.right;
            if (Significant && !other.Significant)
                return mergePriority.left;

            if (Empty && !other.Empty)
                return mergePriority.right;
            if (!Empty && other.Empty)
                return mergePriority.left;

            return mergePriority.none;
        }

        private mergePriority compareByConsistency(T native)
        {
            if (!Significant && isSignificant(native))
                return mergePriority.right;
            if (Significant && !isSignificant(native))
                return mergePriority.left;

            return mergePriority.none;
        }

        public System.DateTime LastModif
        {
            get
            {
                if (Empty)
                    return System.DateTime.MinValue;
                //  sortAndCompact();
                return m_list[0].Date;
            }
        }

        public T Value
        {
            get
            {
                if (Empty)
                    return getNullValue();
                //sortAndCompact();
                int i = 0;
                while (true)
                {
                    var version = m_list[i];
                    if (!version.Consider)
                    {
                        i++;
                        continue;
                    }
                    return version.Data.Value;
                }

            }
            set
            {
                if (value.Equals(Value)) return;
                m_list.Insert(0, new CPieceDataVersion<T>(Now, createPieceDataValueT(value)));
                sortAndCompact();

            }
        }

        public void removeLastVersion()
        {
            int count = m_list.Count;
            if (count <= 1)
                return;
            m_list.RemoveAt(0);
            sortAndCompact();
        }

        public T LastValue
        {
            get
            {
                if (Empty)
                    return getNullValue();
                int count = m_list.Count;
                if (count < 2)
                    return getNullValue();
                int i = 1;
                while (true)
                {
                    var version = m_list[i];
                    if (!version.Consider)
                    {
                        i++;
                        if (i >= count)
                        {
                            return getNullValue();
                        }
                        continue;
                    }
                    return version.Data.Value;
                }

            }

        }


        private bool Simple
        {
            get { return (m_list.Count == 1 && m_list[0].Date == System.DateTime.MinValue) || Empty; }
        }
        public bool Empty
        {
            get
            {
                //if (empty == Bool.not_defined)
                //{
                bool ret = m_list.Count == 0 || m_list[0].Empty;
                return ret;
                //    empty = ret ? Bool.True : Bool.False;
                //    return ret;
                //}
                //return empty == Bool.True;

            }
        }

        public bool Significant
        {
            get
            {
                if (m_list.Count > 1)
                    return true;
                return m_list.Count == 1 && m_list[0].Significant;
            }
        }
        public abstract bool isSignificant(T value);



        public void checkList(CPieceData<T> other)
        {
            foreach (CPieceDataVersion<T> version in other)
            {
                check(version);
            }
            sortAndCompact();
        }


        /// <summary>
        /// indique si la liste contient déja la version
        /// </summary>
        /// <param name="a_version">version testée</param>
        /// <returns>True : si version connue</returns>
        /// <remarks>On ne prend en compte que les dates définies</remarks>
        private bool Contains(CPieceDataVersion<T> a_version)
        {
            foreach (CPieceDataVersion<T> l_elt in this)
            {
                System.DateTime l_date = l_elt.Date;
                if (l_date > System.DateTime.MinValue && a_version.Date == l_date)
                {
                    return true;
                }
            }
            return false;
        }


        private void check(CPieceDataVersion<T> a_version)
        {
            if (!Contains(a_version))
            {
                if (a_version.Date > System.DateTime.MinValue)
                {
                    if (a_version.Consider)
                    {
                        m_list.Add(a_version);
                        //     empty = Bool.not_defined;
                    }
                }
            }

        }


        public CPieceData(System.Xml.XmlElement a_node)
        {

            bool l_bSingle = false;

            XmlElement l_Mynode = XMLTool.NodeLookUp(a_node, getToken());

            if (l_Mynode == null)
                return;

            XmlAttribute att = l_Mynode.Attributes[CPieceDataValue<T>.TOKEN];
            if (att != null)
            {
                l_bSingle = true;
            }




            foreach (XmlNode l_node in l_Mynode)
            {
                if (!l_bSingle)
                {

                    if (l_node is XmlElement && l_node.Name == CPieceDataVersion<T>.VERSION)
                    {
                        XmlElement l_elt = (XmlElement)l_node;
                        CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(l_elt, this);
                        if ((!l_version.Data.Empty || canErase()))
                        {
                            m_list.Add(l_version);
                        }
                    }
                    else
                    {
                        l_bSingle = true;
                        // break; // TODO: might not be correct. Was : Exit For
                    }
                }
            }

            if (l_bSingle)
            {
                CPieceDataVersion<T> l_version = null;
                if (l_Mynode != null)
                    l_version = new CPieceDataVersion<T>(l_Mynode, this);
                else
                    l_version = new CPieceDataVersion<T>(att.Value, this);
                m_list.Add(l_version);
            }
            sortAndCompact();
        }




        public void write(ITextWriter a_sw)
        {
            if (Empty)
                return;
            XMLTool.openBalise(a_sw, getToken());
            if (Simple)
            {
                a_sw.Append(m_list[0].Data.ToString());
            }
            else
            {
                sortAndCompact();
                //    m_list.Sort(c_comparerInv); 
                foreach (CPieceDataVersion<T> l_version in m_list)
                {
                    l_version.write(a_sw);
                }
            }
            XMLTool.closeBalise(a_sw, getToken());
        }

        protected virtual void writeSimple(XmlWriter w)
        {
            w.WriteElementString(getToken(), m_list[0].Data.ToString());
            //  w.WriteAttributeString(getToken(), m_list[0].Data.ToString()); 
        }

        public void write(XmlWriter w)
        {
            if (Empty)
                return;
            //  w.WriteStartElement(getToken()); 

            if (Simple)
            {
                writeSimple(w);


            }
            else
            {
                w.WriteStartElement(getToken());
                sortAndCompact();
                //    m_list.Sort(c_comparerInv); 
                foreach (CPieceDataVersion<T> l_version in new List<CPieceDataVersion<T>>(m_list))
                {
                    l_version.write(w);
                }
                w.WriteEndElement();
            }

        }

        public bool HasChange(CPieceData<T> lastFull)
        {
            if (lastFull.Value == null || !lastFull.Value.Equals(Value))
                return true;
            return false;
        }

        public void writeDiff(XmlWriter w, CPieceData<T> lastFull)
        {
            //if (Empty)
            //    return;
            ////  w.WriteStartElement(getToken()); 

            sortAndCompact();
            lastFull.sortAndCompact();

            if (Value == null)
            {
                if (lastFull.Value == null)
                    return;
            }

            if (lastFull.Value == null || !lastFull.Value.Equals(Value))
            {

                if (Simple)
                {
                    if (lastFull.m_list.Count < 1 || m_list.Count < 1 || !(lastFull.m_list[0].Data.Value.Equals(m_list[0].Data.Value)))
                    {
                        writeSimple(w);
                        return;
                    }


                }
                else
                {
                    w.WriteStartElement(getToken());

                    //    m_list.Sort(c_comparerInv); 

                    //int count = lastFull.m_list.Count;
                    //int count0 = count; 
                    //if (m_list.Count > count)
                    //    count = m_list.Count;

                    //for (int i = count -1 ; i >=0; i++)
                    //{
                    //    CPieceDataVersion<T> my = m_list[i];
                    //    CPieceDataVersion<T> old = null;
                    //    if (i < count0 - 1)
                    //        old = lastFull.m_list[i]; 

                    //    if (old == null)



                    //}
                    foreach (CPieceDataVersion<T> l_version in new List<CPieceDataVersion<T>>(m_list))
                    {
                        bool found = false;
                        foreach (CPieceDataVersion<T> l_version_old in new List<CPieceDataVersion<T>>(lastFull.m_list))
                        {
                            if (l_version_old.Date == l_version.Date && l_version_old.Data.Equals(l_version.Data))
                            {
                                found = true;
                                break;
                            }

                        }

                        if (found)
                            continue;
                        l_version.write(w);
                    }
                    w.WriteEndElement();
                }
            }

        }



        public virtual CListDate Dates
        {
            get
            {
                CListDate dates = new CListDate();
                foreach (CPieceDataVersion<T> data in m_list)
                {
                    dates.check(data.Date);
                }
                return dates;
            }
        }
        //private class CDataVersionComparer : IComparer<CPieceDataVersion<T>>
        //{


        //    public int Compare(CPieceDataVersion<T> x, CPieceDataVersion<T> y)
        //    {
        //        return System.DateTime.Compare(x.Date, y.Date);
        //    }
        //}
        private class CDataVersionComparerInv : IComparer<CPieceDataVersion<T>>
        {
            public int Compare(CPieceDataVersion<T> x, CPieceDataVersion<T> y)
            {
                if (!x.Consider)
                {
                    if (!y.Consider)
                        return -1 * System.DateTime.Compare(x.Date, y.Date);
                    return 1;
                }
                if (!y.Consider)
                    return -1;

                return -1 * System.DateTime.Compare(x.Date, y.Date);
            }
        }

        public System.Collections.IEnumerator GetEnumerator1()
        {
            return m_list.GetEnumerator();
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator1();
        }

        public System.Collections.Generic.IEnumerator<CPieceDataVersion<T>> GetEnumerator()
        {
            return m_list.GetEnumerator();
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\value\CPieceDataValueString.cs">
    <content><![CDATA[using System.Xml;
using pdb.util;
using System;

namespace pdb.db.piece.value
{
    public class CPieceDataValueString : CPieceDataValue<string>
    {

        public void new_(string a_str)
        {

            // QU'est-ce que cest que ce TRUC!!!!
            m_data = XMLTool.FromXml(a_str.Trim());
            //DateTime dt = DateTime.MinValue;
            
            //if (DateTime.TryParse(a_str.Trim(), out dt))
            //    m_data = "";

        }

        public CPieceDataValueString(string a_str)
        {
            new_(a_str);
        }

        public override CPieceDataValue<string> createCopy()
        {
            return new CPieceDataValueString(m_data);
        }
        public CPieceDataValueString(XmlElement a_node)
        {
            XmlElement l_v2 = XMLTool.NodeLookUp(a_node, TOKEN);
            var att = a_node.Attributes[TOKEN];
            if (l_v2 != null)
            {
                new_(l_v2.InnerText);
            }
            else if (att != null)
            {
                new_(att.Value);
            }
            else
                new_(a_node.InnerText); 
        }
        public override bool Empty
        {
            get { return m_data == null || m_data == ""; }
        }



        protected override void writeDb(ITextWriter a_sw)
        {
            XMLTool.writeValue(a_sw, TOKEN, XMLTool.RefToXml(m_data));
        }

        //protected override void writeDb(XmlWriter w)
        //{
        //    w.WriteElementString(TOKEN, m_data);
        //}

        public override string ToString()
        {
            return XMLTool.RefToXml(m_data);
        }

        //public override bool Significant
        //{
        //    get
        //    {
        //        if (!base.Significant)
        //            return false; 
        //        string value
        //    }
        //}
    }
}
]]></content>
  </file>
</db>
