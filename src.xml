<db path="C:\Bernard\db1\pdb4b">
  <file path="\pdb.player\ViewModel\TrackListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Windows;
using pdb.obj;
using pdb.util;
using pdb.gen;
using pdb.db.obj;
using pdb.gen.albums;

namespace pdb.player.ViewModel
{

    public class TrackListViewModel : BibViewModelBase, ITrackNativeDates
    {




        #region répercut
        //  private static BgDict<int, List<TrackListViewModel>> dictT = new BgDict<int, List<TrackListViewModel>>();
        #endregion
        private TrackList track;
        private PieceViewModel piece;
        private static TrackListViewModel currentPlaying;
        private static TrackListViewModel currentSelected;
        public TrackList Track { get { return track; } }
        public CPiece Piece { get { return piece.Piece; } }
        public Piece PieceGen { get { return track.Piece; } }
        public Piece Master { get { return PieceGen.Master; } }

        public void remove()
        {
            //var list = dictT[PieceId];
            //if (list == null)
            //    return;
            //list.Remove(this);
        }

        public void refresh()
        {
            piece.eraseCommentGrouping();
            OnPropertyChanged("ExportStatus");
            OnPropertyChanged("TV");
            OnPropertyChanged("Comment");
            OnPropertyChanged("Grouping");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("ClassementVirtuel");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("");
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                if (value != base.IsSelected)
                {
                    base.IsSelected = value;
                    if (value)
                        CurrentSelected = this;
                    OnPropertyChanged("TV");
                }
            }
        }

        private int index;
        public int Index
        {
            get { return index; }
            set
            {
                if (value != index)
                {
                    index = value;
                    OnPropertyChanged("Index");
                }
            }
        }

        public int StackValue { get { return PieceGen.StackValue; } }
        public int StackIndex { get { return PieceGen.StackIndex; } }

        public static event EventHandler CurrentSelectedChanged;
        public static TrackListViewModel CurrentSelected
        {
            get
            {
                return currentSelected;
            }
            set
            {
                if (value != currentSelected)
                {
                    currentSelected = value;
                    if (CurrentSelectedChanged != null)
                        CurrentSelectedChanged("Track", EventArgs.Empty);
                }
            }
        }

        public static event EventHandler CurrentHumanSelectedChanged;
        private static TrackListViewModel humanSelected;
        private static int humanSelectedId;
        public static TrackListViewModel HumanSelected
        {
            get { return humanSelected; }
            //set
            //{
            //    if (value != humanSelected)
            //    {
            //        humanSelected = value;
            //        if (CurrentHumanSelectedChanged != null)
            //            CurrentHumanSelectedChanged("Human", EventArgs.Empty);
            //    }
            //}
        }

        public static void setHumanSelected(PlayListViewModel pl, TrackListViewModel track)
        {
            //if (humanSelected != null)
            //{
            //    humanSelected.refresh();
            //   // var b = humanSelected.Grouping; 
            //}
            if (track != humanSelected)
            {
                humanSelected = track;


                //  humanSelected.refresh();
                // var b = humanSelected.Grouping; 
                int id = 0;
                if (track != null) id = track.PieceId;
                if (id != humanSelectedId)
                {
                    humanSelectedId = id;
                    if (CurrentHumanSelectedChanged != null)
                        CurrentHumanSelectedChanged(pl, EventArgs.Empty);
                }
            }
        }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
                //if (value != track.Enabled)
                //{
                //    track.Piece.Enabled = value;
                //    OnPropertyChanged("Enabled");
                //}
            }
        }
        //  private exportState exportState;
        //public int ExportState
        //{
        //    get
        //    {
        //        return (int)exportState;
        //    }
        //}

        public static EventHandler ExportStatusChange;
        private static void OnExportStatusChange(TrackListViewModel tv)
        {
            if (ExportStatusChange != null)
                ExportStatusChange(tv, EventArgs.Empty);
        }

        public static event EventHandler ClassementChange;
        private static void OnClassementChange(TrackListViewModel tv)
        {
            if (ClassementChange != null)
                ClassementChange(tv, EventArgs.Empty);
        }

        public TrackListViewModel TV { get { return this; } }

        public exportState ExportStatus
        {
            get
            {
                return Piece.ExportStatus; // exportState;
            }
            set
            {
                if (Piece.ExportStatus != value)
                {
                    Piece.ExportStatus = value;
                    OnPropertyChanged("ExportStatus");
                    OnPropertyChanged("TV");
                    OnPropertyChanged("Background");
                    OnExportStatusChange(this);
                    //refresh();


                }
            }
        }

        public selectedCoeff SelectedMotif
        {
            get
            {
                if (PieceGen == null)
                    return selectedCoeff.none;
                return PieceGen.SelectedMotif;
            }
        }








        public TrackListViewModel(TrackList track, PlayListViewModel playlist)
            : base(track, playlist)
        {
            this.track = track;
            this.piece = PieceViewModel.getPiece(track); // new PieceViewModel(track); // track.Piece.Track as CPiece; 
            piece.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(piece_PropertyChanged);
            int id = track.PieceId;
            //if (!dictT.ContainsKey(id))
            //{
            //    var list = new List<TrackListViewModel>();
            //    dictT.Add(id, list);
            //}

            //dictT[id].Add(this);

        }

        void piece_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            OnPropertyChanged(e.PropertyName);
        }

        public String StrPlaying
        {
            get
            {
                if (playing) return "<))";
                return "";
            }
        }
        public string MedianneStatus
        {
            get
            {
                var p = PieceGen;
                if (p.Medianne)
                    return ">>";
                if (p.MedianneLight)
                    return ">";
                if (p.Border)
                    return "-";
                if (p.BorderMin)
                    return "-";
                if (p.BorderEffect)
                    return "--";

                return "";
            }
        }

        private bool playing;
        public bool Playing
        {
            get { return playing; }
            set
            {
                if (value != playing)
                {
                    playing = value;
                    if (playing)
                    {
                        CurrentPlaying = this;
                    }
                    OnPropertyChanged("Playing");
                    OnPropertyChanged("StrPlaying");
                }
            }
        }

        public static TrackListViewModel CurrentPlaying
        {
            get
            {
                return currentPlaying;
            }
            set
            {
                if (value != currentPlaying)
                {
                    if (currentPlaying != null)
                        currentPlaying.Playing = false;
                    currentPlaying = value;
                }
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
                //if (value != track.Rating)
                //{
                //    track.Rating = value;
                //    onPropertyChanged("Rating");
                //}
            }
        }

        //  private pdb.db.obj.CPiece CPiece { get { return track.Piece.Track as pdb.db.obj.CPiece; } }


        //public static readonly DependencyProperty ClassementProperty =
        //DependencyProperty.Register("Classement", typeof(String),
        // typeof(PieceViewModel), new UIPropertyMetadata(null));
        public String Classement
        {
            get
            {
                return piece.Piece.StrClassement;
            }
            set
            {

                // piece.StrClassement = value;
                if (value != piece.Piece.StrClassement)
                {
                    piece.Classement = value;
                    PieceGen.invalidateCache();
                    App.gen.Albums.signalClassChange(track);
                    try
                    {

                        PlayerViewModel.makeauto(this);
                        App.bib.setClassement(this, value);



                        // piece.Piece.StrClassement = value;

                    }
                    catch
                    {
                    }

                    OnClassementChange(this);
                    App.go(true);
                    // onPropertyChanged("Classement");


                }

            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
                //if (value != piece.Year)
                //{
                //    track.Year = value;
                //    onPropertyChanged("Year");
                //}
            }
        }


        //public static readonly DependencyProperty CommentProperty =
        //DependencyProperty.Register("Comment", typeof(string),
        //typeof(PieceViewModel), new UIPropertyMetadata(null)); 
        public string Comment
        {
            get
            {
                if (PieceGen.Virtual)
                    return ""; 
                return piece.Comment;
            }
            set
            {
                if (PieceGen.Virtual)
                    return; 
                //piece.Comment = value; 
                if (value != piece.Comment)
                {
                    //  track.Comment = value;
                    piece.Comment = value;
                    OnPropertyChanged("Comment");

                }
            }
        }

        public string Grouping
        {
            get { return track.Piece.Grouping; }
            set
            {
                //  piece.Grouping = value;
                if (value != track.Piece.Grouping)
                {
                    track.Piece.setGrouping(value, true);
                    // track.setGrouping(value, true);
                    OnPropertyChanged("Grouping");
                }
            }
        }




        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }


        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set
            {
                piece.Duration = value;
                //if (!Exists)
                //    return; 
                //if (value != Duration)
                //{
                //    var deltaMs = Math.Abs(value.TotalMilliseconds - Duration.TotalMilliseconds);
                //    if (deltaMs >= 1)
                //    {
                //        track.Duration = value;
                //        if (deltaMs >= 1000)
                //            onPropertyChanged("Duration");
                //    }
                //}
            }
        }

        public string Location
        {
            get { return piece.Location; }
        }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
                //if (value != track.Artist)
                //{
                //    track.Artist = value;
                //    onPropertyChanged("Artist");
                //}
            }
        }

        public string Album
        {
            get
            {
                if (track.Virtual)
                {
                    if (track.Piece.VirtualByArtist)
                        return string.Format("[{0}]", track.Album);
                    return track.Album;
                }
                return piece.Album;
            }
            set
            {
                if (!track.Virtual)
                    piece.Album = value;
                //if (value != track.Album)
                //{
                //    track.Album = value;
                //    onPropertyChanged("Album");
                //}
            }
        }

        public string MasterAlbum
        {
            get
            {
                //    if (track.Virtual)
                //        return " " + PieceGen.Master.Album;
                return PieceGen.Master.Album;
            }
            set
            {
                if (value == null)
                    return;
                value = value.Trim();
                if (value != PieceGen.Master.Album)
                {
                    PieceGen.Master.Album = value;
                    OnPropertyChanged("MasterAlbum");
                }
            }
        }

        public Album album { get { return PieceGen.PieceAlbum; } }

        public string Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
                //if (value != track.Name)
                //{
                //    track.Piece.Name = value;
                //    onPropertyChanged("Name");
                //}
            }
        }

        public int TrackNumber
        {
            get
            {
                return track.Piece.TrackNumber;
            }
            set
            {
                if (!track.Virtual)
                    piece.TrackNumber = value;
                //if (value != track.TrackNumber)
                //{
                //    track.TrackNumber = value;
                //    onPropertyChanged("TrackNumber");
                //}
            }
        }


        public void setClassement(string className, int rating)
        {
            piece.Piece.setClassement(className, rating);
            PieceGen.invalidateCache();

        }

        public string ClassName
        {
            get
            {
                return piece.Piece.ClassName;
            }
            set
            {
                piece.Piece.ClassName = value;
            }
        }


        public DateTime PlayedDate
        {
            get { return piece.Piece.PlayedDate; }
        }

        public string ArtWork
        {
            get
            {
                return piece.Piece.ArtWork;
            }
            set
            {
                piece.Piece.ArtWork = value;
            }
        }

        public void setGrouping(string value, bool prior)
        {
            track.Piece.setGrouping(value, prior);
            piece.Grouping = value; // TODO je fait quoi de ça ???
            // onPropertyChanged("Grouping");
        }

        public string ClassementVirtuel { get { return PieceGen.ClassementVirtuel; } }

        public decimal CoeffVirtuel { get { return PieceGen.CoeffVirtuel; } }

        public string ClassementVirtuel2 { get { return PieceGen.ClassementVirtuel2; } }

        public decimal CoeffVirtuel2 { get { return PieceGen.CoeffVirtuel2; } }

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

      

        public List<DateTime> Dates
        {
            get { return new List<DateTime>(piece.Piece.Dates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.Piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return track.Piece.ClassEvol; }
        }

        public long Size { get { return Piece.Size; } }

        public bool Exists { get { return Piece.Exists; } }

        //public void onPropertyChanged(string propertyName)
        //{
        //    var list = dictT[PieceId];
        //    if (list == null)
        //    {
        //        OnPropertyChanged(propertyName);
        //    }
        //    else
        //    {
        //        foreach (TrackListViewModel t in dictT[PieceId])
        //            t.OnPropertyChanged(propertyName);
        //    }
        //}




        public int PieceId
        {
            get { return track.PieceId; }
        }
        public int MasterId { get { return PieceGen.MasterId; } }


        public int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }

        public void setParent(TrackListViewModel parent)
        {
            track.Piece.albumMustRefresh();
            parent.track.Piece.albumMustRefresh(); 

            piece.Piece.Parent = parent.Piece.Master;
            track.Piece.Parent = parent.track.Piece;

            track.Piece.albumMustRefresh();
            parent.track.Piece.albumMustRefresh(); 
        }

        public void fusion(TrackListViewModel toDelete)
        {
            App.Db.List.fusion(piece.Piece, toDelete.Piece);

        }





        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        //public List<string> RelativesPath
        //{
        //    get { return track.RelativesPath; }
        //}

        public DateTime? UpdateClassement { get { return PieceGen.UpdateClassement; } }
        public DateTime? AlbumUpdateClassement { get { return PieceGen.AlbumUpdateClassement; } }

        public DateTime? LastRead { get { return PieceGen.LastRead; } }
        public DateTime? AlbumLastRead { get { return PieceGen.AlbumLastRead; } }

        public int NbClass { get { return PieceGen.NbClass; } }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\Commande\PlayList\ExportCmd.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using pdb.db;
using pdb.db.obj;
using pdb.gen;
using pdb.util;
using pdb.gen.Tuning;
using System.Runtime.InteropServices;
using pdb.gen.albums;
using pdb.obj;

namespace pdb.player.ViewModel.Commande.PlayList
{
    public enum compressState
    {
        none,
        record,
        enCours,
        end,
        reload,
        cancel
    }
    class ExportCmd : CommandeBase
    {
        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool GetDiskFreeSpaceEx(string lpDirectoryName,
        out ulong lpFreeBytesAvailable,
        out ulong lpTotalNumberOfBytes,
        out ulong lpTotalNumberOfFreeBytes);

        private static long getFreeSpace()
        {
            ulong FreeBytesAvailable;
            ulong TotalNumberOfBytes;
            ulong TotalNumberOfFreeBytes;

            bool success = GetDiskFreeSpaceEx(conf.dir, out FreeBytesAvailable, out TotalNumberOfBytes,
                               out TotalNumberOfFreeBytes);
            if (!success)
                throw new System.ComponentModel.Win32Exception();
            return (long)TotalNumberOfFreeBytes;
        }



        private static IExportTracks ihm;
        public static IExportTracks Ihm { set { ihm = value; } }
        // private static bool cancel;
        // protected static string dir;
        protected static PlayListViewModel lastpl;
        protected static List<PiecePrior> presents;
        protected static Dict<int, PiecePrior> dict;
        protected static List<PiecePrior> list;
        protected static List<List<PiecePrior>> listes;
        protected static List<PlayListViewModel> playlists = new List<PlayListViewModel>();

        protected static Dictionary<int, object> ids;
        protected static Dict<int, PiecePrior> idCopie;
        protected static BgDictString<PiecePrior> idCopieLoc;
        private static int nbLoop = 0;
        protected static Export conf;
        private static bool modeAlbum;
        //private static int nbByAlbumMin = int.MaxValue;
        //private static int nbByAlbumMax = int.MaxValue;
        //private static int nbLot = 100; 
        protected static int nbFicherSup;
        protected static int nbFichierAdd;
        const string CAPTION = "export";
        protected string ANNULATION_EXPORT = "Annulation export";

        protected static BgDictString<List<PiecePrior>> locations = new BgDictString<List<PiecePrior>>();

        protected static compressState state;
        public static void CalculExport()
        {
            if (conf != null && conf.oneShot)
                return;
            switch (state)
            {
                case compressState.none:
                    break;
                case compressState.record:
                    break;
                case compressState.enCours:
                    PlayListViewModel.resetExport(exportState.none);
                    state = compressState.reload;
                    break;
                case compressState.end:
                    state = compressState.reload;
                    break;
                case compressState.reload:
                    break;
                case compressState.cancel:
                    break;
                default:
                    break;
            }
        }

        protected class PiecePrior
        {
            private int prior0 = int.MaxValue;
            private int prior1 = int.MaxValue;
            public readonly Piece PieceGen;
            public PiecePrior(Piece piece, int prior)
            {
                this.PieceGen = piece;
                this.prior0 = prior;
            }

            public CPiece Piece { get { return PieceGen.Track as CPiece; } }

            public int Prior0 { get { return prior0; } }
            public int Prior1 { get { return prior1; } }
            public int MasterId { get { return Piece.MasterId; } }
            public void setPrior(int prior)
            {
                if (prior < this.prior1)
                    this.prior1 = prior;
            }

            public static void mergePrior0(ICollection<PiecePrior> list)
            {
                if (list.Count <= 1)
                    return;
                int min = int.MaxValue;
                foreach (PiecePrior p in list)
                {
                    var p0 = p.prior0;
                    if (p0 < min)
                        min = p0;
                }
                foreach (PiecePrior p in list)
                {
                    p.prior0 = min;
                }
            }

            public static void mergePrior1(ICollection<PiecePrior> list)
            {
                if (list.Count <= 1)
                    return;
                int min = int.MaxValue;
                foreach (PiecePrior p in list)
                {
                    var p1 = p.prior1;
                    if (p1 < min)
                        min = p1;
                }
                foreach (PiecePrior p in list)
                {
                    p.prior0 = min;
                }
            }

            public override string ToString()
            {
                int rank = PieceGen.RankAlbumReverse;
                int nb = PieceGen.NbExportPresents;
                return string.Format("{0} {1} {2}\t {3} {4} {5}", rank, nb, PieceGen.TrackNumber, prior0, prior1, PieceGen.ToString());          
              //  return rank + " " + PieceGen.TrackNumber + "\t" + prior0 + " " + prior1 + " " + PieceGen.ToString();
            }
        }

        protected class PriorComparer : IComparer<PiecePrior>
        {
            public int Compare(PiecePrior x, PiecePrior y)
            {
                int cmp = x.Prior1.CompareTo(y.Prior1);
                if (cmp != 0)
                    return cmp;
                return x.Prior0.CompareTo(y.Prior0);
            }
        }

        public ExportCmd()
        {

        }


        public override bool CanExecute(object parameter)
        {
            return ihm != null;
        }

        public override void Execute(object parameter)
        {
            if (state <= compressState.record)
                record();
            else
            {
                state = compressState.cancel;
                PlayListViewModel.resetExport(exportState.none);
            }
            OnPropertyChanged("Header");
        }
        private class TrackAlbumReverseComparer : IComparer<TrackListViewModel>
        {
            //  private static PieceClassementComparerInv comparer = new PieceClassementComparerInv();
            //private bool disabledAlway;

            //public TrackAlbumReverseComparer(bool disabledAlway)
            //{
            //    this.disabledAlway = disabledAlway; 
            //}

            public int Compare(TrackListViewModel x, TrackListViewModel y)
            {
                var xx = x.PieceGen;
                var yy = y.PieceGen;
                if (xx.PieceAlbum != yy.PieceAlbum)
                    return x.Index.CompareTo(y.Index);

                return xx.IndexExport.CompareTo(yy.IndexExport);

                //if (disabledAlway)
                //{
                //    if (x.Enabled != y.Enabled)
                //    {
                //        return -x.Enabled.CompareTo(y.Enabled); // ? -1 : 1;
                //    }
                //}
                //var xv = x.PieceGen.RapportClassement;
                //var yv = y.PieceGen.RapportClassement;

                //int cmp = 0;
                //if (xv > 0 && yv > 0)
                //{
                //    cmp = xv.CompareTo(yv);
                //    if (cmp != 0) return cmp;
                //    cmp = x.PieceGen.VirtualClassement.CompareTo(y.PieceGen.VirtualClassement);
                //    if (cmp != 0) return cmp;
                //}

                //cmp = x.TrackNumber.CompareTo(y.TrackNumber);
                //if (cmp != 0)
                //    return cmp;
                //return x.Location.CompareTo(y.Location);

            }
        }
        protected virtual List<PiecePrior> buildList(PlayListViewModel pl)
        {
            var list = new List<PiecePrior>();
            try
            {
                bool onlyEnabled = PlayerViewModel.Instance.OnlyEnabled && !modeAlbum;
                bool _modeAlbum = modeAlbum && !PlayerViewModel.Instance.SortByAlbum;

                var ids = new Dictionary<int, object>();
                int i = 0;
                var tracks = new List<TrackListViewModel>(pl.ExportTracks);
                if (conf.albumReverse)
                {
                    tracks.Sort(new TrackAlbumReverseComparer()); //conf.disabledAlway));

                }
                else
                    tracks.Sort((x, y) => x.Index.CompareTo(y.Index));

                int lastI = 0;
                Album lastAlbum = null;
              //  int inext = -1; 
                int nbByAlbum = int.MaxValue;
                if (conf.modeAlbum)
                    nbByAlbum = conf.nbMax;
                int nbLot = 0;
                while (true)
                {
                    int nbInThisAlbum = 0;
                    foreach (TrackListViewModel track in tracks)
                    {
                        //  track.ExportStatus = exportState.miss; 
                        if (!onlyEnabled || track.Enabled)
                        {
                            CPiece piece = track.Piece;
                            if (piece.Exists)
                            {
                                int id = piece.MasterId;
                                if (ids.ContainsKey(id))
                                    continue;
                                if (!_modeAlbum)
                                {
                                    if (track.album == lastAlbum)
                                    {
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;
                                        if (track.Enabled || (conf.countFirsts && track.PieceGen.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && track.PieceGen.VirtualClassement <= lastAlbum.ClassementValueLight))
                                            nbInThisAlbum++;
                                        else if (nbInThisAlbum >= nbByAlbum)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;
                                    }
                                    else
                                    {
                                        nbInThisAlbum = 0;
                                        lastAlbum = track.album;// inext = lastAlbum.IndexClass(lastAlbum.Next);
                                        if (track.Enabled || (conf.countFirsts && track.PieceGen.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && track.PieceGen.VirtualClassement <= lastAlbum.ClassementValueLight))
                                            nbInThisAlbum++;
                                        else if (nbInThisAlbum >= nbByAlbum)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;

                                    }
                                    var pp = dict[id]; // list.Add(piece);
                                    if (pp == null)
                                        continue;
                                    pp.setPrior(i);
                                    list.Add(pp);
                                    ids.Add(id, pp);
                                    i++;

                                    //  if (track.Enabled || conf.countAll)
                                    nbLot++;

                                    if (conf.modeAlbum && nbLot > conf.lot)
                                    {
                                        nbLot = 0;
                                        nbByAlbum--;
                                        if (nbByAlbum < conf.nbMin)
                                            nbByAlbum = conf.nbMin;
                                        if (nbByAlbum == 0)
                                            break;
                                    }


                                }
                                else
                                {
                                    if (conf.modeAlbum)
                                    {
                                        if (track.album == lastAlbum)
                                            continue;
                                        else
                                        {
                                            nbLot++;
                                            if (nbLot > conf.lot)
                                            {
                                                nbLot = 0;
                                                nbByAlbum--;
                                                if (nbByAlbum < conf.nbMin)
                                                    nbByAlbum = conf.nbMin;
                                                if (nbByAlbum == 0)
                                                    break;
                                            }
                                        }
                                    }
                                    List<Piece> album = null;
                                    if (conf.albumReverse)
                                        album = App.gen.getTracksAlbumReverse(track.Track);
                                    else
                                        album = App.gen.getTracksAlbumByNumber(track.Track); // piece);
                                    if (album != null)
                                    {
                                        nbInThisAlbum = 0;
                                        lastAlbum = track.album;// inext = lastAlbum.IndexClass(lastAlbum.Next);  //.Album;
                                        foreach (var p in album)
                                        {
                                            CPiece pp = p.Track as CPiece;
                                            if (pp != null && pp.Exists)
                                            {
                                                if (!onlyEnabled || pp.Enabled)
                                                {
                                                    id = pp.MasterId;

                                                    if (ids.ContainsKey(id))
                                                        continue;
                                                    var ppp = dict[id];
                                                    ppp.setPrior(i);
                                                    list.Add(ppp);
                                                    ids.Add(id, ppp);
                                                    i++;
                                                    if (pp.Enabled || (conf.countFirsts && p.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && p.VirtualClassement <= lastAlbum.ClassementValueLight))
                                                    {
                                                        nbLot++;
                                                        if (conf.modeAlbum && nbLot > conf.lot)
                                                        {
                                                            nbLot = 0;
                                                            nbByAlbum--;
                                                            if (nbByAlbum < conf.nbMin)
                                                                nbByAlbum = conf.nbMin;
                                                        }

                                                        nbInThisAlbum++;
                                                        if (nbInThisAlbum >= nbByAlbum)
                                                            break;
                                                    }
                                                }
                                            }

                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (!modeAlbum)
                        break;
                    if (nbByAlbum == int.MaxValue)
                        break;
                    if (nbByAlbum > 0)
                    {
                        if (i == lastI)
                            break;
                    }

                    lastI = i;
                    lastAlbum = null;
                    if (conf.modeAlbum)
                    {
                        if (conf.resetAfterLoop)
                            nbByAlbum = conf.nbMax;
                        if (nbByAlbum < conf.nbMin)
                            nbByAlbum = conf.nbMin;
                        if (nbByAlbum == 0)
                            nbByAlbum = 1;
                    }
                }
                listes.Add(list);
                //   ihm.InfoIHm("liste n° " + listes.Count + " " + list.Count + " éléments", CAPTION);
                OnPropertyChanged("Header");
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
            return list;
        }

        public override string Header
        {
            get
            {
                if (state > compressState.record)
                    return ANNULATION_EXPORT;

                return "Exporter la liste";
            }
        }



        private void record()
        {
            if (state == compressState.none)
            {
                state = compressState.record;
                OnPropertyChanged("Header");
                nbLoop = 0;
                conf = ihm.getConfExport("Configuration Export");

                //  dir = conf.dir; // ihm.folderDialog();

                if (string.IsNullOrEmpty(conf.dir))
                {
                    state = compressState.none;
                    return;
                }

                modeAlbum = conf.modeAlbum; // ihm.Confirm("par albums complets?", CAPTION);

                //if (modeAlbum)
                //{
                //    nbByAlbumMin = conf.nbMin; // ihm.getNb("Nombre de morceaux par passe?");
                //    nbByAlbumMax = conf.nbMax;
                //    nbLot = conf.lot;
                //}
                //else
                //    nbByAlbum = int.MaxValue;

                playlists.Clear();
            }

            bool? status = true;


            var pl = ihm.PlayList;
            if (!playlists.Contains(pl))
            {
                playlists.Add(pl);
                lastpl = pl;
            }

            status = ihm.TriChoix("liste n° " + playlists.Count + " " + pl.ExportTracks.Count + " éléments\r\n lancer l'export ?", CAPTION);



            if (status == null)
            {
                listes = null;
                playlists.Clear();
                state = compressState.none;
                OnPropertyChanged("Header");
                return;
            }
            if (false.Equals(status))
            {
                OnPropertyChanged("Header");
                return;
            }

            state = compressState.enCours;
            OnPropertyChanged("Header");

            var th = new Thread(export__);
            th.SetApartmentState(ApartmentState.STA);
            th.Start();
        }
        //protected static long totalSize = 0;
        //protected static long capacity = int.MaxValue;
        //protected static long freeSpace; 
        //private static void refreshInfoFreeSpace()
        //{
        //    DriveInfo drive = new DriveInfo(Path.GetPathRoot(conf.dir));
        //    var calculfree = freeSpace; 
        //    freeSpace = drive.AvailableFreeSpace;
        //    var delta = freeSpace - calculfree;
        //    if (delta > 0)
        //        App.log.log("difference free space " + delta); 

        //}

        private void buildListIni()
        {

            listes = new List<List<PiecePrior>>();
            presents = new List<PiecePrior>();
            dict = new Dict<int, PiecePrior>();
            locations = new BgDictString<List<PiecePrior>>();

            try
            {

                if (!conf.dir.EndsWith("\\"))
                    conf.dir += "\\";
                //  refreshInfoFreeSpace(); 

                List<Piece> l = null;


                if (lastpl.isSubList("album") || PlayerViewModel.Instance.SortByAlbum)
                {
                    l = App.gen.sortByAlbum();
                    l.Reverse();
                }
                else
                    l = App.gen.sortByClass();
                // l.Reverse();

                int i = 0;
                foreach (Piece p in l)
                {
                    var piece = p.Track as CPiece;
                    if (!dict.ContainsKey(piece.MasterId))
                    {
                        var pp = new PiecePrior(p, i);
                        i++;
                        presents.Add(pp);
                        dict[piece.MasterId] = pp;
                        foreach (CFile file in piece.Files)
                        {
                            var lp = locations[file.File];
                            if (lp == null)
                            {
                                lp = new List<PiecePrior>();
                                lp.Add(pp);
                                locations.Add(file.File, lp);
                            }
                            else
                            {
                                lp.Add(pp);
                                PiecePrior.mergePrior0(lp);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }

        }

        [STAThread]
        private void export__()
        {


            while (true)
            {
                try
                {
                    switch (state)
                    {
                        case compressState.none:
                            return;
                        case compressState.enCours:
                            break;
                        case compressState.end: Thread.Sleep(1000); continue;
                        case compressState.reload:
                            break;
                        case compressState.cancel:
                            {
                                state = compressState.none;
                                nbLoop = 0;
                                return;
                            }

                        default:
                            break;
                    }
                    state = compressState.enCours;
                    nbLoop++;


                    buildListIni();

                    foreach (PlayListViewModel pl in playlists)
                    {
                        buildList(pl);
                    }

                    foreach (List<PiecePrior> lp in locations.Values)
                    {
                        PiecePrior.mergePrior1(lp);
                    }

                    // concaténation
                    int max = 0;
                    list = new List<PiecePrior>();
                    foreach (var _l in listes)
                    {
                        var count_ = _l.Count;
                        if (count_ > max)
                            max = count_;
                    }
                    int count = listes.Count;
                    ids = new Dictionary<int, object>();


                    for (int i = 0; i < max; i++)
                    {
                        for (int j = 0; j < count; j++)
                        {
                            var l = listes[j];
                            if (i < l.Count)
                            {
                                var p = l[i];
                                int id = p.MasterId;
                                if (!ids.ContainsKey(id))
                                {
                                    ids.Add(id, p);
                                    list.Add(p);
                                }
                            }
                        }
                    }






                    App.log.log("Export lancé " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments", CAPTION);
                    _export();
                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                    Thread.Sleep(1000);
                }

            }
        }

        protected virtual bool noMoreSpace()
        {
            return true;
        }
        protected virtual void prepareExport()
        {
        }

        protected void setExport(exportState state, PiecePrior p)
        {
            setExport(state, p.PieceGen);
        }

        protected void setExport(exportState state, ITrackNativeDates p)
        {
            p.ExportStatus = state; 
            PlayListViewModel.setExport(p.PieceId, state);


            var h = TrackListViewModel.HumanSelected;
            if (h != null)
            {
                if (p.Album == h.Album)
                {
                    TrackListViewModel trackAlbum = PlayListViewModel.findTrack(App.bib.Musique, p.PieceId);
                    if (trackAlbum != null)
                    {
                        trackAlbum.ExportStatus = state; 
                    }

                }
            }

            //var track = PlayListViewModel.findTrack(lastpl, p.PieceId);
            //if (track != null)
            //{
            //    track.ExportStatus = state;
            //}
            //var h = TrackListViewModel.HumanSelected;
            //if (h != null)
            //{
            //    if (p.Album == h.Album)
            //    {
            //        var album = App.getAlbum(h);
            //        var f = album.Find(t => t.PieceId == p.PieceId);
            //        if (f != null)
            //            track.ExportStatus = state;
            //    }
          //  }
        }

        private void _export()
        {

            PlayListViewModel.resetExport(exportState.present);
            try
            {
                foreach (PiecePrior piece in list)
                {
                    try
                    {
                        if (state != compressState.enCours)
                            return;
                        //1. Vérification que le fichier n'existe pas déjà 
                        bool exists = false;
                        var files = piece.Piece.Files;
                        foreach (CFile file in files)
                        {
                            if (state != compressState.enCours)
                                return;
                            try
                            {
                                string path = conf.dir + file.File;
                                var fv = FileRegister.Check(path);
                                if (fv.Exists)
                                {
                                    if (fv.Length == file.Size)
                                    {
                                        exists = true;
                                        break;
                                    }
                                    else
                                    {
                                        fv.delete();
                                    }
                                }
                            }

                            catch
                            {
                            }
                        }



                        if (exists)
                        {
                            // PlayListViewModel.setExport(piece.Piece.PieceId, exportState.present);
                            //var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                            //if (track != null)
                            //{
                            //    track.ExportStatus = exportState.present;
                            //}
                        }
                        else
                            setExport(exportState.miss, piece);
                    }
                    catch (Exception e)
                    {
                        App.log.log(e.ToString());
                    }
                }

                nbFicherSup = 0; nbFichierAdd = 0;
                idCopie = new Dict<int, PiecePrior>(); idCopieLoc = new BgDictString<PiecePrior>();
                presents.Sort(new PriorComparer());
                prepareExport();

                string orgDir = CFile.DefaultFolder;
                foreach (PiecePrior piece in list)
                {
                    try
                    {
                        if (state != compressState.enCours)
                            return;

                        int id = piece.MasterId;
                        if (idCopie.ContainsKey(id))
                            continue;
                        var files = piece.Piece.Files;
                        bool contFile = false;
                        foreach (CFile file in files)
                        {
                            if (idCopieLoc.ContainsKey(file.File))
                            {
                                contFile = true;
                                break;
                            }
                        }
                        if (contFile)
                            continue;

                        idCopie[id] = piece;
                        foreach (CFile file in files)
                        {
                            idCopieLoc[file.File] = piece;
                        }




                        //1. Vérification que le fichier n'existe pas déjà 
                        bool exists = false;
                        foreach (CFile file in files)
                        {
                            if (state != compressState.enCours)
                                return;
                            try
                            {
                                string path = conf.dir + file.File;
                                var fv = FileRegister.Check(path);
                                if (fv.Exists)
                                {

                                    if (fv.Length == file.Size)
                                    {
                                        exists = true;
                                        break;
                                    }
                                    else
                                    {
                                        fv.delete();
                                    }

                                }
                            }

                            catch
                            {
                            }
                        }



                        if (exists)
                        {
                            //    var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                            //    if (track != null)
                            //    {
                            //        track.ExportStatus = exportState.present; 
                            //    }
                            continue;
                        }

                        //2. Copie du meilleur fichier
                        CFile pertinent = piece.Piece.PertinentFile;
                        if (pertinent == null)
                            continue;


                        while (true)
                        {
                            if (state != compressState.enCours)
                                return;
                            try
                            {
                                FileInfo f = new FileInfo(pertinent.Path);
                                var freeSpace = getFreeSpace() - conf.marge;
                                long nextfreeAvailable = freeSpace - f.Length;
                                if (nextfreeAvailable < 0)
                                {
                                    if (noMoreSpace())
                                        return;
                                    continue;
                                }
                                App.log.log("copie\t" + piece + "->" + conf.dir + pertinent.File + " ( " + piece + " )");
                                f.copyTree(conf.dir + pertinent.File, true);
                                //  freeSpace = nextfreeAvailable; 
                                //  PlayListViewModel.setExport(piece.Piece.PieceId, exportState.copy);
                                setExport(exportState.copy, piece);
                                //var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                                //if (track != null)
                                //{
                                //    track.ExportStatus = exportState.copy;
                                //}
                                nbFichierAdd++;

                                break;
                            }
                            catch (System.IO.IOException io)
                            {
                                App.log.log(io.Message);
                                //  refreshInfoFreeSpace(); 
                                if (noMoreSpace())
                                    return;
                            }
                        }

                    }

                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }


                }
            }
            catch (Exception ex)
            {
                App.log.log(ex.ToString());

            }
            finally
            {
                var log = string.Format("Fin de l'export {0} liste{1} éléments\r\n{2} fichier{3} copié{3}\r\n{4} fichier{5} supprimé{6}",
                    listes.Count, (list.Count > 1 ? "s " : " "), nbFichierAdd, (nbFichierAdd > 1 ? "s" : ""), nbFicherSup, (nbFicherSup > 1 ? "s" : ""), (nbFicherSup > 1 ? "s" : ""));
                App.log.log(log, CAPTION);
                if (conf.oneShot)
                    ihm.InfoIHm(log, CAPTION);
                //  ihm.InfoIHm("Fin de l'export " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments\r\n" + idCopie.Count + " fichiers copiés\r\n" + nbFicherSup + "fichier" + (nbFicherSup > 1 ? "s" : "") + " supprimé" + (nbFicherSup > 1 ? "s" : ""), CAPTION);
                list = null;
                listes = null;

                if (state == compressState.enCours)
                    state = compressState.end;
                else
                    PlayListViewModel.resetExport(exportState.none);
                OnPropertyChanged("Header");

            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\Commande\PlayList\ExportCompress.cs">
    <content><![CDATA[
using System.Collections.Generic;
using pdb.db;
using pdb.db.obj;
using pdb.obj;
using pdb.util;
using pdb.gen;
namespace pdb.player.ViewModel.Commande.PlayList
{
    class ExportCompress : ExportCmd
    {
        private List<CFile> files;
        private int index = 0;
        private int indexPresent = 0;
        List<PiecePrior> _presents;


        public ExportCompress()
        {
        }
        public override string Header
        {
            get
            {
                string header = base.Header;
                if (header.Contains(ANNULATION_EXPORT))
                    return header;

                return "Exporter la liste et compresser si besoin";

            }
        }
        protected override void prepareExport()
        {
            BgDict<int, ITrackIdentity> dict = new BgDict<int, ITrackIdentity>();
            files = new List<CFile>();
            index = 0;
            indexPresent = 0;
            foreach (PiecePrior track in list)
            {
                int id = track.MasterId;
                dict[id] = track.Piece;
            }

            _presents = new List<PiecePrior>(presents);
            _presents.Reverse();

            // phase 1 compress
            foreach (PiecePrior p in _presents)
            {
                CPiece piece = p.Piece;
                getSecondaryFiles(piece);
            }
        }

        private void getSecondaryFiles(CPiece piece)
        {
            var m_files = piece.Files;
            //if (m_files.Count <= 1)
            //    return;

            var l = new List<CFile>();
            foreach (CFile file in m_files)
            {
                if (FileRegister.Exist(conf.dir + file.File))
                {
                    l.Add(file);
                }
            }
            if (l.Count <= 1)
                return;

            l.Sort(new CFileComparer());

            for (int i = 1; i < l.Count; i++)
                files.Add(l[i]);
        }

        //private CFile getPertinentFile(CPiece piece)
        //{
        //    var m_files = piece.Files;
        //    if (m_files.Count < 1)
        //        return null;

        //    var l = new List<CFile>();
        //    foreach (CFile file in m_files)
        //    {
        //        if (FileRegister.Exist(conf.dir + file.File))
        //        {
        //            l.Add(file);
        //        }
        //    }
        //    if (l.Count < 1)
        //        return null;
        //    if (l.Count >= 2)
        //        l.Sort(new CFileComparer());

        //    return l[0];
        //}

        protected override bool noMoreSpace()
        {
            if (index >= files.Count)
            {
                return noMoreSpace2();
            }

            CFile file = null;
            while (true)
            {
                if (index >= files.Count)
                    return noMoreSpace2();
                file = files[index];
                string path = conf.dir + file.File;
                var fi = FileRegister.Check(path); 
                if (fi.Exists)
                {
                    misc.deleteFile(path,file.ToString());
                 //   freeSpace += fi.Length; 
                    return false;
                }
                index++;
            }
        }

        private bool noMoreSpace2()
        {
            if (indexPresent >= _presents.Count)
                return true;
            while (true)
            {
                if (indexPresent >= _presents.Count)
                    return true;
                var p = _presents[indexPresent];
                int id = p.MasterId;
                if (idCopie[id] == null)
                {
                    var piece = p.Piece;
                    var files = piece.Files;

                    bool contFile = false;
                    foreach (CFile file in files)
                    {
                        if (idCopieLoc.ContainsKey(file.File))
                        {
                            contFile = true;
                            break;
                        }
                    }

                    if (!contFile)
                    {
                        if (files.Exists)
                        {
                            var track = PlayListViewModel.findTrack(lastpl, piece.PieceId);
                            
                            //App.log.log("supression fichiers de {0}", p);
                            foreach (CFile f in files)
                            {
                                string path = conf.dir + f.File;
                                var fv = FileRegister.Check(path); 
                                if (fv.Exists)
                                {
                                    misc.deleteFile(path, string.Format("{0} {1}", p,f));
                                  //  freeSpace += fv.Length; 
                                   // PlayListViewModel.setExport(piece.PieceId, exportState.delete);
                                    setExport(exportState.delete, p.PieceGen); 
                                    //if (track != null)
                                    //    track.ExportStatus = exportState.delete;
                                    nbFicherSup++;
                                    return false;
                                }
                            }
                        }
                    }
                }
                indexPresent++;

            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\FileRegister.cs">
    <content><![CDATA[using System.IO;
using System.Threading.Tasks;

namespace pdb.util
{
    public class FileRegister
    {
        private static FileRegister _instance = new FileRegister();
        private BgDictString0<FileValue> dict = new BgDictString<FileValue>();
        public static void init(BgDictString0<FileValue> dict)
        {
            _instance.dict = dict; 
        }

      
        private FileValue check(string location)
        {
            if (!dict.ContainsKey(location))
            {
                bool _exists = false;
                string fullName = "";
               
                long length = 0; 
                try
                {
                    
                    FileInfo infos = new FileInfo(location);
                    _exists = infos.Exists;                   
                    fullName = infos.FullName;

                    //DirectoryInfo dir = infos.Directory;
                    //dirAndFileName = dir.Name + Path.DirectorySeparatorChar + infos.Name; 

                    if (_exists)
                        length = infos.Length; 
                     
                }
                catch { }
                var value = new FileValue(fullName, length, _exists);
                dict.Add(location, value); 
                    return value; 
            }
            return dict[location] ; 
        }

        private FileValue delete(string location)
        {
            var value = check(location);
            value.delete();
            return value; 
           
        }

        public static FileValue Check(string location)
        {
            return _instance.check(location); 
        }

        public static bool Exist(string location)
        {
            return _instance.check(location).Exists; 
        }
        public static string FullName(string location)
        {
            return _instance.check(location).FullName;
        }
        public static long Length(string location)
        {
            return _instance.check(location).Length;
        }
        public static FileValue Delete(string location)
        {
            return _instance.delete(location); 
        }

       
    }


    public class FileValue
    {
        public readonly string FullName;
        private  bool _exists;
        public long Length;
        //public readonly string DirAndFileName;
        public FileValue(string fullName,  long length, bool exists)
        {
            this.FullName = fullName;
           // this.DirAndFileName = dirAndFileName; 
            this.Length = length;
            this._exists = exists;
        }

        public bool Exists { get { return _exists; } }
        public override string ToString()
        {
            return string.Format("{0} {1} {2}", Exists, FullName, Length);
        }

        public void delete() { _exists = false; }
        public void copy(long length)
        {
            _exists = true;
            Length = length; 
        }

        public override bool Equals(object obj)
        {
            var o = obj as FileValue;
            if (o == null) return false;
            return FullName == o.FullName ; //&& Exists == o.Exists;
        }
        public override int GetHashCode()
        {
            return FullName.GetHashCode(); // +Length.GetHashCode();
        }
    }


}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Piece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;
using System.Linq;
using System.Text.RegularExpressions;

namespace pdb.gen
{
    public enum infoMedianne : short
    {
        none = 0,
        med = 1,
        medLight = 2,
        border = 4,
        borderEff = 8,
        borderMin = 16
    }
    /// <summary>
    /// Ajout de données utiles Ranq
    /// </summary>
    public class Piece : ITrackMetaData, IFile, ITrackNativeDates, IEnumerable<Piece>
    {
        private ITrackNativeDates track;
        public bool Virtual { get { return PieceId < 0; } }
        public virtual bool VirtualByArtist { get { return false; } }
        // private String className = "";
        private static CultureInfo en = new CultureInfo("en-US");
        //  private static List<displayCategory> minCategories;

        protected static Consolid gen;
        public static Consolid Gen { set { gen = value; } }

        static Piece()
        {
            //   minCategories = new List<displayCategory> { displayCategory.rankTime, displayCategory.timeValue, displayCategory.dates, displayCategory.pertinentDates };
        }

        public ITrackNativeDates Track { get { return track; } }

        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank
        {
            get
            {
                if (parent == null)
                    return m_rank;
                return parent.m_rank;
            }
        }

        private infoMedianne _infoMedianne;
        public void eraseInfoMedianne() { _infoMedianne = infoMedianne.none; }
        public infoMedianne InfoMedianne { get { return _infoMedianne; } }
        public bool Medianne
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.med);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Medianne)
                    return;
                _infoMedianne |= infoMedianne.med;
            }
        }
        public bool MedianneLight
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.medLight);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (MedianneLight)
                    return;
                _infoMedianne |= infoMedianne.medLight;
            }
        }

        public bool Border
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.border);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Border)
                    return;
                _infoMedianne |= infoMedianne.border;
            }
        }

        public bool BorderEffect
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderEff);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderEffect)
                    return;
                _infoMedianne |= infoMedianne.borderEff;
            }
        }

        public bool BorderMin
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderMin);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderMin)
                    return;
                _infoMedianne |= infoMedianne.borderMin;
            }
        }


        public virtual void initRank()
        {
            _rapportClassement = -1;
            //_infoMedianne = infoMedianne.none;
            _classementProvisoireRecent = null;

            // _lnClassement = int.MinValue; 
            Rank.init();
        }

        public int QRank
        {
            get { return Rank.Quality; }
            set { Rank.Quality = value; }
        }

        public int LRank
        {
            get { return Rank.Lenght; }
            set { Rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return Rank.Twice; }
            set { Rank.Twice = value; }
        }

        public int RankAllAlbum
        {
            get { return m_rank.RankAllAlbum; }
            set { m_rank.RankAllAlbum = value; }
        }

        public int RankAlbum { get { if (album == null) return 0; return album.Rank.Sort; } }

        public bool AlbumAbsent { get { if (album == null) return true; return album.Absent; } }

        //public int nbInAlbum(exportState state ) { if (album == null) return -1; return album.nbInAlbum(state);  }
        public int NbExportPresents { get { if (album == null) return -1; return album.NbExportPresents; } }

        //public bool SameAlbum(Piece x)
        //{
        //    if (x == null)
        //        return false; 
        //    return album == x.album; 
        //}

        public int IndexExport { get { if (album == null) return -1; return album.IndexExport(this); } }

        //  public TuningData TuningData { get { return m_rank.Rest; } set { m_rank.Rest = value; } }
        #endregion



        public bool FirstClass { get { return track.FirstClass; } set { track.FirstClass = value; } }
        private Album album;

        public Album PieceAlbum { get { return album; } set { album = value; } }
        public int StackValue { get { if (album == null) return 0; return album.StackValue; } }
        public int StackIndex { get { if (album == null) return 0; return album.StackIndex; } }
        public bool Moved { get { if (album == null) return false; return album.Moved; } set { if (album != null) album.Moved = value; } }
        //private static int _sID = 0;
        //private int _dID;
        internal Piece(ITrackNativeDates track)
        {
            //_sID++;
            //_dID = _sID;
            this.track = track; initRank();

#if VOL
            int volumeMin = CConf.VolumeMin;
            if (Volume < volumeMin)
                Volume = volumeMin;
#endif
        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList()
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        public String ClassName { get { return track.ClassName; } set { track.ClassName = value; } }

        public void setClassement(string className, int rating)
        {
            if (className == null)
                return;
            track.setClassement(className, rating);
            invalidateCache();

        }

        public virtual void invalidateCache()
        {
            _classNameAndRating = null;
            _classementValueDecimal = -1;
            _rapportClassement = -1;
            _classementProvisoireRecent = null;

            if (parent != null)
                parent.invalidateCache();

        }

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in track.PLayLists)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        #region CPieceComparer compatibilité
        //public List<CPlayList> ClassPlayLists
        //{
        //    get { return track.ClassPlayLists; }
        //}
        /// <summary>
        /// ClassList principale
        /// </summary>
        //public CPlayList ClassPlayList
        //{
        //    get
        //    {
        //        List<CPlayList> classLists = track.ClassPlayLists;
        //        if (classLists.Count > 0)
        //            return classLists[0];
        //        return null;
        //    }
        //}


        public int RatingCmp
        {
            get
            {
                int rating = track.Rating;
                if (rating < 0)
                    return 0;
                return rating;
            }
        }
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return ClassName.isInteger();
            }
        }

        private string _classNameAndRating;
        public String ClassNameAndRating
        {
            get
            {
                if (_classNameAndRating == null)
                {
                    if (!isClassListNumeric)
                        _classNameAndRating = "";
                    _classNameAndRating = ClassName + ((track.Rating / 20).ToString());
                }
                return _classNameAndRating;
            }
        }

        private decimal _classementValueDecimal = -1;
        public decimal ClassementValueDecimal
        {
            get
            {
                if (_classementValueDecimal < 0)
                {
                    if (!isClassListNumeric) return 0;
                    string classNameAndRating = ClassNameAndRating.Insert(1, ",");
                    _classementValueDecimal = Convert.ToDecimal(classNameAndRating);
                }
                return _classementValueDecimal;
            }
        }
        //private double _classementValue = -1; 
        //public double ClassementValue
        //{
        //    get
        //    {
        //        if (_classementValue == -1)
        //        {
        //            if (!isClassListNumeric)
        //                _classementValue = 0;
        //            else
        //            {
        //                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
        //                _classementValue= Convert.ToDouble(classNameAndRating);
        //            }
        //        }

        //        return _classementValue; 
        //    }
        //}

        public static decimal getRapport(decimal base6)
        {
            string str = base6.ToString("0.######").Replace(",", "");
            return getRapport(str);
        }

        private static decimal getRapport(string classNameAndRating)
        {
            decimal resultat = 0m;
            char[] tab = classNameAndRating.ToCharArray();

            decimal K = 1;
            int count = tab.GetLength(0);


            for (int i = 0; i < count; i++)
            {
                K = K * 6;
                int c = Convert.ToInt32(tab[i].ToString());
                resultat += (decimal)c / K;
            }

            return resultat;
        }

        private decimal _rapportClassement = -1;
        public decimal RapportClassement
        {
            get
            {
                if (parent != null)
                    return parent.RapportClassement;
                if (_rapportClassement != -1)
                    return _rapportClassement;

                decimal resultat = 0;
                try
                {
                    return getRapport(ClassNameAndRating);
                }
                catch
                {
                }
                _rapportClassement = resultat;
                // _classementVirtuel = resultat; 
                return _rapportClassement;
            }
        }


        //private decimal _lnClassement = -1;
        //public decimal LnClassement
        //{
        //    get
        //    {
        //        if (_lnClassement == int.MinValue)
        //        {
        //            var rapport = RapportClassement;
        //            if (rapport <= 0m)
        //                _lnClassement = 0m;
        //            else
        //                _lnClassement = Math.Log10(rapport) + 10;
        //        }
        //        return _lnClassement; 
        //    }
        //}
        static int NB_DEC = 4;
        public static string getReadableCl(string str)
        {
            int count = str.Length;
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {
                        if (i >= NB_DEC)
                        {
                            i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();
        }

        public static string getClassementEquiv(decimal valRapport)
        {
            if (valRapport < 0)
                return "";
            if (valRapport == 0m)
                return "0";
            decimal v = 0;
            decimal r = valRapport;
            StringBuilder sb = new StringBuilder();
            int _ok = Int16.MaxValue;

            for (int i = 0; i < 13; i++)
            {
                v = 6 * r;
                int a = (int)(v + 0.0001m);
                if (a > 0 && i < _ok)
                {
                    _ok = i;
                }
                r = v - a;
                if (r < 0)
                    r = 0;
                sb.Append(a);


                if (i >= _ok + 4)
                    break;
            }
            var str = sb.ToString();
            str = str.Insert(str.Length - 1, ".");
            return getReadableCl(str);
        }




        public decimal RapportClassementDecimal
        {
            get
            {
                if (parent != null)
                    return parent.RapportClassementDecimal;
                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1m;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                return resultat;
            }
        }

        public int classPrecision()
        {
            string classNameAndRating = ClassNameAndRating;
            int precision = 0;
            char[] tab = classNameAndRating.ToCharArray();
            int count = tab.GetLength(0);

            int iIndexDepart = -1;
            int iIndexFin = -1;
            for (int i = 0; i < count; i++)
            {
                Char c = tab[i];
                if (iIndexDepart < 0)
                {
                    if (c != '0')
                        iIndexDepart = i;
                }

                if (c != '0')
                    iIndexFin = i;
            }

            precision = iIndexFin - iIndexDepart + 1;

            return precision;
        }
        #endregion

        #region compatibilité CList
        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        public bool checkIdentity(ITrackIdentity other)
        {
            //return track.Location == other.Location; 
            String location = track.Location;
            return (location.Equals((other.Location)) || CUtil.DefinedEquals(track.Artist, track.Album, track.Name, track.TrackNumber, other.Artist, other.Album, other.Name, other.TrackNumber));
        }
        #endregion

        #region ITrackNative Membres

        public string Artist
        {
            get
            {
                return track.Artist;
            }
            set
            {
                if (track.Artist != value)
                {
                    try
                    {
                        //                 misc.log("change artist from '{0}' to'{1}'", track.Artist, value);
                        track.Artist = value;
                    }
                    catch { misc.log("unable to change artist {0}  {1}", track.Artist, value); }
                }
            }
        }

        public virtual string Album
        {
            get
            {
                return track.Album;
            }
            set
            {
                if (track.Album != value)
                {
                    try
                    {
                        //                   misc.log("change Album from '{0}' to'{1}'", track.Album, value);
                        track.Album = value;
                    }
                    catch { misc.log("unable to change album {0}  {1}", track.Album, value); }
                }
            }
        }

        public string Name
        {
            get
            {
                return track.Name;
            }
            set
            {
                if (track.Name != value)
                {
                    try
                    {
                        //                 misc.log("change Name from '{0}' to'{1}'", track.Name, value);
                        track.Name = value;
                    }
                    catch { misc.log("unable to change name {0}  {1}", track.Name, value); }
                }
            }
        }

        public virtual int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (track.TrackNumber != value)
                {
                    try
                    {
                        //              misc.log("change TrackNumber from '{0}' to'{1}'", track.TrackNumber, value);
                        track.TrackNumber = value;
                    }
                    catch { misc.log("unable to change TrackNumber {0}  {1}", track.TrackNumber, value); }
                }
            }
        }

        public int Rating
        {
            get
            {
                return track.Rating;
            }
            set
            {
                if (track.Rating != value)
                {
                    try
                    {
                        //                misc.log("change Rating from '{0}' to'{1}'", track.Rating, value);
                        track.Rating = value;
                    }
                    catch { misc.log("unable to change Rating {0}  {1}", track.Rating, value); }
                }
            }
        }

        public int Year
        {
            get
            {
                return track.Year;
            }
            set
            {
                if (track.Year != value)
                {
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Year = value;
                    }
                    catch { misc.log("unable to change Year {0}  {1}", track.Year, value); }
                }
            }
        }

#if VOL
        public int Volume
        {
            get
            {
                int volumeMin = CConf.VolumeMin;
                int trackVolume = track.Volume;
                if (trackVolume < volumeMin)
                {
                    Volume = volumeMin;
                }
                return trackVolume;
            }
            set
            {
                if (track.Volume != value)
                {
                    int volumeMin = CConf.VolumeMin;
                    int _value = Math.Max(value, volumeMin);
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Volume = _value;
                    }
                    catch { misc.log("unable to change Volume {0}  {1}", track.Volume, _value); }
                }
            }
        }
#endif

        public string Comment
        {
            get
            {
                //if (string.IsNullOrEmpty(track.Comment))
                //    gen.writeComment(this);
                return track.Comment;
            }
            set
            {
                //if (track.Comment != value)
                //{
                try
                {
                    //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
                    track.Comment = value;
                }
                catch { misc.log("unable to change Comment {0}  {1}", track.Comment, value); }
                //}
            }
        }

        public virtual string Grouping
        {
            get
            {
                if (string.IsNullOrEmpty(track.Grouping))
                {
                    gen.writeGrouping(this);
                }
                return track.Grouping;
            }
            //set
            //{
            //    //if (track.Grouping != value)
            //    //{
            //        try
            //        {
            //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
            //            track.Grouping = value;
            //        }
            //        catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
            //    //}
            //}

        }





        public virtual void setGrouping(string value, bool prior)
        {
            try
            {
                //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
                track.setGrouping(value, prior);
            }
            catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        }

        public bool Enabled
        {
            get
            {
                return track.Enabled;
            }
            set
            {
                if (track.Enabled != value)
                {
                    try
                    {
                        //      misc.log("change Enabled from '{0}' to'{1}'", track.Enabled, value);
                        track.Enabled = value;
                    }
                    catch { misc.log("unable to change Enabled {0}  {1}", track.Enabled, value); }
                }
            }
        }



        public bool isPodcast
        {
            get { return track.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return track.PlayedDate; }
        }

        public string Location
        {
            get { return track.Location; }
        }

        public TimeSpan Duration
        {
            get { return track.Duration; }
            set { track.Duration = value; }
        }

        #endregion

        public List<DateTime> Dates
        {
            get { return track.Dates; }
        }
        public string ArtWork
        {
            get { return track.ArtWork; }
            set { track.ArtWork = value; }
        }

        public List<DateTime> DatesClassement { get { return track.DatesClassement; } }
        public DateTime? UpdateClassement
        {
            get
            {

                var dc = CalcDate.getLastModif(DatesClassement);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public bool LastClassementRecent
        {
            get
            {
               
                foreach (DateTime dt in  track.DatesClassementBrut)
                {
                    if (dt> Piece.SeuilProvisoire)
                        return true; 
                }
                return false; 
              
            }
        }
        public DateTime? AlbumUpdateClassement
        {
            get
            {
                if (album == null)
                    return null;
                return album.UpdateClassement;
            }
        }

        public DateTime? LastRead
        {
            get
            {

                var dc = CalcDate.getLastModif(Dates);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public DateTime? AlbumLastRead
        {
            get
            {
                if (album == null)
                    return null;
                return album.LastRead;
            }
        }

        public String ClassEvol { get { return track.ClassEvol; } }


        public void writeCommentGrouping()
        {
            var mode = CConf.ConfGen.WriteComment;
            writeComment(mode);
            var modeg = CConf.ConfGen.WriteGrouping;
            writeGrouping(modeg);

        }

        //public List<CPlayList> PLayLists
        //{
        //    get { return track.PLayLists; }
        //}

        /// <summary>
        /// Calculer le commentaire
        /// </summary>
        public void writeComment(writeGrouping mode)
        {
            if (parent != null)
                return;
            if (mode == Tuning.writeGrouping.none)
                return;


            if (mode == Tuning.writeGrouping.mix)
            {
                StringBuilder sbEnd = new StringBuilder();

                sbEnd.Append(ClassName);
                sbEnd.Append(".");
                sbEnd.Append((RatingCmp / 20).ToString());
                sbEnd.Append(ClassEvol);
                string strEnd = sbEnd.ToString();
                string found = "";

                string[] tab = Comment.Split(' ');
                int count = tab.GetLength(0);
                if (count > 0)
                {
                    found = tab[count - 1];
                    if (found.Equals(strEnd))
                        return;
                }
                writeComment(Tuning.writeGrouping.all);
            }

            StringBuilder sb = new StringBuilder();
            //string l_pref = "";
            //string l_str = "";

            string l_strList = ClassName;
            //if (ClassPlayList != null)
            //    l_strList = ClassName;

            ////if (m_classement.Imported)
            ////{
            //if (l_strList != ClassName)
            //{
            //    sb.Append("m (");
            //    sb.Append(ClassName);
            //    sb.Append(") "); 
            //  //  l_pref = "m (" + ClassName + ") ";
            //}
            ////}
            int l_rank = Rank.Twice;

            if (l_rank > 0)
            {
                CTuning.format(sb, l_rank);
                sb.Append(" ");
                //    if (l_rank < 1000)
                //    {
                //        if (CTuning.Total > 1000)
                //        {
                //            l_str += "0";
                //        }
                //        if (l_rank < 100)
                //        {
                //            l_str += "0";
                //            if (l_rank < 10)
                //            {
                //                l_str += "0";
                //            }
                //        }
                //    }


                var r = CTuning.Rapport(Rank.Quality);






                var quality = CConf.Select.Quality;
                //if (quality.Mode != listMode.substract || quality.Exp != 1 || quality.Offset != 0 || CConf.Select.TimePriority != 0)
                //{
                double tx0 = Convert.ToInt32(1000 * r);
                sb.Append(tx0.ToString());
                sb.Append(" ");
                //}

                //  double l_tx = Convert.ToInt32(1000 * CTuning.Calc(m_rank, CConf.Select)); //   RapportNorm(m_rank.Quality, CConf.Sort.Quality));
                var l_tx = CConf.ConfGen.Vie.TotalDays() / CTuning.Calc(m_rank, CConf.Select);
                //  double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
                //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
                //getTx(m_rank.Lenght)
                //     l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();


                sb.Append(l_tx.FormatCustom(3, 4)); //   ToString("G2", en));
                //if (l_tx < 100 || l_tx >= 1000)
                //    sb.Append(l_tx.ToString("G2", en));
                //else
                //    sb.Append(Convert.ToInt64(l_tx).ToString("D", en)); 



                sb.Append(" ");
                var rest = r;

                for (int i = 0; i < 4; i++)
                {
                    var ee = rest * 6.0m;
                    int e = (int)System.Math.Floor(ee);
                    rest = ee - e;
                    sb.Append(e);
                }



                sb.Append(" ");


                //sb.Append(l_tx2.ToString());
                //sb.Append(" ");
                //sb.Append((100 * m_rank.SortValue).ToString("0"));
                //sb.Append(" ");

                //sb.Append(Dates.Count.ToString()); sb.Append(" ");

                //sb.Append(DatesClassement.Count.ToString()); sb.Append(" ");

                //sb.Append(ListSelection.buildListReadOrClassementModified(this).Count.ToString()); sb.Append(" ");

                //   sb.Append((100 * m_rank.TimeRest).ToString("0")); sb.Append(" ");



                sb.Append(l_strList);
                sb.Append(".");
                sb.Append((RatingCmp / 20).ToString());

            }

            sb.Append(ClassEvol);



            Comment = sb.ToString();
            //Comment = l_pref + l_str + ClassEvol;
        }

        public override string ToString()
        {
            return track.ToString();
        }

        public override bool Equals(object obj)
        {
            Piece p = obj as Piece;
            if (p == null)
                return false;
            return PieceId.Equals(p.PieceId);
        }

        private decimal _classementVirtuel;

        public string ClassementVirtuel { get { return Piece.getClassementEquiv(_classementVirtuel); } }
        public decimal VirtualClassement { get { return _classementVirtuel; } }
        public void setClassementVirtuel(decimal virt)
        {
            _classementVirtuel = virt;
        }

        public decimal CoeffVirtuel
        {
            get
            {
                if (_classementVirtuel == 0)
                    return 0;
                return RapportClassement / _classementVirtuel;
            }
        }

        private decimal _classementVirtuel2;

        public string ClassementVirtuel2 { get { return Piece.getClassementEquiv(_classementVirtuel2); } }
        public decimal VirtualClassement2 { get { return _classementVirtuel2; } }
        public void setClassementVirtuel2(decimal virt)
        {
            _classementVirtuel2 = virt;
        }

        public decimal CoeffVirtuel2
        {
            get
            {
                if (_classementVirtuel2 == 0)
                    return 0;
                return RapportClassement / _classementVirtuel2;
            }
        }

        public override int GetHashCode()
        {
            return PieceId.GetHashCode();
        }

        private bool haveToUpdateGrouping = false;
        public void MarkAsUpdateGrouping() { haveToUpdateGrouping = true; }

        public void writeGrouping(writeGrouping writeGrouping)
        {
            var cat = CConf.ConfGen.DisplayCategories;
            //if (!CConf.ConfGen.WithOrder)
            //    cat = minCategories; 
            if (writeGrouping == Tuning.writeGrouping.none)
                return;

            //if (m_rank.Twice <= 0)
            //    return;
            if (haveToUpdateGrouping)
            {
                setGrouping(getGroup(cat), true);
            }

            else if (writeGrouping == Tuning.writeGrouping.mix)
            {
                bool haveToUpdate = false;
                string org = Grouping;
                if (org != null)
                {
                    string[] data = org.Split(' ');

                    try
                    {
                        foreach (datesMode mode in Enum.GetValues(typeof(datesMode))) //  CConf.ConfGen.Modes) //  Enum.GetValues(typeof(datesMode)))
                        {
                            DisplayGrouping found = cat.Find(c => (int)c.category == (int)mode);
                            //displayCategory found = cat.Find(c => (int)c == (int)mode);
                            if (found != null)
                            {
                                int indexOfTime = cat.IndexOf(found);

                                string timeValue = data[indexOfTime];
                                string newValue = getTimeValue(mode, found.mode);
                                if (!newValue.Equals(timeValue))
                                {
                                    haveToUpdate = true;
                                    break;
                                }
                            }
                        }
                    }
                    catch
                    {
                        haveToUpdate = true;
                    }
                }
                else
                {
                    haveToUpdate = true;
                }
                if (haveToUpdate)
                    setGrouping(getGroup(cat), true);
            }
            else
                setGrouping(getGroup(cat), false);
        }



        private string getTimeValue(datesMode modeDates, timeMode modeTime)
        {
            switch (modeTime)
            {
                case timeMode.simple: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates)).FormatCustomTs(2);
                case timeMode.complex: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustomTs(2);
                case timeMode.last:
                case timeMode.equiv:
                case timeMode.equivNorm:
                    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    if (modeTime == timeMode.equivNorm)
                        return ts.FormatCustomTs(3, 2, 4);
                    return ts.FormatCustomTs(2);

                case timeMode.delta:
                case timeMode.deltaNorm:

                    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
                    var delta = tsf - ts0;
                    delta = delta * 100;
                    //if (modeTime == timeMode.deltaNorm)
                    //    return delta.FormatCustom(3, 2, 4);
                    return "(" + delta.FormatCustomTs(2) + ")";
                default:
                    throw new NotImplementedException();

            }

            //if (modeTime == timeMode.complex)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustom(2);
            //else if (modeTime == Tuning.timeMode.simple)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates)).FormatCustom(2);
            ////   return m_rank.TimeRest.FormatCustom(2); //.ToString("G2", en); 
            //else if (modeTime == timeMode.equiv || modeTime == timeMode.equivNorm)
            //{
            //    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);

            //    if (modeTime == timeMode.equivNorm || modeTime == timeMode.deltaNorm)
            //        return ts.FormatCustom(3, 2, 4);
            //    return ts.FormatCustom(2);
            //}
            //else
            //{
            //    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
            //    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
            //    var delta = tsf - ts0;

            //    if (modeTime == timeMode.equivNorm)
            //        return delta.FormatCustom(3, 2, 4);
            //    return delta.FormatCustom(2);
            //}
        }

        public int RankAlbumReverse
        {
            get
            {
                if (album != null)
                {
                    int rank = album.Rank.Sort;
                    rank = 1 + gen.Albums.Count - rank;
                    return rank;
                }
                return 0;
            }
        }

        private string getGroup(List<DisplayGrouping> categories)
        {
            StringBuilder sb = new StringBuilder();

            bool begin = false;

            displayCategory last = displayCategory.none;
            foreach (var category in categories)
            {
                try
                {
                    if (begin //&& (int)category.category <= (int)displayCategory.pipe
                        && last != displayCategory.croc1 && last != displayCategory.par1
                        && category.category != displayCategory.croc2 && category.category != displayCategory.par2)
                        sb.Append(" ");
                    begin = true;

                    switch (category.category)
                    {
                        case displayCategory.rankSort:
                            CTuning.format(sb, Rank.Sort); break;
                        case displayCategory.rankDelta:
                            CTuning.format(sb, Rank.RankDelta); break;
                        case displayCategory.rankTime:
                            CTuning.format(sb, Rank.RankRest); break;
                        case displayCategory.rankAllAlbum:
                            CTuning.format(sb, RankAllAlbum); break;
                        case displayCategory.rankAlbum:
                            if (album != null)
                                sb.Append(album.Rank.Sort); break;
                        case displayCategory.rankAlbumReverse:
                            sb.Append(RankAlbumReverse);
                            break;
                        case displayCategory.rankEquiv:
                            if (album != null)
                                sb.Append(album.Equiv);
                            break;
                        case displayCategory.rankEquivLight:
                            if (album != null)
                                sb.Append(album.EquivLight);
                            break;
                        case displayCategory.rankEquivLight0:
                            if (album != null)
                                sb.Append(album.EquivLight0);
                            break;
                        case displayCategory.albumMoy:
                            if (album != null)
                            {
                                sb.Append(album.Moyenne);
                            }
                            break;
                        case displayCategory.lenght:
                            sb.Append(Convert.ToInt32(100 * CTuning.Rapport(Rank.Lenght))); break; //   CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length))); break;
                        case displayCategory.sortValue:
                            sb.Append((1000 * Rank.SortValue).ToString("####", en)); break;
                        case displayCategory.tplay:
                            sb.Append(getTimeValue(datesMode.play, category.mode)); break;
                        case displayCategory.tclass:
                            sb.Append(getTimeValue(datesMode.@class, category.mode)); break;
                        case displayCategory.tclassMin:
                            sb.Append(getTimeValue(datesMode.classMin, category.mode)); break;
                        case displayCategory.tmix:
                            sb.Append(getTimeValue(datesMode.mix, category.mode)); break;
                        case displayCategory.tmixMin:
                            sb.Append(getTimeValue(datesMode.mixMin, category.mode)); break;
                        case displayCategory.timeCoeff:
                            sb.Append((100 * Rank.TimeCoeff).ToString("G3", en)); break;
                        case displayCategory.dplay:
                            sb.Append(ListSelection.getPlayDates(this).Count.ToString()); break;
                        case displayCategory.dclass:
                            sb.Append(ListSelection.getDatesClassement(this).Count.ToString());
                            break;
                        case displayCategory.dclassMin:
                            sb.Append(ListSelection.getClassDatesMin(this).Count.ToString()); break;
                        case displayCategory.dmix:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, false).Count.ToString());
                            break;
                        case displayCategory.dmixMin:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, true).Count.ToString());
                            break;
                        case displayCategory.pipe:
                            sb.Append("|");
                            break;
                        case displayCategory.par1: sb.Append("("); break;
                        case displayCategory.par2: sb.Append(")"); break;
                        case displayCategory.croc1: sb.Append("["); break;
                        case displayCategory.croc2: sb.Append("]"); break;

                        default:
                            break;
                    }


                    last = category.category;
                }

                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }
            }
            return sb.ToString();
        }

        public virtual int PieceId
        {
            get
            {
                return track.PieceId;
            }
        }

        public void albumMustRefresh()
        {
            foreach (Piece p in Master)
            {
                if (p.album != null)
                    p.album.mustRefresh();
            }
        }


        protected Piece parent;
        public virtual Piece Parent
        {
            get { return parent; }
            set
            {
                if (value == parent)
                    return; 
                var old = parent;
                if (old != null)
                    old.albumMustRefresh();
                parent = value;
                if (parent == null)
                {
                    if (old != null)
                    {
                        old.removeChild(this);
                        this.PieceParentId = -1;
                    }
                }
                else
                {
                    parent = parent.Master;
                    this.PieceParentId = value.MasterId;
                    parent.addChild(this);
                }
                if (album != null)
                    this.album.mustRefresh();
            }
        }
        public Piece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        public int MasterId { get { return Master.PieceId; } }

        private List<Piece> childs = new List<Piece>();
        public List<Piece> Childs { get { return childs; } }
        protected void addChild(Piece child)
        {
            if (child != null && parent != null)
                throw new ApplicationException(string.Format("on ne doit pas affecter un enfant à un non-maitre. enfant:{0} parent {1}", child, parent));

            //if (childs.Contains(child))
            //{
            //    throw new ApplicationException("enfant déjà enregistré"));
            //}
            childs.Add(child);
        }

        public void consolidChild()
        {
            if (parent != null)
            {
                parent.addChild(this);
            }
        }

        private void removeChild(Piece child)
        {
            childs.Remove(child);
        }

        public virtual int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public exportState ExportStatus
        {
            get
            {
                return track.ExportStatus; // exportState;
            }
            set
            {
                track.ExportStatus = value;
            }
        }




        //public List<string> RelativesPath
        //{
        //    get { return track.RelativesPath; }
        //}

        public void buildVirtualAlbums(List<Piece> list)
        {

            foreach (var path in track.RelativesPath)
            {

                var tab = path.Split('\\');
                var sb = new StringBuilder();

                sb.Append(@"\");
                var count = tab.GetLength(0);
                for (int i = 0; i < count; i++)
                {
                    var _s = tab[i];
                    if (string.IsNullOrEmpty(_s))
                        continue;

                    var virt = createVirtualAlbum(sb.ToString(), false);

                    if (virt != null)
                        list.Add(virt);

                    if (i > 0)
                        sb.Append(@"\");
                    sb.Append(_s);




                }
            }

            if (CConf.ConfGen.ArtistVirtual)
            {
                foreach (Piece p in this)
                {
                    var virt = createVirtualAlbum(p.Artist, true);
                    if (virt == null)
                        continue;
                    list.Add(virt);
                }

            }

        }

        private Piece createVirtualAlbum(string path, bool artist)
        {
            if (string.IsNullOrEmpty(path))
                return null;
            if (path.Length < 2)
                return null;
            var virt = new VirtualAlbumPiece(track, Master, path, artist);
            return virt;
        }



        public bool IsNext
        {
            get
            {
                if (album == null)
                    return false;
                return this == album.Next;
            }
        }
        const int NB_CHAR_COMPLETE = 4;

        //public bool AutoCoeff1 { get { if (album == null) return false; return album.SelectedByCoeff; } }
        //public bool AutoCoeff2 { get { if (album == null) return false; return album.SelectedByCoeff2; } }
        public selectedCoeff SelectedMotif
        {
            get
            {
                if (album == null || !IsNext) return selectedCoeff.none;
                return album.SelectedCoeff;
            }
        }


        public static DateTime SeuilProvisoire;
        private bool? _classementProvisoireRecent;
        public bool ClassementProvisoireRecent
        {
            get
            {
                return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        private bool getClassementProvisoireRecent()
        {
            if (!ClassementProvisoire)
                return false;
            var list = DatesClassement;
            var last = CalcDate.getLastModif(list);
            if (last > SeuilProvisoire)
                return true;
            return false;
        }

        public int NbClass { get { return DatesClassement.Count<DateTime>(t => t >= Piece.SeuilProvisoire); } }

        public bool ClassementProvisoire
        {
            get
            {
                if (RapportClassement == 0)
                    return false;
                var str = ClassName;
                int count = str.Length;
                if (count < 4)
                    return true;
                if (count >= 8)
                    return false;

                var tab = str.ToCharArray();
                int nb = 0;
                for (int i = 0; i < count; i++)
                {
                    if (nb > 0)
                        nb++;
                    else
                    {
                        if (tab[i] != '0')
                        {
                            nb++;
                        }
                    }
                }
                if (nb >= NB_CHAR_COMPLETE)
                    return false;

                return true;

            }
        }

        private class PieceEnumerator : IEnumerator<Piece>
        {
            private IEnumerator<Piece> childEnumerator;
            private Piece current;
            private Piece piece;

            public PieceEnumerator(Piece piece) { this.piece = piece; }
            public Piece Current
            {
                get { return current; }
            }

            public void Dispose()
            {
                if (childEnumerator != null)
                    childEnumerator.Dispose();
            }

            object System.Collections.IEnumerator.Current
            {
                get { return current; }
            }

            public bool MoveNext()
            {
                if (childEnumerator == null)
                {
                    childEnumerator = piece.childs.GetEnumerator();
                    current = piece;
                    return true;
                }
                var ret = childEnumerator.MoveNext();
                if (!ret)
                    return false;
                current = childEnumerator.Current;
                return true;
            }

            public void Reset()
            {
                if (childEnumerator != null)
                    childEnumerator.Reset();
                childEnumerator = null;
            }
        }


        public IEnumerator<Piece> GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut; 
            }
        }
    }




}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\TrackList.cs">
    <content><![CDATA[
using System;
using System.Collections.Generic;
using pdb.obj;

namespace pdb.gen
{
    public class TrackListCreator : IComponentFactor
    {
        public PlComponent create(object source)
        {
            if (source is Piece)
                return new TrackList(source as Piece);
            else
                throw new ApplicationException(source + " n'est pas du bon type");
        }
    }
    public class TrackList : PlComponent, ITrackMetaData, IFile, ITrackNativeDates
    {

        private Piece piece;
        public TrackList(Piece piece)
        { this.piece = piece; }
        public override string ToString()
        {
            var parent = Parent;
            if (parent == null)
                return piece.ToString();

            return parent.getPath() + " " + piece.ToString();
        }
        public Piece Piece { get { return piece; } }

        public string Name { get { return piece.Name; } set { piece.Name = value; } }
        public override string Location { get { return piece.Location; } }
        public bool Enabled { get { return piece.Enabled; } set { piece.Enabled = value; } }
        public bool Virtual { get { return piece.Virtual; } }

        public string ClassName
        {
            get
            {
                return piece.ClassName;
            }
            set
            {
                piece.ClassName = value;
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
            }
        }

        public string Comment
        {
            get
            {
                return piece.Comment;
            }
            set
            {
                piece.Comment = value;
            }
        }

        bool ITrackMetaData.Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
            }
        }

        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return piece.PlayedDate; }
        }

        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set { piece.Duration = value; }

        }

        public string ArtWork
        {
            get
            {
                return piece.ArtWork;
            }
            set
            {
                piece.ArtWork = value;
            }
        }

        public string Grouping
        {
            get { return piece.Grouping; }
        }

        public void setGrouping(string value, bool prior)
        {
            piece.setGrouping(value, prior);
        }



        public bool FirstClass { get { return piece.FirstClass; } set { piece.FirstClass = value; } }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
            }
        }

        public string Album
        {
            get
            {
                return piece.Album;
            }
            set
            {
                piece.Album = value;
            }
        }

        string ITrackReference.Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
            }
        }

        public int TrackNumber
        {
            get
            {
                return piece.TrackNumber;
            }
            set
            {
                piece.TrackNumber = value;
            }
        }

        //public List<CPlayList> ClassPlayLists
        //{
        //    get { return piece.ClassPlayLists; }
        //}

        //public void AddPlayList(CPlayList a_playList)
        //{
        //    piece.AddPlayList(a_playList);
        //}

        //public void removePlayList(CPlayList list)
        //{
        //    piece.removePlayList(list);
        //}

        public int PieceId
        {
            get { return piece.PieceId; }
        }


        public int PieceParentId
        {
            get { return piece.PieceParentId; }
            set { piece.PieceParentId = value; }
        }

        


        public TrackIdentity Key
        {
            get { return piece.Key; }
        }

        public void setClassement(string className, int rating)
        {
            piece.setClassement(className, rating);
        }

        public List<DateTime> Dates
        {
            get { return piece.Dates; }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return piece.ClassEvol; }
        }

   


        public exportState ExportStatus
        {
            get
            {
                return piece.ExportStatus; 
            }
            set
            {
                piece.ExportStatus = value; 
            }
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return piece.DatesClassementBrut;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\CFIle.cs">
    <content><![CDATA[using System;
using System.IO;
using pdb.obj;
using pdb.util;
namespace pdb.db
{
    public class CFile : IData
    {
        private const string TOKEN_FILE = "file";

        private string m_file = "";
        // private bool? _exists;
        // private String path = "";
        // private String ext;
        private FileType fileType = FileType.unknown;
        // private long size = 0;
        private bool _extern = false;
        // private FileInfo infos;
        public static String DefaultFolder = "";


        FileValue fi;

        private FileValue Info
        {
            get
            {
                if (fi == null)
                {
                    string path;

                    if (isExtern())
                        path = m_file;
                    else
                        path = DefaultFolder + m_file;

                    fi = FileRegister.Check(path);
                }
                return fi;
            }
        }

        public CFile(string a_file)
        {
            try
            {
                m_file = a_file.TrimSafe();
                if (a_file.Contains(@"/"))
                {
                    m_file = XMLTool.FromXml(a_file.Trim());
                    string prefix = "file://";
                    string l_legacyDefaultFolder = new Uri(DefaultFolder).AbsoluteUri;
                    //if (l_legacyDefaultFolder != null && l_legacyDefaultFolder.Contains(l_defaultFolder))
                    //{
                    //    l_defaultFolder = l_legacyDefaultFolder;
                    //}
                    if (!m_file.StartsWith(prefix))
                    {
                        m_file = l_legacyDefaultFolder + m_file;
                    }
                    string l_path = new Uri(m_file).LocalPath;
                    m_file = l_path.Replace("\\\\localhost\\", "");


                }
                m_file = m_file.Replace(DefaultFolder, "");
                _extern = m_file.Substring(1, 2).Equals(@":\");
                //path = getPath();

                //  _exists = true;


                // FileInfo infos = new FileInfo(path);
                //var _exists = FileRegister.Exist(path); // infos.Exists;
                //if (false.Equals(_exists))
                //    path = FileRegister.FullName(path); // infos.FullName;




                //String ext = System.IO.Path.GetExtension(path).Replace(".", "").ToLower();
                //fileType = getFileType(ext);
                //if (_exists)
                //    size = infos.Length;

            }
            catch (Exception e)
            {
                String message = String.Format("impossible de construire CFile {0}", m_file);
                throw new ApplicationException(message, e);
            }
        }
        public void write(ITextWriter a_sw)
        {
            XMLTool.writeValue(a_sw, TOKEN_FILE, XMLTool.FileToXml(m_file));
        }

        public void write(System.Xml.XmlWriter w)
        {
            w.WriteElementString(TOKEN_FILE, m_file);
        }
        public string File
        {
            get { return m_file; }
        }
        public bool exists()
        {
            return Info.Exists;
        }
        //public string getUri()
        //{
        //    return new Uri(path).AbsoluteUri;
        //}
        //private string getPath()
        //{
        //    if (isExtern())
        //        return m_file;
        //    return DefaultFolder + m_file;
        //}

        public override string ToString()
        {
            return Info.FullName; 
        }



        public bool isExtern()
        {
            return _extern;
        }

        public string Path
        {
            get
            {
                return Info.FullName;
                //string l_file = "";
                ////if (m_file.Contains("\\"))
                ////{
                //// chemin windows D:\
                //if (m_file.Substring(1, 2).Equals(@":\"))
                //{
                //    //chemin absolu
                //    l_file = m_file;
                //}
                //else
                //{
                //    //chemin relatif
                //    l_file = CLegacy.DefaultFolder + m_file;
                //}
                //return l_file;
            }
            //else
            //{


            //    if (m_file.Contains("file://"))
            //    {
            //        l_file = m_file;
            //    }
            //    else
            //    {
            //        string l_defaultFolder = "file://";
            //        string l_legacyDefaultFolder =  new Uri( CLegacy.DefaultFolder).AbsoluteUri;
            //        if (l_legacyDefaultFolder != null && l_legacyDefaultFolder.Contains(l_defaultFolder))
            //        {
            //            l_defaultFolder = l_legacyDefaultFolder;
            //        }
            //        l_file = l_defaultFolder + m_file;
            //    }

            //    string l_path = new Uri(l_file).LocalPath;
            //    l_path = l_path.Replace("\\\\localhost\\", "");
            //    return l_path;
            //}
            //}
        }
        public bool Equals(CFile other)
        {
            if (other == null)
                return false;

            return m_file.ToLower().Equals(other.m_file.ToLower());
        }
        public bool isPodcast
        {
            get
            {
                if (m_file.StartsWith("Podcasts/"))
                    return true;
                return false;
            }
        }
        public FileType FileType
        {
            get
            {
                if (fileType == pdb.obj.FileType.none)
                {
                    fileType = FileType.unknown;
                    String ext = System.IO.Path.GetExtension(Info.FullName).Replace(".", "").ToLower();


                    try
                    {
                        fileType = (FileType)Enum.Parse(typeof(FileType), ext, true);
                    }

                    catch
                    {
                    }

                }
                return fileType;
            }



        }

        public long Size
        {
            get
            {
              
                return Info.Length;
            }
        }

        //public string DirAndFileName
        //{
        //    get
        //    {
        //        var ret = getPath();
        //        try
        //        {
        //            var infos = FileRegister.Check(ret); // new FileInfo(path);
        //            return infos.DirAndFileName;
        //        }
        //        catch
        //        {

        //        }
        //        return ret;
        //    }
        //}





    }
}

]]></content>
  </file>
  <file path="\PieceDb.Db\TrackList.cs">
    <content><![CDATA[using pdb.db.obj;
using pdb.obj;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.db
{
    public class TrackListCreator : IComponentFactor
    {
        public PlComponent create(object source)
        {
            return new TrackList(source as CPiece);
        }
    }
    public class TrackList : PlComponent, ITrackInfoItunes
    {

        private CPiece piece;
        public TrackList(CPiece piece)
        { this.piece = piece; }
        public override string ToString()
        {
            var parent = Parent;
            if (parent == null)
                return piece.ToString();

            return parent.getPath() + " " + piece.ToString();
        }
        public CPiece Piece { get { return piece; } }

        public string Name { get { return piece.Name; } set { piece.Name = value; } }
        public override string Location { get { return piece.Location; } }
        public bool Enabled { get { return piece.Enabled; } set { piece.Enabled = value; } }

        public string ClassName
        {
            get
            {
                return piece.ClassName;
            }
            set
            {
                piece.ClassName = value;
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
            }
        }

        public string Comment
        {
            get
            {
                return piece.Comment;
            }
            set
            {
                piece.Comment = value;
            }
        }

        bool ITrackMetaData.Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
            }
        }

        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return piece.PlayedDate; }
        }

        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set { piece.Duration = value; }

        }

        public string ArtWork
        {
            get
            {
                return piece.ArtWork;
            }
            set
            {
                piece.ArtWork = value;
            }
        }

        public string Grouping
        {
            get { return piece.Grouping; }
        }

        public void setGrouping(string value, bool prior)
        {
            piece.setGrouping(value, prior);
        }



        public bool FirstClass { get { return piece.FirstClass; } set { piece.FirstClass = value; } }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
            }
        }

        public string Album
        {
            get
            {
                return piece.Album;
            }
            set
            {
                piece.Album = value;
            }
        }

        string ITrackReference.Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
            }
        }

        public int TrackNumber
        {
            get
            {
                return piece.TrackNumber;
            }
            set
            {
                piece.TrackNumber = value;
            }
        }

        //public List<CPlayList> ClassPlayLists
        //{
        //    get { return piece.ClassPlayLists; }
        //}

        //public void AddPlayList(CPlayList a_playList)
        //{
        //    piece.AddPlayList(a_playList);
        //}

        //public void removePlayList(CPlayList list)
        //{
        //    piece.removePlayList(list);
        //}

        public int PieceId
        {
            get { return piece.PieceId; }
        }


        public int PieceParentId
        {
            get { return piece.PieceParentId; }
          //  set { piece.PieceParentId = value; }
        }


        public TrackIdentity Key
        {
            get { return piece.Key;  }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CListFile.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.util;
using pdb.obj;

using pdb.db.piece;

namespace pdb.db.obj
{
    /// <summary>
    /// liste des fichiers accédant au même morceau
    /// </summary>
    /// <remarks></remarks>
    class CListFile : IEnumerable<CFile>, IData
    {


        //  private static CFileComparer c_comparer = new CFileComparer();
        private const string TOKEN_FILES = "files";
        private List<CFile> m_list = new List<CFile>();
        private CFile pertinentFile;
        // private bool? _exists;
        public CListFile(XmlElement a_xml)
        {
            XmlElement l_xml = XMLTool.NodeLookUp(a_xml, TOKEN_FILES);
            if (l_xml == null)
                return;
            var att = l_xml.Attributes["f"];
            if (att != null)
            {
                CFile f = new CFile(att.Value);
                @add(f);
                return;
            }
            foreach (XmlElement l_xmlFile in l_xml)
            {
                CFile l_file = new CFile(l_xmlFile.InnerText);
                @add(l_file);
            }
        }
        public CListFile()
        {
        }

        public CListFile(CListFile o)
        {
            foreach (CFile f in o)
                @add(f);
        }
        public void @add(CFile a_file)
        {
            //if (!a_file.exists()) return; //TODO provisoire
            bool l_bFound = false;
            foreach (CFile l_file in m_list)
            {
                if (a_file.Equals(l_file))
                {
                    l_bFound = true;
                    break;
                }
            }
            if (l_bFound)
                return;
            if (a_file.FileType.typeMusic())
            {
                m_list.Add(a_file);
                pertinentFile = null;
            }
        }
        //   private CFile _pertinent; 
        public CFile getPertinentFile()
        {
            if (pertinentFile != null)
                return pertinentFile;
            //  var list = m_list.FindAll(delegate(CFile file) { return file.exists(); }); 
            var list = m_list.FindAll(file => file.exists());


            if (list.Count == 1)
                return list[0];

            try
            {
                list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine("impossible de comparer les fichiers");
                foreach (CFile file in list)
                {
                    Console.Write(file.File + ";");
                }
                Console.WriteLine(e.ToString());
            }

            pertinentFile = list.Count == 0 ? null : list[0];
            return pertinentFile;
            //if (m_list.Count == 1)
            //    return m_list[0];


            //foreach (CFile l_file in m_list)
            //{
            //    if (l_file.exists())
            //        return l_file;
            //}
            //return m_list[0];
        }

        private CFile getFirstFile()
        {
            var pertinent = getPertinentFile();
            if (pertinent != null)
                return pertinent;
            //if (_pertinent != null)
            //    return _pertinent; 
            //  var list = m_list.FindAll(delegate(CFile file) { return file.exists(); }); 
            var list = m_list; // m_list.FindAll(file => file.exists());


            if (list.Count == 1)
                return list[0];

            try
            {
                list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine("impossible de comparer les fichiers");
                foreach (CFile file in list)
                {
                    Console.Write(file.File + ";");
                }
                Console.WriteLine(e.ToString());
            }

            var _pertinent = list.Count == 0 ? null : list[0];
            return _pertinent;
            //if (m_list.Count == 1)
            //    return m_list[0];


            //foreach (CFile l_file in m_list)
            //{
            //    if (l_file.exists())
            //        return l_file;
            //}
            //return m_list[0];
        }

        public void getSecondaryFiles(List<CFile> list)
        {
            if (m_list.Count <= 1)
                return;
            var pertinent = getPertinentFile();

            foreach (CFile f in m_list)
            {
                if (f.exists() && f != pertinent)
                    list.Add(f);
            }

        }

        public string File
        {
            get
            {
                CFile l_file = getPertinentFile();
                if (l_file == null)
                {
                    if (m_list.Count > 0) return m_list[0].File;
                    return "";
                }
                return l_file.File;
            }
        }

        public string Path
        {
            get
            {
                CFile l_file = getFirstFile();
                if (l_file == null)
                    return "";
                return l_file.Path;
            }
        }
        //public String getUri()
        //{
        //    CFile l_file = getPertinentFile();
        //    if (l_file == null)
        //        return "";
        //    return l_file.getUri();
        //}

        public bool Exists
        {
            get
            {
                //if (_exists.HasValue)
                //    return _exists.Value;
                if (pertinentFile != null)
                {
                    //  _exists = true;
                    return true;
                }

                foreach (CFile f in m_list)
                {
                    if (f.exists())
                    {
                        //   _exists = true;
                        return true;
                    }
                }

                //  _exists = false;
                return false;

            }
        }

        public void merge(CListFile a_list)
        {
            CFile aux = getPertinentFile();
            foreach (CFile l_file in a_list)
            {
                @add(l_file);
            }


            CFile _new = getPertinentFile();

            if (aux == null)
            {
                if (_new != null)
                    onChange();

            }
            else
            {
                if (!aux.Equals(_new))
                    onChange();
            }

        }

        private IDataObserver observer;
        public IDataObserver Observer { set { observer = value; } }
        private void onChange() { if (observer != null) observer.RefChange(); }


        /// <summary>
        /// teste s'il existe un fichier en commun entre deux listes
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        /// <remarks></remarks>
        public bool HasOnePathInCommonWith(CListFile other)
        {
            foreach (CFile l_myFile in m_list)
            {
                foreach (CFile l_outFile in other.m_list)
                {
                    if (l_myFile.Equals(l_outFile))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        public bool HasOnePathInCommonWith(String path)
        {

            foreach (CFile l_myFile in m_list)
            {

                if (l_myFile.Path.Equals(path))
                {
                    return true;
                }

            }
            return false;
        }


        public int Count
        {
            get { return m_list.Count; }
        }

        public System.Collections.Generic.IEnumerator<CFile> GetEnumerator()
        {
            return m_list.GetEnumerator();
        }

        public System.Collections.IEnumerator GetEnumerator1()
        {
            return GetEnumerator();
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator1();
        }

        public bool isPodcast
        {
            get
            {
                foreach (CFile l_file in new List<CFile>(m_list))
                {
                    if (l_file.isPodcast)
                        return true;
                }
                return false;
            }
        }


        #region IData Members


        public void write(ITextWriter a_sw)
        {
            //   m_list.Sort(c_comparer)
            XMLTool.openBalise(a_sw, TOKEN_FILES);
            foreach (CFile l_file in this)
            {
                l_file.write(a_sw);
            }
            XMLTool.closeBalise(a_sw, TOKEN_FILES);
        }


        public void write(XmlWriter w)
        {
            m_list.Sort(new CFileComparerName());
            w.WriteStartElement(TOKEN_FILES);
            if (m_list.Count == 1 && m_list[0] != null)
            {
                w.WriteAttributeString("f", m_list[0].File);
            }
            else
            {

                foreach (CFile l_file in this)
                {
                    l_file.write(w);
                }
            }
            w.WriteEndElement();
        }
        public bool HasChange(CListFile lastFull)
        {
            return m_list.Count != lastFull.m_list.Count;
        }
        public void writeDiff(XmlWriter w, CListFile lastFull)
        {
            if (m_list.Count == lastFull.m_list.Count)
                return;
            m_list.Sort(new CFileComparerName());
            lastFull.m_list.Sort(new CFileComparerName());

            w.WriteStartElement(TOKEN_FILES);
            foreach (CFile l_file in this)
            {
                bool found = false;
                foreach (CFile o in lastFull.m_list)
                {
                    if (o.File.Equals(l_file.File))
                    {
                        found = true;
                        break;
                    }
                }
                if (found)
                    continue;

                l_file.write(w);
            }
            w.WriteEndElement();
        }

        #endregion

        public CFile this[int a_index]
        {
            get
            {
                if (a_index < 0 || a_index >= Count)
                {
                    throw new ApplicationException("bad index:" + a_index + " / " + Count);
                }
                else
                {
                    return m_list[a_index];
                }
            }
        }

        public void Sort()
        {
            try
            {
                m_list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
        }
        //private class CFileComparer : IComparer<CFile>
        //{

        //    public int Compare(CFile x, CFile y)
        //    {
        //        return string.Compare(x.File.Trim().ToUpper(), y.File.Trim().ToUpper());
        //    }
        //}

        // private long size = -1;
        public long Size
        {
            get
            {
                var file = getPertinentFile();
                if (file == null)
                    return 0;
                return file.Size;

            }

        }

        //public string DirAndFileName
        //{
        //    get
        //    {
        //        var file = getFirstFile();
        //        if (file == null)
        //            return "";
        //        return file.DirAndFileName;
        //    }
        //}


    }
}


]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CPiece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.db.piece.data;
using pdb.db.piece.type;
using pdb.obj;
using pdb.util;
using pdb.db.piece;
using System.Diagnostics;


namespace pdb.db.obj
{

    /// <summary>
    /// Métadonnées d'un fichier
    /// </summary>
    /// <remarks>On veut pouvoir merger les modifications venant de deux sources
    /// exemeple : un modifie le classement, l'autre l'année
    /// Pour cela, il est envisagé d'enregistrer pour chaque modification effectué par le client
    /// tout simplement la date de cette modification
    /// le merge se baserait ainsi sur la comparaison entre les dates de modification
    /// source 1 date modif d1' pour classement > d1
    /// source 2 date modif d2' pour année > d2
    /// 
    /// On pourrait aussi se baser sur un flag => mettre à jour
    /// ainsi on gagnerait de la place, mais on perdrait la date de derniere mise à jour
    /// et se poserait aussi la question de quand retirer le flaf "mettre à jour"
    /// 
    /// On peut aussi établir un historique
    ///
    ///</remarks>
    /// 

    public enum Bool
    {
        not_defined = 0,
        False = 1,
        True = 2
    }

    public class CPiece : IData, ITrackMetaData, ITrackNativeDates, IDataObserver, ITrackInfoItunes
    {
        private static Logger logTrack = Logger.getLogger("Track");
        //  private static NullTrack NullTrack = new NullTrack();
        private const string TOKEN_PIECE = "piece";

      
        private PieceMaster master; 

        #region "Composants"
     
        private CPieceReference m_ref;
        private CPieceInfo m_infos;
      
      


      
        #endregion

        //private class StringEventArgs : EventArgs
        //{
        //    public StringEventArgs(String value) { this.Value = value; }
        //    readonly public String Value;
        //}


        private void checkNative()
        {
            //if (native == null)
            //{
            //    StackTrace st = new StackTrace();
            //    logTrack.logNoDate("native null " + this + " " + st.ToString());
            //}
        }
        //   public void makeFirstClass() { if (native == null) return; native.makeFirstClass(); }
        public bool FirstClass
        {
            get
            {
                if (native == null) return false;
                return native.FirstClass;
            }
            set { if (native == null) return; native.FirstClass = value; }
        }
        public bool HasNoNative { get { return native == null; } }
        private void OnCommentChange(String value)
        {
            checkNative();
            if (native == null)
                return;
            native.Comment = value;
        }
        private void OnGroupingChange(String value, bool prior)
        {
            checkNative();
            if (native == null)
                return;
            native.setGrouping(value, prior);
        }
        private void OnNameChange(string value) { if (native == null) return; native.Name = value; }
        private void OnAlbumChanged(String value) { if (native == null) return; native.Album = value; }
        private void OnArtistChanged(String value) { if (native == null) return; native.Artist = value; }
        private void OnUncheck() { if (native == null) return; native.Enabled = false; }



        //private EventHandler<StringEventArgs> commentChanged;
        //private EventHandler<StringEventArgs> groupingChanged;
        //private EventHandler<StringEventArgs> albumChanged;
        //private EventHandler<StringEventArgs> artistChanged;


        private List<IReference> referenceObs = new List<IReference>();
        public void addReferenceObs(IReference obs) { if (!referenceObs.Contains(obs)) referenceObs.Add(obs); }
        public void removeReferenceObs(IReference obs) { referenceObs.Remove(obs); }
        private void OnReferenceChanged() { for (int i = 0; i < referenceObs.Count; i++) { referenceObs[i].referenceChange(this); } }


        #region logs
        private void valueChangedHandler()
        {

            //m_ref.AlbumData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Album", args); };
            //m_ref.ArtistData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Artist", args); };
            //m_ref.NameData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Name", args); };
            //m_infos.YearData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Year", args); };
            //Classement.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Classement", args); };

            //m_ref.AlbumData.changeLocalValueByNative += (o, args) => { langChangeByNative("Album", args); };
            //m_ref.ArtistData.changeLocalValueByNative += (o, args) => { langChangeByNative("Artist", args); };
            //m_ref.NameData.changeLocalValueByNative += (o, args) => { langChangeByNative("Name", args); };
            //m_infos.YearData.changeLocalValueByNative += (o, args) => { langChangeByNative("Year", args); };
            //Classement.changeLocalValueByNative += (o, args) => { langChangeByNative("Classement", args); };

            //m_ref.AlbumData.change += new EventHandler(Ref_change);
            //m_ref.NameData.change += new EventHandler(Ref_change);
            //m_ref.ArtistData.change += new EventHandler(Ref_change);
            //m_ref.TrackData.change += new EventHandler(Ref_change);
            //Files.Observer = this;
            m_ref.Observer = this;
            m_infos.Observer = this;
            //Classement.Observer = this;
            //Checked.Observer = this;
        }


        private void logChange(String typeChange, String typeData, object Old, object New)
        {
            logTrack.log("{0}:{1} from '{2}' to '{3}' {4}", typeChange, typeData, Old, New, this);
        }
        //private void logChangeByRemote(String typeData, object Old, object New)
        //{
        //    logChange("change by remote", typeData, Old, New);
        //}
        //private void langChangeByNative(String typeData, object Old, object New)
        //{
        //    logChange("change by native", typeData, Old, New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}

        //private void langChangeByNative(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}

        #endregion


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        public void keyGener()
        {
            try
            {
                key = new TrackIdentity(this);
            }
            catch
            {
                logTrack.log("pb de clé " + this);
                throw;
            }
        }

        #endregion

        #region constructeurs





        /// <summary>
        /// création d'un morceau vide
        /// </summary>
        /// <remarks></remarks>
        public CPiece()
        {
            master = new PieceMaster(); 
         
            m_ref = new CPieceReference();
            m_infos = new CPieceInfo();          
            valueChangedHandler();
        }

        //public CPiece(string location, string baseClassement)
        //    : this()
        //{
        //    m_files.add(new CFile(location));
        //    m_classement = new CPieceClassement(baseClassement);
        //    valueChangedHandler();
        //}

        public CPiece(string location)
            : this()
        {
            master = new PieceMaster(location);  

            m_ref = new CPieceReference();
            m_infos = new CPieceInfo();
            valueChangedHandler();
          
        }

        public void initClassementIfEmpty(string classement)
        {
            master.initClassementIfEmpty(classement);
        }


        public void eraseClassement()
        {
            master.eraseClassement();
        }


        private ITrackInfoItunes native = null;

        public void recordJustReadTrack()
        {
            ListDates.check(DateTime.Now);
        }

//        public CPiece(ITrackInfoItunes ext)
//        {
//            native = ext;
//            //  ext.registerDependency(this); 

//            m_classPlayLists = ext.ClassPlayLists;
//            //m_playList = ext.PLayLists;

//            string className = ext.ClassName; // getClassName(ext); 

//            m_dates = new CListDate();
//            ListDates.check(ext.PlayedDate);

//            m_files = new CListFile();
//            Files.add(new CFile(ext.Location));
//            m_ref = new CPieceReference(ext.Artist, ext.Album, ext.Name, ext.TrackNumber);
//#if VOL
//            m_infos = new CPieceInfo(ext.Year, ext.Volume);
//#else
//            m_infos = new CPieceInfo(ext.Year);
//#endif
//            this.artWork = ext.ArtWork;

//            m_classement = new CPieceClassement(className, ext.Rating);
//            //m_comment = ext.Comment;
//            //grouping = ext.Grouping; 

//            m_duration = ext.Duration;
//            bool enabled = ext.Enabled;
//            if (enabled)
//                Checked.Enable();
//            else
//                Checked.Disable();

//            //m_ref.AlbumData.changeNativeValue += (o, args) =>  { if (native == null) return; native.Album = args.Value; };
//            //m_ref.ArtistData.changeNativeValue += (o, args) => { if (native == null) return; native.Artist = args.Value; };
//            //m_ref.NameData.changeNativeValue += (o, args) => { if (native == null) return; native.Name = args.Value; };
//            //m_ref.TrackData.changeNativeValue += (o, args) => { if (native == null) return; native.TrackNumber = args.Value; };
//            //m_infos.YearData.changeNativeValue += (o, args) => { if (native == null) return; native.Year = args.Value; };
//            //Classement.changeNativeValue += (o, args) => { if (native == null) return; native.Rating = args.Value.Rating; native.ClassName = args.Value.ClassList; };

//            m_ref.Observer = this;
//            Classement.Observer = this;
//            Checked.Observer = this;
//            //  m_Enabled.checkedChanged += (o, args) => { if (native == null) return; native.Enabled = false; };





//            valueChangedHandler();


//        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList(ITrackNative track)
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        /// <summary>
        /// construction à partir de la base maison 
        /// </summary>
        /// <param name="a_xml"></param>
        /// <remarks></remarks>
        public CPiece(XmlElement a_xml)
        {
            var xmlTool = new XMLTool(a_xml);
            m_id = xmlTool.getIntAttValue("id");
            deleted = xmlTool.getBoolAttValue("deleted");
            m_ref = new CPieceReference(a_xml);
            m_infos = new CPieceInfo(a_xml);

            parentID = xmlTool.getIntAttValue("parent");
            if (parentID < 0)
            {
                master = new PieceMaster(a_xml); 
                //m_dates = new CListDate(a_xml);
                //m_files = new CListFile(a_xml);
                //m_classement = new CPieceClassement(a_xml);
                //var xDisabled = xmlTool.NodeLookUp(TOKEN_DISABLED);
                //{
                //    if (xDisabled != null)
                //    {
                //        if (xDisabled.InnerText == "false")
                //            Checked.Enable();
                //        else
                //            Checked.Disable(); 
                //    }
                //}
            }
            else
            {
                //m_dates = new CListDate();
                //m_files = new CListFile();
                //m_classement = new CPieceClassement();

            }





           // var xtool = new XMLTool(a_xml);
         //   artWork = xtool.getNodeValue(TOKEN_ARTWORK);
            //Comment = xtool.getNodeValue("classement");
            //_grouping = xtool.getNodeValue("grouping");
          

            m_ref.Observer = this;
            //Classement.Observer = this;
            //Checked.Observer = this;
            valueChangedHandler();

        }


        ///// <summary>
        ///// construction à partir de la base propriétaire
        ///// </summary>
        ///// <param name="a_ref"></param>
        ///// <param name="a_file"></param>
        ///// <param name="a_info"></param>
        ///// <param name="a_rating"></param>
        ///// <param name="a_date"></param>
        ///// <remarks></remarks>
        //public CPiece(CPieceReference a_ref, string a_file, CPieceInfo a_info, int a_rating, System.DateTime a_date, TimeSpan a_duration, bool a_bEnabled)
        //{

        //    m_dates = new CListDate();
        //    ListDates.check(a_date);

        //    m_files = new CListFile();
        //    Files.@add(new CFile(a_file));

        //    m_ref = a_ref;
        //    m_infos = a_info;

        //    m_classement = new CPieceClassement(a_rating);
        //    m_duration = a_duration;
        //    if (a_bEnabled)
        //    {
        //        m_Enabled.True();
        //    }
        //    else
        //    {
        //        m_Enabled.False();
        //    }
        //    valueChangedHandler();

        //}

        #endregion


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackMetaData other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.Location) || m_ref.DefinedEquals(other.Artist, other.Album, other.Name, other.TrackNumber));
        //}


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(CPiece other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.m_files) || m_ref.DefinedEquals(other.m_ref));
        //}

        //public bool checkFile(CPiece other)
        //{
        //    return Files.HasOnePathInCommonWith(other.Files);
        //}



        private void raiseChangeRefEvent()
        {
            if (isRefchanged)
            {
                isRefchanged = false;
                OnReferenceChanged();
            }
        }

        /// <summary>
        /// rapatrie les info d'une piece vers l'autre
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>cas d'égalité enre les deux : doublons de la même liste</remarks>

        public void merge(CPiece other)
        {

            if (!m_ref.AlbumData.choose(other.m_ref.AlbumData))
            {
                log("merge album between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.AlbumData.mergeManual(other.m_ref.AlbumData);
            }

            if (!m_ref.ArtistData.choose(other.m_ref.ArtistData))
            {
                log("merge artist between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.ArtistData.mergeManual(other.m_ref.ArtistData);
            }
            if (!m_ref.NameData.choose(other.m_ref.NameData))
            {
                log("merge name between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.NameData.mergeManual(other.m_ref.NameData);
            }
            if (!m_ref.TrackData.choose(other.m_ref.TrackData))
            {
                log("merge trackNumber between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.TrackData.mergeManual(other.m_ref.TrackData);
            }




            if (!m_infos.YearData.choose(other.m_infos.YearData))
            {
                log("merge infos between " + this.ToString() + "[" + this.Year + "]" + " and " + other.ToString() + "[" + other.Year + "]");
                m_infos.YearData.mergeManual(other.m_infos.YearData);
            }

            if (!master.choose(other.master))
            {
                log("merge classement between " + this.ToString() + "[" + this.ClassList + ":" + this.Rating + "]" + " and " + other.ToString() + "[" + other.ClassList + ":" + other.Rating + "]");
                 master.mergeManual(other.master);
            }

            addData(other);
            raiseChangeRefEvent();
        }


        /// <summary>
        /// Simple ajout de données venant du doublon
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>Utilisé par legacy pour génération d'une liste propre à partir de la liste native
        /// Les fichiers auront préalablement été triés par classement</remarks>
        public void mergeDataFrom(CPiece other)
        {
            try
            {
                m_ref.mergeDataFrom(other.m_ref);
                m_infos.YearData.mergeAll(other.m_infos.YearData, mergePriority.none);

                master.mergeDataFrom(other.master); 
               // Classement.mergeAll(other.Classement, mergePriority.none);

                addData(other);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + @"\r\n" + other.ToString() + @"\r\n" + e.ToString());
            }
        }


        // <summary>
        // addition sans collision des dates et fichiers
        // </summary>

        // <remarks></remarks>

        public void addData(CPiece other)
        {
            master.addData(other.master); 
        }


        public void consolid(CPiece remote, mergePriority a_priority)
        {

            try
            {
                m_ref.consolid(remote.m_ref, a_priority);
               // Classement.Consolid(remote.Classement, a_priority);
                m_infos.consolid(remote.m_infos, a_priority);
                master.consolid(remote.master, a_priority); 
             //   Checked.Consolid(remote.Checked, a_priority);

                //if (m_duration.TotalMilliseconds < 2)
                //    this.m_duration = remote.m_duration;
                //else if (remote.m_duration.TotalMilliseconds < 2)
                //    remote.m_duration = this.m_duration;
                //else if (a_priority == mergePriority.right)
                //    m_duration = remote.m_duration;

              //  addData(remote);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + "\r\n" + remote.ToString() + "\r\n" + e.ToString());
            }
        }


        public mergePriority checklegacyModifString(CPieceData<String> data, String native)
        {

            mergePriority l_consistencyComp = data.Value.compareByConsistency(native);
            if (l_consistencyComp != mergePriority.none)
                return l_consistencyComp;

            if (data.Imported) return mergePriority.right;
            return mergePriority.left;
        }


        /// <summary>
        /// piece de la liste native consolidée ou mise à jour 
        /// suivant le cas par le fichier maison
        /// </summary>
        /// <param name="native"></param>
        /// <remarks></remarks>
        //public void legacyConsolid(CPiece l_native)
        //{



        //    //TODO éviter de créer un objet juste pour la comparaison
        //    //en fait très complexe de casser le modèle. A la place, on abonne le track natif aux modifications éventuelles de la DB



        //    //this.grouping = l_native.Grouping;
        //    //this.m_comment = l_native.Comment; 







        //    l_native.m_ref.legacyConsolid(this.m_ref);
        //    l_native.m_infos.legacyConsolid(this.m_infos);

        //    l_native.setClassPlayList(this);
        //    l_native.Classement.LegacyConsolid(this.Classement);
        //    l_native.Checked.LegacyConsolid(this.Checked);

        //    //   native.synchroLegacy(this);  //plus besoin de synchro dans l'autre sens, on n'utilise pas l'objet créé ==> en fait si : on modifie directement le track

        //    addData(l_native);

        //    this.m_playList = l_native.PLayLists;
        //    this.m_classPlayLists = l_native.ClassPlayLists;
        //    this.m_duration = l_native.Duration;
        //    raiseChangeRefEvent();

        //    //On court-circuite la liste intermédiaire pour toujours pointer directement vers le trackInfoItunes
        //    this.native = l_native.native;

        //    checkNative();
        //}

//        /// <summary>
//        /// Synchro directe entre la Db et le track Itunes (mode daemon)
//        /// </summary>
//        public void SynchroNative()
//        {
//            checkNative();
//            if (native == null)
//                return;

//            m_ref.SynchroNative(native);
//#if VOL
//            m_infos.SynchroNative(native.Year, native.Volume);
//#else
//            m_infos.SynchroNative(native.Year);
//#endif
//            var newClassList = getClassName(native);
//            Classement newCl = new Classement(newClassList, native.Rating);
//            Classement.SynchroNative(newCl);
//            Checked.SynchroNative(native.Enabled);

//            this.ListDates.merge(native.PlayedDate);



//            //  this.m_playList = native.PLayLists;
//            this.m_classPlayLists = native.ClassPlayLists;
//            if (native.Duration.TotalMilliseconds > 1)
//                this.m_duration = native.Duration;
//            raiseChangeRefEvent();
//        }

        public void removeVersions()
        {
            m_ref.removeVersions();
            master.removeVersions();
        }

      

        public void Menage()
        {
            //  misc.log("ménage {0}", this); 
            master.Menage(this); // Classement.Menage(this);
        }




        //public void synchroLegacy(CPiece native)
        //{
        //    this.m_classPlayLists = native.m_classPlayLists;

        //    this.ID = native.ID;
        //}

        //private List<CPlayList> m_classPlayLists = new List<CPlayList>();
        //private List<CPlayList> m_playList = new List<CPlayList>();
        //public void AddPlayList(CPlayList a_playList)
        //{
        //    if (a_playList.isClassSubList())
        //    {
        //        m_classPlayLists.Add(a_playList);
        //    }
        //    m_playList.Add(a_playList);
        //}
        //public void removePlayList(CPlayList list)
        //{
        //    if (list.isClassSubList())
        //        m_classPlayLists.Remove(list);
        //    m_playList.Remove(list);
        //}

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in m_playList)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        ////définit la liste qui le classe
        //public void setClassPlayList()
        //{
        //    int count =  m_classPlayLists.Count; 
        //    if (count > 0)
        //    {
        //        if (count > 1)
        //        {
        //            m_classPlayLists.Sort(new CPlayListComparer());
        //        }
        //        Classement.ClassList = m_classPlayLists[0].Name;
        //    }
        //}


        //private void setClassPlayList(ITrackNative pieceDb)
        //{
        //    string dbClasslist = pieceDb.ClassName;
        //    int count = m_classPlayLists.Count;
        //    if (count > 0)
        //    {
        //        string className = m_classPlayLists[0].Name;
        //        if (count > 1)
        //        {
        //            m_classPlayLists.Sort(new CPlayListComparer());
        //            foreach (var list in m_classPlayLists)
        //            {
        //                className = list.Name;
        //                if (className == dbClasslist)
        //                    continue;
        //                break;
        //            }
        //        }

        //        if (!className.Equals(Classement.Value.ClassList) && className.Equals(Classement.LastValue.ClassList))
        //        {
        //            misc.log("Classement:setClassPlayList {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
        //            return;
        //        }

        //        Classement.ClassList = className;

        //    }
        //}

        //public string getClassName(ITrackNative native)
        //{
        //    string dbClasslist = this.ClassName;
        //    var firstStep = getClassName_(native);
        //    if (!firstStep.Equals(Classement.Value.ClassList) && firstStep.Equals(Classement.LastValue.ClassList))
        //    {
        //        misc.log("Classement:getClassName {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
        //        return dbClasslist;
        //    }
        //    else
        //        return firstStep;
        //}

        //public string getClassName_(ITrackNative native)
        //{
        //    string dbClasslist = this.ClassName;
        //    string className = dbClasslist;
        //    int count = native.ClassPlayLists.Count;
        //    if (count > 0)
        //    {
        //        className = native.ClassPlayLists[0].Name;
        //        if (count > 1)
        //        {
        //            native.ClassPlayLists.Sort(new CPlayListComparer());
        //            foreach (var list in native.ClassPlayLists)
        //            {
        //                className = list.Name;
        //                if (className.Equals(dbClasslist))
        //                    continue;
        //                break;
        //            }
        //        }
        //    }
        //    return className;
        //}

        //utilisé par le player maison
        //public void setClassPlayList(String name)
        //{
        //    Classement.ClassList = name;
        //    // TODO Gérer l'absence de classList
        //}

        //private CPlayList ClassPlayList
        //{
        //    get
        //    {
        //        if (m_classPlayLists.Count > 0)
        //            return m_classPlayLists[0];
        //        return null;
        //    }
        //}

    //    public List<CPlayList> PLayLists { get { return m_playList; } }

        public String ClassName { get { return master.ClassName; } set { } }

        //public List<CPlayList> ClassPlayLists
        //{
        //    get
        //    {
        //        return m_classPlayLists;
        //    }
        //}



        /// <summary>
        /// 
        /// </summary>
        /// <param name="a_sw"></param>
        /// <remarks></remarks>
        /// 
        #region IData Members
        public void write(ITextWriter a_sw)
        {
            XMLTool.openBalise(a_sw, TOKEN_PIECE);

            m_ref.write(a_sw);
            m_infos.write(a_sw);

            master.write(a_sw);
            var dur = master.Duration; 

            //Classement.write(a_sw);

            //Files.write(a_sw);
            //ListDates.write(a_sw);

            //if (!Checked.Enabled)
            //    XMLTool.writeValue(a_sw, TOKEN_DISABLED, true.ToString());
            //if (artWork.NotNullOrEmpty())
            //    XMLTool.writeValue(a_sw, TOKEN_ARTWORK, artWork);
            //if (dur.TotalMilliseconds > 1)
            //    XMLTool.writeValue(a_sw, TOKEN_DURATION, (int)m_duration.TotalMilliseconds);

            XMLTool.closeBalise(a_sw, TOKEN_PIECE);
        }


        public bool hasParent() { return m_id != master.Id; }
        public bool IsMaster { get { return m_id == master.Id; }}

        public void write(XmlWriter w)
        {           
            try
            {
                w.WriteStartElement(TOKEN_PIECE);
                if (PieceId > 0)
                    w.WriteAttributeString("id", PieceId.ToString());

                bool hasParent_ = hasParent(); 
                if (hasParent_)
                    w.WriteAttributeString("parent",master.Id.ToString());
                if (!hasParent_)
                {
                    if (Duration.TotalMilliseconds > 1)
                        w.WriteAttributeString(PieceMaster.TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
                }

                m_ref.write(w);
                m_infos.write(w);

                if (hasParent_)
                {
                    master.write(w); 
                }

            

                w.WriteEndElement();
            }
            catch (Exception ex)
            {
                misc.log("immpossible de sérialiser {0}", this);
                throw;
            }
        }

    
        public void writeDeleted(XmlWriter w)
        {
            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            w.WriteAttributeString("deleted", "true");
            w.WriteEndElement();

        }

        public void writeDiff(XmlWriter w, CPiece lastFull)
        {
            if (lastFull == null)
            {
                write(w);
                return;
            }

            if (!HasChange(lastFull))
                return;

            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            if (master.Id != m_id)
                w.WriteAttributeString("parent", master.Id.ToString());

            m_ref.writeDiff(w, lastFull.m_ref);
            m_infos.writeDiff(w, lastFull.m_infos);

            if (master.Id == m_id)
            {
                master.writeDiff(w, lastFull.master);               
            }

            


          

            w.WriteEndElement();
        }

        public bool HasChange(CPiece lastFull)
        {
            if (lastFull == null)
            {
                return true;
            }
            if (PieceParentId != lastFull.PieceParentId)
                return true;

            if (m_ref.HasChanged(lastFull.m_ref))
                return true;
            if (m_infos.HasChange(lastFull.m_infos))
                return true;
            return master.HasChange(lastFull.master); 

            //if (parent == null)
            //{
            //    if (Classement.HasChange(lastFull.Classement))
            //        return true;
            //    if (Files.HasChange(lastFull.Files))
            //        return true;
            //    if (ListDates.HasChange(lastFull.ListDates))
            //        return true;
            //}

            //if (Checked.Enabled != lastFull.Checked.Enabled)
            //    return true;


            //if (m_duration.TotalMilliseconds > 1 && (int)lastFull.m_duration.TotalMilliseconds != (int)m_duration.TotalMilliseconds)
            //    return true;

            return false;
        }

        #endregion

       

        


        //public CListFile Files
        //{
        //    get { return master.Files; }
        //}


        public IList<DateTime> Dates
        {
            get { return ListDates.Dates; }
        }

        public DateTime PlayedDate
        {
            get { return ListDates.LastModif; }
        }

        public string ClassList
        {
            get { return Classement.ClassList; }
        }

        public int Rating
        {
            get { return Classement.Rating; }
            set { Classement.Rating = value; }
        }

        public int RatingCmp
        {
            get
            {
                if (Rating < 0)
                    return 0;
                return Rating;
            }
        }
        public CPieceReference Reference
        {
            get { return m_ref; }
        }
        public string Name
        {
            get { return m_ref.Name; }
            set { m_ref.Name = value; }
        }
        public string Album
        {
            get { return m_ref.Album; }
            set
            {
                if (!m_ref.Album.Equals(value))
                {
                    m_ref.Album = value;
                    OnAlbumChanged(value);
                }
            }
        }
        public string Artist
        {
            get { return m_ref.Artist; }
            set
            {
                if (!m_ref.Artist.Equals(value))
                {
                    m_ref.Artist = value;
                    OnArtistChanged(value);
                }
            }
        }
        public int TrackNumber { get { return m_ref.TrackNumber; } set { m_ref.TrackNumber = value; } }
        public int DurationInSec
        {
            get { return master.DurationInSec; }
        }
        //public TimeSpan Duration
        //{
        //    get { return m_duration; }
        //    set
        //    {
        //        if (value.TotalMilliseconds > 1)
        //            m_duration = value;
        //    }
        //}
        public int Year
        {
            get { return m_infos.Year; }
            set { m_infos.Year = value; }
        }
#if VOL
        public int Volume { get { return m_infos.Volume; } set { m_infos.Volume = value; } }
#endif
        public bool Enabled
        {
            get { return Checked.Enabled; }
            set
            {
                if (value)
                    Checked.Enable();
                else
                    Checked.Disable();
            }
        }
        public CPieceInfo Infos
        {
            get { return m_infos; }
        }

        public string ArtWork { get { return artWork; } set { artWork = value; } }


        /// <summary>
        /// ID interne
        /// </summary>
        /// <remarks></remarks>
        private int m_id = -1;
       // private int parentID = -1;
        public int PieceId
        {
            get { return m_id; }
        }

        public int PieceParentId
        {
            get
            {
                if (master.Id == m_id)
                    return -1;
                return master.Id; 
            }
        }

        public int MasterId
        {
            get
            {
                return master.Id; 
            }
        }

        public bool IsMaster 

        //public CPiece Master
        //{
        //    get
        //    {
        //        if (parent == null)
        //            return this; 
        //        return parent;
        //    }
        //}


        public void setId(int value)
        {
            if (m_id < 0)
            {
                m_id = value;
            }
        }

     //   public CPieceClassement Classement { get { return master.Classement;  } }
        public TimeSpan Duration
        {
            get {return master.Duration; }
            set
            {
                master.Duration = value; 
            }
        }
      //  public CListDate ListDates { get { if (parent == null) return m_dates; return parent.m_dates; } }
       // private CPieceChecked Checked { get { if (parent == null) return m_Enabled; return parent.m_Enabled; } }
        //  private CListFile Files { get { if (parent == null) return m_files; return parent.m_files; } }
        public Classement getClassement() { return master.Classement; }
        public IEnumerable<CFile> Files { get { return master.Files; } }
        public CFile PertinentFile
        {
            get { return master.PertinentFile; }
        }


        //public string getUri()
        //{
        //    return Files.getUri();

        //    //string l_file = File;
        //    //if (l_file.Contains("file://"))
        //    //{
        //    //    return l_file;
        //    //}
        //    //else
        //    //{
        //    //    return CLegacy.DefaultFolder + File;
        //    //}

        //}


        //Sub synchroClassFrom(ByVal a_list As CListPiece)
        //    Dim l_piece As CPiece = a_list.getPiece(Me)
        //    m_classement = l_piece.m_classement
        //End Sub

        public override string ToString()
        {
            var parent = " ";
            if (PieceParentId >= 0)
                parent = string.Format(" ({0}) ", PieceParentId); 
            return string.Format("{0} {1}{2}{3} {4} {5}", master.Classement, PieceId, parent, Name, Album, master.File); 
            //String location = Location;
            //return location == "" ? Files.File : location;
        }
        //public string File
        //{
        //    get { return Files.File; }
        //}
        public string PathAndRef
        {
            get { return Location + " " + m_ref.ToString(); }
        }
        //private string _location;
        public string Location
        {

            get
            {
                return master.Path; // Files.Path; 
                //if (_location == null)
                //_location =  Files.Path;
                //return _location; 


            }
        }
        public bool Exists { get { return master.Exists;}} // Files.Exists; } }

        //public bool classListToUpdate()
        //{
        //    string l_strList = "";
        //    if (ClassPlayList != null)
        //        l_strList = ClassPlayList.Name;

        //    //if (Classement.Imported)
        //    //{
        //    if (l_strList != ClassList)
        //    {
        //        return true;
        //    }
        //    //}
        //    return false;
        //}

       
        private string _grouping;
        public string Grouping
        {
            get
            {
                if (_grouping == null)
                {
                    if (native != null)

                        _grouping = native.Grouping;
                }
                return _grouping;
            }
            //set
            //{
            //    //if (value != Grouping)
            //    //{
            //    //  grouping = value;
            //    OnGroupingChange(value);
            //    //}
            //}
        }

        public void setGrouping(string value, bool prior)
        {
            if (value != _grouping)
            {
                _grouping = value;
                OnGroupingChange(value, prior);
            }
        }

        //private static double getTx(int rank)
        //{
        //    if (rank <= 0)
        //        return 0;
        //    return (Math.Log(Convert.ToDouble(CTuning.Total) / Convert.ToDouble(rank)) / Math.Log(2));
        //}

        //public int QRank
        //{
        //    get { return m_rank.Goodness; }
        //    set { m_rank.Goodness = value; }
        //}

        //public int LRank
        //{
        //    get { return m_rank.Lenght; }
        //    set { m_rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return m_rank.Twice; }
        //    set { m_rank.Twice = value; }
        //}




        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return Classement.isClassListNumeric;
            }
        }

        //  public String ClassNameAndRating { get { return Classement.ClassNameAndRating; } }



        #region "calcul liste dynamiques"
        // Private m_bCanPlay As Boolean = True
        public delegate bool canPlayDel(int a_base);
        //public bool canPlay(int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    if (a_base <= 0)
        //        return true;
        //    DateTime now = DateTime.Now;
        //    bool l_bRet = ListDates.canPlay(now, Delta, a_base);
        //    if (!l_bRet)
        //    {
        //        Console.WriteLine(" " + Comment + " " + Location);
        //    }

        //    return l_bRet;
        //}

        // private CListDate m_datesModifClassement = null;
        //private CListDate DatesClassement_
        //{
        //    get
        //    {
        //        //if (m_datesModifClassement == null)
        //        //    m_datesModifClassement = Classement.Dates;
        //        return Classement.Dates;
        //    }
        //}

        //public bool mustPlayToPreciseClassement(DateTime now, int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    bool bRet = !DatesClassement.canPlay(now, Delta, a_base);
        //    bool bLastModif = DatesClassement.LastModif > DatesPlayed.LastModif;


        //    if (CConf.CheckModifStrict)
        //        // on ne retient que s'i n'a pas été lu depuis la dernière modif.
        //        // encore en cours : j'écoute puis je modifie
        //        bRet = bRet && bLastModif;

        //    if (a_base == 0)
        //        return bLastModif;
        //    return bRet;
        //}

        //public String getClassementEvol()
        //{
        //    DateTime playedCorr = ListDates.LastModif;
        //    try
        //    {
        //        if (playedCorr > DateTime.MinValue)
        //            playedCorr -= m_duration;
        //    }
        //    catch (Exception)
        //    {
        //        logTrack.log("{0} impossible de corriger la date jouée {1} avec la durée {2}", this, ListDates.LastModif, m_duration);
        //    }
        //    if (DatesClassement_.LastModif > playedCorr)
        //    {
        //        return Classement.Evol;
        //    }
        //    return "";

        //}

        public static double LogBase = 2.0;
        public static double Scale = 0.1;
        //private TimeSpan Delta
        //{

        //    get
        //    {
        //        if (m_rank.Goodness < 0)
        //            return TimeSpan.MaxValue;
        //        long l_ticks = Convert.ToInt64(new TimeSpan(1, 0, 0, 0).Ticks * Scale);

        //        double r = CPieceInListComparer.Calc(this, CConf.Select);
        //        //     Rapport(m_rank.Goodness, CConf.Sort.Quality)
        //        if (r == -1)
        //            return TimeSpan.MaxValue;

        //        long l_nt = long.MaxValue;
        //        try
        //        {
        //            l_nt = Convert.ToInt64(l_ticks / r);
        //        }
        //        catch (Exception ex)
        //        {
        //        }

        //        return new TimeSpan(l_nt);
        //    }
        //}



        //Sub reinitCanPlay()
        //    m_bCanPlay = True
        //End Sub

        #endregion

        #region "COM"

        //public void checkComRating(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        if (Rating < 0)
        //            return;
        //        //if (!Classement.Imported)
        //        //    return;

        //        int l_trackRating = a_track.Rating;
        //        if (l_trackRating != Rating)
        //        {
        //            log("change rating from " + l_trackRating + " to " + Rating + " " + Location);
        //            a_track.Rating = Rating;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Rating {0} for {1}", Rating, this);
        //    }

        //}


        //public void checkComInfo(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        //if (!m_infos.YearData.Imported)
        //        //    return;
        //        if (Year <= 0) return;
        //        if (a_track.Year != Year)
        //        {
        //            log("change year from " + a_track.Year + " to " + Year + " " + Location);
        //            a_track.Year = Year;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Year {0} for {1}", Year, this);
        //    }

        //}

        //public void checkComRef(ITrackMetaData a_track)
        //{

        //    if (m_ref == null)
        //        return;


        //    string l_trackArtist = a_track.Artist.TrimSafe();
        //    string l_trackAlbum = a_track.Album.TrimSafe();
        //    string l_trackName = a_track.Name.TrimSafe();
        //    int l_trackNumber = a_track.TrackNumber;

        //    if (l_trackArtist != m_ref.Artist)// && m_ref.ArtistData.Imported)
        //    {
        //        log("change Artist from " + l_trackArtist + " to " + m_ref.Artist + " " + Location);
        //        try { a_track.Artist = m_ref.Artist.TrimSafe(); }
        //        catch { misc.log("unable to change Artist {0} for {1}", Artist, this); }
        //    }
        //    if (l_trackAlbum != m_ref.Album) // && m_ref.AlbumData.Imported)
        //    {
        //        log("change Album from " + l_trackAlbum + " to " + m_ref.Album + " " + Location);
        //        try { a_track.Album = m_ref.Album; }
        //        catch { misc.log("unable to change Album {0} for {1}", Album, this); }
        //    }
        //    if (l_trackName != m_ref.Name) // && m_ref.NameData.Imported)
        //    {
        //        log("change Name from " + l_trackName + " to " + m_ref.Name + " " + Location);
        //        try
        //        {
        //            a_track.Name = m_ref.Name.TrimSafe();
        //        }
        //        catch { misc.log("unable to change Name {0} for {1}", Name, this); }
        //    }
        //    if (l_trackNumber != m_ref.TrackNumber && TrackNumber >= 0)//&& m_ref.TrackData.Imported)
        //    {
        //        log("change Track from " + l_trackNumber + " to " + m_ref.TrackNumber + " " + Location);
        //        try { a_track.TrackNumber = TrackNumber; }
        //        catch { misc.log("unable to change TrackNumber {0} for {1}", TrackNumber, this); }
        //    }


        //}


        //public void checkComComment(ITrackMetaData a_track)
        //{
        //    try
        //    {

        //        string l_pieceComment = Comment.Trim();
        //        String l_trackComment = a_track.Comment;
        //        if (l_trackComment == null) l_trackComment = "";
        //        l_trackComment = l_trackComment.Trim();
        //        if (l_trackComment != l_pieceComment)
        //        {
        //            misc.logNoDate("write comment from " + a_track.Comment + " to " + l_pieceComment + " " + Location);
        //            // If l_pieceComment.Trim = "" Then Throw New ApplicationException(Me.ToString() & " set comment to null")
        //            a_track.Comment = l_pieceComment;
        //        }

        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Comments {0} for {1}", Comment, this);
        //    }
        //}

        //public void checkComEnabled(ITrackMetaData a_track)
        //{
        //    if (m_Enabled.isFalse && a_track.Enabled)
        //    {
        //        misc.log("disable {0}", this);
        //        a_track.Enabled = false;
        //    }
        //}

        //public void checkComDate(ITrackInfo a_track)
        //{
        //    //Dim l_date As String = a_track.EQ

        //}
        #endregion


        public bool isPodcast
        {
            get { return master.isPodcast; }
        }
        private void log(String txt)
        {
            logTrack.log(txt);
        }



        List<DateTime> ITrackPlayedDates.Dates
        {
            get { return new List<DateTime>(ListDates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return new List<DateTime>(DatesClassement_.Dates); }
        }

        public DateTime LastModifClass { get { return m_classement.LastModif; } }

        public string ClassEvol
        {
            get { return getClassementEvol(); }
        }





        public void changeNativeValueAlbum(string value)
        {
            if (native == null)
                return;
            native.Album = value;
        }

        public void changeNativeValueArtist(string value)
        {
            if (native == null) return; native.Artist = value;
        }

        public void changeNativeValueName(string value)
        {
            if (native == null) return; native.Name = value;
        }

        public void changeNativeValueTrack(int value)
        {
            if (native == null) return; native.TrackNumber = value;
        }

        public void changeNativeValueYear(int value)
        {
            if (native == null) return; native.Year = value;
        }

        public void changeNativeValueClassement(Classement value)
        {
            if (native == null)
                return;
            native.Rating = value.Rating; native.ClassName = value.ClassList;
        }
#if VOL
        public void changeNativeValueVolume(int value)
        {
            if (native == null) return;
            native.Volume = value;
        }
#endif

        public void changeByRemote(string type, object Old, object New)
        {
            logChange("change by remote", type, Old, New);
        }

        public void changeByNative(string type, object Old, object New)
        {
            logChange("change by native", type, Old, New);
        }

        private bool isRefchanged;
        public void RefChange()
        {
            isRefchanged = true;
        }

        public void unCheck()
        {
            if (native == null) return; native.Enabled = false;
        }

        public void changeLocalValueByRemoteAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void change()
        {
            throw new NotImplementedException();
        }

        public void setClassement(string className, int rating)
        {
            master.setClassement(className, rating);
        }

        public string StrClassement
        {
            get
            {
                return master.StrClassement; 
            }
            set
            {
                master.StrClassement = value; 
            }
        }

        public long Size
        {
            get
            {
                return master.Size;              
            }
        }

        //public string DirAndFileName
        //{
        //    get
        //    {
        //        return Files.DirAndFileName;
        //    }
        //}
        //private CPiece parent;

        public void setParent(CPiece parent)
        {
            var _oldParent = master;

            if (parent == null)
            {
                var copy = new PieceMaster(master, m_id);
                this.master = copy; 
                return;
            }
            else
            {
                master = parent.master; 
            }
        }
        //public CPiece Parent
        //{
        //    get { return parent; }
        //    set
        //    {
        //        var _oldParent = parent;

        //        if (value == null)
        //        {
        //            parent = null;
        //            PieceParentId = -1;
        //            if (_oldParent != null)
        //            {
        //                addDataLink(_oldParent);
        //            }
        //            return;
        //        }
        //        else
        //        {
        //            parent = value.Master; 
        //        }
        //        parent.addDataLink(this);
        //        PieceParentId = parent.PieceId;

        //    }
        //}

        private bool deleted;
        public bool Deleted
        {
            get { return deleted; }
            set
            {
                if (value != deleted)
                {
                    if (value)
                        misc.log("Suppression de {0}", this);
                    deleted = value;
                }
            }
        }

        //private List<string> _RelativesPath;
        //public List<string> RelativesPath
        //{
        //    get
        //    {
        //        if (_RelativesPath == null)
        //        {
        //            _RelativesPath = new List<string>();
        //            foreach (CFile f in m_files)
        //            {
        //                _RelativesPath.Add(f.File);
        //            }
        //        }
        //        return _RelativesPath;
        //    }
        //}


        private exportState _exportState; 
        public exportState ExportStatus
        {
            get
            {
                return _exportState; 
            }
            set
            {
                _exportState = value; 
            }
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return master.DatesClassementBrut; 
            }
        }


        public string Comment
        {
            get
            {
                return master.Comment; 
            }
            set
            {
                master.Comment = value; 
            }
        }

        
    }
}






]]></content>
  </file>
  <file path="\PieceDb.Db\piece\PieceMaster.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.db.obj;
using pdb.db.piece.data;
using System.Xml;
using pdb.util;

namespace pdb.db.piece
{
    public class PieceMaster
    {
        private const string TOKEN_DISABLED = "disabled";
        public const string TOKEN_DURATION = "duration";
        private static Logger logMaster = Logger.getLogger("Master");



        private CListDate m_dates;
        private CListFile m_files;
        private CPieceClassement m_classement;
        //durée en ms du titre
        private TimeSpan m_duration = new TimeSpan();
        private CPieceChecked m_Enabled = new CPieceChecked();

        private int m_id = -1;


        public PieceMaster(XmlElement a_xml)
        {
            var xtool = new XMLTool(a_xml);
            m_id = xtool.getIntAttValue("id");
            m_dates = new CListDate(a_xml);
            m_files = new CListFile(a_xml);
            m_classement = new CPieceClassement(a_xml);
            var xDisabled = xtool.NodeLookUp(TOKEN_DISABLED);
            {
                if (xDisabled != null)
                {
                    if (xDisabled.InnerText == "false")
                        m_Enabled.Enable();
                    else
                        m_Enabled.Disable();
                }
            }

            string strDur = "";
            var attDuration = a_xml.Attributes[TOKEN_DURATION];
            if (attDuration != null)
                strDur = attDuration.Value;
            else
                strDur = xtool.getNodeValue(TOKEN_DURATION);


            if (!string.IsNullOrEmpty(strDur))
            {
                var ms = Convert.ToDouble(strDur);
                if (ms > 1)
                    m_duration = TimeSpan.FromMilliseconds(ms);
            }
        }

        public PieceMaster(PieceMaster o, int id)
        {
            m_id = id;

            m_dates = new CListDate(o.m_dates);
            m_files = new CListFile(o.m_files);
            m_classement = new CPieceClassement(o.m_classement); 
        }

        private string _comment;
        public string Comment
        {
            get
            {
                return _comment;
            }
            set
            {
                _comment = value;
            }
        }


        public PieceMaster()
        {
            m_dates = new CListDate();
            m_files = new CListFile();
            m_classement = new CPieceClassement();
        }

        public PieceMaster(string location)
            : this()
        {
            m_files.add(new CFile(location));
        }


        public int Id
        {
            get { return m_id; }
        }

        //public CPieceClassement Classement { get { return m_classement; } }
        //public CListFile Files { get { return m_files; } }

        public void initClassementIfEmpty(string classement)
        {
            m_classement.initClassementIfEmpty(classement);
        }


        public void eraseClassement()
        {
            m_classement.eraseClassement();
        }


        public void addData(PieceMaster other)
        {
            if (other == this)
                return;
            m_dates.merge(other.m_dates);
            other.m_dates.merge(m_dates);

            m_files.merge(other.m_files);
            other.m_files.merge(m_files);
        }

        public void mergeDataFrom(PieceMaster other)
        {
            if (other == this)
                return;
            m_classement.mergeAll(other.m_classement, mergePriority.none);
        }

        public void consolid(PieceMaster remote, mergePriority a_priority)
        {

            try
            {
                m_classement.Consolid(remote.m_classement, a_priority);


                m_Enabled.Consolid(remote.m_Enabled, a_priority);

                if (m_duration.TotalMilliseconds < 2)
                    this.m_duration = remote.m_duration;
                else if (remote.m_duration.TotalMilliseconds < 2)
                    remote.m_duration = this.m_duration;
                else if (a_priority == mergePriority.right)
                    m_duration = remote.m_duration;

                addData(remote);

            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + "\r\n" + remote.ToString() + "\r\n" + e.ToString());
            }
        }

        public void removeVersions()
        {
            m_classement.removeVersions();
        }

        public void Menage(CPiece piece)
        {
            //  misc.log("ménage {0}", this); 
            m_classement.Menage(piece);
        }

        public string ClassName { get { return m_classement.ClassList; } }

        public void setClassement(string strClassement)
        {
            var cl = pdb.db.piece.type.Classement.create(strClassement);
            if (cl == null)
                throw new ApplicationException("input classement invalide " + strClassement);
            if (cl.Equals(m_classement.Value))
                return;
            m_classement.Value = cl;

        }

        public pdb.db.piece.type.Classement Classement { get { return m_classement.Value; } }
        public string File { get { return m_files.File; } }
        public string Path { get { return m_files.Path; } }
        public bool Exists { get { return m_files.Exists; } }

        public TimeSpan Duration
        {
            get { return m_duration; }
            set
            {
                if (value.TotalMilliseconds > 1)
                {
                    m_duration = value;
                }
            }
        }


        private void log(String txt)
        {
            logMaster.log(txt);
        }


        public int DurationInSec
        {
            get { return Convert.ToInt32(m_duration.TotalSeconds); }
        }

        public void write(ITextWriter a_sw)
        {
            m_classement.write(a_sw);
            m_files.write(a_sw);
            m_dates.write(a_sw);

            if (!m_Enabled.Enabled)
                XMLTool.writeValue(a_sw, TOKEN_DISABLED, true.ToString());

            if (m_duration.TotalMilliseconds > 1)
                XMLTool.writeValue(a_sw, TOKEN_DURATION, (int)m_duration.TotalMilliseconds);
        }




        public void write(XmlWriter w)
        {

            try
            {


                m_classement.write(w);
                m_files.write(w);
                m_dates.write(w);

                if (!m_Enabled.Enabled)
                    w.WriteElementString(TOKEN_DISABLED, "");

            }
            catch (Exception ex)
            {
                misc.log("immpossible de sérialiser {0}", this);
                throw;
            }
        }

        public bool HasChange(PieceMaster lastFull)
        {
            if (lastFull == null)
            {
                return true;
            }

            if (m_classement.HasChange(lastFull.m_classement))
                return true;
            if (m_files.HasChange(lastFull.m_files))
                return true;
            if (m_dates.HasChange(lastFull.m_dates))
                return true;


            if (m_Enabled.Enabled != lastFull.m_Enabled.Enabled)
                return true;


            if (m_duration.TotalMilliseconds > 1 && (int)lastFull.m_duration.TotalMilliseconds != (int)m_duration.TotalMilliseconds)
                return true;

            return false;
        }

        public void writeDiff(XmlWriter w, PieceMaster lastFull)
        {
            if (lastFull == null)
            {
                write(w);
                return;
            }



            m_classement.writeDiff(w, lastFull.m_classement);
            m_files.writeDiff(w, lastFull.m_files);
            m_dates.writeDiff(w, lastFull.m_dates);

            if (!m_Enabled.Enabled && lastFull.m_Enabled.Enabled)
                w.WriteElementString(TOKEN_DISABLED, "");

            if (m_Enabled.Enabled && !lastFull.m_Enabled.Enabled)
                w.WriteElementString(TOKEN_DISABLED, "false");

            if (Duration.TotalMilliseconds > 1 && lastFull.DurationInSec != DurationInSec)
                w.WriteElementString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());







            w.WriteEndElement();
        }

        public bool choose(PieceMaster remote)
        {
            return m_classement.choose(remote.m_classement);
        }

        public void mergeManual(PieceMaster other)
        {
            m_classement.mergeManual(other.m_classement);
        }

        public String getClassementEvol()
        {
            DateTime playedCorr = m_dates.LastModif;
            try
            {
                if (playedCorr > DateTime.MinValue)
                    playedCorr -= m_duration;
            }
            catch (Exception)
            {
                logMaster.log("{0} impossible de corriger la date jouée {1} avec la durée {2}", this, m_dates.LastModif, m_duration);
            }
            if (m_classement.Dates.LastModif > playedCorr)
            {
                return m_classement.Evol;
            }
            return "";

        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return m_classement.getDates();
            }
        }

        public void setClassement(string className, int rating)
        {
            m_classement.setClassement(className, rating);
        }

        public string StrClassement
        {
            get
            {
                return m_classement.ToString();
            }
            set
            {
                setClassement(value);
            }
        }

        #region Files

        public CFile PertinentFile
        {
            get { return m_files.getPertinentFile(); }
        }
        public IEnumerable<CFile> Files
        {
            get
            {
                return m_files; 
            }
        }

        public bool isPodcast
        {
            get { return m_files.isPodcast; }
        }

        public long Size
        {
            get
            {
                var ret = m_files.Size;
                if (ret <= 0)
                    return 0;
                return ret;
            }
        }

        #endregion

    }
}
]]></content>
  </file>
  <file path="\PieceDb.obj\FileType.cs">
    <content><![CDATA[
using System.IO;
using System;
namespace pdb.obj
{
    public enum FileType : short
    {
        none =-100,
        jpg = -10,
        png = -11,
        tif = -12,
        tiff = -13,
        gif= -14,
       
        unknown = -1,
        mp3 = 1,
        mp4 = 2,
        wma = 3,
        m4v = 4,
        m4a = 6,
        ogg = 8,
        aac = 10,       
        wav = 11,
        flac=30
    }

    public enum listMode
    {
        substract,
        rapport,
        logPure,
        log,
        logAbs,
        linear

    }

    public static class FileUtil
    {
        public static string ext(this FileInfo file)
        {
            return file.Extension.ToLower().Replace(".",""); 
        }

        public static FileType type(this FileInfo file)
        {
            try
            {
                return (FileType)Enum.Parse(typeof(FileType), file.ext()); 
            }
            catch 
            {
                return FileType.unknown; 
            }
        }

        public static FileType type(this string file)
        {
            string ext = Path.GetExtension(file).Replace(".", "").ToLower();

            try
            {
                return (FileType)Enum.Parse(typeof(FileType),ext);
            }
            catch
            {
                return FileType.unknown;
            }
        }

        public static bool isMusic(this string file)
        {
            return file.type().typeMusic(); 
        }

        public static bool typeImg(this FileType type)
        {
            return (int)type <= -10; 
        }

        public static bool typeMusic(this FileType type)
        {
            return (int)type > 0;
        }

        public static bool IsImage(this FileInfo file)
        {
            return file.type().typeImg(); 
        }

        public static bool IsMusic(this FileInfo file)
        {
            return file.type().typeMusic();
        }

    }


}

]]></content>
  </file>
  <file path="\PieceDb.obj\Interfaces.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;

namespace pdb.obj
{

    public enum exportState
    {
        none = 0,
        miss = 1,
        present = 2,
        copy = 3,
        delete = 4
    }

    /// <summary>
    /// définit chemin d'un fichier
    /// </summary>
    public interface IFile
    {
        String Location { get; }
        int PieceId { get; }
    }

    /// <summary>
    /// carte d'identité d'un morceau
    /// </summary>
    public interface ITrackReference
    {
        String Artist { get; set; }
        String Album { get; set; }
        String Name { get; set; }
        int TrackNumber { get; set; }
    }

    // définition non ambigue d'un morceau
    public interface ITrackIdentity : IFile, ITrackReference
    {

        int PieceParentId { get; }
        TrackIdentity Key { get; }
    }


    /// <summary>
    /// infos de base du morceau :métafonnées de la piste
    /// </summary> 
    public interface ITrackMetaData : ITrackIdentity
    {

        int Rating { get; set; }
        int Year { get; set; }
        String Comment { get; set; }
        bool Enabled { get; set; }
        bool isPodcast { get; }
        DateTime PlayedDate { get; }
        TimeSpan Duration { get; set; }
        string ArtWork { get; set; }
        string Grouping { get; }
        void setGrouping(string value,bool prior);
        bool FirstClass { get; set; }
#if VOL
        int Volume { get; set; }
#endif 
    }

    /// <summary>
    /// Supplément d'infos fournies par Db. liste de dates
    /// </summary>
    public interface ITrackPlayedDates
    {
        List<DateTime> Dates { get; }
        List<DateTime> DatesClassement { get; }
        List<DateTime> DatesClassementBrut { get; }
        String ClassEvol { get; }
    }

    /// <summary>
    /// infos max récupérées de iTunes: 
    /// Métadonnées + listes
    /// 
    /// </summary>
    public interface ITrackNative : ITrackMetaData//, ITrackPlayListReport
    {
        String ClassName { get; set; }

      //  void registerDependency(ITrackNative local);
     //   void releaseDependency();
    }

    /// <summary>
    /// infos de base + liste de dates
    /// Infos que Db met à dispo
    /// </summary>
    public interface ITrackNativeDates : ITrackNative, ITrackPlayedDates
    {
        void setClassement(string className, int rating);
       // List<string> RelativesPath { get; }
        exportState ExportStatus { get; set;}
        
    }

    ///// <summary>
    ///// Enregistrement des playlists associées au morceau
    ///// </summary>
    //public interface ITrackPlayListRecorder
    //{
    //    void AddPlayList(CPlayList a_playList);
    //    void removePlayList(CPlayList list);
    //}

    /// <summary>
    /// récupération des infos PlayList du morceau
    /// </summary>
    //public interface ITrackPlayListReport
    //{
    //   // List<CPlayList> PLayLists { get; }
    //    List<CPlayList> ClassPlayLists { get; }
    //}

    /// <summary>
    /// abstraction de trackInfoItunes
    /// </summary>
    public interface ITrackInfoItunes : ITrackNative
    {


    }

    public class NullTrack : ITrackNative
    {

        #region ITrackNative Members

        public string ClassName
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public void registerDependency(ITrackNative local) { }
       public void releaseDependency() { }

        #endregion

        #region ITrackMetaData Members

        public int Rating
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public int Year
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public string Comment
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public bool Enabled
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public bool isPodcast
        {
            get { return false; }
        }

        public DateTime PlayedDate
        {
            get { return DateTime.MinValue; }
        }

        public TimeSpan Duration
        {
            get { return new TimeSpan();  }
            set { }
        }

        public string ArtWork
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Grouping
        {
            get
            {
                return "";
            }
            
        }
            
        public void setGrouping(string value, bool prior) { }


        public int Volume { get { return 0; } set { } }

        #endregion

        #region IFile Members

        public string Location
        {
            get { return ""; }
        }

        #endregion

        #region ITrackReference Members

        public string Artist
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Album
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Name
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int TrackNumber
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        #endregion

        #region ITrackPlayListReport Members

        public List<CPlayList> PLayLists
        {
            get { return new List<CPlayList>(); }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return new List<CPlayList>(); }
        }

        #endregion

        public bool FirstClass { get { return false; } set {  } }

        public int PieceId
        {
            get { return -1;  }
        }

        public int PieceParentId
        {
            get { return -1; }
            set { }
        }



        public TrackIdentity Key
        {
            get { return new TrackIdentity(this);  }
        }
    }





}


]]></content>
  </file>
</db>
